{"version":3,"sources":["webpack:///static/js/vendor.b782ad69b17e217df14e.js","webpack:///./~/rxjs/Observable.js","webpack:///./~/rxjs/Subscriber.js","webpack:///./~/rxjs/OuterSubscriber.js","webpack:///./~/rxjs/util/subscribeToResult.js","webpack:///./~/rxjs/Subscription.js","webpack:///./~/rxjs/Subject.js","webpack:///./~/rxjs/util/errorObject.js","webpack:///./~/rxjs/util/root.js","webpack:///./~/rxjs/util/tryCatch.js","webpack:///./~/rxjs/scheduler/async.js","webpack:///./~/rxjs/observable/ArrayObservable.js","webpack:///./~/rxjs/util/isArray.js","webpack:///./~/rxjs/util/isScheduler.js","webpack:///./~/rxjs/observable/EmptyObservable.js","webpack:///./~/rxjs/operator/multicast.js","webpack:///./~/d3/build/d3.js","webpack:///./~/rxjs/Notification.js","webpack:///./~/rxjs/scheduler/AsyncAction.js","webpack:///./~/rxjs/scheduler/AsyncScheduler.js","webpack:///./~/rxjs/symbol/iterator.js","webpack:///./~/rxjs/util/ArgumentOutOfRangeError.js","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./~/rxjs/AsyncSubject.js","webpack:///./~/rxjs/ReplaySubject.js","webpack:///./~/rxjs/operator/mergeAll.js","webpack:///./~/rxjs/symbol/observable.js","webpack:///./~/rxjs/symbol/rxSubscriber.js","webpack:///./~/rxjs/util/EmptyError.js","webpack:///./~/rxjs/util/ObjectUnsubscribedError.js","webpack:///./~/rxjs/util/isDate.js","webpack:///./~/rxjs/util/isFunction.js","webpack:///./~/rxjs/util/isNumeric.js","webpack:///./~/rxjs/observable/ScalarObservable.js","webpack:///./~/rxjs/operator/combineLatest.js","webpack:///./~/rxjs/operator/concat.js","webpack:///./~/rxjs/operator/map.js","webpack:///./~/rxjs/operator/observeOn.js","webpack:///./~/rxjs/operator/reduce.js","webpack:///./~/rxjs/operator/zip.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/rxjs/Rx.js","webpack:///./~/vue/dist/vue.esm.js","webpack:///./~/rxjs/BehaviorSubject.js","webpack:///./~/rxjs/Observer.js","webpack:///./~/rxjs/SubjectSubscription.js","webpack:///./~/rxjs/observable/ConnectableObservable.js","webpack:///./~/rxjs/observable/FromObservable.js","webpack:///./~/rxjs/observable/PromiseObservable.js","webpack:///./~/rxjs/observable/dom/AjaxObservable.js","webpack:///./~/rxjs/operator/distinctUntilChanged.js","webpack:///./~/rxjs/operator/filter.js","webpack:///./~/rxjs/operator/find.js","webpack:///./~/rxjs/operator/merge.js","webpack:///./~/rxjs/operator/mergeMap.js","webpack:///./~/rxjs/operator/mergeMapTo.js","webpack:///./~/rxjs/operator/onErrorResumeNext.js","webpack:///./~/rxjs/operator/race.js","webpack:///./~/rxjs/operator/throttle.js","webpack:///./~/rxjs/operator/timeInterval.js","webpack:///./~/rxjs/operator/timestamp.js","webpack:///./~/rxjs/scheduler/VirtualTimeScheduler.js","webpack:///./~/rxjs/scheduler/asap.js","webpack:///./~/rxjs/scheduler/queue.js","webpack:///./~/rxjs/testing/SubscriptionLog.js","webpack:///./~/rxjs/testing/SubscriptionLoggable.js","webpack:///./~/rxjs/util/TimeoutError.js","webpack:///./~/rxjs/util/UnsubscriptionError.js","webpack:///./~/rxjs/util/applyMixins.js","webpack:///./~/rxjs/util/isArrayLike.js","webpack:///./~/rxjs/util/isObject.js","webpack:///./~/rxjs/util/isPromise.js","webpack:///./~/rxjs/util/noop.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/vue-rx/dist/vue-rx.js","webpack:///./~/process/browser.js","webpack:///./~/rxjs/InnerSubscriber.js","webpack:///./~/rxjs/Scheduler.js","webpack:///./~/rxjs/add/observable/bindCallback.js","webpack:///./~/rxjs/add/observable/bindNodeCallback.js","webpack:///./~/rxjs/add/observable/combineLatest.js","webpack:///./~/rxjs/add/observable/concat.js","webpack:///./~/rxjs/add/observable/defer.js","webpack:///./~/rxjs/add/observable/dom/ajax.js","webpack:///./~/rxjs/add/observable/dom/webSocket.js","webpack:///./~/rxjs/add/observable/empty.js","webpack:///./~/rxjs/add/observable/forkJoin.js","webpack:///./~/rxjs/add/observable/from.js","webpack:///./~/rxjs/add/observable/fromEvent.js","webpack:///./~/rxjs/add/observable/fromEventPattern.js","webpack:///./~/rxjs/add/observable/fromPromise.js","webpack:///./~/rxjs/add/observable/generate.js","webpack:///./~/rxjs/add/observable/if.js","webpack:///./~/rxjs/add/observable/interval.js","webpack:///./~/rxjs/add/observable/merge.js","webpack:///./~/rxjs/add/observable/never.js","webpack:///./~/rxjs/add/observable/of.js","webpack:///./~/rxjs/add/observable/onErrorResumeNext.js","webpack:///./~/rxjs/add/observable/pairs.js","webpack:///./~/rxjs/add/observable/race.js","webpack:///./~/rxjs/add/observable/range.js","webpack:///./~/rxjs/add/observable/throw.js","webpack:///./~/rxjs/add/observable/timer.js","webpack:///./~/rxjs/add/observable/using.js","webpack:///./~/rxjs/add/observable/zip.js","webpack:///./~/rxjs/add/operator/audit.js","webpack:///./~/rxjs/add/operator/auditTime.js","webpack:///./~/rxjs/add/operator/buffer.js","webpack:///./~/rxjs/add/operator/bufferCount.js","webpack:///./~/rxjs/add/operator/bufferTime.js","webpack:///./~/rxjs/add/operator/bufferToggle.js","webpack:///./~/rxjs/add/operator/bufferWhen.js","webpack:///./~/rxjs/add/operator/catch.js","webpack:///./~/rxjs/add/operator/combineAll.js","webpack:///./~/rxjs/add/operator/combineLatest.js","webpack:///./~/rxjs/add/operator/concat.js","webpack:///./~/rxjs/add/operator/concatAll.js","webpack:///./~/rxjs/add/operator/concatMap.js","webpack:///./~/rxjs/add/operator/concatMapTo.js","webpack:///./~/rxjs/add/operator/count.js","webpack:///./~/rxjs/add/operator/debounce.js","webpack:///./~/rxjs/add/operator/debounceTime.js","webpack:///./~/rxjs/add/operator/defaultIfEmpty.js","webpack:///./~/rxjs/add/operator/delay.js","webpack:///./~/rxjs/add/operator/delayWhen.js","webpack:///./~/rxjs/add/operator/dematerialize.js","webpack:///./~/rxjs/add/operator/distinct.js","webpack:///./~/rxjs/add/operator/distinctUntilChanged.js","webpack:///./~/rxjs/add/operator/distinctUntilKeyChanged.js","webpack:///./~/rxjs/add/operator/do.js","webpack:///./~/rxjs/add/operator/elementAt.js","webpack:///./~/rxjs/add/operator/every.js","webpack:///./~/rxjs/add/operator/exhaust.js","webpack:///./~/rxjs/add/operator/exhaustMap.js","webpack:///./~/rxjs/add/operator/expand.js","webpack:///./~/rxjs/add/operator/filter.js","webpack:///./~/rxjs/add/operator/finally.js","webpack:///./~/rxjs/add/operator/find.js","webpack:///./~/rxjs/add/operator/findIndex.js","webpack:///./~/rxjs/add/operator/first.js","webpack:///./~/rxjs/add/operator/groupBy.js","webpack:///./~/rxjs/add/operator/ignoreElements.js","webpack:///./~/rxjs/add/operator/isEmpty.js","webpack:///./~/rxjs/add/operator/last.js","webpack:///./~/rxjs/add/operator/let.js","webpack:///./~/rxjs/add/operator/map.js","webpack:///./~/rxjs/add/operator/mapTo.js","webpack:///./~/rxjs/add/operator/materialize.js","webpack:///./~/rxjs/add/operator/max.js","webpack:///./~/rxjs/add/operator/merge.js","webpack:///./~/rxjs/add/operator/mergeAll.js","webpack:///./~/rxjs/add/operator/mergeMap.js","webpack:///./~/rxjs/add/operator/mergeMapTo.js","webpack:///./~/rxjs/add/operator/mergeScan.js","webpack:///./~/rxjs/add/operator/min.js","webpack:///./~/rxjs/add/operator/multicast.js","webpack:///./~/rxjs/add/operator/observeOn.js","webpack:///./~/rxjs/add/operator/onErrorResumeNext.js","webpack:///./~/rxjs/add/operator/pairwise.js","webpack:///./~/rxjs/add/operator/partition.js","webpack:///./~/rxjs/add/operator/pluck.js","webpack:///./~/rxjs/add/operator/publish.js","webpack:///./~/rxjs/add/operator/publishBehavior.js","webpack:///./~/rxjs/add/operator/publishLast.js","webpack:///./~/rxjs/add/operator/publishReplay.js","webpack:///./~/rxjs/add/operator/race.js","webpack:///./~/rxjs/add/operator/reduce.js","webpack:///./~/rxjs/add/operator/repeat.js","webpack:///./~/rxjs/add/operator/repeatWhen.js","webpack:///./~/rxjs/add/operator/retry.js","webpack:///./~/rxjs/add/operator/retryWhen.js","webpack:///./~/rxjs/add/operator/sample.js","webpack:///./~/rxjs/add/operator/sampleTime.js","webpack:///./~/rxjs/add/operator/scan.js","webpack:///./~/rxjs/add/operator/sequenceEqual.js","webpack:///./~/rxjs/add/operator/share.js","webpack:///./~/rxjs/add/operator/shareReplay.js","webpack:///./~/rxjs/add/operator/single.js","webpack:///./~/rxjs/add/operator/skip.js","webpack:///./~/rxjs/add/operator/skipLast.js","webpack:///./~/rxjs/add/operator/skipUntil.js","webpack:///./~/rxjs/add/operator/skipWhile.js","webpack:///./~/rxjs/add/operator/startWith.js","webpack:///./~/rxjs/add/operator/subscribeOn.js","webpack:///./~/rxjs/add/operator/switch.js","webpack:///./~/rxjs/add/operator/switchMap.js","webpack:///./~/rxjs/add/operator/switchMapTo.js","webpack:///./~/rxjs/add/operator/take.js","webpack:///./~/rxjs/add/operator/takeLast.js","webpack:///./~/rxjs/add/operator/takeUntil.js","webpack:///./~/rxjs/add/operator/takeWhile.js","webpack:///./~/rxjs/add/operator/throttle.js","webpack:///./~/rxjs/add/operator/throttleTime.js","webpack:///./~/rxjs/add/operator/timeInterval.js","webpack:///./~/rxjs/add/operator/timeout.js","webpack:///./~/rxjs/add/operator/timeoutWith.js","webpack:///./~/rxjs/add/operator/timestamp.js","webpack:///./~/rxjs/add/operator/toArray.js","webpack:///./~/rxjs/add/operator/toPromise.js","webpack:///./~/rxjs/add/operator/window.js","webpack:///./~/rxjs/add/operator/windowCount.js","webpack:///./~/rxjs/add/operator/windowTime.js","webpack:///./~/rxjs/add/operator/windowToggle.js","webpack:///./~/rxjs/add/operator/windowWhen.js","webpack:///./~/rxjs/add/operator/withLatestFrom.js","webpack:///./~/rxjs/add/operator/zip.js","webpack:///./~/rxjs/add/operator/zipAll.js","webpack:///./~/rxjs/observable/ArrayLikeObservable.js","webpack:///./~/rxjs/observable/BoundCallbackObservable.js","webpack:///./~/rxjs/observable/BoundNodeCallbackObservable.js","webpack:///./~/rxjs/observable/DeferObservable.js","webpack:///./~/rxjs/observable/ErrorObservable.js","webpack:///./~/rxjs/observable/ForkJoinObservable.js","webpack:///./~/rxjs/observable/FromEventObservable.js","webpack:///./~/rxjs/observable/FromEventPatternObservable.js","webpack:///./~/rxjs/observable/GenerateObservable.js","webpack:///./~/rxjs/observable/IfObservable.js","webpack:///./~/rxjs/observable/IntervalObservable.js","webpack:///./~/rxjs/observable/IteratorObservable.js","webpack:///./~/rxjs/observable/NeverObservable.js","webpack:///./~/rxjs/observable/PairsObservable.js","webpack:///./~/rxjs/observable/RangeObservable.js","webpack:///./~/rxjs/observable/SubscribeOnObservable.js","webpack:///./~/rxjs/observable/TimerObservable.js","webpack:///./~/rxjs/observable/UsingObservable.js","webpack:///./~/rxjs/observable/bindCallback.js","webpack:///./~/rxjs/observable/bindNodeCallback.js","webpack:///./~/rxjs/observable/combineLatest.js","webpack:///./~/rxjs/observable/concat.js","webpack:///./~/rxjs/observable/defer.js","webpack:///./~/rxjs/observable/dom/WebSocketSubject.js","webpack:///./~/rxjs/observable/dom/ajax.js","webpack:///./~/rxjs/observable/dom/webSocket.js","webpack:///./~/rxjs/observable/empty.js","webpack:///./~/rxjs/observable/forkJoin.js","webpack:///./~/rxjs/observable/from.js","webpack:///./~/rxjs/observable/fromEvent.js","webpack:///./~/rxjs/observable/fromEventPattern.js","webpack:///./~/rxjs/observable/fromPromise.js","webpack:///./~/rxjs/observable/generate.js","webpack:///./~/rxjs/observable/if.js","webpack:///./~/rxjs/observable/interval.js","webpack:///./~/rxjs/observable/merge.js","webpack:///./~/rxjs/observable/never.js","webpack:///./~/rxjs/observable/of.js","webpack:///./~/rxjs/observable/onErrorResumeNext.js","webpack:///./~/rxjs/observable/pairs.js","webpack:///./~/rxjs/observable/race.js","webpack:///./~/rxjs/observable/range.js","webpack:///./~/rxjs/observable/throw.js","webpack:///./~/rxjs/observable/timer.js","webpack:///./~/rxjs/observable/using.js","webpack:///./~/rxjs/observable/zip.js","webpack:///./~/rxjs/operator/audit.js","webpack:///./~/rxjs/operator/auditTime.js","webpack:///./~/rxjs/operator/buffer.js","webpack:///./~/rxjs/operator/bufferCount.js","webpack:///./~/rxjs/operator/bufferTime.js","webpack:///./~/rxjs/operator/bufferToggle.js","webpack:///./~/rxjs/operator/bufferWhen.js","webpack:///./~/rxjs/operator/catch.js","webpack:///./~/rxjs/operator/combineAll.js","webpack:///./~/rxjs/operator/concatAll.js","webpack:///./~/rxjs/operator/concatMap.js","webpack:///./~/rxjs/operator/concatMapTo.js","webpack:///./~/rxjs/operator/count.js","webpack:///./~/rxjs/operator/debounce.js","webpack:///./~/rxjs/operator/debounceTime.js","webpack:///./~/rxjs/operator/defaultIfEmpty.js","webpack:///./~/rxjs/operator/delay.js","webpack:///./~/rxjs/operator/delayWhen.js","webpack:///./~/rxjs/operator/dematerialize.js","webpack:///./~/rxjs/operator/distinct.js","webpack:///./~/rxjs/operator/distinctUntilKeyChanged.js","webpack:///./~/rxjs/operator/do.js","webpack:///./~/rxjs/operator/elementAt.js","webpack:///./~/rxjs/operator/every.js","webpack:///./~/rxjs/operator/exhaust.js","webpack:///./~/rxjs/operator/exhaustMap.js","webpack:///./~/rxjs/operator/expand.js","webpack:///./~/rxjs/operator/finally.js","webpack:///./~/rxjs/operator/findIndex.js","webpack:///./~/rxjs/operator/first.js","webpack:///./~/rxjs/operator/groupBy.js","webpack:///./~/rxjs/operator/ignoreElements.js","webpack:///./~/rxjs/operator/isEmpty.js","webpack:///./~/rxjs/operator/last.js","webpack:///./~/rxjs/operator/let.js","webpack:///./~/rxjs/operator/mapTo.js","webpack:///./~/rxjs/operator/materialize.js","webpack:///./~/rxjs/operator/max.js","webpack:///./~/rxjs/operator/mergeScan.js","webpack:///./~/rxjs/operator/min.js","webpack:///./~/rxjs/operator/pairwise.js","webpack:///./~/rxjs/operator/partition.js","webpack:///./~/rxjs/operator/pluck.js","webpack:///./~/rxjs/operator/publish.js","webpack:///./~/rxjs/operator/publishBehavior.js","webpack:///./~/rxjs/operator/publishLast.js","webpack:///./~/rxjs/operator/publishReplay.js","webpack:///./~/rxjs/operator/repeat.js","webpack:///./~/rxjs/operator/repeatWhen.js","webpack:///./~/rxjs/operator/retry.js","webpack:///./~/rxjs/operator/retryWhen.js","webpack:///./~/rxjs/operator/sample.js","webpack:///./~/rxjs/operator/sampleTime.js","webpack:///./~/rxjs/operator/scan.js","webpack:///./~/rxjs/operator/sequenceEqual.js","webpack:///./~/rxjs/operator/share.js","webpack:///./~/rxjs/operator/shareReplay.js","webpack:///./~/rxjs/operator/single.js","webpack:///./~/rxjs/operator/skip.js","webpack:///./~/rxjs/operator/skipLast.js","webpack:///./~/rxjs/operator/skipUntil.js","webpack:///./~/rxjs/operator/skipWhile.js","webpack:///./~/rxjs/operator/startWith.js","webpack:///./~/rxjs/operator/subscribeOn.js","webpack:///./~/rxjs/operator/switch.js","webpack:///./~/rxjs/operator/switchMap.js","webpack:///./~/rxjs/operator/switchMapTo.js","webpack:///./~/rxjs/operator/take.js","webpack:///./~/rxjs/operator/takeLast.js","webpack:///./~/rxjs/operator/takeUntil.js","webpack:///./~/rxjs/operator/takeWhile.js","webpack:///./~/rxjs/operator/throttleTime.js","webpack:///./~/rxjs/operator/timeout.js","webpack:///./~/rxjs/operator/timeoutWith.js","webpack:///./~/rxjs/operator/toArray.js","webpack:///./~/rxjs/operator/toPromise.js","webpack:///./~/rxjs/operator/window.js","webpack:///./~/rxjs/operator/windowCount.js","webpack:///./~/rxjs/operator/windowTime.js","webpack:///./~/rxjs/operator/windowToggle.js","webpack:///./~/rxjs/operator/windowWhen.js","webpack:///./~/rxjs/operator/withLatestFrom.js","webpack:///./~/rxjs/operator/zipAll.js","webpack:///./~/rxjs/scheduler/Action.js","webpack:///./~/rxjs/scheduler/AnimationFrameAction.js","webpack:///./~/rxjs/scheduler/AnimationFrameScheduler.js","webpack:///./~/rxjs/scheduler/AsapAction.js","webpack:///./~/rxjs/scheduler/AsapScheduler.js","webpack:///./~/rxjs/scheduler/QueueAction.js","webpack:///./~/rxjs/scheduler/QueueScheduler.js","webpack:///./~/rxjs/scheduler/animationFrame.js","webpack:///./~/rxjs/testing/ColdObservable.js","webpack:///./~/rxjs/testing/HotObservable.js","webpack:///./~/rxjs/testing/TestScheduler.js","webpack:///./~/rxjs/util/AnimationFrame.js","webpack:///./~/rxjs/util/FastMap.js","webpack:///./~/rxjs/util/Immediate.js","webpack:///./~/rxjs/util/Map.js","webpack:///./~/rxjs/util/MapPolyfill.js","webpack:///./~/rxjs/util/Set.js","webpack:///./~/rxjs/util/assign.js","webpack:///./~/rxjs/util/not.js","webpack:///./~/rxjs/util/toSubscriber.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/vue-router/dist/vue-router.esm.js","webpack:///./~/vue-style-loader/lib/listToStyles.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/lib/addStylesClient.js"],"names":["webpackJsonp","module","exports","__webpack_require__","root_1","toSubscriber_1","observable_1","Observable","subscribe","this","_isScalar","_subscribe","prototype","lift","operator","observable","source","observerOrNext","error","complete","sink","toSubscriber","call","add","_trySubscribe","syncErrorThrowable","syncErrorThrown","syncErrorValue","err","forEach","next","PromiseCtor","_this","root","Rx","config","Promise","Error","resolve","reject","subscription","value","unsubscribe","subscriber","create","__extends","d","b","__","constructor","p","hasOwnProperty","Object","isFunction_1","Subscription_1","Observer_1","rxSubscriber_1","Subscriber","_super","destinationOrNext","isStopped","arguments","length","destination","empty","SafeSubscriber","rxSubscriber","_next","_error","_complete","closed","_unsubscribeAndRecycle","_a","_parent","_parents","Subscription","_parentSubscriber","context","isFunction","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","fn","parent","_unsubscribe","Subscriber_1","OuterSubscriber","apply","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","subscribeToResult","outerSubscriber","result","InnerSubscriber_1","InnerSubscriber","Observable_1","isArrayLike_1","isArrayLike","i","len","isPromise_1","isPromise","then","setTimeout","iterator_1","iterator","item","done","obs","TypeError","isObject_1","isObject","msg","flattenUnsubscriptionErrors","errors","reduce","errs","concat","UnsubscriptionError_1","UnsubscriptionError","isArray_1","tryCatch_1","errorObject_1","_subscriptions","hasErrors","index","remove","trial","tryCatch","errorObject","e","isArray","sub","push","teardown","EMPTY","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","ObjectUnsubscribedError_1","SubjectSubscription_1","SubjectSubscriber","Subject","observers","hasError","thrownError","subject","AnonymousSubject","ObjectUnsubscribedError","copy","slice","SubjectSubscription","asObservable","global","__window","window","__self","self","WorkerGlobalScope","__global","_root","tryCatcher","tryCatchTarget","AsyncAction_1","AsyncScheduler_1","async","AsyncScheduler","AsyncAction","ScalarObservable_1","EmptyObservable_1","isScheduler_1","ArrayObservable","array","scheduler","of","_i","isScheduler","pop","ScalarObservable","EmptyObservable","dispatch","state","count","schedule","Array","x","arg","multicast","subjectOrSubjectFactory","selector","subjectFactory","MulticastOperator","connectable","ConnectableObservable_1","connectableObservableDescriptor","factory","ascendingComparator","f","ascending","pair","a","tickIncrement","start","stop","step","Math","max","power","floor","log","LN10","pow","e10","e5","e2","tickStep","step0","abs","step1","translateX","translateY","y","number$1","scale","center","offset","bandwidth","round","entering","__axis","axis","orient","values","tickValues","ticks","tickArguments","domain","format","tickFormat","identity$1","spacing","tickSizeInner","tickPadding","range","range0","range1","position","selection","path","selectAll","data","tick","order","tickExit","exit","tickEnter","enter","append","attr","line","select","text","merge","insert","k","top","bottom","transition","epsilon","isFinite","transform","getAttribute","parentNode","left","right","tickSizeOuter","filter","each","_","slice$1","tickSize","axisTop","axisRight","axisBottom","axisLeft","t","n","Dispatch","parseTypenames","typenames","types","trim","split","map","name","type","get","c","set","callback","noop","creatorInherit","document","ownerDocument","uri","namespaceURI","xhtml","documentElement","createElement","createElementNS","creatorFixed","fullname","space","local","local$1","Local","nextId","toString","filterContextListener","listener","group","contextListener","event","related","relatedTarget","compareDocumentPosition","event1","event0","__data__","parseTypenames$1","onRemove","typename","on","__on","o","j","m","removeEventListener","capture","onAdd","wrap","filterEvents","addEventListener","customEvent","that","args","sourceEvent","none","empty$1","EnterNode","datum","bindIndex","update","node","groupLength","dataLength","bindKey","key","keyValue","nodeByKeyValue","keyValues","keyPrefix","ascending$1","NaN","attrRemove","removeAttribute","attrRemoveNS","removeAttributeNS","attrConstant","setAttribute","attrConstantNS","setAttributeNS","attrFunction","v","attrFunctionNS","styleRemove","style","removeProperty","styleConstant","priority","setProperty","styleFunction","styleValue","getPropertyValue","defaultView","getComputedStyle","propertyRemove","propertyConstant","propertyFunction","classArray","string","classList","ClassList","_node","_names","classedAdd","names","list","classedRemove","classedTrue","classedFalse","classedFunction","textRemove","textContent","textConstant","textFunction","htmlRemove","innerHTML","htmlConstant","htmlFunction","raise","nextSibling","appendChild","lower","previousSibling","insertBefore","firstChild","constantNull","removeChild","dispatchEvent","params","CustomEvent","createEvent","initEvent","bubbles","cancelable","detail","dispatchConstant","dispatchFunction","Selection","groups","parents","_groups","nopropagation","stopImmediatePropagation","yesdrag","view","noclick","selection$$1","noevent","MozUserSelect","__noselect","DragEvent","target","id","active","dx","dy","identifier","defaultFilter$1","button","defaultContainer","defaultSubject","touchable","extend","definition","Color","color","toLowerCase","reHex3","exec","parseInt","Rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reRgbaInteger","rgba","reRgbaPercent","reHslPercent","hsla","reHslaPercent","named","r","g","rgbConvert","rgb","opacity","h","s","l","Hsl","hslConvert","min","hsl","hsl2rgb","m1","m2","labConvert","Lab","Hcl","deg2rad","cos","sin","rgb2xyz","xyz2lab","Xn","Yn","Zn","lab","t3","t2","t0","lab2xyz","t1","xyz2rgb","hclConvert","atan2","rad2deg","sqrt","hcl","cubehelixConvert","Cubehelix","BC_DA","ED","EB","bl","E","C","D","cubehelix","basis","v0","v1","v2","v3","linear","exponential","hue","constant$3","isNaN","gamma","nogamma","rgbSpline","spline","colors","color$$1","zero","one","parseCss","identity$2","cssNode","cssRoot","cssView","decompose","parseSvg","svgNode","baseVal","consolidate","matrix","interpolateTransform","parse","pxComma","pxParen","degParen","translate","xa","ya","xb","yb","q","reinterpolate","rotate","skewX","scaleX","scaleY","join","cosh","exp","sinh","tanh","hsl$1","hue$$1","end","lab$1","hcl$1","cubehelix$1","cubehelixGamma","cubehelix$$1","now","clockNow","setFrame","clearNow","clock","clockSkew","Timer","_call","_time","timer","delay","time","restart","timerFlush","frame","taskHead","wake","clockLast","timeout","nap","poke","pokeDelay","Infinity","taskTail","sleep","clearTimeout","interval","clearInterval","setInterval","init","__transition","CREATED","set$1","STARTING","get$1","elapsed","SCHEDULED","schedules","STARTED","timeout$1","RUNNING","ENDED","tween","duration","ease","ENDING","tweenRemove","tween0","tween1","schedule$$1","tweenFunction","tweenValue","_id","attrRemove$1","attrRemoveNS$1","attrConstant$1","interpolate$$1","value1","value00","interpolate0","value0","attrConstantNS$1","getAttributeNS","attrFunction$1","value10","attrFunctionNS$1","attrTweenNS","_value","attrTween","delayFunction","delayConstant","durationFunction","durationConstant","easeConstant","every","onFunction","on0","on1","sit","removeFunction","styleRemove$1","styleRemoveEnd","styleConstant$1","styleFunction$1","styleTween","textConstant$1","textFunction$1","Transition","_name","newId","linear$1","quadIn","quadOut","quadInOut","cubicIn","cubicOut","cubicInOut","sinIn","halfPi","sinOut","sinInOut","pi","expIn","expOut","expInOut","circleIn","circleOut","circleInOut","bounceIn","bounceOut","b1","b0","b3","b2","b4","b6","b5","b7","b8","b9","bounceInOut","inherit","timing","defaultTiming","nopropagation$1","defaultFilter","defaultExtent","svg","ownerSVGElement","width","height","local$$1","__brush","extent","brushSelection","dim","output","brushX","brush$1","X","brushY","Y","brush","overlay","property","initialize","cursors","handle","handles","redraw","started","handleSize","emitter","Emitter","moved","point1","mouse","shifting","lockX","lockY","point","moving","noevent$1","move","point0","mode","MODE_SPACE","MODE_DRAG","signX","W","w0","e0","w1","e1","signY","N","n0","S","s0","n1","s1","MODE_HANDLE","MODE_CENTER","flipX","flipY","emit","ended","touches","touchending","keydowned","keyCode","keyupped","altKey","changedTouches","metaKey","signsX","signsY","shiftKey","beforestart","dragDisable","interrupt","listeners","selection1","selection0","input","interpolateValue","starting","BrushEvent","constant$4","compareValue","compare","Path","_x0","_y0","_x1","_y1","defaultSource","defaultTarget","defaultRadius","radius","defaultStartAngle","startAngle","defaultEndAngle","endAngle","Map","map$1","object","createObject","setObject","createMap","setMap","Set","set$2","objectConverter","columns","Function","JSON","stringify","customConverter","row","inferColumns","rows","columnSet","column","tree","xm","ym","xp","yp","leaf","x0","y0","x1","y1","_x","_y","addAll","xz","yz","cover","removeAll","defaultX","defaultY","quadtree","nodes","Quadtree","undefined","leaf_copy","vx","vy","find","nodeById","nodeId","x$1","y$1","formatSpecifier","specifier","FormatSpecifier","match","re","fill","align","sign","symbol","comma","precision","formatTypes","defaultLocale","locale$1","formatLocale","formatPrefix","Adder","reset","add$1","adder","bv","av","acos","pi$3","asin","halfPi$2","haversin","sin$1","noop$1","streamGeometry","geometry","stream","streamGeometryType","streamLine","coordinates","coordinate","lineStart","lineEnd","streamPolygon","polygonStart","polygonEnd","areaRingStart","areaStream","areaPointFirst","areaRingEnd","areaPoint","lambda00","phi00","lambda","phi","radians","lambda0","cosPhi0","cos$1","quarterPi","sinPhi0","dLambda","sdLambda","adLambda","cosPhi","sinPhi","u","areaRingSum","spherical","cartesian","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","boundsPoint","ranges","lambda0$1","lambda1","phi0","phi1","linePoint","p0","normal","equatorial","inflection","phii","delta","lambda2","sign$$1","lambdai","degrees$1","antimeridian","angle","boundsLineStart","boundsStream","boundsLineEnd","boundsRingPoint","deltaSum","lambda00$1","phi00$1","boundsRingStart","boundsRingEnd","epsilon$2","rangeCompare","rangeContains","centroidPoint","centroidPointCartesian","z","W0","X0","Y0","Z0","centroidLineStart","centroidStream","centroidLinePointFirst","z0","centroidLinePoint","w","W1","X1","Y1","Z1","centroidLineEnd","centroidRingStart","centroidRingPointFirst","centroidRingEnd","centroidRingPoint","lambda00$2","phi00$2","cx","cy","cz","X2","Y2","Z2","rotationIdentity","tau$3","rotateRadians","deltaLambda","deltaPhi","deltaGamma","compose","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","invert","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","circleStream","direction","cosRadius","sinRadius","circleRadius","Intersection","points","other","entry","link$1","clipExtent","visible","interpolate","from","to","a1","corner","comparePoint","compareIntersection","ca","cb","activeStream","polygonInside","winding","polygon","a0","ring","bufferStream","segments","clean","startInside","cleanInside","clipPolygon","clipStream","first","v_","x_","y_","x__","y__","v__","rejoin","clipMin","clipMax","clipLine","clipBuffer","lengthLineStart","lengthStream","lengthPointFirst","lengthLineEnd","lambda0$2","sinPhi0$1","cosPhi0$1","lengthPoint","cosDelta","sinDelta","lengthSum","containsGeometry","containsGeometryType","containsPoint","distance","containsLine","ab","containsPolygon","polygonContains","ringRadians","pointRadians","graticuleX","sequence","graticuleY","graticule","lines","ceil","DX","DY","outline","reverse","extentMajor","extentMinor","stepMajor","stepMinor","graticule10","areaRingStart$1","areaStream$1","areaPointFirst$1","areaPoint$1","x00","x0$1","y00","y0$1","areaRingSum$1","areaRingEnd$1","boundsPoint$1","x0$2","y0$2","centroidPoint$1","X0$1","Y0$1","Z0$1","centroidLineStart$1","centroidStream$1","centroidPointFirstLine","centroidPointLine","x0$3","y0$3","X1$1","Y1$1","Z1$1","centroidLineEnd$1","centroidRingStart$1","centroidPointFirstRing","centroidRingEnd$1","centroidPointRing","x00$1","y00$1","X2$1","Y2$1","Z2$1","PathContext","lengthPointFirst$1","lengthStream$1","lengthPoint$1","x00$2","x0$4","y00$2","y0$4","lengthSum$1","PathString","_string","circle$1","validSegment","segment","clipAntimeridianLine","sign0","sign1","clipAntimeridianIntersect","cosPhi1","sinLambda0Lambda1","atan","clipAntimeridianInterpolate","transformer","methods","TransformStream","fitExtent","projection","clip","geoStream","boundsStream$1","fitSize","size","resampleNone","project","resample$1","delta2","resampleLineTo","c0","c1","depth","d2","phi2","x2","y2","dx2","dy2","dz","cosMinDistance","resampleStream","maxDepth","ringStart","ringPoint","ringEnd","a00","b00","c00","projectionMutator","projectAt","projectRotate","projectTransform","recenter","cache","cacheStream","theta","preclip","clipAntimeridian","postclip","identity$4","projectResample","resample","transformRadians","clipAngle","clipCircle","conicProjection","parallels","cylindricalEqualAreaRaw","forward","conicEqualAreaRaw","r0","sy0","r0y","multiplex","streams","sphere","azimuthalRaw","azimuthalInvert","sc","cc","mercatorRaw","tan","mercatorProjection","reclip","tany","conicConformalRaw","cy0","fy","equirectangularRaw","conicEquidistantRaw","gy","nx","gnomonicRaw","scaleTranslate","kx","ky","tx","ty","orthographicRaw","stereographicRaw","transverseMercatorRaw","defaultSeparation","meanX","children","meanXReduce","maxY","maxYReduce","leafLeft","leafRight","sum","leastCommonAncestor","aNodes","ancestors","bNodes","hierarchy","child","childs","Node","valued","defaultChildren","eachBefore","computeHeight","node_copy","copyData","shuffle$1","random","extendBasis","B","enclosesWeakAll","enclosesNot","encloseBasis2","encloseBasis3","dr","enclosesWeak","encloseBasis","encloseBasis1","r1","r2","x21","y21","r21","x3","y3","r3","a2","a3","c2","c3","d1","d3","A","place","ax","ay","da","db","dc","intersects","score","Node$1","circle","previous","packEnclose","circles","aa","sj","sk","pack","enclose","optional","required","constantZero","defaultRadius$1","radiusLeaf","packChildren","padding","translateChild","defaultId","defaultParentId","parentId","defaultSeparation$1","nextLeft","nextRight","moveSubtree","wm","wp","shift","change","executeShifts","nextAncestor","vim","ancestor","TreeNode","treeRoot","squarifyRatio","ratio","nodeValue","sumValue","minValue","maxValue","newRatio","minRatio","alpha","beta","i0","i1","dice","treemapDice","treemapSlice","lexicographicOrder","computeUpperHullIndexes","indexes","cross$1","Queue","_size","_tasks","_data","_waiting","_active","_ended","_start","poke$1","start$1","abort","noabort","maybeNotify","queue","concurrency","fixCallback","xhr","hasResponse","responseType","response","responseText","responseOf","request$$1","ordinal","unknown","implicit","slice$5","has","band","rescale","paddingInner","paddingOuter","ordinalRange","rangeRound","pointish","point$1","deinterpolateLinear","constant$9","deinterpolateClamp","deinterpolate","reinterpolateClamp","reinterpolate$$1","bimap","d0","polymap","bisectRight","clamp","continuous","piecewise","unit","map$3","number$2","interpolateRound","linearish","nice","linear$2","identity$6","reinterpolate$1","pow10","powp","base","logp","log10","log2","reflect","log$1","logs","pows","raise$1","exponent","pow$1","sqrt$1","quantile","thresholds","threshold","invertExtent","sort","quantiles","quantize$1","threshold$1","newInterval","floori","offseti","field","date","Date","test","setTime","t0$1","t1$1","weekday","setDate","getDate","getDay","setHours","getTimezoneOffset","durationMinute$1","durationWeek$1","utcWeekday","setUTCDate","getUTCDate","getUTCDay","setUTCHours","localDate","H","M","L","setFullYear","utcDate","UTC","setUTCFullYear","newYear","formatLocale$1","locale","newFormat","formats","pad","charCodeAt","pads","charAt","newParse","newDate","parseSpecifier","day$$1","U","Z","parses","parsePeriod","periodRe","periodLookup","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","getMonth","formatMonth","locale_months","formatPeriod","locale_periods","getHours","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","getUTCMonth","formatUTCMonth","formatUTCPeriod","getUTCHours","dateTime","periods","days","shortDays","months","shortMonths","formatRe","formatLookup","formatDayOfMonth","formatHour24","I","formatHour12","formatDayOfYear","formatMilliseconds","formatMonthNumber","formatMinutes","formatSeconds","formatWeekNumberSunday","formatWeekdayNumber","formatWeekNumberMonday","formatYear","formatFullYear","formatZone","%","formatLiteralPercent","utcFormats","formatUTCDayOfMonth","formatUTCHour24","formatUTCHour12","formatUTCDayOfYear","formatUTCMilliseconds","formatUTCMonthNumber","formatUTCMinutes","formatUTCSeconds","formatUTCWeekNumberSunday","formatUTCWeekdayNumber","formatUTCWeekNumberMonday","formatUTCYear","formatUTCFullYear","formatUTCZone","parseDayOfMonth","parseHour24","parseDayOfYear","parseMilliseconds","parseMonthNumber","parseMinutes","parseSeconds","parseWeekNumberSunday","parseWeekdayNumber","parseWeekNumberMonday","parseYear","parseFullYear","parseZone","parseLiteralPercent","utcFormat","utcParse","requote","replace","requoteRe","RegExp","numberRe","percentRe","day","year","getMilliseconds","getMinutes","getSeconds","sunday","monday","getFullYear","utcDay","utcYear","getUTCMilliseconds","getUTCMinutes","getUTCSeconds","utcSunday","utcMonday","getUTCFullYear","defaultLocale$1","locale$2","timeFormat","timeParse","formatIsoNative","toISOString","parseIsoNative","date$1","number$3","calendar","year$$1","month$$1","week","hour$$1","minute$$1","second$$1","millisecond$$1","date$$1","formatMillisecond","formatSecond","formatMinute","formatHour","formatDay","formatWeek","tickInterval","interval$$1","bisector","tickIntervals","durationYear","durationSecond","durationMinute","durationHour","durationDay","durationWeek","durationMonth","ramp","sequential","interpolator","acos$1","pi$4","asin$1","halfPi$3","arcInnerRadius","innerRadius","arcOuterRadius","outerRadius","arcStartAngle","arcEndAngle","arcPadAngle","padAngle","intersect","x10","y10","x32","y32","cornerTangents","rc","cw","x01","y01","lo","sqrt$2","ox","oy","x11","y11","max$2","cx0","cx1","cy1","dx0","dy0","dx1","dy1","Linear","x$3","y$3","Radial","curve","_curve","curveRadial","radial","lineRadial","linkSource","linkTarget","link$2","link","buffer","argv","slice$6","constant$10","curveHorizontal","moveTo","bezierCurveTo","curveVertical","curveRadial$1","pointRadial","p1","p2","p3","linkHorizontal","linkVertical","linkRadial","point$2","Basis","BasisClosed","BasisOpen","Bundle","_basis","_beta","point$3","_k","_x2","_y2","Cardinal","tension","CardinalClosed","CardinalOpen","point$4","_l01_a","epsilon$3","_l01_2a","_l12_a","_l12_2a","_l23_a","_l23_2a","CatmullRom","_alpha","CatmullRomClosed","CatmullRomOpen","LinearClosed","sign$1","slope3","h0","h1","slope2","point$5","MonotoneX","MonotoneY","ReflectContext","monotoneX","monotoneY","Natural","controlPoints","Step","_t","stepBefore","stepAfter","stackValue","sum$2","series","x$4","y$4","RedBlackTree","RedBlackNode","R","P","RedBlackRotateLeft","RedBlackRotateRight","RedBlackFirst","createEdge","edge","edges","setEdgeEnd","cells","halfedges","createBorderEdge","vertex","clipEdge","bx","by","connectEdge","fm","fb","lx","ly","rx","ry","fx","clipEdges","epsilon$4","createCell","site","cellHalfedgeAngle","cell","va","vb","cellHalfedgeStart","cellHalfedgeEnd","sortCellHalfedges","clipCells","iCell","iHalfedge","nHalfedges","startX","startY","endX","endY","nCells","v00","v01","v11","v10","Circle","arc","attachCircle","lArc","rArc","lSite","cSite","rSite","epsilon2$2","ha","hc","circlePool","before","firstCircle","detachCircle","Beach","createBeach","beach","beachPool","detachBeach","beaches","removeBeach","disappearing","unshift","iArc","nArcs","addBeach","dxl","dxr","directrix","leftBreakPoint","rightBreakPoint","newArc","hb","rfocx","rfocy","pby2","lfocx","lfocy","plby2","hl","aby2","triangleArea","lexicographic","Diagram","sites","ZoomEvent","Transform","transform$1","__zoom","identity$8","nopropagation$2","defaultFilter$2","defaultExtent$1","SVGElement","clientWidth","clientHeight","defaultTransform","defaultWheelDelta","deltaY","deltaMode","touchable$1","hi","mid","ascendingBisect","bisectLeft","pairs","cross","values0","values1","descending","number","variance","valueof","mean","deviation","constant","identity","sturges","LN2","histogram","tz","bin","bins","freedmanDiaconis","scott","median","numbers","arrays","merged","permute","permutes","scan","xi","xj","shuffle","transpose","zip","T","namespaces","xlink","xml","xmlns","namespace","prefix","creator","matcher","matches","element","vendorMatches","webkitMatchesSelector","msMatchesSelector","mozMatchesSelector","oMatchesSelector","matcher$1","mouseenter","mouseleave","selection_on","current","createSVGPoint","clientX","clientY","matrixTransform","getScreenCTM","inverse","rect","getBoundingClientRect","clientLeft","clientTop","querySelector","selection_select","subgroups","subnode","subgroup","selectorAll","querySelectorAll","selection_selectAll","selection_filter","sparse","selection_enter","_enter","constant$1","selection_data","enterGroup","updateGroup","_exit","selection_exit","selection_merge","groups0","groups1","m0","merges","group0","group1","selection_order","selection_sort","compareNode","sortgroups","sortgroup","selection_call","selection_nodes","selection_node","selection_size","selection_empty","selection_each","selection_attr","selection_style","selection_property","contains","selection_classed","selection_text","selection_html","selection_raise","selection_lower","selection_append","selection_insert","selection_remove","selection_datum","selection_dispatch","classed","html","touch","preventDefault","constant$2","drag","mousedowned","touchstarted","touchmoved","touchended","gesture","container","mousemoved","mouseupped","mousemoving","mousedownx","mousedowny","clickDistance2","gestures","touches$$1","sublisteners","clickDistance","define","reI","reN","reP","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","displayable","brighter","darker","PI","basis$1","basisClosed","interpolateRgb","rgbGamma","rgb$$1","rgbBasis","rgbBasisClosed","array$1","nb","na","reA","reB","interpolateString","am","bm","bs","bi","lastIndex","valueOf","degrees","interpolateTransformCss","interpolateTransformSvg","rho","SQRT2","interpolateZoom","ux0","uy0","ux1","uy1","coshr0","hsl$2","hslLong","hcl$2","hclLong","cubehelix$2","cubehelixLong","quantize","samples","performance","requestAnimationFrame","interval$1","total","emptyOn","emptyTween","selection_interrupt","transition_tween","transition_attr","transition_attrTween","transition_delay","transition_duration","transition_ease","transition_filter","transition_merge","transition$$1","transition_on","transition_remove","transition_select","select$$1","transition_selectAll","Selection$1","transition_selection","transition_style","transition_styleTween","transition_text","transition_transition","id0","id1","selection_prototype","polyIn","custom","polyOut","polyInOut","backIn","overshoot","backOut","backInOut","tau","elasticIn","amplitude","period","elasticOut","elasticInOut","selection_transition","root$1","xy","XY","nw","ne","se","sw","pi$1","halfPi$1","tau$1","max$1","chord","groupSums","groupIndex","subgroupIndex","chords","sortGroups","sortSubgroups","di","dj","subindex","sortChords","slice$2","constant$5","pi$2","tau$2","tauEpsilon","closePath","lineTo","quadraticCurveTo","arcTo","l01_2","x20","y20","l21_2","l20_2","l21","l01","t01","t21","ccw","ribbon","sr","sa0","sa1","sx0","tr","ta0","ta1","clear","keys","entries","nest","createResult","setResult","sortValues","rollup","valuesByKey","sortKey","sortKeys","proto","dsv","delimiter","convert","parseRows","token","EOF","eol","EOL","delimiterCode","formatValue","formatRows","formatRow","reFormat","csv","csvParse","csvParseRows","csvFormat","csvFormatRows","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatRows","center$1","force","sx","sy","constant$6","jiggle","tree_add","tree_cover","tree_data","visit","tree_extent","Quad","tree_find","quads","tree_remove","retainer","tree_root","tree_size","tree_visit","tree_visitAfter","tree_x","tree_y","treeProto","visitAfter","prefixExponent","collide","quad","rj","ri","yi","strength","ri2","iterations","prepare","radii","links","defaultStrength","distances","strengths","bias","initializeStrength","initializeDistance","initialRadius","initialAngle","simulation","alphaMin","stepper","alphaTarget","alphaDecay","forces","velocityDecay","initializeNodes","initializeForce","closest","manyBody","accumulate","theta2","distanceMax2","distanceMin2","distanceMin","distanceMax","x$2","y$2","formatDecimal","toExponential","coefficient","exponent$1","formatGroup","grouping","thousands","substring","formatNumerals","numerals","formatDefault","toPrecision","out","formatPrefixAuto","formatRounded","","toFixed","toUpperCase","identity$3","prefixes","valuePrefix","valueSuffix","suffix","formatType","valueNegative","maybeSuffix","decimal","currency","percent","precisionFixed","precisionPrefix","precisionRound","temp","streamObjectType","Feature","FeatureCollection","features","Sphere","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","geometries","areaSum","areaRing","area","bounds","feature","deltaMax","centroid","constant$7","pointEqual","isSubject","extent$1","sum$1","sinPhi1","absDelta","intersection","phiArc","length$1","object$1","containsObjectType","interpolate$1","sy1","kx0","ky0","kx1","ky1","areaSum$1","_radius","pointRadius","_line","_point","lengthRing","_circle","index$1","contextStream","projectionStream","measure","pointVisible","pointLine","pointRing","ringSink","ringSegments","ringBuffer","polygonStarted","rotatedStart","cr","point2","smallRadius","code","notHemisphere","two","pa","pb","n2","n2n2","n1n2","determinant","n1xn2","uu","polar","meridian","q1","conicEqualArea","albers","albersUsa","lower48Point","alaskaPoint","hawaiiPoint","lower48","alaska","hawaii","pointStream","azimuthalEqualAreaRaw","cxcy","azimuthalEqualArea","azimuthalEquidistantRaw","azimuthalEquidistant","mercator","conicConformal","equirectangular","conicEquidistant","gnomonic","identity$5","transform$$1","reflectX","reflectY","orthographic","stereographic","transverseMercator","cluster","previousNode","eachAfter","separation","nodeSize","node_count","node_each","node_eachBefore","node_eachAfter","node_sum","node_sort","node_path","node_ancestors","node_descendants","node_leaves","leaves","node_links","descendants","slice$3","siblings","constant$8","index$2","roundNode","partition","positionNode","keyPrefix$1","preroot","ambiguous","stratify","nodeKey","nodeByKey","firstWalk","secondWalk","sizeNode","midpoint","apportion","vip","vop","vom","sip","sop","sim","som","squarify","index$3","treemap","paddingStack","paddingLeft","paddingTop","paddingRight","paddingBottom","tile","binary","valueOffset","sums","valueTarget","valueLeft","valueRight","xk","yk","sliceDice","resquarify","_squarify","area$1","centroid$1","hull","sortedPoints","flippedPoints","upperIndexes","lowerIndexes","skipLeft","skipRight","contains$1","inside","length$2","perimeter","slice$4","defer","await","results","awaitAll","defaultSource$1","uniform","sourceRandomUniform","randomUniform","sourceRandomNormal","randomNormal","mu","sigma","logNormal","sourceRandomLogNormal","randomLogNormal","irwinHall","sourceRandomIrwinHall","randomIrwinHall","bates","sourceRandomBates","randomBates","exponential$1","sourceRandomExponential","randomExponential","request","url","respond","status","mimeType","headers","XMLHttpRequest","user","password","XDomainRequest","onload","onerror","ontimeout","onreadystatechange","readyState","onprogress","header","send","post","method","open","setRequestHeader","overrideMimeType","type$1","defaultMimeType","createRange","createContextualFragment","json","responseXML","dsv$1","csv$1","tsv$1","array$2","millisecond","milliseconds","second","seconds","minute","minutes","hour","hours","tuesday","wednesday","thursday","friday","saturday","sundays","mondays","tuesdays","wednesdays","thursdays","fridays","saturdays","month","setMonth","years","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcTuesday","utcWednesday","utcThursday","utcFriday","utcSaturday","utcSundays","utcMondays","utcTuesdays","utcWednesdays","utcThursdays","utcFridays","utcSaturdays","utcMonth","setUTCMonth","utcMonths","utcYears","-","0","formatIso","parseIso","utcTime","category10","category20b","category20c","category20","cubehelix$3","warm","cool","rainbow","rainbow$1","ts","viridis","magma","inferno","plasma","abs$1","atan2$1","cos$2","min$1","sin$2","tau$4","a01","a11","a10","da0","da1","ap","rp","padRadius","cornerRadius","rc0","rc1","oc","kc","lc","areaStart","areaEnd","curveLinear","defined0","defined","area$2","x0z","y0z","arealine","lineX0","lineY0","lineY1","lineX1","descending$1","identity$7","pie","arcs","curveRadialLinear","lineRadial$1","areaRadial","lineStartAngle","lineEndAngle","lineInnerRadius","lineOuterRadius","circle$2","draw","cross$2","tan30","tan30_2","diamond","kr","star","square","sqrt3","triangle","wye","symbols","noop$2","basis$2","_x3","_x4","_y3","_y4","basisClosed$1","basisOpen","bundle","cardinal","_x5","_y5","cardinalClosed","cardinal$$1","cardinalOpen","x23","y23","catmullRom","catmullRomClosed","catmullRom$$1","catmullRomOpen","linearClosed","_t0","px","py","natural","none$1","none$2","stack","oz","kz","sz","sij","ki","si","expand","diverging","yn","silhouette","wiggle","s2","sij0","sij1","s3","ascending$2","descending$2","insideOut","tops","bottoms","constant$11","after","grandpa","uncle","sibling","polygons","triangles","_found","voronoi","constant$12","applyX","applyY","location","invertX","invertY","rescaleX","rescaleY","noevent$2","zoom","wheeled","dblclicked","k0","k1","constrain","Gesture","wheelidled","wheel","wheelDelta","wheelDelay","touch0","touch1","touchstarting","touchDelay","l0","l1","dp","dl","collection","scaleBy","scaleTo","translateBy","translateTo","scaleExtent","translateExtent","version","bisect","thresholdFreedmanDiaconis","thresholdScott","thresholdSturges","dragEnable","dsvFormat","easeLinear","easeQuad","easeQuadIn","easeQuadOut","easeQuadInOut","easeCubic","easeCubicIn","easeCubicOut","easeCubicInOut","easePoly","easePolyIn","easePolyOut","easePolyInOut","easeSin","easeSinIn","easeSinOut","easeSinInOut","easeExp","easeExpIn","easeExpOut","easeExpInOut","easeCircle","easeCircleIn","easeCircleOut","easeCircleInOut","easeBounce","easeBounceIn","easeBounceOut","easeBounceInOut","easeBack","easeBackIn","easeBackOut","easeBackInOut","easeElastic","easeElasticIn","easeElasticOut","easeElasticInOut","forceCenter","forceCollide","forceLink","forceManyBody","forceSimulation","forceX","forceY","formatDefaultLocale","geoArea","geoBounds","geoCentroid","geoCircle","geoClipExtent","geoContains","geoDistance","geoGraticule","geoGraticule10","geoInterpolate","geoLength","geoPath","geoAlbers","geoAlbersUsa","geoAzimuthalEqualArea","geoAzimuthalEqualAreaRaw","geoAzimuthalEquidistant","geoAzimuthalEquidistantRaw","geoConicConformal","geoConicConformalRaw","geoConicEqualArea","geoConicEqualAreaRaw","geoConicEquidistant","geoConicEquidistantRaw","geoEquirectangular","geoEquirectangularRaw","geoGnomonic","geoGnomonicRaw","geoIdentity","geoProjection","geoProjectionMutator","geoMercator","geoMercatorRaw","geoOrthographic","geoOrthographicRaw","geoStereographic","geoStereographicRaw","geoTransverseMercator","geoTransverseMercatorRaw","geoRotation","geoTransform","packSiblings","treemapBinary","treemapSliceDice","treemapSquarify","treemapResquarify","interpolateArray","interpolateBasis","interpolateBasisClosed","interpolateDate","interpolateNumber","interpolateObject","interpolateRgbBasis","interpolateRgbBasisClosed","interpolateHsl","interpolateHslLong","interpolateLab","interpolateHcl","interpolateHclLong","interpolateCubehelix","interpolateCubehelixLong","polygonArea","polygonCentroid","polygonHull","polygonLength","scaleBand","scalePoint","scaleIdentity","scaleLinear","scaleLog","scaleOrdinal","scaleImplicit","scalePow","scaleSqrt","scaleQuantile","scaleQuantize","scaleThreshold","scaleTime","scaleUtc","schemeCategory10","schemeCategory20b","schemeCategory20c","schemeCategory20","interpolateCubehelixDefault","interpolateRainbow","interpolateWarm","interpolateCool","interpolateViridis","interpolateMagma","interpolateInferno","interpolatePlasma","scaleSequential","radialArea","radialLine","symbolCircle","symbolCross","symbolDiamond","symbolSquare","symbolStar","symbolTriangle","symbolWye","curveBasisClosed","curveBasisOpen","curveBasis","curveBundle","curveCardinalClosed","curveCardinalOpen","curveCardinal","curveCatmullRomClosed","curveCatmullRomOpen","curveCatmullRom","curveLinearClosed","curveMonotoneX","curveMonotoneY","curveNatural","curveStep","curveStepAfter","curveStepBefore","stackOffsetExpand","stackOffsetDiverging","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderAscending","stackOrderDescending","stackOrderInsideOut","stackOrderNone","stackOrderReverse","timeInterval","timeMillisecond","timeMilliseconds","utcMillisecond","utcMilliseconds","timeSecond","timeSeconds","utcSecond","utcSeconds","timeMinute","timeMinutes","timeHour","timeHours","timeDay","timeDays","timeWeek","timeWeeks","timeSunday","timeSundays","timeMonday","timeMondays","timeTuesday","timeTuesdays","timeWednesday","timeWednesdays","timeThursday","timeThursdays","timeFriday","timeFridays","timeSaturday","timeSaturdays","timeMonth","timeMonths","timeYear","timeYears","utcWeek","utcWeeks","timeFormatDefaultLocale","timeFormatLocale","isoFormat","isoParse","zoomTransform","zoomIdentity","defineProperty","Notification","kind","hasValue","observe","observer","do","accept","nextOrObserver","toObservable","throw","createNext","undefinedValueNotification","createError","createComplete","completeNotification","Action_1","work","pending","recycleAsyncId","requestAsyncId","flush","execute","_execute","errored","errorValue","actions","Action","Scheduler_1","scheduled","action","Scheduler","symbolIteratorPonyfill","Symbol","Set_1","Map_1","getOwnPropertyNames","$$iterator","ArgumentOutOfRangeError","message","rawScriptExports","compiledTemplate","injectStyles","scopeId","moduleIdentifier","esModule","scriptExports","default","options","render","staticRenderFns","_scopeId","hook","$vnode","ssrContext","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","functional","existing","beforeCreate","Subject_1","AsyncSubject","hasNext","hasCompleted","queue_1","observeOn_1","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_bufferSize","_windowTime","_getNow","ReplayEvent","_trimBufferThenGetEvents","ObserveOnSubscriber","eventsCount","spliceCount","mergeAll","concurrent","MergeAllOperator","OuterSubscriber_1","subscribeToResult_1","MergeAllSubscriber","getSymbolObservable","$$observable","for","$$rxSubscriber","EmptyError","isDate","isNumeric","val","parseFloat","combineLatest","observables","ArrayObservable_1","CombineLatestOperator","CombineLatestSubscriber","toRespond","unused","oldVal","_tryProject","concatStatic","mergeAll_1","thisArg","MapOperator","MapSubscriber","observeOn","ObserveOnOperator","Notification_1","notification","scheduleMessage","ObserveOnMessage","accumulator","seed","hasSeed","ReduceOperator","ReduceSubscriber","acc","_tryReduce","zipProto","zipStatic","ZipOperator","ZipSubscriber","iterators","StaticArrayIterator","StaticIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","nextResult","isComplete","eval","AsyncSubject_1","ReplaySubject_1","BehaviorSubject_1","BehaviorSubject","ConnectableObservable","EmptyError_1","ArgumentOutOfRangeError_1","TimeoutError_1","TimeoutError","timeInterval_1","TimeInterval","timestamp_1","Timestamp","TestScheduler_1","TestScheduler","VirtualTimeScheduler_1","VirtualTimeScheduler","AjaxObservable_1","AjaxResponse","AjaxError","AjaxTimeoutError","asap_1","async_1","animationFrame_1","asap","animationFrame","__webpack_exports__","isUndef","isDef","isTrue","isFalse","isPrimitive","obj","isPlainObject","_toString","isRegExp","isValidArrayIndex","String","toNumber","makeMap","str","expectsLowerCase","arr","hasOwn","cached","ctx","boundFn","_length","toArray","ret","_from","toObject","res","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","keysA","keysB","looseIndexOf","once","called","isReserved","def","enumerable","writable","configurable","parsePath","bailRE","handleError","vm","info","errorHandler","inBrowser","console","isNative","Ctor","pushTarget","_target","Dep","targetStack","popTarget","protoAugment","src","__proto__","copyAugment","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","shallow","dep","getOwnPropertyDescriptor","getter","setter","childOb","depend","dependArray","newVal","notify","del","mergeData","toVal","fromVal","mergeDataOrFn","parentVal","childVal","instanceData","defaultData","mergeHook","mergeAssets","normalizeProps","props","camelize","normalizeInject","inject","normalized","normalizeDirectives","dirs","directives","mergeOptions","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","getPropDefaultValue","prevShouldConvert","$options","_props","getType","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","elm","componentOptions","asyncFactory","ns","isStatic","isComment","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","updateListeners","oldOn","remove$$1","cur","old","normalizeEvent","passive","mergeVNodeHook","hookKey","wrappedHook","oldHook","extractPropsFromVNodeData","attrs","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","nestedIndex","last","_isVList","ensureCtor","comp","__esModule","createAsyncPlaceholder","createEmptyVNode","asyncMeta","resolveAsyncComponent","baseCtor","errorComp","resolved","loading","loadingComp","contexts","sync","forceRender","$forceUpdate","reason","component","getFirstComponentChild","initEvents","_hasHookEvent","_parentListeners","updateComponentListeners","once$$1","$once","$on","remove$1","$off","oldListeners","resolveSlots","slots","defaultSlot","functionalContext","slot","isWhitespace","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","callHook","updateComponent","_update","_render","Watcher","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","$attrs","$listeners","propKeys","_propKeys","$slots","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","$emit","resetSchedulerState","activatedChildren","waiting","flushing","flushSchedulerQueue","watcher","run","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","devtools","queueActivatedComponent","queueWatcher","nextTick","traverse","seenObjects","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","initMethods","initData","computed","initComputed","watch","nativeWatch","initWatch","propsOptions","isRoot","getData","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","dirty","evaluate","handler","createWatcher","keyOrFn","$watch","initProvide","provide","_provided","initInjections","resolveInject","hasSymbol","Reflect","ownKeys","provideKey","createFunctionalComponent","mergeProps","injections","functionalOptions","createComponent","_base","cid","resolveConstructorOptions","model","transformModel","nativeOn","mergeHooks","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","_parentElm","_refElm","inlineTemplate","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","is","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","isSync","isReservedAttribute","mustUseProp","domProps","$event","renderStatic","isInFor","_staticTrees","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","bindObjectListeners","initRender","renderContext","_c","$createElement","parentData","initInternalComponent","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","extended","sealed","sealedOptions","dedupe","Vue$3","_init","initUse","Vue","use","plugin","installedPlugins","_installedPlugins","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","getComponentName","pattern","pruneCache","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","childNode","mergeClassData","renderClass","staticClass","class","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","isSVG","isUnknownElement","unknownElementCache","HTMLUnknownElement","HTMLElement","query","selected","createElement$1","tagName","multiple","namespaceMap","createTextNode","createComment","newNode","referenceNode","setTextContent","registerRef","isRemoval","ref","refs","refInFor","sameVnode","sameInputType","isAsyncPlaceholder","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","inheritAttrs","oldAttrs","setAttr","isIE9","isXlink","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","pushFilter","filters","lastFilterIndex","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","paren","validDivisionCharRE","wrapFilter","baseWarn","pluckModuleFunction","modules","addProp","addAttr","addDirective","addHandler","important","warn","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","idx","expressionPos","expressionEndPos","lastIndexOf","eof","chr","isStringStart","parseString","parseBracket","inBracket","stringQuote","_warn","warn$1","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","selectedVal","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","oldHandler","target$1","ev","remove$2","supportsPassive","updateDOMListeners","updateDOMProps","oldProps","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","notInFocus","activeElement","_vModifiers","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","removeClass","tar","resolveTransition","def$$1","css","autoCssTransition","nextFrame","raf","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","onEnd","styles","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","toggleDisplay","_leaveCb","cancelled","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","setSelected","binding","isMultiple","option","getValue","selectedIndex","onCompositionStart","onCompositionEnd","trigger","locateNode","getRealChild","compOptions","extractTransitionData","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","applyTranslation","oldPos","pos","WebkitTransform","transitionDuration","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","transformNode","classBinding","genData","transformNode$1","styleBinding","genData$1","decodeAttr","shouldDecodeNewlines","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseEndTag","lowerCasedTagName","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","endTagLength","stackedTag","reStackedTag","reCache","rest$1","all","endTag","shouldIgnoreFirstNewline","chars","textEnd","comment","commentEnd","shouldKeepComment","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","startTagClose","attribute","unarySlash","isNonPhrasingTag","unary","IS_REGEX_CAPTURING_BROKEN","rest","template","endPre","pre","inVPre","platformIsPreTag","inPre","warn$2","isPreTag","platformMustUseProp","platformGetTagNamespace","transforms","preTransforms","postTransforms","currentParent","preserveWhitespace","comments","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","processPre","processRawAttrs","processFor","processIf","processOnce","processKey","plain","processRef","processSlot","processComponent","i$1","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","i$2","lastNode","isTextTag","decodeHTMLCached","checkInFor","inMatch","forAliasRE","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","condition","ifConditions","slotName","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","isStaticKey","genStaticKeysCached","staticKeys","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","l$1","staticInFor","staticRoot","isBuiltInTag","isDirectChildOfTemplateFor","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","wrapListeners","bind$1","wrapData","generate","ast","CodegenState","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData$2","genChildren","onceId","altGen","altEmpty","genIfConditions","conditions","genTernaryExp","altHelper","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","inlineRenderFns","genScopedSlot","genForScopedSlot","scope","checkSkip","altGenElement","altGenNode","el$1","getNormalizationType","maybeComponent","genNode","needsNormalization","some","genComment","genText","transformSpecialNewlines","bind$$1","componentName","createFunction","createCompileToFunctionFn","compile","compiled","fnGenErrors","getOuterHTML","outerHTML","cloneNode","camelizeRE","hyphenateRE","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","warnHandler","ignoredElements","isReservedAttr","_lifecycleHooks","freeze","hasProto","UA","navigator","userAgent","isEdge","isAndroid","isIOS","_isServer","_Set","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","copies","callbacks","timerFunc","logError","catch","MutationObserver","counter","textNode","characterData","_resolve","uid","subs","addSub","removeSub","addDep","arrayProto","arrayMethods","original","observeArray","arrayKeys","walk","items","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","deep","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","$mount","keepAlive","mountedNode","prepatch","destroy","uid$1","_uid","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","cbs","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_o","_n","_s","_l","_q","_m","_f","_b","_v","_e","_u","_g","patternTypes","KeepAlive","include","exclude","created","destroyed","builtInComponents","configDef","util","defineReactive","delete","emptyStyle","acceptValue","math","isHTMLTag","nodeOps","hooks","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","normalizedName","normalize","vendorNames","capName","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ref$$1","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hydrate","postpatch","invokeInsertHook","initial","hasChildNodes","childrenMatch","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","isTextInputType","vmodel","model$1","_vOptions","prevOptions","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","clone","platformComponents","decoder","content","encoded","div","regexEscapeRE","close","klass$1","style$1","modules$1","directives$1","baseOptions","he","decode","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","&lt;","&gt;","&quot;","&amp;","&#10;","isIgnoreNewlineTag","esc","tab","up","down","genGuard","prevent","ctrl","alt","meta","middle","baseDirectives","cloak","createCompiler","baseCompile","finalOptions","tips","tip","compileToFunctions","ref$1","idToTemplate","mount","subscriberIndex","_refCount","_isComplete","getSubject","_subject","connect","connection","_connection","ConnectableSubscriber","refCount","RefCountOperator","connectableProto","refCounter","RefCountSubscriber","sharedConnection","PromiseObservable_1","IteratorObservable_1","ArrayLikeObservable_1","FromObservable","ish","PromiseObservable","IteratorObservable","ArrayLikeObservable","dispatchNext","dispatchError","promise","getCORSRequest","getXMLHttpRequest","progId","progIds","ActiveXObject","ajaxGet","AjaxObservable","ajaxPost","ajaxDelete","ajaxPut","ajaxPatch","ajaxGetJSON","map_1","urlOrRequest","createXHR","crossDomain","withCredentials","AjaxSubscriber","put","getJSON","FormData","serializeBody","setupEvents","setHeaders","contentType","splitIndex","encodeURI","xhrTimeout","progressSubscriber","xhrReadyStateChange","status_1","upload","xhrProgress_1","xhrError_1","originalEvent","distinctUntilChanged","keySelector","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","hasKey","predicate","FilterOperator","FilterSubscriber","FindValueOperator","yieldIndex","FindValueSubscriber","mergeStatic","mergeMap","resultSelector","MergeMapOperator","MergeMapSubscriber","_tryNext","_innerSub","_notifyResultSelector","mergeMapTo","innerObservable","MergeMapToOperator","MergeMapToSubscriber","trySelectResult","onErrorResumeNext","nextSources","OnErrorResumeNextOperator","onErrorResumeNextStatic","FromObservable_1","OnErrorResumeNextSubscriber","subscribeToNextSource","race","raceStatic","RaceOperator","RaceSubscriber","hasFirst","throttle","durationSelector","defaultThrottleConfig","ThrottleOperator","leading","trailing","ThrottleSubscriber","_leading","_trailing","_hasTrailingValue","throttled","_trailingValue","tryDurationSelector","_sendTrailing","TimeIntervalOperator","TimeIntervalSubscriber","lastTime","span","timestamp","TimestampOperator","TimestampSubscriber","SchedulerAction","maxFrames","VirtualAction","frameTimeFactor","sortActions","AsapAction_1","AsapScheduler_1","AsapScheduler","AsapAction","QueueAction_1","QueueScheduler_1","QueueScheduler","QueueAction","SubscriptionLog","subscribedFrame","unsubscribedFrame","SubscriptionLog_1","SubscriptionLoggable","logSubscribedFrame","logUnsubscribedFrame","subscriptionLogs","oldSubscriptionLog","applyMixins","derivedCtor","baseCtors","propertyKeys","len2","name_1","Timeout","clearFn","_clearFn","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","setImmediate","clearImmediate","_Vue","_Rx","Rx$1","Vue$1","hasRx","isObservable","onNext","unsub","dispose","getDisposable","Disposable","getKey","watchAsObservable","_unwatch","newValue","fromDOMEvent","doc","els","subscribeTo","obs$","_obSubscriptions","eventToObservable","evtName","evtNames","eventPairs","createObservableMethod","methodName","passContext","share","VueRx","Vue$$1","Rx$$1","rxMixin","directive","streamDirective","$watchAsObservable","$fromDOMEvent","$subscribeTo","$eventToObservable","$createObservableMethod","domStreams","observableMethods","$observables","beforeDestroy","streamName","fromEvent","fromEventArgs","_rxHandles","_handle","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","Item","process","title","browser","versions","addListener","off","removeListener","removeAllListeners","prependListener","prependOnceListener","cwd","chdir","umask","bindCallback_1","bindCallback","bindNodeCallback_1","bindNodeCallback","combineLatest_1","concat_1","defer_1","ajax_1","ajax","webSocket_1","webSocket","empty_1","forkJoin_1","forkJoin","from_1","fromEvent_1","fromEventPattern_1","fromEventPattern","fromPromise_1","fromPromise","generate_1","if_1","_if","interval_1","merge_1","never_1","never","of_1","onErrorResumeNext_1","pairs_1","race_1","range_1","throw_1","_throw","timer_1","using_1","using","zip_1","audit_1","audit","auditTime_1","auditTime","buffer_1","bufferCount_1","bufferCount","bufferTime_1","bufferTime","bufferToggle_1","bufferToggle","bufferWhen_1","bufferWhen","catch_1","_catch","combineAll_1","combineAll","concatAll_1","concatAll","concatMap_1","concatMap","concatMapTo_1","concatMapTo","count_1","debounce_1","debounce","debounceTime_1","debounceTime","defaultIfEmpty_1","defaultIfEmpty","delay_1","delayWhen_1","delayWhen","dematerialize_1","dematerialize","distinct_1","distinct","distinctUntilChanged_1","distinctUntilKeyChanged_1","distinctUntilKeyChanged","do_1","_do","elementAt_1","elementAt","every_1","exhaust_1","exhaust","exhaustMap_1","exhaustMap","expand_1","filter_1","finally_1","finally","_finally","find_1","findIndex_1","findIndex","first_1","groupBy_1","groupBy","ignoreElements_1","ignoreElements","isEmpty_1","isEmpty","last_1","let_1","let","letProto","letBind","mapTo_1","mapTo","materialize_1","materialize","max_1","mergeMap_1","flatMap","mergeMapTo_1","flatMapTo","mergeScan_1","mergeScan","min_1","multicast_1","pairwise_1","pairwise","partition_1","pluck_1","pluck","publish_1","publish","publishBehavior_1","publishBehavior","publishLast_1","publishLast","publishReplay_1","publishReplay","reduce_1","repeat_1","repeat","repeatWhen_1","repeatWhen","retry_1","retry","retryWhen_1","retryWhen","sample_1","sample","sampleTime_1","sampleTime","scan_1","sequenceEqual_1","sequenceEqual","share_1","shareReplay_1","shareReplay","single_1","single","skip_1","skip","skipLast_1","skipLast","skipUntil_1","skipUntil","skipWhile_1","skipWhile","startWith_1","startWith","subscribeOn_1","subscribeOn","switch_1","switch","_switch","switchMap_1","switchMap","switchMapTo_1","switchMapTo","take_1","take","takeLast_1","takeLast","takeUntil_1","takeUntil","takeWhile_1","takeWhile","throttle_1","throttleTime_1","throttleTime","timeout_1","timeoutWith_1","timeoutWith","toArray_1","toPromise_1","toPromise","window_1","windowCount_1","windowCount","windowTime_1","windowToggle_1","windowToggle","windowWhen_1","windowWhen","withLatestFrom_1","withLatestFrom","zipAll_1","zipAll","arrayLike","BoundCallbackObservable","callbackFunc","func","handlerFn","innerArgs","result_1","result_2","BoundNodeCallbackObservable","DeferObservable","observableFactory","DeferSubscriber","tryDefer","_callFactory","ErrorObservable","ForkJoinObservable","sources","ForkJoinSubscriber","completed","haveValues","innerSubscription","_hasValue","isNodeStyleEventEmitter","sourceObj","isJQueryStyleEventEmitter","isNodeList","isHTMLCollection","isEventTarget","FromEventObservable","eventName","setupSubscription","source_1","source_2","source_3","FromEventPatternObservable","removeHandler","_callSelector","retValue","_callAddHandler","errorSubscriber","selfSelector","GenerateObservable","initialState","iterate","initialStateOrOptions","resultSelectorOrObservable","conditionResult","needIterate","IfObservable","thenSource","elseSource","IfSubscriber","tryIf","isNumeric_1","IntervalObservable","getIterator","StringIterator","ArrayIterator","toLength","numberIsFinite","maxSafeInteger","valueAsNumber","return","noop_1","NeverObservable","PairsObservable","RangeObservable","_count","SubscribeOnObservable","delayTime","isDate_1","TimerObservable","dueTime","initialDelay","UsingObservable","resourceFactory","resource","UsingSubscriber","tryUse","BoundCallbackObservable_1","BoundNodeCallbackObservable_1","DeferObservable_1","assign_1","WebSocketSubject","urlConfigOrSource","WebSocketCtor","WebSocket","_output","assign","sock","_resetState","socket","subMsg","unsubMsg","messageFilter","_connectSocket","protocol","binaryType","onopen","openObserver","closingObserver","onclose","closeObserver","wasClean","onmessage","WebSocketSubject_1","ForkJoinObservable_1","FromEventObservable_1","FromEventPatternObservable_1","GenerateObservable_1","IfObservable_1","IntervalObservable_1","NeverObservable_1","PairsObservable_1","RangeObservable_1","ErrorObservable_1","TimerObservable_1","UsingObservable_1","AuditOperator","AuditSubscriber","clearThrottle","AuditTimeOperator","AuditTimeSubscriber","closingNotifier","BufferOperator","BufferSubscriber","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","bufferTimeSpan","bufferCreationInterval","maxBufferSize","BufferTimeOperator","dispatchBufferTimeSpanOnly","prevContext","closeContext","openContext","closeAction","dispatchBufferCreation","dispatchBufferClose","BufferTimeSubscriber","Context","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","onBufferFull","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","closeBuffer","openBuffer","trySubscribe","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","CatchOperator","caught","CatchSubscriber","err2","CountOperator","CountSubscriber","_tryPredicate","DebounceOperator","DebounceSubscriber","durationSubscription","emitValue","DebounceTimeOperator","debouncedNext","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","defaultValue","DefaultIfEmptyOperator","DefaultIfEmptySubscriber","absoluteDelay","delayFor","DelayOperator","DelaySubscriber","_schedule","scheduleNotification","DelayMessage","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","delayNotifierSubscriptions","removeSubscription","tryComplete","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","sourceSubscribed","subscribeToSource","DeMaterializeOperator","DeMaterializeSubscriber","flushes","DistinctOperator","DistinctSubscriber","_useKeySelector","_finalizeNext","DoOperator","DoSubscriber","safeSubscriber","ElementAtOperator","ElementAtSubscriber","EveryOperator","EverySubscriber","everyValueMatch","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","SwitchFirstMapOperator","SwitchFirstMapSubscriber","tryNext","ExpandOperator","ExpandSubscriber","subscribeToProjection","FinallyOperator","FinallySubscriber","FirstOperator","FirstSubscriber","_emitted","_emit","_tryResultSelector","_emitFinal","elementSelector","subjectSelector","GroupByOperator","FastMap_1","GroupBySubscriber","attemptedToUnsubscribe","_group","FastMap","groupedObservable","GroupedObservable","GroupDurationSubscriber","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","IgnoreElementsOperator","IgnoreElementsSubscriber","IsEmptyOperator","IsEmptySubscriber","LastOperator","LastSubscriber","MapToOperator","MapToSubscriber","MaterializeOperator","MaterializeSubscriber","comparer","MergeScanOperator","MergeScanSubscriber","PairwiseOperator","PairwiseSubscriber","hasPrev","not_1","not","properties","plucker","currentProp","RepeatOperator","RepeatSubscriber","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","retriesSubscription","subscribeToRetries","notifications","RetryOperator","RetrySubscriber","RetryWhenOperator","RetryWhenSubscriber","SampleOperator","sampleSubscriber","SampleSubscriber","SampleTimeOperator","dispatchNotification","SampleTimeSubscriber","ScanOperator","ScanSubscriber","_seed","compareTo","comparor","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","SequenceEqualCompareToSubscriber","checkValues","areEqual","nextB","shareSubjectFactory","SingleOperator","SingleSubscriber","seenValue","applySingleValue","singleValue","SkipOperator","SkipSubscriber","SkipLastOperator","_skipCount","SkipLastSubscriber","_ring","skipCount","currentIndex","SkipUntilOperator","SkipUntilSubscriber","isInnerStopped","SkipWhileOperator","SkipWhileSubscriber","skipping","tryCallPredicate","SubscribeOnOperator","SubscribeOnObservable_1","SwitchOperator","SwitchSubscriber","unsubscribeInner","SwitchMapOperator","SwitchMapSubscriber","_tryNotifyNext","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","TakeOperator","TakeSubscriber","TakeLastOperator","TakeLastSubscriber","TakeUntilOperator","TakeUntilSubscriber","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","predicateResult","ThrottleTimeOperator","ThrottleTimeSubscriber","due","absoluteTimeout","waitFor","TimeoutOperator","errorInstance","TimeoutSubscriber","scheduleTimeout","dispatchTimeout","withObservable","TimeoutWithOperator","TimeoutWithSubscriber","ToArrayOperator","ToArraySubscriber","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","newWindow","windowSize","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","windowTimeSpan","windowCreationInterval","maxWindowSize","WindowTimeOperator","dispatchWindowTimeSpanOnly","closeWindow","dispatchWindowCreation","timeSpanState","dispatchWindowClose","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","numberOfNextedValues","window_2","WindowToggleOperator","WindowToggleSubscriber","openSubscription","unsubscribeClosingNotification","closingNotification","WithLatestFromOperator","WithLatestFromSubscriber","found","AnimationFrame_1","AnimationFrameAction","AnimationFrame","cancelAnimationFrame","AnimationFrameScheduler","Immediate_1","Immediate","AnimationFrameAction_1","AnimationFrameScheduler_1","SubscriptionLoggable_1","applyMixins_1","ColdObservable","messages","scheduleMessages","messagesLength","HotObservable","setup","ColdObservable_1","HotObservable_1","defaultMaxFrame","assertDeepEqual","hotObservables","coldObservables","flushTests","createTime","marbles","createColdObservable","parseMarbles","cold","createHotObservable","materializeInnerObservable","outerFrame","expectObservable","unsubscriptionMarbles","actual","flushTest","ready","unsubscriptionFrame","parseMarblesAsSubscriptions","toBe","expected","expectSubscriptions","actualSubscriptionLogs","marblesArray","readyFlushTests","groupStart","subscriptionFrame","materializeInnerObservables","testMessages","subIndex","frameOffset","RequestAnimationFrameDefinition","mozRequestAnimationFrame","mozCancelAnimationFrame","webkitRequestAnimationFrame","webkitCancelAnimationFrame","msRequestAnimationFrame","msCancelAnimationFrame","oRequestAnimationFrame","oCancelAnimationFrame","ImmediateDefinition","nextHandle","tasksByHandle","currentlyRunningATask","canUseProcessNextTick","createProcessNextTickSetImmediate","canUsePostMessage","createPostMessageSetImmediate","canUseMessageChannel","createMessageChannelSetImmediate","canUseReadyStateChange","createReadyStateChangeSetImmediate","createSetTimeoutSetImmediate","ci","instance","identify","MessageChannel","postMessage","importScripts","postMessageIsAsynchronous_1","oldOnMessage","partiallyApplied","addFromSetImmediateArguments","runIfPresent","messagePrefix","onGlobalMessage","globalMessageHandler","task","channel","port1","port2","script","MapPolyfill_1","MapPolyfill","_values","_keys","minimalSetImpl","MinimalSet","assignImpl","getAssign","pred","notPred","registerImmediate","attachTo","getPrototypeOf","postMessageIsAsynchronous","attachEvent","isError","resolveProps","route","resolveQuery","extraQuery","_parseQuery","parsedQuery","parseQuery","param","parts","stringifyQuery","encode","val2","createRoute","record","redirectedFrom","router","stringifyQuery$$1","fullPath","getFullPath","matched","formatMatch","_stringifyQuery","isSameRoute","START","trailingSlashRE","isObjectEqual","aKeys","bKeys","aVal","bVal","isIncludedRoute","queryIncludes","guardEvent","ctrlKey","defaultPrevented","currentTarget","findAnchor","installed","registerInstance","callVal","registerRouteInstance","_routerRoot","_router","history","_route","View","Link","beforeRouteEnter","beforeRouteLeave","beforeRouteUpdate","resolvePath","relative","firstChar","hashIndex","queryIndex","cleanPath","defaultDelimiter","PATH_REGEXP","escaped","modifier","asterisk","partial","escapeGroup","escapeString","substr","tokensToFunction","encodeURIComponentPretty","encodeAsterisk","pretty","encodeURIComponent","attachKeys","flags","sensitive","regexpToRegexp","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","strict","endsWithDelimiter","fillParams","routeMsg","regexpCompileCache","createRouteMap","routes","oldPathList","oldPathMap","oldNameMap","pathList","pathMap","nameMap","addRouteRecord","matchAs","normalizedPath","normalizePath","pathToRegexpOptions","caseSensitive","regex","compileRouteRegex","instances","redirect","childMatchAs","aliasRoute","normalizeLocation","_normalized","rawPath","parsedPath","basePath","createMatcher","addRoutes","currentRoute","_createRoute","paramNames","record$1","matchRoute","originalRedirect","resolveRecordPath","aliasedPath","aliasedMatch","aliasedRecord","decodeURIComponent","setupScroll","saveScrollPosition","setStateKey","handleScroll","isPop","app","behavior","scrollBehavior","getScrollPosition","shouldScroll","normalizeOffset","getElementPosition","isValidPosition","normalizePosition","scrollTo","getStateKey","positionStore","pageXOffset","pageYOffset","docEl","docRect","elRect","isNumber","genKey","Time","_key","pushState","replaceState","runQueue","resolveAsyncComponents","hasAsync","flatMapComponents","resolvedDef","flatten","normalizeBase","baseEl","resolveQueue","activated","deactivated","extractGuards","records","guards","guard","extractGuard","extractLeaveGuards","bindGuard","extractUpdateHooks","extractEnterGuards","isValid","bindEnterGuard","poll","getLocation","pathname","search","checkFallback","ensureSlash","getHash","replaceHash","href","pushHash","registerHook","createHref","routerView","$route","_routerViewCache","inactive","routerViewDepth","encodeReserveRE","encodeReserveReplacer","commaRE","toTypes","eventTypes","exact","exactActiveClass","$router","classes","globalActiveClass","linkActiveClass","globalExactActiveClass","linkExactActiveClass","activeClassFallback","exactActiveClassFallback","compareTarget","click","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","supportsPushState","ua","History","readyCbs","readyErrorCbs","errorCbs","listen","onReady","errorCb","onError","transitionTo","onComplete","onAbort","confirmTransition","updateRoute","ensureURL","beforeHooks","postEnterCbs","resolveHooks","afterHooks","HTML5History","History$$1","expectScroll","go","fromRoute","getCurrentLocation","HashHistory","setupListeners","AbstractHistory","targetIndex","VueRouter","apps","setupHashListener","beforeEach","beforeResolve","afterEach","back","getMatchedComponents","normalizedTo","newStyles","media","sourceMap","part","cssWithMappingToString","useSourceMap","cssMapping","btoa","sourceMapping","toComment","sourceRoot","unescape","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","createStyleElement","styleElement","head","isProduction","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","childNodes","hasDocument","DEBUG","listToStyles","getElementsByTagName","_isProduction","newList","mayRemove","textStore","replacement"],"mappings":"AAAAA,cAAc,IAER,SAAUC,EAAQC,EAASC,GAEjC,YCHA,IAAAC,GAAAD,EAAA,GACAE,EAAAF,EAAA,KACAG,EAAAH,EAAA,IAOAI,EAAA,WAQA,QAAAA,GAAAC,GACAC,KAAAC,WAAA,EACAF,IACAC,KAAAE,WAAAH,GAuOA,MA7NAD,GAAAK,UAAAC,KAAA,SAAAC,GACA,GAAAC,GAAA,GAAAR,EAGA,OAFAQ,GAAAC,OAAAP,KACAM,EAAAD,WACAC,GAoHAR,EAAAK,UAAAJ,UAAA,SAAAS,EAAAC,EAAAC,GACA,GAAAL,GAAAL,KAAAK,SACAM,EAAAf,EAAAgB,aAAAJ,EAAAC,EAAAC,EAOA,IANAL,EACAA,EAAAQ,KAAAF,EAAAX,KAAAO,QAGAI,EAAAG,IAAAd,KAAAO,OAAAP,KAAAE,WAAAS,GAAAX,KAAAe,cAAAJ,IAEAA,EAAAK,qBACAL,EAAAK,oBAAA,EACAL,EAAAM,iBACA,KAAAN,GAAAO,cAGA,OAAAP,IAEAb,EAAAK,UAAAY,cAAA,SAAAJ,GACA,IACA,MAAAX,MAAAE,WAAAS,GAEA,MAAAQ,GACAR,EAAAM,iBAAA,EACAN,EAAAO,eAAAC,EACAR,EAAAF,MAAAU,KAUArB,EAAAK,UAAAiB,QAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAvB,IASA,IARAsB,IACA3B,EAAA6B,KAAAC,IAAA9B,EAAA6B,KAAAC,GAAAC,QAAA/B,EAAA6B,KAAAC,GAAAC,OAAAC,QACAL,EAAA3B,EAAA6B,KAAAC,GAAAC,OAAAC,QAEAhC,EAAA6B,KAAAG,UACAL,EAAA3B,EAAA6B,KAAAG,WAGAL,EACA,SAAAM,OAAA,wBAEA,WAAAN,GAAA,SAAAO,EAAAC,GAGA,GAAAC,EACAA,GAAAR,EAAAxB,UAAA,SAAAiC,GACA,GAAAD,EAKA,IACAV,EAAAW,GAEA,MAAAb,GACAW,EAAAX,GACAY,EAAAE,kBAUAZ,GAAAW,IAEaF,EAAAD,MAGb/B,EAAAK,UAAAD,WAAA,SAAAgC,GACA,MAAAlC,MAAAO,OAAAR,UAAAmC,IAOApC,EAAAK,UAAAN,EAAAS,YAAA,WACA,MAAAN,OAYAF,EAAAqC,OAAA,SAAApC,GACA,UAAAD,GAAAC,IAEAD,IAEAL,GAAAK,cDUM,SAAUN,EAAQC,EAASC,GAEjC,YEzQA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAK,EAAAlD,EAAA,IACAmD,EAAAnD,EAAA,GACAoD,EAAApD,EAAA,IACAqD,EAAArD,EAAA,IAWAsD,EAAA,SAAAC,GAUA,QAAAD,GAAAE,EAAAzC,EAAAC,GAMA,OALAuC,EAAApC,KAAAb,MACAA,KAAAkB,eAAA,KACAlB,KAAAiB,iBAAA,EACAjB,KAAAgB,oBAAA,EACAhB,KAAAmD,WAAA,EACAC,UAAAC,QACA,OACArD,KAAAsD,YAAAR,EAAAS,KACA,MACA,QACA,IAAAL,EAAA,CACAlD,KAAAsD,YAAAR,EAAAS,KACA,OAEA,mBAAAL,GAAA,CACAA,YAAAF,IACAhD,KAAAsD,YAAAJ,EACAlD,KAAAsD,YAAAxC,IAAAd,QAGAA,KAAAgB,oBAAA,EACAhB,KAAAsD,YAAA,GAAAE,GAAAxD,KAAAkD,GAEA,OAEA,QACAlD,KAAAgB,oBAAA,EACAhB,KAAAsD,YAAA,GAAAE,GAAAxD,KAAAkD,EAAAzC,EAAAC,IAuFA,MA5HA0B,GAAAY,EAAAC,GAyCAD,EAAA7C,UAAA4C,EAAAU,cAAA,WAAqE,MAAAzD,OAYrEgD,EAAAb,OAAA,SAAAd,EAAAZ,EAAAC,GACA,GAAAwB,GAAA,GAAAc,GAAA3B,EAAAZ,EAAAC,EAEA,OADAwB,GAAAlB,oBAAA,EACAkB,GASAc,EAAA7C,UAAAkB,KAAA,SAAAW,GACAhC,KAAAmD,WACAnD,KAAA0D,MAAA1B,IAUAgB,EAAA7C,UAAAM,MAAA,SAAAU,GACAnB,KAAAmD,YACAnD,KAAAmD,WAAA,EACAnD,KAAA2D,OAAAxC,KASA6B,EAAA7C,UAAAO,SAAA,WACAV,KAAAmD,YACAnD,KAAAmD,WAAA,EACAnD,KAAA4D,cAGAZ,EAAA7C,UAAA8B,YAAA,WACAjC,KAAA6D,SAGA7D,KAAAmD,WAAA,EACAF,EAAA9C,UAAA8B,YAAApB,KAAAb,QAEAgD,EAAA7C,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAsD,YAAAjC,KAAAW,IAEAgB,EAAA7C,UAAAwD,OAAA,SAAAxC,GACAnB,KAAAsD,YAAA7C,MAAAU,GACAnB,KAAAiC,eAEAe,EAAA7C,UAAAyD,UAAA,WACA5D,KAAAsD,YAAA5C,WACAV,KAAAiC,eAEAe,EAAA7C,UAAA2D,uBAAA,WACA,GAAAC,GAAA/D,KAAAgE,EAAAD,EAAAC,QAAAC,EAAAF,EAAAE,QAQA,OAPAjE,MAAAgE,QAAA,KACAhE,KAAAiE,SAAA,KACAjE,KAAAiC,cACAjC,KAAA6D,QAAA,EACA7D,KAAAmD,WAAA,EACAnD,KAAAgE,UACAhE,KAAAiE,WACAjE,MAEAgD,GACCH,EAAAqB,aACDzE,GAAAuD,YAMA,IAAAQ,GAAA,SAAAP,GAEA,QAAAO,GAAAW,EAAA3D,EAAAC,EAAAC,GACAuC,EAAApC,KAAAb,MACAA,KAAAmE,mBACA,IAAA9C,GACA+C,EAAApE,IACA4C,GAAAyB,WAAA7D,GACAa,EAAAb,EAEAA,IACAa,EAAAb,EAAAa,KACAZ,EAAAD,EAAAC,MACAC,EAAAF,EAAAE,SACAF,IAAAsC,EAAAS,QACAa,EAAAzB,OAAAR,OAAA3B,GACAoC,EAAAyB,WAAAD,EAAAnC,cACAjC,KAAAc,IAAAsD,EAAAnC,YAAAqC,KAAAF,IAEAA,EAAAnC,YAAAjC,KAAAiC,YAAAqC,KAAAtE,QAGAA,KAAAuE,SAAAH,EACApE,KAAA0D,MAAArC,EACArB,KAAA2D,OAAAlD,EACAT,KAAA4D,UAAAlD,EAmFA,MA3GA0B,GAAAoB,EAAAP,GA0BAO,EAAArD,UAAAkB,KAAA,SAAAW,GACA,IAAAhC,KAAAmD,WAAAnD,KAAA0D,MAAA,CACA,GAAAS,GAAAnE,KAAAmE,iBACAA,GAAAnD,mBAGAhB,KAAAwE,gBAAAL,EAAAnE,KAAA0D,MAAA1B,IACAhC,KAAAiC,cAHAjC,KAAAyE,aAAAzE,KAAA0D,MAAA1B,KAOAwB,EAAArD,UAAAM,MAAA,SAAAU,GACA,IAAAnB,KAAAmD,UAAA,CACA,GAAAgB,GAAAnE,KAAAmE,iBACA,IAAAnE,KAAA2D,OACAQ,EAAAnD,oBAKAhB,KAAAwE,gBAAAL,EAAAnE,KAAA2D,OAAAxC,GACAnB,KAAAiC,gBALAjC,KAAAyE,aAAAzE,KAAA2D,OAAAxC,GACAnB,KAAAiC,mBAOA,KAAAkC,EAAAnD,mBAEA,KADAhB,MAAAiC,cACAd,CAGAgD,GAAAjD,eAAAC,EACAgD,EAAAlD,iBAAA,EACAjB,KAAAiC,iBAIAuB,EAAArD,UAAAO,SAAA,WACA,GAAAa,GAAAvB,IACA,KAAAA,KAAAmD,UAAA,CACA,GAAAgB,GAAAnE,KAAAmE,iBACA,IAAAnE,KAAA4D,UAAA,CACA,GAAAc,GAAA,WAAmD,MAAAnD,GAAAqC,UAAA/C,KAAAU,EAAAgD,UACnDJ,GAAAnD,oBAKAhB,KAAAwE,gBAAAL,EAAAO,GACA1E,KAAAiC,gBALAjC,KAAAyE,aAAAC,GACA1E,KAAAiC,mBAQAjC,MAAAiC,gBAIAuB,EAAArD,UAAAsE,aAAA,SAAAE,EAAA3C,GACA,IACA2C,EAAA9D,KAAAb,KAAAuE,SAAAvC,GAEA,MAAAb,GAEA,KADAnB,MAAAiC,cACAd,IAGAqC,EAAArD,UAAAqE,gBAAA,SAAAI,EAAAD,EAAA3C,GACA,IACA2C,EAAA9D,KAAAb,KAAAuE,SAAAvC,GAEA,MAAAb,GAGA,MAFAyD,GAAA1D,eAAAC,EACAyD,EAAA3D,iBAAA,GACA,EAEA,UAEAuC,EAAArD,UAAA0E,aAAA,WACA,GAAAV,GAAAnE,KAAAmE,iBACAnE,MAAAuE,SAAA,KACAvE,KAAAmE,kBAAA,KACAA,EAAAlC,eAEAuB,GACCR,IFgRK,SAAUxD,EAAQC,EAASC,GAEjC,YGvhBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GAMAqF,EAAA,SAAA9B,GAEA,QAAA8B,KACA9B,EAAA+B,MAAAhF,KAAAoD,WAWA,MAbAhB,GAAA2C,EAAA9B,GAIA8B,EAAA5E,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAsD,YAAAjC,KAAA8D,IAEAJ,EAAA5E,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAAsD,YAAA7C,UAEAsE,EAAA5E,UAAAqF,eAAA,SAAAF,GACAtF,KAAAsD,YAAA5C,YAEAqE,GACCD,EAAA9B,WACDvD,GAAAsF,mBH8hBM,SAAUvF,EAAQC,EAASC,GAEjC,YInjBA,SAAA+F,GAAAC,EAAAC,EAAAT,EAAAE,GACA,GAAA9B,GAAA,GAAAsC,GAAAC,gBAAAH,EAAAR,EAAAE,EACA,IAAA9B,EAAAO,OACA,WAEA,IAAA8B,YAAAG,GAAAhG,WACA,MAAA6F,GAAA1F,WACAqD,EAAAjC,KAAAsE,EAAA3D,OACAsB,EAAA5C,WACA,MAGAiF,EAAA5F,UAAAuD,EAGA,IAAAyC,EAAAC,YAAAL,GAAA,CACA,OAAAM,GAAA,EAAAC,EAAAP,EAAAtC,OAA4C4C,EAAAC,IAAA5C,EAAAO,OAAgCoC,IAC5E3C,EAAAjC,KAAAsE,EAAAM,GAEA3C,GAAAO,QACAP,EAAA5C,eAGA,IAAAyF,EAAAC,UAAAT,GAWA,MAVAA,GAAAU,KAAA,SAAArE,GACAsB,EAAAO,SACAP,EAAAjC,KAAAW,GACAsB,EAAA5C,aAES,SAAAS,GAAkB,MAAAmC,GAAA7C,MAAAU,KAC3BkF,KAAA,cAAAlF,GAEAxB,EAAA6B,KAAA8E,WAAA,WAAgD,KAAAnF,OAEhDmC,CAEA,IAAAqC,GAAA,kBAAAA,GAAAY,EAAAC,UAEA,IADA,GAAAA,GAAAb,EAAAY,EAAAC,cACA,CACA,GAAAC,GAAAD,EAAAnF,MACA,IAAAoF,EAAAC,KAAA,CACApD,EAAA5C,UACA,OAGA,GADA4C,EAAAjC,KAAAoF,EAAAzE,OACAsB,EAAAO,OACA,UAIA,IAAA8B,GAAA,kBAAAA,GAAA9F,EAAAS,YAAA,CACA,GAAAqG,GAAAhB,EAAA9F,EAAAS,aACA,sBAAAqG,GAAA5G,UAIA,MAAA4G,GAAA5G,UAAA,GAAA6F,GAAAC,gBAAAH,EAAAR,EAAAE,GAHA9B,GAAA7C,MAAA,GAAAmG,WAAA,uEAMA,CACA,GAAA5E,GAAA6E,EAAAC,SAAAnB,GAAA,wBAAAA,EAAA,IACAoB,EAAA,gBAAA/E,EAAA,2FAEAsB,GAAA7C,MAAA,GAAAmG,WAAAG,KAEA,YAzEA,GAAApH,GAAAD,EAAA,GACAqG,EAAArG,EAAA,IACAyG,EAAAzG,EAAA,IACAmH,EAAAnH,EAAA,IACAoG,EAAApG,EAAA,GACA6G,EAAA7G,EAAA,IACAkG,EAAAlG,EAAA,IACAG,EAAAH,EAAA,GAoEAD,GAAAgG,qBJkkBM,SAAUjG,EAAQC,EAASC,GAEjC,YKndA,SAAAsH,GAAAC,GACA,MAAAA,GAAAC,OAAA,SAAAC,EAAAhG,GAA+C,MAAAgG,GAAAC,OAAAjG,YAAAkG,GAAAC,oBAAAnG,EAAA8F,OAAA9F,QA7L/C,GAAAoG,GAAA7H,EAAA,IACAmH,EAAAnH,EAAA,IACAkD,EAAAlD,EAAA,IACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACA2H,EAAA3H,EAAA,IAaAwE,EAAA,WAKA,QAAAA,GAAAjC,GAKAjC,KAAA6D,QAAA,EACA7D,KAAAgE,QAAA,KACAhE,KAAAiE,SAAA,KACAjE,KAAA0H,eAAA,KACAzF,IACAjC,KAAA6E,aAAA5C,GAwJA,MA/IAiC,GAAA/D,UAAA8B,YAAA,WACA,GACAgF,GADAU,GAAA,CAEA,KAAA3H,KAAA6D,OAAA,CAGA,GAAAE,GAAA/D,KAAAgE,EAAAD,EAAAC,QAAAC,EAAAF,EAAAE,SAAAY,EAAAd,EAAAc,aAAA6C,EAAA3D,EAAA2D,cACA1H,MAAA6D,QAAA,EACA7D,KAAAgE,QAAA,KACAhE,KAAAiE,SAAA,KAGAjE,KAAA0H,eAAA,IAKA,KAJA,GAAAE,IAAA,EACA1B,EAAAjC,IAAAZ,OAAA,EAGAW,GACAA,EAAA6D,OAAA7H,MAGAgE,IAAA4D,EAAA1B,GAAAjC,EAAA2D,IAAA,IAEA,IAAAhF,EAAAyB,WAAAQ,GAAA,CACA,GAAAiD,GAAAN,EAAAO,SAAAlD,GAAAhE,KAAAb,KACA8H,KAAAL,EAAAO,cACAL,GAAA,EACAV,MAAAQ,EAAAO,YAAAC,YAAAZ,GAAAC,oBACAN,EAAAS,EAAAO,YAAAC,EAAAhB,SAAAQ,EAAAO,YAAAC,KAGA,GAAAV,EAAAW,QAAAR,GAGA,IAFAE,GAAA,EACA1B,EAAAwB,EAAArE,SACAuE,EAAA1B,GAAA,CACA,GAAAiC,GAAAT,EAAAE,EACA,IAAAf,EAAAC,SAAAqB,GAAA,CACA,GAAAL,GAAAN,EAAAO,SAAAI,EAAAlG,aAAApB,KAAAsH,EACA,IAAAL,IAAAL,EAAAO,YAAA,CACAL,GAAA,EACAV,OACA,IAAA9F,GAAAsG,EAAAO,YAAAC,CACA9G,aAAAkG,GAAAC,oBACAL,IAAAG,OAAAJ,EAAA7F,EAAA8F,SAGAA,EAAAmB,KAAAjH,KAMA,GAAAwG,EACA,SAAAN,GAAAC,oBAAAL,KAqBA/C,EAAA/D,UAAAW,IAAA,SAAAuH,GACA,IAAAA,OAAAnE,EAAAoE,MACA,MAAApE,GAAAoE,KAEA,IAAAD,IAAArI,KACA,MAAAA,KAEA,IAAA+B,GAAAsG,CACA,cAAAA,IACA,eACAtG,EAAA,GAAAmC,GAAAmE,EACA,cACA,GAAAtG,EAAA8B,QAAA,kBAAA9B,GAAAE,YACA,MAAAF,EAEA,IAAA/B,KAAA6D,OAEA,MADA9B,GAAAE,cACAF,CAEA,sBAAAA,GAAAwG,WAAA,CACA,GAAAC,GAAAzG,CACAA,GAAA,GAAAmC,GACAnC,EAAA2F,gBAAAc,GAEA,KACA,SACA,SAAA5G,OAAA,yBAAAyG,EAAA,2BAKA,OAHArI,KAAA0H,iBAAA1H,KAAA0H,oBACAU,KAAArG,GACAA,EAAAwG,WAAAvI,MACA+B,GAQAmC,EAAA/D,UAAA0H,OAAA,SAAA9F,GACA,GAAA0G,GAAAzI,KAAA0H,cACA,IAAAe,EAAA,CACA,GAAAC,GAAAD,EAAAE,QAAA5G,IACA,IAAA2G,GACAD,EAAAG,OAAAF,EAAA,KAIAxE,EAAA/D,UAAAoI,WAAA,SAAA3D,GACA,GAAAb,GAAA/D,KAAAgE,EAAAD,EAAAC,QAAAC,EAAAF,EAAAE,QACAD,QAAAY,EAKAX,GAKA,IAAAA,EAAA0E,QAAA/D,IAEAX,EAAAmE,KAAAxD,GAJA5E,KAAAiE,UAAAW,GALA5E,KAAAgE,QAAAY,GAYAV,EAAAoE,MAAA,SAAA/E,GAEA,MADAA,GAAAM,QAAA,EACAN,GACK,GAAAW,IACLA,IAEAzE,GAAAyE,gBLypBM,SAAU1E,EAAQC,EAASC,GAEjC,YMt1BA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAoF,EAAApF,EAAA,GACAmD,EAAAnD,EAAA,GACAmJ,EAAAnJ,EAAA,IACAoJ,EAAApJ,EAAA,IACAqD,EAAArD,EAAA,IAIAqJ,EAAA,SAAA9F,GAEA,QAAA8F,GAAAzF,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cAEA,MALAlB,GAAA2G,EAAA9F,GAKA8F,GACCjE,EAAA9B,WACDvD,GAAAsJ,mBAIA,IAAAC,GAAA,SAAA/F,GAEA,QAAA+F,KACA/F,EAAApC,KAAAb,MACAA,KAAAiJ,aACAjJ,KAAA6D,QAAA,EACA7D,KAAAmD,WAAA,EACAnD,KAAAkJ,UAAA,EACAlJ,KAAAmJ,YAAA,KAyFA,MAhGA/G,GAAA4G,EAAA/F,GASA+F,EAAA7I,UAAA4C,EAAAU,cAAA,WACA,UAAAsF,GAAA/I,OAEAgJ,EAAA7I,UAAAC,KAAA,SAAAC,GACA,GAAA+I,GAAA,GAAAC,GAAArJ,UAEA,OADAoJ,GAAA/I,WACA+I,GAEAJ,EAAA7I,UAAAkB,KAAA,SAAAW,GACA,GAAAhC,KAAA6D,OACA,SAAAgF,GAAAS,uBAEA,KAAAtJ,KAAAmD,UAIA,OAHA8F,GAAAjJ,KAAAiJ,UACA/C,EAAA+C,EAAA5F,OACAkG,EAAAN,EAAAO,QACAvD,EAAA,EAA2BA,EAAAC,EAASD,IACpCsD,EAAAtD,GAAA5E,KAAAW,IAIAgH,EAAA7I,UAAAM,MAAA,SAAAU,GACA,GAAAnB,KAAA6D,OACA,SAAAgF,GAAAS,uBAEAtJ,MAAAkJ,UAAA,EACAlJ,KAAAmJ,YAAAhI,EACAnB,KAAAmD,WAAA,CAIA,QAHA8F,GAAAjJ,KAAAiJ,UACA/C,EAAA+C,EAAA5F,OACAkG,EAAAN,EAAAO,QACAvD,EAAA,EAAuBA,EAAAC,EAASD,IAChCsD,EAAAtD,GAAAxF,MAAAU,EAEAnB,MAAAiJ,UAAA5F,OAAA,GAEA2F,EAAA7I,UAAAO,SAAA,WACA,GAAAV,KAAA6D,OACA,SAAAgF,GAAAS,uBAEAtJ,MAAAmD,WAAA,CAIA,QAHA8F,GAAAjJ,KAAAiJ,UACA/C,EAAA+C,EAAA5F,OACAkG,EAAAN,EAAAO,QACAvD,EAAA,EAAuBA,EAAAC,EAASD,IAChCsD,EAAAtD,GAAAvF,UAEAV,MAAAiJ,UAAA5F,OAAA,GAEA2F,EAAA7I,UAAA8B,YAAA,WACAjC,KAAAmD,WAAA,EACAnD,KAAA6D,QAAA,EACA7D,KAAAiJ,UAAA,MAEAD,EAAA7I,UAAAY,cAAA,SAAAmB,GACA,GAAAlC,KAAA6D,OACA,SAAAgF,GAAAS,uBAGA,OAAArG,GAAA9C,UAAAY,cAAAF,KAAAb,KAAAkC,IAGA8G,EAAA7I,UAAAD,WAAA,SAAAgC,GACA,GAAAlC,KAAA6D,OACA,SAAAgF,GAAAS,uBAEA,OAAAtJ,MAAAkJ,UACAhH,EAAAzB,MAAAT,KAAAmJ,aACAtG,EAAAqB,aAAAoE,OAEAtI,KAAAmD,WACAjB,EAAAxB,WACAmC,EAAAqB,aAAAoE,QAGAtI,KAAAiJ,UAAAb,KAAAlG,GACA,GAAA4G,GAAAW,oBAAAzJ,KAAAkC,KAGA8G,EAAA7I,UAAAuJ,aAAA,WACA,GAAApJ,GAAA,GAAAwF,GAAAhG,UAEA,OADAQ,GAAAC,OAAAP,KACAM,GAEA0I,EAAA7G,OAAA,SAAAmB,EAAA/C,GACA,UAAA8I,GAAA/F,EAAA/C,IAEAyI,GACClD,EAAAhG,WACDL,GAAAuJ,SAIA,IAAAK,GAAA,SAAApG,GAEA,QAAAoG,GAAA/F,EAAA/C,GACA0C,EAAApC,KAAAb,MACAA,KAAAsD,cACAtD,KAAAO,SA6BA,MAjCA6B,GAAAiH,EAAApG,GAMAoG,EAAAlJ,UAAAkB,KAAA,SAAAW,GACA,GAAAsB,GAAAtD,KAAAsD,WACAA,MAAAjC,MACAiC,EAAAjC,KAAAW,IAGAqH,EAAAlJ,UAAAM,MAAA,SAAAU,GACA,GAAAmC,GAAAtD,KAAAsD,WACAA,MAAA7C,OACAT,KAAAsD,YAAA7C,MAAAU,IAGAkI,EAAAlJ,UAAAO,SAAA,WACA,GAAA4C,GAAAtD,KAAAsD,WACAA,MAAA5C,UACAV,KAAAsD,YAAA5C,YAGA2I,EAAAlJ,UAAAD,WAAA,SAAAgC,GAEA,MADAlC,MAAAO,OAEAP,KAAAO,OAAAR,UAAAmC,GAGAW,EAAAqB,aAAAoE,OAGAe,GACCL,EACDvJ,GAAA4J,oBN61BM,SAAU7J,EAAQC,EAASC,GAEjC,YOngCAD,GAAAuI,aAAuBC,OP2gCjB,SAAUzI,EAAQC,EAASC,GAEjC,cAC4B,SAASiK,GQ5gCrC,GAAAC,GAAA,mBAAAC,gBACAC,EAAA,mBAAAC,OAAA,mBAAAC,oBACAD,eAAAC,oBAAAD,KACAE,MAAA,KAAAN,KACAO,EAAAN,GAAAK,GAAAH,CACArK,GAAA+B,KAAA0I,EAIA,WACA,IAAAA,EACA,SAAAtI,OAAA,sERohC6Bf,KAAKpB,EAASC,EAAoB,MAIzD,SAAUF,EAAQC,EAASC,GAEjC,YStiCA,SAAAyK,KACA,IACA,MAAAC,GAAApF,MAAAhF,KAAAoD,WAEA,MAAA6E,GAEA,MADAR,GAAAO,YAAAC,IACAR,EAAAO,aAGA,QAAAD,GAAApD,GAEA,MADAyF,GAAAzF,EACAwF,EAbA,GACAC,GADA3C,EAAA/H,EAAA,EAeAD,GAAAsI,YTgjCM,SAAUvI,EAAQC,EAASC,GAEjC,YUjkCA,IAAA2K,GAAA3K,EAAA,IACA4K,EAAA5K,EAAA,GA2CAD,GAAA8K,MAAA,GAAAD,GAAAE,eAAAH,EAAAI,cVwkCM,SAAUjL,EAAQC,EAASC,GAEjC,YWtnCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAgL,EAAAhL,EAAA,IACAiL,EAAAjL,EAAA,IACAkL,EAAAlL,EAAA,IAMAmL,EAAA,SAAA5H,GAEA,QAAA4H,GAAAC,EAAAC,GACA9H,EAAApC,KAAAb,MACAA,KAAA8K,QACA9K,KAAA+K,YACAA,GAAA,IAAAD,EAAAzH,SACArD,KAAAC,WAAA,EACAD,KAAAgC,MAAA8I,EAAA,IA+FA,MAtGA1I,GAAAyI,EAAA5H,GAUA4H,EAAA1I,OAAA,SAAA2I,EAAAC,GACA,UAAAF,GAAAC,EAAAC,IAsCAF,EAAAG,GAAA,WAEA,OADAF,MACAG,EAAA,EAAwBA,EAAA7H,UAAAC,OAAuB4H,IAC/CH,EAAAG,EAAA,GAAA7H,UAAA6H,EAEA,IAAAF,GAAAD,IAAAzH,OAAA,EACAuH,GAAAM,YAAAH,GACAD,EAAAK,MAGAJ,EAAA,IAEA,IAAA7E,GAAA4E,EAAAzH,MACA,OAAA6C,GAAA,EACA,GAAA2E,GAAAC,EAAAC,GAEA,IAAA7E,EACA,GAAAwE,GAAAU,iBAAAN,EAAA,GAAAC,GAGA,GAAAJ,GAAAU,gBAAAN,IAGAF,EAAAS,SAAA,SAAAC,GACA,GAAAT,GAAAS,EAAAT,MAAAlD,EAAA2D,EAAA3D,MAAA4D,EAAAD,EAAAC,MAAAtJ,EAAAqJ,EAAArJ,UACA,IAAA0F,GAAA4D,EAEA,WADAtJ,GAAAxB,UAGAwB,GAAAb,KAAAyJ,EAAAlD,IACA1F,EAAA2B,SAGA0H,EAAA3D,QAAA,EACA5H,KAAAyL,SAAAF,KAEAV,EAAA1K,UAAAD,WAAA,SAAAgC,GACA,GACA4I,GAAA9K,KAAA8K,MACAU,EAAAV,EAAAzH,OACA0H,EAAA/K,KAAA+K,SACA,IAAAA,EACA,MAAAA,GAAAU,SAAAZ,EAAAS,SAAA,GACAR,QAAAlD,MANA,EAMA4D,QAAAtJ,cAIA,QAAA+D,GAAA,EAA2BA,EAAAuF,IAAAtJ,EAAA2B,OAAiCoC,IAC5D/D,EAAAb,KAAAyJ,EAAA7E,GAEA/D,GAAAxB,YAGAmK,GACC/E,EAAAhG,WACDL,GAAAoL,mBX6nCM,SAAUrL,EAAQC,EAASC,GAEjC,YYtvCAD,GAAAyI,QAAAwD,MAAAxD,SAAA,SAAAyD,GAAkD,MAAAA,IAAA,gBAAAA,GAAAtI,SZ6vC5C,SAAU7D,EAAQC,EAASC,GAEjC,Ya/vCA,SAAAwL,GAAAlJ,GACA,MAAAA,IAAA,kBAAAA,GAAAyJ,SAEAhM,EAAAyL,ebswCM,SAAU1L,EAAQC,EAASC,GAEjC,Yc3wCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GAMA2L,EAAA,SAAApI,GAEA,QAAAoI,GAAAN,GACA9H,EAAApC,KAAAb,MACAA,KAAA+K,YA6DA,MAhEA3I,GAAAiJ,EAAApI,GAgDAoI,EAAAlJ,OAAA,SAAA4I,GACA,UAAAM,GAAAN,IAEAM,EAAAC,SAAA,SAAAM,GACAA,EAAA1J,WACAxB,YAEA2K,EAAAlL,UAAAD,WAAA,SAAAgC,GACA,GAAA6I,GAAA/K,KAAA+K,SACA,IAAAA,EACA,MAAAA,GAAAU,SAAAJ,EAAAC,SAAA,GAAoEpJ,cAGpEA,GAAAxB,YAGA2K,GACCvF,EAAAhG,WACDL,GAAA4L,mBdkxCM,SAAU7L,EAAQC,EAASC,GAEjC,Ye70CA,SAAAmM,GAAAC,EAAAC,GACA,GAAAC,EASA,IAPAA,EADA,kBAAAF,GACAA,EAGA,WACA,MAAAA,IAGA,kBAAAC,GACA,MAAA/L,MAAAI,KAAA,GAAA6L,GAAAD,EAAAD,GAEA,IAAAG,GAAAvJ,OAAAR,OAAAnC,KAAAmM,EAAAC,gCAGA,OAFAF,GAAA3L,OAAAP,KACAkM,EAAAF,iBACAE,EArCA,GAAAC,GAAAzM,EAAA,GAuCAD,GAAAoM,WACA,IAAAI,GAAA,WACA,QAAAA,GAAAD,EAAAD,GACA/L,KAAAgM,iBACAhM,KAAA+L,WASA,MAPAE,GAAA9L,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,GAAAwL,GAAA/L,KAAA+L,SACA3C,EAAApJ,KAAAgM,iBACAjK,EAAAgK,EAAA3C,GAAArJ,UAAAmC,EAEA,OADAH,GAAAjB,IAAAP,EAAAR,UAAAqJ,IACArH,GAEAkK,IAEAxM,GAAAwM,qBfy2CM,SAAUzM,EAAQC,EAASC,IgB/5CjC,SAAAiK,EAAA0C,GACAA,EAAA5M,IAGCO,EAAA,SAAAP,GAA4B,YAkC7B,SAAA6M,GAAAC,GACA,gBAAAlK,EAAAsJ,GACA,MAAAa,IAAAD,EAAAlK,GAAAsJ,IAeA,QAAAc,GAAAC,EAAApK,GACA,OAAAoK,EAAApK,GAuKA,QAAAqK,GAAAC,EAAAC,EAAArB,GACA,GAAAsB,IAAAD,EAAAD,GAAAG,KAAAC,IAAA,EAAAxB,GACAyB,EAAAF,KAAAG,MAAAH,KAAAI,IAAAL,GAAAC,KAAAK,MACA3M,EAAAqM,EAAAC,KAAAM,IAAA,GAAAJ,EACA,OAAAA,IAAA,GACAxM,GAAA6M,GAAA,GAAA7M,GAAA8M,GAAA,EAAA9M,GAAA+M,GAAA,KAAAT,KAAAM,IAAA,GAAAJ,IACAF,KAAAM,IAAA,IAAAJ,IAAAxM,GAAA6M,GAAA,GAAA7M,GAAA8M,GAAA,EAAA9M,GAAA+M,GAAA,KAGA,QAAAC,GAAAb,EAAAC,EAAArB,GACA,GAAAkC,GAAAX,KAAAY,IAAAd,EAAAD,GAAAG,KAAAC,IAAA,EAAAxB,GACAoC,EAAAb,KAAAM,IAAA,GAAAN,KAAAG,MAAAH,KAAAI,IAAAO,GAAAX,KAAAK,OACA3M,EAAAiN,EAAAE,CAIA,OAHAnN,IAAA6M,GAAAM,GAAA,GACAnN,GAAA8M,GAAAK,GAAA,EACAnN,GAAA+M,KAAAI,GAAA,GACAf,EAAAD,GAAAgB,IAoTA,QAAAvK,GAAAhB,GACA,MAAAA,GAAAgB,OAmBA,QAAAwK,GAAAlC,GACA,oBAAAA,EAAA,UAGA,QAAAmC,GAAAC,GACA,sBAAAA,EAAA,QAGA,QAAAC,GAAAC,GACA,gBAAA5L,GACA,OAAA4L,EAAA5L,IAIA,QAAA6L,GAAAD,GACA,GAAAE,GAAApB,KAAAC,IAAA,EAAAiB,EAAAG,YAAA,IAEA,OADAH,GAAAI,UAAAF,EAAApB,KAAAsB,MAAAF,IACA,SAAA9L,GACA,OAAA4L,EAAA5L,GAAA8L,GAIA,QAAAG,KACA,OAAAtO,KAAAuO,OAGA,QAAAC,GAAAC,EAAAR,GAWA,QAAAO,GAAApK,GACA,GAAAsK,GAAA,MAAAC,EAAAV,EAAAW,MAAAX,EAAAW,MAAA5J,MAAAiJ,EAAAY,GAAAZ,EAAAa,SAAAH,EACAI,EAAA,MAAAC,EAAAf,EAAAe,WAAAf,EAAAe,WAAAhK,MAAAiJ,EAAAY,GAAAI,GAAAD,EACAE,EAAAnC,KAAAC,IAAAmC,EAAA,GAAAC,EACAC,EAAApB,EAAAoB,QACAC,GAAAD,EAAA,MACAE,GAAAF,IAAAhM,OAAA,MACAmM,GAAAvB,EAAAG,UAAAF,EAAAF,GAAAC,EAAA1E,QACAkG,EAAArL,EAAAqL,UAAArL,EAAAqL,YAAArL,EACAsL,EAAAD,EAAAE,UAAA,WAAAC,MAAA,OACAC,EAAAJ,EAAAE,UAAA,SAAAC,KAAAlB,EAAAT,GAAA6B,QACAC,EAAAF,EAAAG,OACAC,EAAAJ,EAAAK,QAAAC,OAAA,KAAAC,KAAA,gBACAC,EAAAR,EAAAS,OAAA,QACAC,EAAAV,EAAAS,OAAA,OAEAZ,KAAAc,MAAAd,EAAAQ,QAAAO,OAAA,gBACAL,KAAA,kBACAA,KAAA,kBAEAP,IAAAW,MAAAP,GAEAI,IAAAG,MAAAP,EAAAE,OAAA,QACAC,KAAA,iBACAA,KAAAzE,EAAA,IAAA+E,EAAAvB,IAEAoB,IAAAC,MAAAP,EAAAE,OAAA,QACAC,KAAA,eACAA,KAAAzE,EAAA+E,EAAAxB,GACAkB,KAAA,KAAA3B,IAAAkC,GAAA,MAAAlC,IAAAmC,GAAA,oBAEAxM,IAAAqL,IACAC,IAAAmB,WAAAzM,GACAyL,IAAAgB,WAAAzM,GACAiM,IAAAQ,WAAAzM,GACAmM,IAAAM,WAAAzM,GAEA2L,IAAAc,WAAAzM,GACAgM,KAAA,UAAAU,IACAV,KAAA,qBAAA/N,GAA0C,MAAA0O,UAAA1O,EAAAmN,EAAAnN,IAAA2O,EAAA3O,GAAArC,KAAAiR,aAAA,eAE1ChB,EACAG,KAAA,UAAAU,IACAV,KAAA,qBAAA/N,GAA0C,GAAAI,GAAAzC,KAAAkR,WAAA3C,MAAgC,OAAAyC,GAAAvO,GAAAsO,SAAAtO,IAAAJ,IAAAI,EAAA+M,EAAAnN,OAG1E0N,EAAAlI,SAEA6H,EACAU,KAAA,IAAA3B,IAAA0C,IAAA1C,GAAA2C,GACA,IAAAV,EAAAW,EAAA,IAAA/B,EAAA,QAAAC,EAAA,IAAAmB,EAAAW,EACA,IAAA/B,EAAA,IAAAoB,EAAAW,EAAA,QAAA9B,EAAA,IAAAmB,EAAAW,GAEAxB,EACAO,KAAA,aACAA,KAAA,qBAAA/N,GAAwC,MAAA2O,GAAAxB,EAAAnN,MAExCgO,EACAD,KAAAzE,EAAA,IAAA+E,EAAAvB,GAEAoB,EACAH,KAAAzE,EAAA+E,EAAAxB,GACAqB,KAAAxB,GAEAU,EAAA6B,OAAAhD,GACA8B,KAAA,eACAA,KAAA,gBACAA,KAAA,4BACAA,KAAA,cAAA3B,IAAA2C,GAAA,QAAA3C,IAAA0C,GAAA,gBAEA1B,EACA8B,KAAA,WAA0BvR,KAAAuO,OAAAiB,IAjF1B,GAAAX,MACAF,EAAA,KACAK,EAAA,KACAG,EAAA,EACAkC,EAAA,EACAjC,EAAA,EACAsB,EAAAjC,IAAAkC,IAAAlC,IAAA0C,IAAA,IACAxF,EAAA8C,IAAA0C,IAAA1C,IAAA2C,GAAA,QACAJ,EAAAvC,IAAAkC,IAAAlC,IAAAmC,GAAA/C,EAAAC,CAgHA,OApCAU,GAAAP,MAAA,SAAAuD,GACA,MAAApO,WAAAC,QAAA4K,EAAAuD,EAAAhD,GAAAP,GAGAO,EAAAI,MAAA,WACA,MAAAC,GAAA4C,GAAA5Q,KAAAuC,WAAAoL,GAGAA,EAAAK,cAAA,SAAA2C,GACA,MAAApO,WAAAC,QAAAwL,EAAA,MAAA2C,KAAAC,GAAA5Q,KAAA2Q,GAAAhD,GAAAK,EAAArF,SAGAgF,EAAAG,WAAA,SAAA6C,GACA,MAAApO,WAAAC,QAAAsL,EAAA,MAAA6C,EAAA,KAAAC,GAAA5Q,KAAA2Q,GAAAhD,GAAAG,KAAAnF,SAGAgF,EAAAQ,WAAA,SAAAwC,GACA,MAAApO,WAAAC,QAAA2L,EAAAwC,EAAAhD,GAAAQ,GAGAR,EAAAkD,SAAA,SAAAF,GACA,MAAApO,WAAAC,QAAA8L,EAAAkC,GAAAG,EAAAhD,GAAAW,GAGAX,EAAAW,cAAA,SAAAqC,GACA,MAAApO,WAAAC,QAAA8L,GAAAqC,EAAAhD,GAAAW,GAGAX,EAAA6C,cAAA,SAAAG,GACA,MAAApO,WAAAC,QAAAgO,GAAAG,EAAAhD,GAAA6C,GAGA7C,EAAAY,YAAA,SAAAoC,GACA,MAAApO,WAAAC,QAAA+L,GAAAoC,EAAAhD,GAAAY,GAGAZ,EAGA,QAAAmD,GAAA1D,GACA,MAAAO,GAAAmC,GAAA1C,GAGA,QAAA2D,GAAA3D,GACA,MAAAO,GAAA4C,GAAAnD,GAGA,QAAA4D,GAAA5D,GACA,MAAAO,GAAAoC,GAAA3C,GAGA,QAAA6D,GAAA7D,GACA,MAAAO,GAAA2C,GAAAlD,GAKA,QAAA3C,KACA,OAA8CyG,GAA9C9L,EAAA,EAAA+L,EAAA5O,UAAAC,OAAAmO,KAAkDvL,EAAA+L,IAAO/L,EAAA,CACzD,KAAA8L,EAAA3O,UAAA6C,GAAA,KAAA8L,IAAAP,GAAA,SAAA5P,OAAA,iBAAAmQ,EACAP,GAAAO,MAEA,UAAAE,GAAAT,GAGA,QAAAS,GAAAT,GACAxR,KAAAwR,IAGA,QAAAU,GAAAC,EAAAC,GACA,MAAAD,GAAAE,OAAAC,MAAA,SAAAC,IAAA,SAAAR,GACA,GAAAS,GAAA,GAAAvM,EAAA8L,EAAApJ,QAAA,IAEA,IADA1C,GAAA,IAAAuM,EAAAT,EAAAvI,MAAAvD,EAAA,GAAA8L,IAAAvI,MAAA,EAAAvD,IACA8L,IAAAK,EAAA1P,eAAAqP,GAAA,SAAAnQ,OAAA,iBAAAmQ,EACA,QAAYU,KAAAV,EAAAS,UA6CZ,QAAAE,GAAAD,EAAAD,GACA,OAAAG,GAAA1M,EAAA,EAAA+L,EAAAS,EAAApP,OAAqC4C,EAAA+L,IAAO/L,EAC5C,IAAA0M,EAAAF,EAAAxM,IAAAuM,SACA,MAAAG,GAAA3Q,MAKA,QAAA4Q,GAAAH,EAAAD,EAAAK,GACA,OAAA5M,GAAA,EAAA+L,EAAAS,EAAApP,OAAkC4C,EAAA+L,IAAO/L,EACzC,GAAAwM,EAAAxM,GAAAuM,SAAA,CACAC,EAAAxM,GAAA6M,GAAAL,IAAAjJ,MAAA,EAAAvD,GAAAmB,OAAAqL,EAAAjJ,MAAAvD,EAAA,GACA,OAIA,MADA,OAAA4M,GAAAJ,EAAArK,MAAmCoK,OAAAxQ,MAAA6Q,IACnCJ,EAmBA,QAAAM,GAAAP,GACA,kBACA,GAAAQ,GAAAhT,KAAAiT,cACAC,EAAAlT,KAAAmT,YACA,OAAAD,KAAAE,IAAAJ,EAAAK,gBAAAF,eAAAC,GACAJ,EAAAM,cAAAd,GACAQ,EAAAO,gBAAAL,EAAAV,IAIA,QAAAgB,GAAAC,GACA,kBACA,MAAAzT,MAAAiT,cAAAM,gBAAAE,EAAAC,MAAAD,EAAAE,QAaA,QAAAC,KACA,UAAAC,GAGA,QAAAA,KACA7T,KAAAwR,EAAA,OAAAsC,IAAAC,SAAA,IAuDA,QAAAC,GAAAC,EAAArM,EAAAsM,GAEA,MADAD,GAAAE,EAAAF,EAAArM,EAAAsM,GACA,SAAAE,GACA,GAAAC,GAAAD,EAAAE,aACAD,SAAArU,MAAA,EAAAqU,EAAAE,wBAAAvU,QACAiU,EAAApT,KAAAb,KAAAoU,IAKA,QAAAD,GAAAF,EAAArM,EAAAsM,GACA,gBAAAM,GACA,GAAAC,GAAAhV,EAAA2U,KACA3U,GAAA2U,MAAAI,CACA,KACAP,EAAApT,KAAAb,UAAA0U,SAAA9M,EAAAsM,GACK,QACLzU,EAAA2U,MAAAK,IAKA,QAAAE,GAAAxC,GACA,MAAAA,GAAAE,OAAAC,MAAA,SAAAC,IAAA,SAAAR,GACA,GAAAS,GAAA,GAAAvM,EAAA8L,EAAApJ,QAAA,IAEA,OADA1C,IAAA,IAAAuM,EAAAT,EAAAvI,MAAAvD,EAAA,GAAA8L,IAAAvI,MAAA,EAAAvD,KACYwM,KAAAV,EAAAS,UAIZ,QAAAoC,GAAAC,GACA,kBACA,GAAAC,GAAA9U,KAAA+U,IACA,IAAAD,EAAA,CACA,OAAAE,GAAAC,EAAA,EAAAhP,GAAA,EAAAiP,EAAAJ,EAAAzR,OAA6C4R,EAAAC,IAAOD,EACpDD,EAAAF,EAAAG,GAAAJ,EAAApC,MAAAuC,EAAAvC,OAAAoC,EAAApC,MAAAuC,EAAAxC,OAAAqC,EAAArC,KAGAsC,IAAA7O,GAAA+O,EAFAhV,KAAAmV,oBAAAH,EAAAvC,KAAAuC,EAAAf,SAAAe,EAAAI,WAKAnP,EAAA6O,EAAAzR,OAAA4C,QACAjG,MAAA+U,OAIA,QAAAM,GAAAR,EAAA7S,EAAAoT,GACA,GAAAE,GAAAC,GAAA7S,eAAAmS,EAAApC,MAAAuB,EAAAG,CACA,iBAAA9R,EAAA4D,EAAAiO,GACA,GAAAc,GAAAF,EAAA9U,KAAA+U,KAAAd,EAAAqB,EAAAtT,EAAAiE,EAAAiO,EACA,IAAAY,EAAA,OAAAG,GAAA,EAAAC,EAAAJ,EAAAzR,OAA0C4R,EAAAC,IAAOD,EACjD,IAAAD,EAAAF,EAAAG,IAAAxC,OAAAoC,EAAApC,MAAAuC,EAAAxC,OAAAqC,EAAArC,KAIA,MAHAxS,MAAAmV,oBAAAH,EAAAvC,KAAAuC,EAAAf,SAAAe,EAAAI,SACApV,KAAAwV,iBAAAR,EAAAvC,KAAAuC,EAAAf,WAAAe,EAAAI,gBACAJ,EAAAhT,QAIAhC,MAAAwV,iBAAAX,EAAApC,KAAAwB,EAAAmB,GACAJ,GAASvC,KAAAoC,EAAApC,KAAAD,KAAAqC,EAAArC,KAAAxQ,QAAAiS,WAAAmB,WACTN,EACAA,EAAA1M,KAAA4M,GADAhV,KAAA+U,MAAAC,IA0BA,QAAAS,GAAAjB,EAAAP,EAAAyB,EAAAC,GACA,GAAAlB,GAAAhV,EAAA2U,KACAI,GAAAoB,YAAAnW,EAAA2U,MACA3U,EAAA2U,MAAAI,CACA,KACA,MAAAP,GAAAjP,MAAA0Q,EAAAC,GACG,QACHlW,EAAA2U,MAAAK,GA8BA,QAAAoB,MAuBA,QAAAC,KACA,SA8CA,QAAAC,GAAAnR,EAAAoR,GACAhW,KAAAiT,cAAArO,EAAAqO,cACAjT,KAAAmT,aAAAvO,EAAAuO,aACAnT,KAAA0D,MAAA,KACA1D,KAAAgE,QAAAY,EACA5E,KAAA0U,SAAAsB,EAmBA,QAAAC,GAAArR,EAAAsP,EAAAhE,EAAAgG,EAAAlG,EAAAJ,GASA,IARA,GACAuG,GADAlQ,EAAA,EAEAmQ,EAAAlC,EAAA7Q,OACAgT,EAAAzG,EAAAvM,OAKQ4C,EAAAoQ,IAAgBpQ,GACxBkQ,EAAAjC,EAAAjO,KACAkQ,EAAAzB,SAAA9E,EAAA3J,GACAiQ,EAAAjQ,GAAAkQ,GAEAjG,EAAAjK,GAAA,GAAA8P,GAAAnR,EAAAgL,EAAA3J,GAKA,MAAQA,EAAAmQ,IAAiBnQ,GACzBkQ,EAAAjC,EAAAjO,MACA+J,EAAA/J,GAAAkQ,GAKA,QAAAG,GAAA1R,EAAAsP,EAAAhE,EAAAgG,EAAAlG,EAAAJ,EAAA2G,GACA,GAAAtQ,GACAkQ,EAKAK,EAJAC,KACAL,EAAAlC,EAAA7Q,OACAgT,EAAAzG,EAAAvM,OACAqT,EAAA,GAAAhL,OAAA0K,EAKA,KAAAnQ,EAAA,EAAaA,EAAAmQ,IAAiBnQ,GAC9BkQ,EAAAjC,EAAAjO,MACAyQ,EAAAzQ,GAAAuQ,EAAAG,GAAAJ,EAAA1V,KAAAsV,IAAAzB,SAAAzO,EAAAiO,GACAsC,IAAAC,GACAzG,EAAA/J,GAAAkQ,EAEAM,EAAAD,GAAAL,EAQA,KAAAlQ,EAAA,EAAaA,EAAAoQ,IAAgBpQ,EAC7BuQ,EAAAG,GAAAJ,EAAA1V,KAAA+D,EAAAgL,EAAA3J,KAAA2J,IACAuG,EAAAM,EAAAD,KACAN,EAAAjQ,GAAAkQ,EACAA,EAAAzB,SAAA9E,EAAA3J,GACAwQ,EAAAD,GAAA,MAEAtG,EAAAjK,GAAA,GAAA8P,GAAAnR,EAAAgL,EAAA3J,GAKA,KAAAA,EAAA,EAAaA,EAAAmQ,IAAiBnQ,GAC9BkQ,EAAAjC,EAAAjO,KAAAwQ,EAAAC,EAAAzQ,MAAAkQ,IACAnG,EAAA/J,GAAAkQ,GAsGA,QAAAS,GAAAlK,EAAApK,GACA,MAAAoK,GAAApK,GAAA,EAAAoK,EAAApK,EAAA,EAAAoK,GAAApK,EAAA,EAAAuU,IAiDA,QAAAC,GAAAtE,GACA,kBACAxS,KAAA+W,gBAAAvE,IAIA,QAAAwE,GAAAvD,GACA,kBACAzT,KAAAiX,kBAAAxD,EAAAC,MAAAD,EAAAE,QAIA,QAAAuD,GAAA1E,EAAAxQ,GACA,kBACAhC,KAAAmX,aAAA3E,EAAAxQ,IAIA,QAAAoV,GAAA3D,EAAAzR,GACA,kBACAhC,KAAAqX,eAAA5D,EAAAC,MAAAD,EAAAE,MAAA3R,IAIA,QAAAsV,GAAA9E,EAAAxQ,GACA,kBACA,GAAAuV,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACA,OAAAmU,EAAAvX,KAAA+W,gBAAAvE,GACAxS,KAAAmX,aAAA3E,EAAA+E,IAIA,QAAAC,GAAA/D,EAAAzR,GACA,kBACA,GAAAuV,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACA,OAAAmU,EAAAvX,KAAAiX,kBAAAxD,EAAAC,MAAAD,EAAAE,OACA3T,KAAAqX,eAAA5D,EAAAC,MAAAD,EAAAE,MAAA4D,IA0BA,QAAAE,GAAAjF,GACA,kBACAxS,KAAA0X,MAAAC,eAAAnF,IAIA,QAAAoF,GAAApF,EAAAxQ,EAAA6V,GACA,kBACA7X,KAAA0X,MAAAI,YAAAtF,EAAAxQ,EAAA6V,IAIA,QAAAE,GAAAvF,EAAAxQ,EAAA6V,GACA,kBACA,GAAAN,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACA,OAAAmU,EAAAvX,KAAA0X,MAAAC,eAAAnF,GACAxS,KAAA0X,MAAAI,YAAAtF,EAAA+E,EAAAM,IAaA,QAAAG,GAAA7B,EAAA3D,GACA,MAAA2D,GAAAuB,MAAAO,iBAAAzF,IACA0F,GAAA/B,GAAAgC,iBAAAhC,EAAA,MAAA8B,iBAAAzF,GAGA,QAAA4F,GAAA5F,GACA,wBACAxS,MAAAwS,IAIA,QAAA6F,GAAA7F,EAAAxQ,GACA,kBACAhC,KAAAwS,GAAAxQ,GAIA,QAAAsW,GAAA9F,EAAAxQ,GACA,kBACA,GAAAuV,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACA,OAAAmU,QAAAvX,MAAAwS,GACAxS,KAAAwS,GAAA+E,GAaA,QAAAgB,GAAAC,GACA,MAAAA,GAAAnG,OAAAC,MAAA,SAGA,QAAAmG,GAAAtC,GACA,MAAAA,GAAAsC,WAAA,GAAAC,GAAAvC,GAGA,QAAAuC,GAAAvC,GACAnW,KAAA2Y,MAAAxC,EACAnW,KAAA4Y,OAAAL,EAAApC,EAAAlF,aAAA,cAuBA,QAAA4H,GAAA1C,EAAA2C,GAEA,IADA,GAAAC,GAAAN,EAAAtC,GAAAlQ,GAAA,EAAA+L,EAAA8G,EAAAzV,SACA4C,EAAA+L,GAAA+G,EAAAjY,IAAAgY,EAAA7S,IAGA,QAAA+S,IAAA7C,EAAA2C,GAEA,IADA,GAAAC,GAAAN,EAAAtC,GAAAlQ,GAAA,EAAA+L,EAAA8G,EAAAzV,SACA4C,EAAA+L,GAAA+G,EAAAlR,OAAAiR,EAAA7S,IAGA,QAAAgT,IAAAH,GACA,kBACAD,EAAA7Y,KAAA8Y,IAIA,QAAAI,IAAAJ,GACA,kBACAE,GAAAhZ,KAAA8Y,IAIA,QAAAK,IAAAL,EAAA9W,GACA,mBACAA,EAAAgD,MAAAhF,KAAAoD,WAAAyV,EAAAG,IAAAhZ,KAAA8Y,IAmBA,QAAAM,MACApZ,KAAAqZ,YAAA,GAGA,QAAAC,IAAAtX,GACA,kBACAhC,KAAAqZ,YAAArX,GAIA,QAAAuX,IAAAvX,GACA,kBACA,GAAAuV,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACApD,MAAAqZ,YAAA,MAAA9B,EAAA,GAAAA,GAaA,QAAAiC,MACAxZ,KAAAyZ,UAAA,GAGA,QAAAC,IAAA1X,GACA,kBACAhC,KAAAyZ,UAAAzX,GAIA,QAAA2X,IAAA3X,GACA,kBACA,GAAAuV,GAAAvV,EAAAgD,MAAAhF,KAAAoD,UACApD,MAAAyZ,UAAA,MAAAlC,EAAA,GAAAA,GAaA,QAAAqC,MACA5Z,KAAA6Z,aAAA7Z,KAAAkR,WAAA4I,YAAA9Z,MAOA,QAAA+Z,MACA/Z,KAAAga,iBAAAha,KAAAkR,WAAA+I,aAAAja,UAAAkR,WAAAgJ,YAcA,QAAAC,MACA,YAWA,QAAAtS,MACA,GAAAjD,GAAA5E,KAAAkR,UACAtM,MAAAwV,YAAApa,MAaA,QAAAqa,IAAAlE,EAAA1D,EAAA6H,GACA,GAAAzQ,GAAAqO,GAAA/B,GACA/B,EAAAvK,EAAA0Q,WAEA,mBAAAnG,GACAA,EAAA,GAAAA,GAAA3B,EAAA6H,IAEAlG,EAAAvK,EAAAmJ,SAAAwH,YAAA,SACAF,GAAAlG,EAAAqG,UAAAhI,EAAA6H,EAAAI,QAAAJ,EAAAK,YAAAvG,EAAAwG,OAAAN,EAAAM,QACAxG,EAAAqG,UAAAhI,GAAA,OAGA0D,EAAAkE,cAAAjG,GAGA,QAAAyG,IAAApI,EAAA6H,GACA,kBACA,MAAAD,IAAAra,KAAAyS,EAAA6H,IAIA,QAAAQ,IAAArI,EAAA6H,GACA,kBACA,MAAAD,IAAAra,KAAAyS,EAAA6H,EAAAtV,MAAAhF,KAAAoD,aAYA,QAAA2X,IAAAC,EAAAC,GACAjb,KAAAkb,QAAAF,EACAhb,KAAAiE,SAAAgX,EAGA,QAAAxL,MACA,UAAAsL,MAAA/H,SAAAK,kBAAA7R,IAsEA,QAAA2Z,MACA1b,EAAA2U,MAAAgH,2BAmBA,QAAAC,IAAAC,EAAAC,GACA,GAAA/Z,GAAA8Z,EAAAtI,SAAAK,gBACAmI,EAAAlL,GAAAgL,GAAAxG,GAAA,sBACAyG,KACAC,EAAA1G,GAAA,aAAA2G,IAAA,GACAnV,WAAA,WAA2BkV,EAAA1G,GAAA,oBAAuC,IAElE,iBAAAtT,GACAga,EAAA1G,GAAA,0BAEAtT,EAAAkW,MAAAgE,cAAAla,EAAAma,iBACAna,GAAAma,YAUA,QAAAC,IAAAC,EAAApJ,EAAArJ,EAAA0S,EAAAC,EAAApQ,EAAAoC,EAAAiO,EAAAC,EAAA3Q,GACAtL,KAAA6b,SACA7b,KAAAyS,OACAzS,KAAAoJ,UACApJ,KAAAkc,WAAAJ,EACA9b,KAAA+b,SACA/b,KAAA2L,IACA3L,KAAA+N,IACA/N,KAAAgc,KACAhc,KAAAic,KACAjc,KAAAwR,EAAAlG,EASA,QAAA6Q,MACA,OAAA1c,EAAA2U,MAAAgI,OAGA,QAAAC,MACA,MAAArc,MAAAkR,WAGA,QAAAoL,IAAAja,GACA,aAAAA,GAAsBsJ,EAAAlM,EAAA2U,MAAAzI,EAAAoC,EAAAtO,EAAA2U,MAAArG,GAAuC1L,EAG7D,QAAAka,MACA,sBAAAvc,MAmJA,QAAAwc,IAAA5X,EAAA6X,GACA,GAAAtc,GAAAwC,OAAAR,OAAAyC,EAAAzE,UACA,QAAAoW,KAAAkG,GAAAtc,EAAAoW,GAAAkG,EAAAlG,EACA,OAAApW,GAGA,QAAAuc,OAiLA,QAAAC,IAAA5N,GACA,GAAAmG,EAEA,OADAnG,MAAA,IAAAsD,OAAAuK,eACA1H,EAAA2H,GAAAC,KAAA/N,KAAAmG,EAAA6H,SAAA7H,EAAA,UAAA8H,IAAA9H,GAAA,KAAAA,GAAA,MAAAA,GAAA,SAAAA,GAAA,GAAAA,IAAA,KAAAA,EAAA,KACAA,EAAA+H,GAAAH,KAAA/N,IAAAmO,GAAAH,SAAA7H,EAAA,SACAA,EAAAiI,GAAAL,KAAA/N,IAAA,GAAAiO,IAAA9H,EAAA,GAAAA,EAAA,GAAAA,EAAA,OACAA,EAAAkI,GAAAN,KAAA/N,IAAA,GAAAiO,IAAA,IAAA9H,EAAA,WAAAA,EAAA,WAAAA,EAAA,WACAA,EAAAmI,GAAAP,KAAA/N,IAAAuO,GAAApI,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KACAA,EAAAqI,GAAAT,KAAA/N,IAAAuO,GAAA,IAAApI,EAAA,WAAAA,EAAA,WAAAA,EAAA,OAAAA,EAAA,KACAA,EAAAsI,GAAAV,KAAA/N,IAAA0O,GAAAvI,EAAA,GAAAA,EAAA,OAAAA,EAAA,WACAA,EAAAwI,GAAAZ,KAAA/N,IAAA0O,GAAAvI,EAAA,GAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,IACAyI,GAAAjb,eAAAqM,GAAAmO,GAAAS,GAAA5O,IACA,gBAAAA,EAAA,GAAAiO,IAAAnG,YAAA,GACA,KAGA,QAAAqG,IAAAlL,GACA,UAAAgL,IAAAhL,GAAA,OAAAA,GAAA,UAAAA,EAAA,GAGA,QAAAsL,IAAAM,EAAAC,EAAAvb,EAAAoK,GAEA,MADAA,IAAA,IAAAkR,EAAAC,EAAAvb,EAAAuU,KACA,GAAAmG,IAAAY,EAAAC,EAAAvb,EAAAoK,GAGA,QAAAoR,IAAA9I,GAEA,MADAA,aAAA0H,MAAA1H,EAAA2H,GAAA3H,IACAA,GACAA,IAAA+I,MACA,GAAAf,IAAAhI,EAAA4I,EAAA5I,EAAA6I,EAAA7I,EAAA1S,EAAA0S,EAAAgJ,UAFA,GAAAhB,IAKA,QAAAe,IAAAH,EAAAC,EAAAvb,EAAA0b,GACA,WAAA5a,UAAAC,OAAAya,GAAAF,GAAA,GAAAZ,IAAAY,EAAAC,EAAAvb,EAAA,MAAA0b,EAAA,EAAAA,GAGA,QAAAhB,IAAAY,EAAAC,EAAAvb,EAAA0b,GACAhe,KAAA4d,KACA5d,KAAA6d,KACA7d,KAAAsC,KACAtC,KAAAge,WA+BA,QAAAP,IAAAQ,EAAAC,EAAAC,EAAAzR,GAIA,MAHAA,IAAA,EAAAuR,EAAAC,EAAAC,EAAAtH,IACAsH,GAAA,GAAAA,GAAA,EAAAF,EAAAC,EAAArH,IACAqH,GAAA,IAAAD,EAAApH,KACA,GAAAuH,IAAAH,EAAAC,EAAAC,EAAAzR,GAGA,QAAA2R,IAAArJ,GACA,GAAAA,YAAAoJ,IAAA,UAAAA,IAAApJ,EAAAiJ,EAAAjJ,EAAAkJ,EAAAlJ,EAAAmJ,EAAAnJ,EAAAgJ,QAEA,IADAhJ,YAAA0H,MAAA1H,EAAA2H,GAAA3H,KACAA,EAAA,UAAAoJ,GACA,IAAApJ,YAAAoJ,IAAA,MAAApJ,EACAA,KAAA+I,KACA,IAAAH,GAAA5I,EAAA4I,EAAA,IACAC,EAAA7I,EAAA6I,EAAA,IACAvb,EAAA0S,EAAA1S,EAAA,IACAgc,EAAAvR,KAAAuR,IAAAV,EAAAC,EAAAvb,GACA0K,EAAAD,KAAAC,IAAA4Q,EAAAC,EAAAvb,GACA2b,EAAApH,IACAqH,EAAAlR,EAAAsR,EACAH,GAAAnR,EAAAsR,GAAA,CAUA,OATAJ,IACAD,EAAAL,IAAA5Q,GAAA6Q,EAAAvb,GAAA4b,EAAA,GAAAL,EAAAvb,GACAub,IAAA7Q,GAAA1K,EAAAsb,GAAAM,EAAA,GACAN,EAAAC,GAAAK,EAAA,EACAA,GAAAC,EAAA,GAAAnR,EAAAsR,EAAA,EAAAtR,EAAAsR,EACAL,GAAA,IAEAC,EAAAC,EAAA,GAAAA,EAAA,IAAAF,EAEA,GAAAG,IAAAH,EAAAC,EAAAC,EAAAnJ,EAAAgJ,SAGA,QAAAO,IAAAN,EAAAC,EAAAC,EAAAH,GACA,WAAA5a,UAAAC,OAAAgb,GAAAJ,GAAA,GAAAG,IAAAH,EAAAC,EAAAC,EAAA,MAAAH,EAAA,EAAAA,GAGA,QAAAI,IAAAH,EAAAC,EAAAC,EAAAH,GACAhe,KAAAie,KACAje,KAAAke,KACAle,KAAAme,KACAne,KAAAge,WAiCA,QAAAQ,IAAAP,EAAAQ,EAAAC,GACA,MAGA,MAHAT,EAAA,GAAAQ,GAAAC,EAAAD,GAAAR,EAAA,GACAA,EAAA,IAAAS,EACAT,EAAA,IAAAQ,GAAAC,EAAAD,IAAA,IAAAR,GAAA,GACAQ,GAeA,QAAAE,IAAA3J,GACA,GAAAA,YAAA4J,IAAA,UAAAA,IAAA5J,EAAAmJ,EAAAnJ,EAAAtI,EAAAsI,EAAA1S,EAAA0S,EAAAgJ,QACA,IAAAhJ,YAAA6J,IAAA,CACA,GAAAZ,GAAAjJ,EAAAiJ,EAAAa,EACA,WAAAF,IAAA5J,EAAAmJ,EAAApR,KAAAgS,IAAAd,GAAAjJ,EAAArC,EAAA5F,KAAAiS,IAAAf,GAAAjJ,EAAArC,EAAAqC,EAAAgJ,SAEAhJ,YAAAgI,MAAAhI,EAAA8I,GAAA9I,GACA,IAAA1S,GAAA2c,GAAAjK,EAAA4I,GACAlR,EAAAuS,GAAAjK,EAAA6I,GACAM,EAAAc,GAAAjK,EAAA1S,GACAqJ,EAAAuT,IAAA,SAAA5c,EAAA,SAAAoK,EAAA,SAAAyR,GAAAgB,IACApR,EAAAmR,IAAA,SAAA5c,EAAA,SAAAoK,EAAA,QAAAyR,GAAAiB,GAEA,WAAAR,IAAA,IAAA7Q,EAAA,QAAApC,EAAAoC,GAAA,KAAAA,EADAmR,IAAA,SAAA5c,EAAA,QAAAoK,EAAA,SAAAyR,GAAAkB,KACArK,EAAAgJ,SAGA,QAAAsB,IAAAnB,EAAAzR,EAAApK,EAAA0b,GACA,WAAA5a,UAAAC,OAAAsb,GAAAR,GAAA,GAAAS,IAAAT,EAAAzR,EAAApK,EAAA,MAAA0b,EAAA,EAAAA,GAGA,QAAAY,IAAAT,EAAAzR,EAAApK,EAAA0b,GACAhe,KAAAme,KACAne,KAAA0M,KACA1M,KAAAsC,KACAtC,KAAAge,WA0BA,QAAAkB,IAAAnN,GACA,MAAAA,GAAAwN,GAAAxS,KAAAM,IAAA0E,EAAA,KAAAA,EAAAyN,GAAAC,GAGA,QAAAC,IAAA3N,GACA,MAAAA,GAAA4N,GAAA5N,MAAAyN,IAAAzN,EAAA0N,IAGA,QAAAG,IAAAjU,GACA,YAAAA,GAAA,eAAAA,EAAA,MAAAoB,KAAAM,IAAA1B,EAAA,aAGA,QAAAsT,IAAAtT,GACA,OAAAA,GAAA,aAAAA,EAAA,MAAAoB,KAAAM,KAAA1B,EAAA,iBAGA,QAAAkU,IAAA7K,GACA,GAAAA,YAAA6J,IAAA,UAAAA,IAAA7J,EAAAiJ,EAAAjJ,EAAArC,EAAAqC,EAAAmJ,EAAAnJ,EAAAgJ,QACAhJ,aAAA4J,MAAA5J,EAAA2J,GAAA3J,GACA,IAAAiJ,GAAAlR,KAAA+S,MAAA9K,EAAA1S,EAAA0S,EAAAtI,GAAAqT,EACA,WAAAlB,IAAAZ,EAAA,EAAAA,EAAA,IAAAA,EAAAlR,KAAAiT,KAAAhL,EAAAtI,EAAAsI,EAAAtI,EAAAsI,EAAA1S,EAAA0S,EAAA1S,GAAA0S,EAAAmJ,EAAAnJ,EAAAgJ,SAGA,QAAAiC,IAAAhC,EAAAtL,EAAAwL,EAAAH,GACA,WAAA5a,UAAAC,OAAAwc,GAAA5B,GAAA,GAAAY,IAAAZ,EAAAtL,EAAAwL,EAAA,MAAAH,EAAA,EAAAA,GAGA,QAAAa,IAAAZ,EAAAtL,EAAAwL,EAAAH,GACAhe,KAAAie,KACAje,KAAA2S,KACA3S,KAAAme,KACAne,KAAAge,WAwBA,QAAAkC,IAAAlL,GACA,GAAAA,YAAAmL,IAAA,UAAAA,IAAAnL,EAAAiJ,EAAAjJ,EAAAkJ,EAAAlJ,EAAAmJ,EAAAnJ,EAAAgJ,QACAhJ,aAAAgI,MAAAhI,EAAA8I,GAAA9I,GACA,IAAA4I,GAAA5I,EAAA4I,EAAA,IACAC,EAAA7I,EAAA6I,EAAA,IACAvb,EAAA0S,EAAA1S,EAAA,IACA6b,GAAAiC,GAAA9d,EAAA+d,GAAAzC,EAAA0C,GAAAzC,IAAAuC,GAAAC,GAAAC,IACAC,EAAAje,EAAA6b,EACAzN,GAAA8P,IAAA3C,EAAAM,GAAAsC,GAAAF,GAAAG,GACAxC,EAAAnR,KAAAiT,KAAAtP,IAAA6P,MAAAC,GAAArC,GAAA,EAAAA,IACAF,EAAAC,EAAAnR,KAAA+S,MAAApP,EAAA6P,GAAAR,GAAA,IAAAlJ,GACA,WAAAsJ,IAAAlC,EAAA,EAAAA,EAAA,IAAAA,EAAAC,EAAAC,EAAAnJ,EAAAgJ,SAGA,QAAA2C,IAAA1C,EAAAC,EAAAC,EAAAH,GACA,WAAA5a,UAAAC,OAAA6c,GAAAjC,GAAA,GAAAkC,IAAAlC,EAAAC,EAAAC,EAAA,MAAAH,EAAA,EAAAA,GAGA,QAAAmC,IAAAlC,EAAAC,EAAAC,EAAAH,GACAhe,KAAAie,KACAje,KAAAke,KACAle,KAAAme,KACAne,KAAAge,WA2BA,QAAA4C,IAAAjB,EAAAkB,EAAAC,EAAAC,EAAAC,GACA,GAAAxB,GAAAG,IAAAJ,EAAAC,EAAAG,CACA,aAAAA,EAAA,EAAAH,EAAAD,GAAAsB,GACA,IAAArB,EAAA,EAAAD,GAAAuB,GACA,IAAAnB,EAAA,EAAAH,EAAA,EAAAD,GAAAwB,EACAxB,EAAAyB,GAAA,EAiCA,QAAAC,IAAAvU,EAAArK,GACA,gBAAA0P,GACA,MAAArF,GAAAqF,EAAA1P,GAIA,QAAA6e,IAAAxU,EAAApK,EAAAyL,GACA,MAAArB,GAAAK,KAAAM,IAAAX,EAAAqB,GAAAzL,EAAAyK,KAAAM,IAAA/K,EAAAyL,GAAArB,EAAAqB,EAAA,EAAAA,EAAA,SAAAgE,GACA,MAAAhF,MAAAM,IAAAX,EAAAqF,EAAAzP,EAAAyL,IAIA,QAAAoT,IAAAzU,EAAApK,GACA,GAAAD,GAAAC,EAAAoK,CACA,OAAArK,GAAA4e,GAAAvU,EAAArK,EAAA,KAAAA,GAAA,IAAAA,EAAA,IAAA0K,KAAAsB,MAAAhM,EAAA,KAAAA,GAAA+e,GAAAC,MAAA3U,GAAApK,EAAAoK,GAGA,QAAA4U,IAAAvT,GACA,WAAAA,MAAAwT,GAAA,SAAA7U,EAAApK,GACA,MAAAA,GAAAoK,EAAAwU,GAAAxU,EAAApK,EAAAyL,GAAAqT,GAAAC,MAAA3U,GAAApK,EAAAoK,IAIA,QAAA6U,IAAA7U,EAAApK,GACA,GAAAD,GAAAC,EAAAoK,CACA,OAAArK,GAAA4e,GAAAvU,EAAArK,GAAA+e,GAAAC,MAAA3U,GAAApK,EAAAoK,GAyBA,QAAA8U,IAAAC,GACA,gBAAAC,GACA,GAIAzb,GAAA0b,EAJA3P,EAAA0P,EAAAre,OACAua,EAAA,GAAAlS,OAAAsG,GACA6L,EAAA,GAAAnS,OAAAsG,GACA1P,EAAA,GAAAoJ,OAAAsG,EAEA,KAAA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB0b,EAAA5D,GAAA2D,EAAAzb,IACA2X,EAAA3X,GAAA0b,EAAA/D,GAAA,EACAC,EAAA5X,GAAA0b,EAAA9D,GAAA,EACAvb,EAAA2D,GAAA0b,EAAArf,GAAA,CAMA,OAJAsb,GAAA6D,EAAA7D,GACAC,EAAA4D,EAAA5D,GACAvb,EAAAmf,EAAAnf,GACAqf,EAAA3D,QAAA,EACA,SAAAjM,GAIA,MAHA4P,GAAA/D,IAAA7L,GACA4P,EAAA9D,IAAA9L,GACA4P,EAAArf,IAAAyP,GACA4P,EAAA,KA8DA,QAAAC,IAAAtf,GACA,kBACA,MAAAA,IAIA,QAAAuf,IAAAvf,GACA,gBAAAyP,GACA,MAAAzP,GAAAyP,GAAA,IAsGA,QAAA+P,IAAA9f,GACA,eAAAA,EAAA+f,IACAC,QAAAhP,SAAAM,cAAA,OAAA2O,GAAAjP,SAAAK,gBAAA6O,GAAAlP,SAAAkF,aACA8J,GAAAtK,MAAA1G,UAAAhP,EACAA,EAAAkgB,GAAA/J,iBAAA8J,GAAAnI,YAAAkI,IAAA,MAAA/J,iBAAA,aACAgK,GAAA7H,YAAA4H,IACAhgB,IAAAwH,MAAA,MAAA8I,MAAA,KACA6P,IAAAngB,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,KAGA,QAAAogB,IAAApgB,GACA,aAAAA,EAAA+f,IACAM,QAAArP,SAAAO,gBAAA,mCACA8O,GAAAlL,aAAA,YAAAnV,IACAA,EAAAqgB,GAAArR,UAAAsR,QAAAC,gBACAvgB,IAAAwgB,OACAL,GAAAngB,EAAA0K,EAAA1K,EAAAM,EAAAN,EAAA2Q,EAAA3Q,EAAAK,EAAAL,EAAAiG,EAAAjG,EAAAuK,IAFAwV,IAKA,QAAAU,IAAAC,EAAAC,EAAAC,EAAAC,GAEA,QAAA1X,GAAA+S,GACA,MAAAA,GAAA7a,OAAA6a,EAAA/S,MAAA,OAGA,QAAA2X,GAAAC,EAAAC,EAAAC,EAAAC,EAAAhF,EAAAiF,GACA,GAAAJ,IAAAE,GAAAD,IAAAE,EAAA,CACA,GAAAjd,GAAAiY,EAAA9V,KAAA,kBAAAua,EAAA,KAAAC,EACAO,GAAA/a,MAAcnC,IAAA,EAAA0F,EAAAyX,GAAAL,EAAAE,KAAsChd,IAAA,EAAA0F,EAAAyX,GAAAJ,EAAAE,UAC/CD,GAAAC,IACLhF,EAAA9V,KAAA,aAAA6a,EAAAN,EAAAO,EAAAN,GAIA,QAAAS,GAAA3W,EAAApK,EAAA4b,EAAAiF,GACAzW,IAAApK,GACAoK,EAAApK,EAAA,IAAAA,GAAA,IAAgCA,EAAAoK,EAAA,MAAAA,GAAA,KAChCyW,EAAA/a,MAAcnC,EAAAiY,EAAA9V,KAAA+C,EAAA+S,GAAA,eAAA2E,GAAA,EAAAlX,EAAAyX,GAAA1W,EAAApK,MACTA,GACL4b,EAAA9V,KAAA+C,EAAA+S,GAAA,UAAA5b,EAAAugB,GAIA,QAAAS,GAAA5W,EAAApK,EAAA4b,EAAAiF,GACAzW,IAAApK,EACA6gB,EAAA/a,MAAcnC,EAAAiY,EAAA9V,KAAA+C,EAAA+S,GAAA,cAAA2E,GAAA,EAAAlX,EAAAyX,GAAA1W,EAAApK,KACTA,GACL4b,EAAA9V,KAAA+C,EAAA+S,GAAA,SAAA5b,EAAAugB,GAIA,QAAA5U,GAAA8U,EAAAC,EAAAC,EAAAC,EAAAhF,EAAAiF,GACA,GAAAJ,IAAAE,GAAAD,IAAAE,EAAA,CACA,GAAAjd,GAAAiY,EAAA9V,KAAA+C,EAAA+S,GAAA,2BACAiF,GAAA/a,MAAcnC,IAAA,EAAA0F,EAAAyX,GAAAL,EAAAE,KAAsChd,IAAA,EAAA0F,EAAAyX,GAAAJ,EAAAE,SAC/C,KAAAD,GAAA,IAAAC,GACLhF,EAAA9V,KAAA+C,EAAA+S,GAAA,SAAA+E,EAAA,IAAAC,EAAA,KAIA,gBAAAxW,EAAApK,GACA,GAAA4b,MACAiF,IAOA,OANAzW,GAAAgW,EAAAhW,GAAApK,EAAAogB,EAAApgB,GACAwgB,EAAApW,EAAAmB,WAAAnB,EAAAoB,WAAAxL,EAAAuL,WAAAvL,EAAAwL,WAAAoQ,EAAAiF,GACAE,EAAA3W,EAAA2W,OAAA/gB,EAAA+gB,OAAAnF,EAAAiF,GACAG,EAAA5W,EAAA4W,MAAAhhB,EAAAghB,MAAApF,EAAAiF,GACAlV,EAAAvB,EAAA6W,OAAA7W,EAAA8W,OAAAlhB,EAAAihB,OAAAjhB,EAAAkhB,OAAAtF,EAAAiF,GACAzW,EAAApK,EAAA,KACA,SAAAyP,GAEA,IADA,GAAAiD,GAAA/O,GAAA,EAAA+L,EAAAmR,EAAA9f,SACA4C,EAAA+L,GAAAkM,GAAAlJ,EAAAmO,EAAAld,OAAA+O,EAAArJ,EAAAoG,EACA,OAAAmM,GAAAuF,KAAA,MAaA,QAAAC,IAAA/X,GACA,QAAAA,EAAAoB,KAAA4W,IAAAhY,IAAA,EAAAA,GAAA,EAGA,QAAAiY,IAAAjY,GACA,QAAAA,EAAAoB,KAAA4W,IAAAhY,IAAA,EAAAA,GAAA,EAGA,QAAAkY,IAAAlY,GACA,QAAAA,EAAAoB,KAAA4W,IAAA,EAAAhY,IAAA,IAAAA,EAAA,GAmDA,QAAAmY,IAAAC,GACA,gBAAAnX,EAAAoX,GACA,GAAA/F,GAAA8F,GAAAnX,EAAA2R,GAAA3R,IAAAqR,GAAA+F,EAAAzF,GAAAyF,IAAA/F,GACAC,EAAAqD,GAAA3U,EAAAsR,EAAA8F,EAAA9F,GACAC,EAAAoD,GAAA3U,EAAAuR,EAAA6F,EAAA7F,GACAH,EAAAuD,GAAA3U,EAAAoR,QAAAgG,EAAAhG,QACA,iBAAAjM,GAKA,MAJAnF,GAAAqR,IAAAlM,GACAnF,EAAAsR,IAAAnM,GACAnF,EAAAuR,IAAApM,GACAnF,EAAAoR,UAAAjM,GACAnF,EAAA,KAQA,QAAAqX,IAAArX,EAAAoX,GACA,GAAA7F,GAAAoD,IAAA3U,EAAA0S,GAAA1S,IAAAuR,GAAA6F,EAAA1E,GAAA0E,IAAA7F,GACAzR,EAAA6U,GAAA3U,EAAAF,EAAAsX,EAAAtX,GACApK,EAAAif,GAAA3U,EAAAtK,EAAA0hB,EAAA1hB,GACA0b,EAAAuD,GAAA3U,EAAAoR,QAAAgG,EAAAhG,QACA,iBAAAjM,GAKA,MAJAnF,GAAAuR,IAAApM,GACAnF,EAAAF,IAAAqF,GACAnF,EAAAtK,IAAAyP,GACAnF,EAAAoR,UAAAjM,GACAnF,EAAA,IAIA,QAAAsX,IAAAH,GACA,gBAAAnX,EAAAoX,GACA,GAAA/F,GAAA8F,GAAAnX,EAAAqT,GAAArT,IAAAqR,GAAA+F,EAAA/D,GAAA+D,IAAA/F,GACAtL,EAAA4O,GAAA3U,EAAA+F,EAAAqR,EAAArR,GACAwL,EAAAoD,GAAA3U,EAAAuR,EAAA6F,EAAA7F,GACAH,EAAAuD,GAAA3U,EAAAoR,QAAAgG,EAAAhG,QACA,iBAAAjM,GAKA,MAJAnF,GAAAqR,IAAAlM,GACAnF,EAAA+F,IAAAZ,GACAnF,EAAAuR,IAAApM,GACAnF,EAAAoR,UAAAjM,GACAnF,EAAA,KAQA,QAAAuX,IAAAJ,GACA,eAAAK,GAAArW,GAGA,QAAAsW,GAAAzX,EAAAoX,GACA,GAAA/F,GAAA8F,GAAAnX,EAAA+T,GAAA/T,IAAAqR,GAAA+F,EAAArD,GAAAqD,IAAA/F,GACAC,EAAAqD,GAAA3U,EAAAsR,EAAA8F,EAAA9F,GACAC,EAAAoD,GAAA3U,EAAAuR,EAAA6F,EAAA7F,GACAH,EAAAuD,GAAA3U,EAAAoR,QAAAgG,EAAAhG,QACA,iBAAAjM,GAKA,MAJAnF,GAAAqR,IAAAlM,GACAnF,EAAAsR,IAAAnM,GACAnF,EAAAuR,IAAApR,KAAAM,IAAA0E,EAAAhE,IACAnB,EAAAoR,UAAAjM,GACAnF,EAAA,IAMA,MAlBAmB,MAgBAsW,EAAA/C,MAAA8C,EAEAC,GACG,GAwBH,QAAAC,MACA,MAAAC,MAAAC,GAAAC,IAAAF,GAAAG,GAAAJ,MAAAK,IAGA,QAAAF,MACAF,GAAA,EAGA,QAAAK,MACA5kB,KAAA6kB,MACA7kB,KAAA8kB,MACA9kB,KAAA0D,MAAA,KA0BA,QAAAqhB,IAAAlS,EAAAmS,EAAAC,GACA,GAAAlT,GAAA,GAAA6S,GAEA,OADA7S,GAAAmT,QAAArS,EAAAmS,EAAAC,GACAlT,EAGA,QAAAoT,MACAb,OACAc,EAEA,KADA,GAAAnd,GAAA8J,EAAAsT,GACAtT,IACA9J,EAAAsc,GAAAxS,EAAA+S,QAAA,GAAA/S,EAAA8S,MAAAhkB,KAAA,KAAAoH,GACA8J,IAAArO,QAEA0hB,GAGA,QAAAE,MACAf,IAAAgB,GAAAb,GAAAJ,OAAAK,GACAS,GAAAI,GAAA,CACA,KACAL,KACG,QACHC,GAAA,EACAK,KACAlB,GAAA,GAIA,QAAAmB,MACA,GAAApB,GAAAI,GAAAJ,MAAAU,EAAAV,EAAAiB,EACAP,GAAAW,KAAAhB,IAAAK,EAAAO,GAAAjB,GAGA,QAAAmB,MAEA,IADA,GAAAhG,GAAAD,EAAAG,EAAA0F,GAAAJ,EAAAW,IACAjG,GACAA,EAAAkF,OACAI,EAAAtF,EAAAmF,QAAAG,EAAAtF,EAAAmF,OACArF,EAAAE,MAAAjc,QAEA8b,EAAAG,EAAAjc,MAAAic,EAAAjc,MAAA,KACAic,EAAAF,IAAA/b,MAAA8b,EAAA6F,GAAA7F,EAGAqG,IAAApG,EACAqG,GAAAb,GAGA,QAAAa,IAAAb,GACA,IAAAG,GAAA,CACAI,QAAAO,aAAAP,IACA,IAAAR,GAAAC,EAAAV,EACAS,GAAA,IACAC,EAAAW,MAAAJ,GAAAlf,WAAAgf,GAAAN,IACAgB,QAAAC,cAAAD,OAEAA,KAAAT,GAAAhB,GAAAyB,GAAAE,YAAAR,GAAAC,KACAP,GAAA,EAAAZ,GAAAc,MAwDA,QAAAa,IAAAhQ,EAAA2F,GACA,GAAArQ,GAAA0K,EAAAiQ,YACA,KAAA3a,SAAAqQ,KAAArQ,EAAAF,MAAA8a,GAAA,SAAAzkB,OAAA,WACA,OAAA6J,GAGA,QAAA6a,IAAAnQ,EAAA2F,GACA,GAAArQ,GAAA0K,EAAAiQ,YACA,KAAA3a,SAAAqQ,KAAArQ,EAAAF,MAAAgb,GAAA,SAAA3kB,OAAA,WACA,OAAA6J,GAGA,QAAA+a,IAAArQ,EAAA2F,GACA,GAAArQ,GAAA0K,EAAAiQ,YACA,KAAA3a,SAAAqQ,IAAA,SAAAla,OAAA,WACA,OAAA6J,GAGA,QAAAtJ,IAAAgU,EAAA2F,EAAA/R,GASA,QAAA0B,GAAAgb,GACA1c,EAAAwB,MAAAmb,GACA3c,EAAAgb,MAAAG,QAAAtY,EAAA7C,EAAAib,MAAAjb,EAAAkb,MAGAlb,EAAAib,OAAAyB,GAAA7Z,EAAA6Z,EAAA1c,EAAAib,OAGA,QAAApY,GAAA6Z,GACA,GAAAxgB,GAAAgP,EAAAjD,EAAAgD,CAGA,IAAAjL,EAAAwB,QAAAmb,GAAA,MAAA7Z,IAEA,KAAA5G,IAAA0gB,GAEA,GADA3R,EAAA2R,EAAA1gB,GACA+O,EAAAxC,OAAAzI,EAAAyI,KAAA,CAKA,GAAAwC,EAAAzJ,QAAAqb,GAAA,MAAAC,IAAAja,EAIAoI,GAAAzJ,QAAAub,IACA9R,EAAAzJ,MAAAwb,GACA/R,EAAA+P,MAAAlY,OACAmI,EAAAF,GAAAjU,KAAA,YAAAsV,IAAAzB,SAAAM,EAAApN,MAAAoN,EAAAd,aACAyS,GAAA1gB,KAMAA,EAAA6V,IACA9G,EAAAzJ,MAAAwb,GACA/R,EAAA+P,MAAAlY,aACA8Z,GAAA1gB,IAoBA,GAZA4gB,GAAA,WACA9c,EAAAwB,QAAAqb,KACA7c,EAAAwB,MAAAub,GACA/c,EAAAgb,MAAAG,QAAArV,EAAA9F,EAAAib,MAAAjb,EAAAkb,MACApV,EAAA4W,MAMA1c,EAAAwB,MAAAgb,GACAxc,EAAA+K,GAAAjU,KAAA,QAAAsV,IAAAzB,SAAA3K,EAAAnC,MAAAmC,EAAAmK,OACAnK,EAAAwB,QAAAgb,GAAA,CAKA,IAJAxc,EAAAwB,MAAAqb,GAGAI,EAAA,GAAAtb,OAAAsG,EAAAjI,EAAAid,MAAA3jB,QACA4C,EAAA,EAAAgP,GAAA,EAAuBhP,EAAA+L,IAAO/L,GAC9B+O,EAAAjL,EAAAid,MAAA/gB,GAAAjE,MAAAnB,KAAAsV,IAAAzB,SAAA3K,EAAAnC,MAAAmC,EAAAmK,UACA8S,IAAA/R,GAAAD,EAGAgS,GAAA3jB,OAAA4R,EAAA,GAGA,QAAApF,GAAA4W,GAKA,IAJA,GAAA1U,GAAA0U,EAAA1c,EAAAkd,SAAAld,EAAAmd,KAAArmB,KAAA,KAAA4lB,EAAA1c,EAAAkd,WAAAld,EAAAgb,MAAAG,QAAArY,GAAA9C,EAAAwB,MAAA4b,GAAA,GACAlhB,GAAA,EACA+L,EAAAgV,EAAA3jB,SAEA4C,EAAA+L,GACAgV,EAAA/gB,GAAApF,KAAA,KAAAkR,EAIAhI,GAAAwB,QAAA4b,KACApd,EAAA+K,GAAAjU,KAAA,MAAAsV,IAAAzB,SAAA3K,EAAAnC,MAAAmC,EAAAmK,OACArH,KAIA,QAAAA,KACA9C,EAAAwB,MAAAwb,GACAhd,EAAAgb,MAAAlY,aACA8Z,GAAA7K,EACA,QAAA7V,KAAA0gB,GAAA,aACAxQ,GAAAiQ,aApGA,GACAY,GADAL,EAAAxQ,EAAAiQ,YAKAO,GAAA7K,GAAA/R,EACAA,EAAAgb,SAAAtZ,EAAA,EAAA1B,EAAAkb,MA+HA,QAAAmC,IAAAtL,EAAAtJ,GACA,GAAA6U,GAAAC,CACA,mBACA,GAAAC,GAAAjB,GAAAtmB,KAAA8b,GACAkL,EAAAO,EAAAP,KAKA,IAAAA,IAAAK,EAAA,CACAC,EAAAD,EAAAL,CACA,QAAA/gB,GAAA,EAAA+L,EAAAsV,EAAAjkB,OAAwC4C,EAAA+L,IAAO/L,EAC/C,GAAAqhB,EAAArhB,GAAAuM,SAAA,CACA8U,IAAA9d,QACA8d,EAAA1e,OAAA3C,EAAA,EACA,QAKAshB,EAAAP,MAAAM,GAIA,QAAAE,IAAA1L,EAAAtJ,EAAAxQ,GACA,GAAAqlB,GAAAC,CACA,sBAAAtlB,GAAA,SAAAJ,MACA,mBACA,GAAA2lB,GAAAjB,GAAAtmB,KAAA8b,GACAkL,EAAAO,EAAAP,KAKA,IAAAA,IAAAK,EAAA,CACAC,GAAAD,EAAAL,GAAAxd,OACA,QAAAuI,IAAoBS,OAAAxQ,SAAyBiE,EAAA,EAAA+L,EAAAsV,EAAAjkB,OAA2B4C,EAAA+L,IAAO/L,EAC/E,GAAAqhB,EAAArhB,GAAAuM,SAAA,CACA8U,EAAArhB,GAAA8L,CACA,OAGA9L,IAAA+L,GAAAsV,EAAAlf,KAAA2J,GAGAwV,EAAAP,MAAAM,GAsBA,QAAAG,IAAA5W,EAAA2B,EAAAxQ,GACA,GAAA8Z,GAAAjL,EAAA6W,GAOA,OALA7W,GAAAU,KAAA,WACA,GAAAgW,GAAAjB,GAAAtmB,KAAA8b,IACAyL,EAAAvlB,QAAAulB,EAAAvlB,WAAiDwQ,GAAAxQ,EAAAgD,MAAAhF,KAAAoD,aAGjD,SAAA+S,GACA,MAAAqQ,IAAArQ,EAAA2F,GAAA9Z,MAAAwQ,IAYA,QAAAmV,IAAAnV,GACA,kBACAxS,KAAA+W,gBAAAvE,IAIA,QAAAoV,IAAAnU,GACA,kBACAzT,KAAAiX,kBAAAxD,EAAAC,MAAAD,EAAAE,QAIA,QAAAkU,IAAArV,EAAAsV,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAloB,KAAAiR,aAAAuB,EACA,OAAA0V,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAAI,IAAA1U,EAAAqU,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAloB,KAAAooB,eAAA3U,EAAAC,MAAAD,EAAAE,MACA,OAAAuU,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAAM,IAAA7V,EAAAsV,EAAA9lB,GACA,GAAAgmB,GACAM,EACAL,CACA,mBACA,GAAAC,GAAAH,EAAA/lB,EAAAhC,KACA,cAAA+nB,MAAA/nB,MAAA+W,gBAAAvE,IACA0V,EAAAloB,KAAAiR,aAAAuB,GACA0V,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAO,EAAAL,EACAA,EAAAH,EAAAE,EAAAE,EAAAI,EAAAP,KAIA,QAAAQ,IAAA9U,EAAAqU,EAAA9lB,GACA,GAAAgmB,GACAM,EACAL,CACA,mBACA,GAAAC,GAAAH,EAAA/lB,EAAAhC,KACA,cAAA+nB,MAAA/nB,MAAAiX,kBAAAxD,EAAAC,MAAAD,EAAAE,QACAuU,EAAAloB,KAAAooB,eAAA3U,EAAAC,MAAAD,EAAAE,OACAuU,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAO,EAAAL,EACAA,EAAAH,EAAAE,EAAAE,EAAAI,EAAAP,KAYA,QAAAS,IAAA/U,EAAAzR,GACA,QAAAglB,KACA,GAAA7Q,GAAAnW,KAAAiG,EAAAjE,EAAAgD,MAAAmR,EAAA/S,UACA,OAAA6C,IAAA,SAAA8L,GACAoE,EAAAkB,eAAA5D,EAAAC,MAAAD,EAAAE,MAAA1N,EAAA8L,KAIA,MADAiV,GAAAyB,OAAAzmB,EACAglB,EAGA,QAAA0B,IAAAlW,EAAAxQ,GACA,QAAAglB,KACA,GAAA7Q,GAAAnW,KAAAiG,EAAAjE,EAAAgD,MAAAmR,EAAA/S,UACA,OAAA6C,IAAA,SAAA8L,GACAoE,EAAAgB,aAAA3E,EAAAvM,EAAA8L,KAIA,MADAiV,GAAAyB,OAAAzmB,EACAglB,EAYA,QAAA2B,IAAA7M,EAAA9Z,GACA,kBACAmkB,GAAAnmB,KAAA8b,GAAAkJ,OAAAhjB,EAAAgD,MAAAhF,KAAAoD,YAIA,QAAAwlB,IAAA9M,EAAA9Z,GACA,MAAAA,MAAA,WACAmkB,GAAAnmB,KAAA8b,GAAAkJ,MAAAhjB,GAcA,QAAA6mB,IAAA/M,EAAA9Z,GACA,kBACAskB,GAAAtmB,KAAA8b,GAAAmL,UAAAjlB,EAAAgD,MAAAhF,KAAAoD,YAIA,QAAA0lB,IAAAhN,EAAA9Z,GACA,MAAAA,MAAA,WACAskB,GAAAtmB,KAAA8b,GAAAmL,SAAAjlB,GAcA,QAAA+mB,IAAAjN,EAAA9Z,GACA,qBAAAA,GAAA,SAAAJ,MACA,mBACA0kB,GAAAtmB,KAAA8b,GAAAoL,KAAAllB,GA4CA,QAAA4K,IAAA4F,GACA,OAAAA,EAAA,IAAAH,OAAAC,MAAA,SAAA0W,MAAA,SAAAjX,GACA,GAAA9L,GAAA8L,EAAApJ,QAAA,IAEA,OADA1C,IAAA,IAAA8L,IAAAvI,MAAA,EAAAvD,KACA8L,GAAA,UAAAA,IAIA,QAAAkX,IAAAnN,EAAAtJ,EAAAyB,GACA,GAAAiV,GAAAC,EAAAC,EAAAxc,GAAA4F,GAAA2T,GAAAG,EACA,mBACA,GAAAiB,GAAA6B,EAAAppB,KAAA8b,GACAhH,EAAAyS,EAAAzS,EAKAA,KAAAoU,IAAAC,GAAAD,EAAApU,GAAAvL,QAAAuL,GAAAtC,EAAAyB,GAEAsT,EAAAzS,GAAAqU,GAYA,QAAAE,IAAAvN,GACA,kBACA,GAAAlX,GAAA5E,KAAAkR,UACA,QAAAjL,KAAAjG,MAAAomB,aAAA,IAAAngB,IAAA6V,EAAA,MACAlX,MAAAwV,YAAApa,OAwDA,QAAAspB,IAAA9W,EAAAsV,GACA,GAAAE,GACAM,EACAL,CACA,mBACA,GAAAC,GAAAlQ,EAAAhY,KAAAwS,GACAuV,GAAA/nB,KAAA0X,MAAAC,eAAAnF,GAAAwF,EAAAhY,KAAAwS,GACA,OAAA0V,KAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAO,EAAAL,EACAA,EAAAH,EAAAE,EAAAE,EAAAI,EAAAP,IAIA,QAAAwB,IAAA/W,GACA,kBACAxS,KAAA0X,MAAAC,eAAAnF,IAIA,QAAAgX,IAAAhX,EAAAsV,EAAAC,GACA,GAAAC,GACAC,CACA,mBACA,GAAAC,GAAAlQ,EAAAhY,KAAAwS,EACA,OAAA0V,KAAAH,EAAA,KACAG,IAAAF,EAAAC,EACAA,EAAAH,EAAAE,EAAAE,EAAAH,IAIA,QAAA0B,IAAAjX,EAAAsV,EAAA9lB,GACA,GAAAgmB,GACAM,EACAL,CACA,mBACA,GAAAC,GAAAlQ,EAAAhY,KAAAwS,GACAuV,EAAA/lB,EAAAhC,KAEA,OADA,OAAA+nB,IAAA/nB,KAAA0X,MAAAC,eAAAnF,GAAAuV,EAAA/P,EAAAhY,KAAAwS,IACA0V,IAAAH,EAAA,KACAG,IAAAF,GAAAD,IAAAO,EAAAL,EACAA,EAAAH,EAAAE,EAAAE,EAAAI,EAAAP,IAcA,QAAA2B,IAAAlX,EAAAxQ,EAAA6V,GACA,QAAAmP,KACA,GAAA7Q,GAAAnW,KAAAiG,EAAAjE,EAAAgD,MAAAmR,EAAA/S,UACA,OAAA6C,IAAA,SAAA8L,GACAoE,EAAAuB,MAAAI,YAAAtF,EAAAvM,EAAA8L,GAAA8F,IAIA,MADAmP,GAAAyB,OAAAzmB,EACAglB,EAWA,QAAA2C,IAAA3nB,GACA,kBACAhC,KAAAqZ,YAAArX,GAIA,QAAA4nB,IAAA5nB,GACA,kBACA,GAAA+lB,GAAA/lB,EAAAhC,KACAA,MAAAqZ,YAAA,MAAA0O,EAAA,GAAAA,GAkCA,QAAA8B,IAAA7O,EAAAC,EAAAzI,EAAAsJ,GACA9b,KAAAkb,QAAAF,EACAhb,KAAAiE,SAAAgX,EACAjb,KAAA8pB,MAAAtX,EACAxS,KAAA0nB,IAAA5L,EAGA,QAAAjL,IAAA2B,GACA,MAAA/C,MAAAoB,WAAA2B,GAGA,QAAAuX,MACA,QAAAjO,GAgCA,QAAAkO,IAAAjY,GACA,OAAAA,EAGA,QAAAkY,IAAAlY,GACA,MAAAA,KAGA,QAAAmY,IAAAnY,GACA,MAAAA,IAAA,EAAAA,GAGA,QAAAoY,IAAApY,GACA,QAAAA,GAAA,MAAAA,SAAA,EAAAA,GAAA,KAGA,QAAAqY,IAAArY,GACA,MAAAA,OAGA,QAAAsY,IAAAtY,GACA,QAAAA,MAAA,EAGA,QAAAuY,IAAAvY,GACA,QAAAA,GAAA,MAAAA,UAAA,GAAAA,IAAA,KA4CA,QAAAwY,IAAAxY,GACA,SAAAhF,KAAAgS,IAAAhN,EAAAyY,IAGA,QAAAC,IAAA1Y,GACA,MAAAhF,MAAAiS,IAAAjN,EAAAyY,IAGA,QAAAE,IAAA3Y,GACA,SAAAhF,KAAAgS,IAAA4L,GAAA5Y,IAAA,EAGA,QAAA6Y,IAAA7Y,GACA,MAAAhF,MAAAM,IAAA,KAAA0E,EAAA,IAGA,QAAA8Y,IAAA9Y,GACA,SAAAhF,KAAAM,IAAA,MAAA0E,GAGA,QAAA+Y,IAAA/Y,GACA,QAAAA,GAAA,MAAAhF,KAAAM,IAAA,KAAA0E,EAAA,MAAAhF,KAAAM,IAAA,QAAA0E,IAAA,EAGA,QAAAgZ,IAAAhZ,GACA,SAAAhF,KAAAiT,KAAA,EAAAjO,KAGA,QAAAiZ,IAAAjZ,GACA,MAAAhF,MAAAiT,KAAA,KAAAjO,KAGA,QAAAkZ,IAAAlZ,GACA,QAAAA,GAAA,QAAAhF,KAAAiT,KAAA,EAAAjO,KAAAhF,KAAAiT,KAAA,GAAAjO,GAAA,GAAAA,GAAA,KAcA,QAAAmZ,IAAAnZ,GACA,SAAAoZ,GAAA,EAAApZ,GAGA,QAAAoZ,IAAApZ,GACA,OAAAA,MAAAqZ,GAAAC,GAAAtZ,MAAAuZ,GAAAD,IAAAtZ,GAAAwZ,IAAAxZ,EAAAyZ,GAAAzZ,EAAA0Z,GAAAJ,IAAAtZ,GAAA2Z,IAAA3Z,EAAA4Z,GAAAN,IAAAtZ,GAAA6Z,IAAA7Z,EAAA8Z,GAGA,QAAAC,IAAA/Z,GACA,QAAAA,GAAA,QAAAoZ,GAAA,EAAApZ,GAAAoZ,GAAApZ,EAAA,QA6FA,QAAAga,IAAA5V,EAAA2F,GAEA,IADA,GAAAkQ,KACAA,EAAA7V,EAAAiQ,iBAAA4F,IAAAlQ,KACA,KAAA3F,IAAAjF,YACA,MAAA+a,IAAAhH,KAAAX,KAAA2H,EAGA,OAAAD,GA0DA,QAAAE,MACAzsB,EAAA2U,MAAAgH,2BA2FA,QAAA3I,IAAAV,GACA,OAAUU,KAAAV,GAIV,QAAAoa,MACA,OAAA1sB,EAAA2U,MAAAgI,OAGA,QAAAgQ,MACA,GAAAC,GAAArsB,KAAAssB,iBAAAtsB,IACA,eAAAqsB,EAAAE,MAAAjK,QAAAtgB,MAAAqqB,EAAAG,OAAAlK,QAAAtgB,QAIA,QAAAyqB,IAAAtW,GACA,MAAAA,EAAAuW,SAAA,KAAAvW,IAAAjF,YAAA,MACA,OAAAiF,GAAAuW,QAGA,QAAAnpB,IAAAopB,GACA,MAAAA,GAAA,QAAAA,EAAA,OACAA,EAAA,QAAAA,EAAA,MAGA,QAAAC,IAAAzW,GACA,GAAA5K,GAAA4K,EAAAuW,OACA,OAAAnhB,KAAAshB,IAAAC,OAAAvhB,EAAAkE,WAAA,KAGA,QAAAsd,MACA,MAAAC,IAAAC,IAGA,QAAAC,MACA,MAAAF,IAAAG,IAOA,QAAAH,IAAAH,GAOA,QAAAO,GAAAlZ,GACA,GAAAmZ,GAAAnZ,EACAoZ,SAAA,UAAAC,GACA5d,UAAA,YACAC,MAAA6C,GAAA,YAEA4a,GAAAnd,QAAAC,OAAA,QACAC,KAAA,mBACAA,KAAA,wBACAA,KAAA,SAAAod,GAAAH,SACA7c,MAAA6c,GACA9b,KAAA,WACA,GAAAob,GAAAF,GAAAzsB,MAAA2sB,MACArc,IAAAtQ,MACAoQ,KAAA,IAAAuc,EAAA,OACAvc,KAAA,IAAAuc,EAAA,OACAvc,KAAA,QAAAuc,EAAA,MAAAA,EAAA,OACAvc,KAAA,SAAAuc,EAAA,MAAAA,EAAA,SAGAzY,EAAAvE,UAAA,cACAC,MAAA6C,GAAA,eACAvC,QAAAC,OAAA,QACAC,KAAA,qBACAA,KAAA,SAAAod,GAAA/d,WACAW,KAAA,eACAA,KAAA,mBACAA,KAAA,iBACAA,KAAA,+BAEA,IAAAqd,GAAAvZ,EAAAvE,UAAA,WACAC,KAAAid,EAAAa,QAAA,SAAArrB,GAAsC,MAAAA,GAAAoQ,MAEtCgb,GAAAzd,OAAAnI,SAEA4lB,EAAAvd,QAAAC,OAAA,QACAC,KAAA,iBAAA/N,GAAoC,wBAAAA,EAAAoQ,OACpCrC,KAAA,kBAAA/N,GAAqC,MAAAmrB,IAAAnrB,EAAAoQ,QAErCyB,EACA3C,KAAAoc,GACAvd,KAAA,eACAA,KAAA,wBACAsH,MAAA,+CACA5C,GAAA,mCAAA8Y,GAyCA,QAAAD,KACA,GAAAzZ,GAAA5D,GAAAtQ,MACAyP,EAAAgd,GAAAzsB,MAAAyP,SAEAA,IACAyE,EAAAvE,UAAA,cACA+H,MAAA,gBACAtH,KAAA,IAAAX,EAAA,OACAW,KAAA,IAAAX,EAAA,OACAW,KAAA,QAAAX,EAAA,MAAAA,EAAA,OACAW,KAAA,SAAAX,EAAA,MAAAA,EAAA,OAEAyE,EAAAvE,UAAA,WACA+H,MAAA,gBACAtH,KAAA,aAAA/N,GAAkC,YAAAA,EAAAoQ,KAAApQ,EAAAoQ,KAAApP,OAAA,GAAAoM,EAAA,MAAAoe,EAAA,EAAApe,EAAA,MAAAoe,EAAA,IAClCzd,KAAA,aAAA/N,GAAkC,YAAAA,EAAAoQ,KAAA,GAAAhD,EAAA,MAAAoe,EAAA,EAAApe,EAAA,MAAAoe,EAAA,IAClCzd,KAAA,iBAAA/N,GAAsC,YAAAA,EAAAoQ,MAAA,MAAApQ,EAAAoQ,KAAAhD,EAAA,MAAAA,EAAA,MAAAoe,MACtCzd,KAAA,kBAAA/N,GAAuC,YAAAA,EAAAoQ,MAAA,MAAApQ,EAAAoQ,KAAAhD,EAAA,MAAAA,EAAA,MAAAoe,OAIvC3Z,EAAAvE,UAAA,sBACA+H,MAAA,kBACAtH,KAAA,UACAA,KAAA,UACAA,KAAA,cACAA,KAAA,eAIA,QAAA0d,GAAApY,EAAAC,GACA,MAAAD,GAAAgX,QAAAoB,SAAA,GAAAC,GAAArY,EAAAC,GAGA,QAAAoY,GAAArY,EAAAC,GACA3V,KAAA0V,OACA1V,KAAA2V,OACA3V,KAAAuL,MAAAmK,EAAAgX,QACA1sB,KAAA+b,OAAA,EAyBA,QAAA6R,KAqEA,QAAAI,KACA,GAAAC,GAAAC,GAAAxY,IACAyY,GAAAC,GAAAC,IACAthB,KAAAY,IAAAsgB,EAAA,GAAAK,EAAA,IAAAvhB,KAAAY,IAAAsgB,EAAA,GAAAK,EAAA,IAAAD,GAAA,EACAD,GAAA,GAEAE,EAAAL,EACAM,GAAA,EACAC,KACAC,IAGA,QAAAA,KACA,GAAA1c,EAKA,QAHAiK,EAAAsS,EAAA,GAAAI,EAAA,GACAzS,EAAAqS,EAAA,GAAAI,EAAA,GAEAC,GACA,IAAAC,IACA,IAAAC,IACAC,IAAA9S,EAAAjP,KAAAC,IAAA+hB,EAAAC,EAAAjiB,KAAAuR,IAAAkC,EAAAyO,EAAAjT,IAAAkT,EAAAF,EAAAhT,EAAAmT,EAAAF,EAAAjT,GACAoT,IAAAnT,EAAAlP,KAAAC,IAAAqiB,EAAAC,EAAAviB,KAAAuR,IAAAiR,EAAAC,EAAAvT,IAAAwT,EAAAH,EAAArT,EAAAyT,EAAAF,EAAAvT,EACA,MAEA,KAAA0T,IACAb,EAAA,GAAA9S,EAAAjP,KAAAC,IAAA+hB,EAAAC,EAAAjiB,KAAAuR,IAAAkC,EAAAwO,EAAAhT,IAAAkT,EAAAF,EAAAhT,EAAAmT,EAAAF,GACAH,EAAA,IAAA9S,EAAAjP,KAAAC,IAAA+hB,EAAAE,EAAAliB,KAAAuR,IAAAkC,EAAAyO,EAAAjT,IAAAkT,EAAAF,EAAAG,EAAAF,EAAAjT,GACAoT,EAAA,GAAAnT,EAAAlP,KAAAC,IAAAqiB,EAAAC,EAAAviB,KAAAuR,IAAAiR,EAAAD,EAAArT,IAAAwT,EAAAH,EAAArT,EAAAyT,EAAAF,GACAJ,EAAA,IAAAnT,EAAAlP,KAAAC,IAAAqiB,EAAAG,EAAAziB,KAAAuR,IAAAiR,EAAAC,EAAAvT,IAAAwT,EAAAH,EAAAI,EAAAF,EAAAvT,EACA,MAEA,KAAA2T,IACAd,IAAAI,EAAAniB,KAAAC,IAAA+hB,EAAAhiB,KAAAuR,IAAAkC,EAAAwO,EAAAhT,EAAA8S,IAAAK,EAAApiB,KAAAC,IAAA+hB,EAAAhiB,KAAAuR,IAAAkC,EAAAyO,EAAAjT,EAAA8S,KACAM,IAAAK,EAAA1iB,KAAAC,IAAAqiB,EAAAtiB,KAAAuR,IAAAiR,EAAAD,EAAArT,EAAAmT,IAAAM,EAAA3iB,KAAAC,IAAAqiB,EAAAtiB,KAAAuR,IAAAiR,EAAAC,EAAAvT,EAAAmT,KAKAD,EAAAD,IACAJ,IAAA,EACA/c,EAAAid,IAAAC,IAAAld,EACAA,EAAAmd,IAAAC,IAAApd,EACAU,IAAAod,KAAAxC,EAAAjd,KAAA,SAAAod,GAAA/a,EAAAod,GAAApd,MAGAid,EAAAD,IACAL,IAAA,EACArd,EAAAud,IAAAE,IAAAzd,EACAA,EAAA0d,IAAAC,IAAA3d,EACAU,IAAAqd,KAAAzC,EAAAjd,KAAA,SAAAod,GAAA/a,EAAAqd,GAAArd,MAGAlH,EAAAkE,cAAAlE,EAAAkE,WACA2e,IAAAc,EAAAzf,EAAA,MAAA0f,EAAA1f,EAAA,OACA4e,IAAAoB,EAAAhgB,EAAA,MAAAigB,EAAAjgB,EAAA,OAEAA,EAAA,QAAAyf,GACAzf,EAAA,QAAAggB,GACAhgB,EAAA,QAAA0f,GACA1f,EAAA,QAAAigB,IACAnkB,EAAAkE,YAAAyf,EAAAO,IAAAN,EAAAO,IACA/B,EAAA9sB,KAAA6U,GACAqa,EAAA3C,SAIA,QAAA4C,KAEA,GADA9D,KACAzsB,EAAA2U,MAAA6b,QAAA,CACA,GAAAxwB,EAAA2U,MAAA6b,QAAA5sB,OAAA,MACA6sB,IAAAnK,aAAAmK,GACAA,EAAA5pB,WAAA,WAA6C4pB,EAAA,MAAsB,KACnEhc,EAAAY,GAAA,6DAEAuG,IAAA5b,EAAA2U,MAAAkH,KAAAiT,GACAjT,EAAAxG,GAAA,+DAEAZ,GAAA9D,KAAA,wBACAid,EAAAjd,KAAA,SAAAod,GAAAH,SACA9hB,EAAAkE,cAAAlE,EAAAkE,WACAlM,GAAAkM,KAAAlE,EAAAkE,UAAA,KAAAke,EAAA9sB,KAAA6U,IACAqa,EAAA/L,MAGA,QAAAmM,KACA,OAAA1wB,EAAA2U,MAAAgc,SACA,QACAjC,EAAAW,GAAAM,CACA,MAEA,SACAT,IAAAgB,KACAb,IAAAG,EAAAE,EAAAnT,EAAA8S,EAAAE,EAAAE,EAAAlT,EAAA8S,GACAM,IAAAI,EAAAE,EAAAzT,EAAAmT,EAAAE,EAAAG,EAAAxT,EAAAmT,GACAT,EAAAiB,GACAnB,IAEA,MAEA,SACAE,IAAAgB,IAAAhB,IAAAiB,KACAd,EAAA,EAAAG,EAAAE,EAAAnT,EAAwC8S,EAAA,IAAAE,EAAAE,EAAAlT,GACxCoT,EAAA,EAAAI,EAAAE,EAAAzT,EAAwCmT,EAAA,IAAAE,EAAAG,EAAAxT,GACxC0S,EAAAC,GACAvB,EAAAjd,KAAA,SAAAod,GAAA/d,WACAgf,IAEA,MAEA,gBAEAD,KAGA,QAAA6B,KACA,OAAA5wB,EAAA2U,MAAAgc,SACA,QACAjC,IACAC,EAAAC,EAAAF,GAAA,EACAM,IAEA,MAEA,SACAE,IAAAiB,KACAd,EAAA,EAAAG,EAAAE,EAAmCL,EAAA,IAAAE,EAAAE,GACnCE,EAAA,EAAAI,EAAAE,EAAmCN,EAAA,IAAAE,EAAAG,GACnCd,EAAAgB,GACAlB,IAEA,MAEA,SACAE,IAAAC,KACAnvB,EAAA2U,MAAAkc,QACAxB,IAAAG,EAAAE,EAAAnT,EAAA8S,EAAAE,EAAAE,EAAAlT,EAAA8S,GACAM,IAAAI,EAAAE,EAAAzT,EAAAmT,EAAAE,EAAAG,EAAAxT,EAAAmT,GACAT,EAAAiB,KAEAd,EAAA,EAAAG,EAAAE,EAAqCL,EAAA,IAAAE,EAAAE,GACrCE,EAAA,EAAAI,EAAAE,EAAqCN,EAAA,IAAAE,EAAAG,GACrCd,EAAAgB,IAEAtC,EAAAjd,KAAA,SAAAod,GAAA/a,IACAgc,IAEA,MAEA,gBAEAD,KA3NA,GAAA/uB,EAAA2U,MAAA6b,SAAgC,GAAAxwB,EAAA2U,MAAAmc,eAAAltB,OAAA5D,EAAA2U,MAAA6b,QAAA5sB,OAAA,MAAAmrB,UAChC,IAAA0B,EAAA,MACA,IAAA5e,EAAAtM,MAAAhF,KAAAoD,WAAA,CAEA,GAQA4rB,GAAAE,EACAI,EAAAG,EACAR,EAAAE,EACAK,EAAAE,EACA1T,EACAC,EACAsS,EAEAH,EACAC,EAjBA3Y,EAAA1V,KACAyS,EAAAhT,EAAA2U,MAAAyH,OAAAnH,SAAAjC,KACAkc,EAAA,eAAAlvB,EAAA2U,MAAAoc,QAAA/d,EAAA,UAAAA,GAAAoc,GAAApvB,EAAA2U,MAAAkc,OAAAV,GAAAD,GACAb,EAAAjC,IAAAM,GAAA,KAAAsD,GAAAhe,GACA2c,EAAAvC,IAAAI,GAAA,KAAAyD,GAAAje,GACAlH,EAAAkhB,GAAA/W,GACAiX,EAAAphB,EAAAohB,OACAld,EAAAlE,EAAAkE,UACAsf,EAAApC,EAAA,MACA0C,EAAA1C,EAAA,MACAnM,EAAAmM,EAAA,MACA4C,EAAA5C,EAAA,MAIAwB,EAAAW,GAAAM,GAAA3vB,EAAA2U,MAAAuc,SAGAjC,EAAAR,GAAAxY,GACA4Y,EAAAI,EACAqB,EAAAjC,EAAApY,EAAAtS,WAAAwtB,aAEA,aAAAne,EACAlH,EAAAkE,cACAuf,EAAAnC,IAAAM,GAAA4B,EAAAL,EAAA,GAAAY,EAAAzC,IAAAI,GAAAoC,EAAAX,EAAA,KACAO,EAAApC,IAAAM,GAAA3M,EAAAwO,EAAAQ,EAAA3C,IAAAI,GAAAsC,EAAAD,KAGAN,EAAAvf,EAAA,MACA6f,EAAA7f,EAAA,MACAwf,EAAAxf,EAAA,MACA+f,EAAA/f,EAAA,OAGAyf,EAAAF,EACAS,EAAAH,EACAH,EAAAF,EACAS,EAAAF,CAEA,IAAAtb,GAAA5D,GAAAoF,GACAtF,KAAA,yBAEAid,EAAAnZ,EAAAvE,UAAA,YACAS,KAAA,SAAAod,GAAA/a,GAEA,IAAAhT,EAAA2U,MAAA6b,QACA/b,EACAY,GAAA,kBAAAkZ,GAAA,GACAlZ,GAAA,mCAAAkb,GAAA,OACK,CACL,GAAA1U,GAAAhL,GAAA7Q,EAAA2U,MAAAkH,MACAxG,GAAA,gBAAAqb,GAAA,GACArb,GAAA,cAAAub,GAAA,GACAvb,GAAA,kBAAAkZ,GAAA,GACAlZ,GAAA,gBAAAkb,GAAA,EAEAa,IAAApxB,EAAA2U,MAAAkH,MAGA4Q,KACA4E,GAAApb,GACAiY,EAAA9sB,KAAA6U,GACAqa,EAAAnjB,SA6JA,QAAA2gB,KACA,GAAAhiB,GAAAvL,KAAA0sB,UAAiCjd,UAAA,KAGjC,OAFAlE,GAAAohB,SAAA3nB,MAAAhF,KAAAoD,WACAmI,EAAAshB,MACAthB,EA9XA,GAIA2kB,GAJAvD,EAAAP,GACA9a,EAAA6a,GACA4E,EAAAzlB,EAAA8hB,EAAA,uBACAS,EAAA,CA+YA,OA7VAT,GAAAqB,KAAA,SAAAva,EAAAzE,GACAyE,EAAAzE,UACAyE,EACAY,GAAA,yBAAyCgZ,EAAA9tB,KAAAoD,WAAAwtB,cAAAhkB,UACzCkI,GAAA,uCAAuDgZ,EAAA9tB,KAAAoD,WAAA4gB,QACvDgD,MAAA,mBAQA,QAAAA,GAAAjV,GACAxG,EAAAkE,UAAA,IAAAsC,GAAAxO,GAAAytB,GAAA,KAAA/qB,EAAA8L,GACA4b,EAAA9sB,KAAA6U,GACAqa,EAAA3C,QAVA,GAAA1X,GAAA1V,KACAuL,EAAAmK,EAAAgX,QACAqD,EAAAjC,EAAApY,EAAAtS,WACA6tB,EAAA1lB,EAAAkE,UACAuhB,EAAAnE,EAAAqE,MAAA,kBAAAzhB,KAAAzK,MAAAhF,KAAAoD,WAAAqM,EAAAlE,EAAAohB,QACA1mB,EAAAkrB,GAAAF,EAAAD,EAQA,OAAAC,IAAAD,EAAAhK,IAAA,KAGA9S,EACA3C,KAAA,WACA,GAAAmE,GAAA1V,KACA2V,EAAAvS,UACAmI,EAAAmK,EAAAgX,QACAsE,EAAAnE,EAAAqE,MAAA,kBAAAzhB,KAAAzK,MAAA0Q,EAAAC,GAAAlG,EAAAlE,EAAAohB,QACAoD,EAAAjC,EAAApY,EAAAC,GAAAib,aAEAE,IAAApb,GACAnK,EAAAkE,UAAA,MAAAuhB,GAAAztB,GAAAytB,GAAA,KAAAA,EACArD,EAAA9sB,KAAA6U,GACAqa,EAAAnjB,QAAAwgB,QAAApJ,SA8CA+J,EAAA5tB,WACAywB,YAAA,WAEA,MADA,MAAA5wB,KAAA+b,SAAA/b,KAAAuL,MAAAuiB,QAAA9tB,UAAAoxB,UAAA,GACApxB,MAEA4M,MAAA,WAEA,MADA5M,MAAAoxB,WAAApxB,KAAAoxB,UAAA,EAAApxB,KAAA+vB,KAAA,UACA/vB,MAEAotB,MAAA,WAEA,MADAptB,MAAA+vB,KAAA,SACA/vB,MAEAgkB,IAAA,WAEA,MADA,MAAAhkB,KAAA+b,eAAA/b,MAAAuL,MAAAuiB,QAAA9tB,KAAA+vB,KAAA,QACA/vB,MAEA+vB,KAAA,SAAAtd,GACAgD,EAAA,GAAA4b,IAAAjE,EAAA3a,EAAAoa,EAAAC,OAAA9sB,KAAAuL,MAAAkE,YAAAshB,EAAA/rB,MAAA+rB,GAAAte,EAAAzS,KAAA0V,KAAA1V,KAAA2V,SA2OAyX,EAAAT,OAAA,SAAAnb,GACA,MAAApO,WAAAC,QAAAspB,EAAA,kBAAAnb,KAAA8f,MAAA9f,EAAA,OAAAA,EAAA,SAAAA,EAAA,OAAAA,EAAA,SAAA4b,GAAAT,GAGAS,EAAA9b,OAAA,SAAAE,GACA,MAAApO,WAAAC,QAAAiO,EAAA,kBAAAE,KAAA8f,KAAA9f,GAAA4b,GAAA9b,GAGA8b,EAAAS,WAAA,SAAArc,GACA,MAAApO,WAAAC,QAAAwqB,GAAArc,EAAA4b,GAAAS,GAGAT,EAAAtY,GAAA,WACA,GAAA9S,GAAA+uB,EAAAjc,GAAA9P,MAAA+rB,EAAA3tB,UACA,OAAApB,KAAA+uB,EAAA3D,EAAAprB,GAGAorB,EAUA,QAAAmE,IAAAC,GACA,gBAAA9kB,EAAApK,GACA,MAAAkvB,GACA9kB,EAAAnM,OAAAyB,MAAA0K,EAAAmP,OAAA7Z,MACAM,EAAA/B,OAAAyB,MAAAM,EAAAuZ,OAAA7Z,QAgIA,QAAAyvB,MACAzxB,KAAA0xB,IAAA1xB,KAAA2xB,IACA3xB,KAAA4xB,IAAA5xB,KAAA6xB,IAAA,KACA7xB,KAAAwR,EAAA,GAGA,QAAA9B,MACA,UAAA+hB,IAqHA,QAAAK,IAAAzvB,GACA,MAAAA,GAAA9B,OAGA,QAAAwxB,IAAA1vB,GACA,MAAAA,GAAAwZ,OAGA,QAAAmW,IAAA3vB,GACA,MAAAA,GAAA4vB,OAGA,QAAAC,IAAA7vB,GACA,MAAAA,GAAA8vB,WAGA,QAAAC,IAAA/vB,GACA,MAAAA,GAAAgwB,SAoEA,QAAAC,OAkDA,QAAAC,IAAAC,EAAAjmB,GACA,GAAAgG,GAAA,GAAA+f,GAGA,IAAAE,YAAAF,IAAAE,EAAAjhB,KAAA,SAAAvP,EAAAuU,GAA+DhE,EAAAK,IAAA2D,EAAAvU,SAG/D,IAAA0J,MAAAxD,QAAAsqB,GAAA,CACA,GAEAxd,GAFA/O,GAAA,EACA+L,EAAAwgB,EAAAnvB,MAGA,UAAAkJ,EAAA,OAAAtG,EAAA+L,GAAAO,EAAAK,IAAA3M,EAAAusB,EAAAvsB,QACA,QAAAA,EAAA+L,GAAAO,EAAAK,IAAArG,EAAAyI,EAAAwd,EAAAvsB,KAAAusB,GAAAxd,OAIA,IAAAwd,EAAA,OAAAjc,KAAAic,GAAAjgB,EAAAK,IAAA2D,EAAAic,EAAAjc,GAEA,OAAAhE,GA2DA,QAAAkgB,MACA,SAGA,QAAAC,IAAAF,EAAAjc,EAAAvU,GACAwwB,EAAAjc,GAAAvU,EAGA,QAAA2wB,MACA,MAAAJ,MAGA,QAAAK,IAAArgB,EAAAgE,EAAAvU,GACAuQ,EAAAK,IAAA2D,EAAAvU,GAGA,QAAA6wB,OAoBA,QAAAC,IAAAN,EAAAjmB,GACA,GAAAqG,GAAA,GAAAigB,GAGA,IAAAL,YAAAK,IAAAL,EAAAjhB,KAAA,SAAAvP,GAA0D4Q,EAAA9R,IAAAkB,SAG1D,IAAAwwB,EAAA,CACA,GAAAvsB,IAAA,EAAA+L,EAAAwgB,EAAAnvB,MACA,UAAAkJ,EAAA,OAAAtG,EAAA+L,GAAAY,EAAA9R,IAAA0xB,EAAAvsB,QACA,QAAAA,EAAA+L,GAAAY,EAAA9R,IAAAyL,EAAAimB,EAAAvsB,KAAAusB,IAGA,MAAA5f,GAqBA,QAAAmgB,IAAAC,GACA,UAAAC,UAAA,eAAoCD,EAAAzgB,IAAA,SAAAC,EAAAvM,GACpC,MAAAitB,MAAAC,UAAA3gB,GAAA,OAAAvM,EAAA,MACGwd,KAAA,UAGH,QAAA2P,IAAAJ,EAAAzmB,GACA,GAAAimB,GAAAO,GAAAC,EACA,iBAAAK,EAAAptB,GACA,MAAAsG,GAAAimB,EAAAa,GAAAptB,EAAA+sB,IAKA,QAAAM,IAAAC,GACA,GAAAC,GAAA7wB,OAAAR,OAAA,MACA6wB,IAUA,OARAO,GAAAnyB,QAAA,SAAAiyB,GACA,OAAAI,KAAAJ,GACAI,IAAAD,IACAR,EAAA5qB,KAAAorB,EAAAC,QAKAT,EAgLA,QAAAlyB,IAAA4yB,EAAA/nB,EAAAoC,EAAA1L,GACA,GAAAgf,MAAA1V,IAAA0V,MAAAtT,GAAA,MAAA2lB,EAEA,IAAA9uB,GAOA+uB,EACAC,EACAC,EACAC,EACA1iB,EACAR,EACA3K,EACAgP,EAbAkB,EAAAud,EAAAxpB,MACA6pB,GAAcnkB,KAAAvN,GACd2xB,EAAAN,EAAAhC,IACAuC,EAAAP,EAAA/B,IACAuC,EAAAR,EAAA9B,IACAuC,EAAAT,EAAA7B,GAWA,KAAA1b,EAAA,MAAAud,GAAAxpB,MAAA6pB,EAAAL,CAGA,MAAAvd,EAAA9S,QAGA,IAFA+N,EAAAzF,IAAAgoB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAmDO,EAAAP,GACnD/iB,EAAA7C,IAAA6lB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAoDO,EAAAP,EACpDhvB,EAAAuR,QAAAlQ,EAAA2K,GAAA,EAAAQ,IAAA,MAAAxM,GAAAqB,GAAA8tB,EAAAL,CAMA,IAFAG,GAAAH,EAAAU,GAAAvzB,KAAA,KAAAsV,EAAAvG,MACAkkB,GAAAJ,EAAAW,GAAAxzB,KAAA,KAAAsV,EAAAvG,MACAjE,IAAAkoB,GAAA9lB,IAAA+lB,EAAA,MAAAC,GAAA1yB,KAAA8U,EAAAvR,IAAAqB,GAAA8tB,EAAAL,EAAAxpB,MAAA6pB,EAAAL,CAGA,IACA9uB,MAAAqB,GAAA,GAAAyF,OAAA,GAAAgoB,EAAAxpB,MAAA,GAAAwB,OAAA,IACA0F,EAAAzF,IAAAgoB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAmDO,EAAAP,GACnD/iB,EAAA7C,IAAA6lB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAoDO,EAAAP,SACjD3tB,EAAA2K,GAAA,EAAAQ,KAAA6D,GAAA6e,GAAAF,IAAA,EAAAC,GAAAF,GACH,OAAA/uB,GAAAqQ,GAAAkB,EAAAvR,EAAAqB,GAAA8tB,EAAAL,EAGA,QAAAY,IAAA1kB,GACA,GAAAvN,GAAA4D,EACA0F,EACAoC,EAFAiE,EAAApC,EAAAvM,OAGAkxB,EAAA,GAAA7oB,OAAAsG,GACAwiB,EAAA,GAAA9oB,OAAAsG,GACAgiB,EAAApO,IACAqO,EAAArO,IACAsO,GAAAtO,IACAuO,GAAAvO,GAGA,KAAA3f,EAAA,EAAaA,EAAA+L,IAAO/L,EACpBob,MAAA1V,GAAA3L,KAAAo0B,GAAAvzB,KAAA,KAAAwB,EAAAuN,EAAA3J,MAAAob,MAAAtT,GAAA/N,KAAAq0B,GAAAxzB,KAAA,KAAAwB,MACAkyB,EAAAtuB,GAAA0F,EACA6oB,EAAAvuB,GAAA8H,EACApC,EAAAqoB,MAAAroB,GACAA,EAAAuoB,MAAAvoB,GACAoC,EAAAkmB,MAAAlmB,GACAA,EAAAomB,MAAApmB,GAWA,KAPAmmB,EAAAF,MAAAh0B,KAAA0xB,IAAAwC,EAAAl0B,KAAA4xB,KACAuC,EAAAF,MAAAj0B,KAAA2xB,IAAAwC,EAAAn0B,KAAA6xB,KAGA7xB,KAAAy0B,MAAAT,EAAAC,GAAAQ,MAAAP,EAAAC,GAGAluB,EAAA,EAAaA,EAAA+L,IAAO/L,EACpBnF,GAAAd,KAAAu0B,EAAAtuB,GAAAuuB,EAAAvuB,GAAA2J,EAAA3J,GAGA,OAAAjG,MAmNA,QAAA00B,IAAA9kB,GACA,OAAA3J,GAAA,EAAA+L,EAAApC,EAAAvM,OAAkC4C,EAAA+L,IAAO/L,EAAAjG,KAAA6H,OAAA+H,EAAA3J,GACzC,OAAAjG,MAkDA,QAAA20B,IAAAtyB,GACA,MAAAA,GAAA,GAOA,QAAAuyB,IAAAvyB,GACA,MAAAA,GAAA,GAOA,QAAAwyB,IAAAC,EAAAnpB,EAAAoC,GACA,GAAA2lB,GAAA,GAAAqB,IAAA,MAAAppB,EAAAgpB,GAAAhpB,EAAA,MAAAoC,EAAA6mB,GAAA7mB,EAAA8I,gBACA,cAAAie,EAAApB,IAAAY,OAAAQ,GAGA,QAAAC,IAAAppB,EAAAoC,EAAAimB,EAAAC,EAAAC,EAAAC,GACAn0B,KAAAo0B,GAAAzoB,EACA3L,KAAAq0B,GAAAtmB,EACA/N,KAAA0xB,IAAAsC,EACAh0B,KAAA2xB,IAAAsC,EACAj0B,KAAA4xB,IAAAsC,EACAl0B,KAAA6xB,IAAAsC,EACAn0B,KAAAkK,UAAA8qB,GAGA,QAAAC,IAAAlB,GAEA,IADA,GAAAxqB,IAAcqG,KAAAmkB,EAAAnkB,MAAgBvO,EAAAkI,EAC9BwqB,IAAA1yB,gBAA+CuO,KAAAmkB,EAAAnkB,KAC/C,OAAArG,GA2CA,QAAAoC,IAAAtJ,GACA,MAAAA,GAAAsJ,EAAAtJ,EAAA6yB,GAGA,QAAAnnB,IAAA1L,GACA,MAAAA,GAAA0L,EAAA1L,EAAA8yB,GA0FA,QAAAvtB,IAAAvF,GACA,MAAAA,GAAAuF,MAGA,QAAAwtB,IAAAC,EAAAC,GACA,GAAAnf,GAAAkf,EAAA3iB,IAAA4iB,EACA,KAAAnf,EAAA,SAAAvU,OAAA,YAAA0zB,EACA,OAAAnf,GA0GA,QAAAof,IAAAlzB,GACA,MAAAA,GAAAsJ,EAGA,QAAA6pB,IAAAnzB,GACA,MAAAA,GAAA0L,EA+aA,QAAA0nB,IAAAC,GACA,UAAAC,IAAAD,GAKA,QAAAC,IAAAD,GACA,KAAAE,EAAAC,GAAA/Y,KAAA4Y,IAAA,SAAA9zB,OAAA,mBAAA8zB,EAEA,IAAAE,GACAE,EAAAF,EAAA,QACAG,EAAAH,EAAA,QACAI,EAAAJ,EAAA,QACAK,EAAAL,EAAA,OACAhU,IAAAgU,EAAA,GACArJ,EAAAqJ,EAAA,KAAAA,EAAA,GACAM,IAAAN,EAAA,GACAO,EAAAP,EAAA,KAAAA,EAAA,GAAApsB,MAAA,GACAiJ,EAAAmjB,EAAA,MAGA,OAAAnjB,GAAAyjB,GAAA,EAAAzjB,EAAA,KAGA2jB,GAAA3jB,OAAA,KAGAmP,GAAA,MAAAkU,GAAA,MAAAC,KAAAnU,GAAA,EAAAkU,EAAA,IAAAC,EAAA,KAEA/1B,KAAA81B,OACA91B,KAAA+1B,QACA/1B,KAAAg2B,OACAh2B,KAAAi2B,SACAj2B,KAAA4hB,OACA5hB,KAAAusB,QACAvsB,KAAAk2B,QACAl2B,KAAAm2B,YACAn2B,KAAAyS,OAuJA,QAAA4jB,IAAA5Z,GAIA,MAHA6Z,IAAAC,GAAA9Z,GACAhd,EAAAsP,OAAAunB,GAAAvnB,OACAtP,EAAA+2B,aAAAF,GAAAE,aACAF,GA2BA,QAAAG,MACAz2B,KAAA02B,QAsBA,QAAAC,IAAAC,EAAAlqB,EAAApK,GACA,GAAAqJ,GAAAirB,EAAA1Y,EAAAxR,EAAApK,EACAu0B,EAAAlrB,EAAAe,EACAoqB,EAAAnrB,EAAAkrB,CACAD,GAAA7kB,EAAArF,EAAAoqB,GAAAx0B,EAAAu0B,GA2BA,QAAAE,IAAAprB,GACA,MAAAA,GAAA,IAAAA,GAAA,EAAAqrB,GAAAjqB,KAAAgqB,KAAAprB,GAGA,QAAAsrB,IAAAtrB,GACA,MAAAA,GAAA,EAAAurB,GAAAvrB,GAAA,GAAAurB,GAAAnqB,KAAAkqB,KAAAtrB,GAGA,QAAAwrB,IAAAxrB,GACA,OAAAA,EAAAyrB,GAAAzrB,EAAA,IAAAA,EAGA,QAAA0rB,OAEA,QAAAC,IAAAC,EAAAC,GACAD,GAAAE,GAAA/0B,eAAA60B,EAAA9kB,OACAglB,GAAAF,EAAA9kB,MAAA8kB,EAAAC,GA8CA,QAAAE,IAAAC,EAAAH,EAAA3zB,GACA,GAAA+zB,GAAA3xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,OAAAQ,CAEA,KADA2zB,EAAAK,cACA5xB,EAAA+L,GAAA4lB,EAAAD,EAAA1xB,GAAAuxB,EAAAlJ,MAAAsJ,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAJ,GAAAM,UAGA,QAAAC,IAAAJ,EAAAH,GACA,GAAAvxB,IAAA,EAAA+L,EAAA2lB,EAAAt0B,MAEA,KADAm0B,EAAAQ,iBACA/xB,EAAA+L,GAAA0lB,GAAAC,EAAA1xB,GAAAuxB,EAAA,EACAA,GAAAS,aAuCA,QAAAC,MACAC,GAAA7J,MAAA8J,GAGA,QAAAC,MACAC,GAAAC,GAAAC,IAGA,QAAAJ,IAAAK,EAAAC,GACAP,GAAA7J,MAAAgK,GACAC,GAAAE,EAAAD,GAAAE,EACAD,GAAAE,GAAAD,GAAAC,GACAC,GAAAH,EAAAI,GAAAC,GAAAJ,IAAA,EAAAK,IAAAC,GAAA5B,GAAAsB,GAGA,QAAAJ,IAAAG,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,GACAD,IAAA,EAAAK,EAKA,IAAAE,GAAAR,EAAAG,GACAM,EAAAD,GAAA,OACAE,EAAAD,EAAAD,EACAG,EAAAN,GAAAJ,GACAW,EAAAjC,GAAAsB,GACAhoB,EAAAsoB,GAAAK,EACAC,EAAAT,GAAAO,EAAA1oB,EAAAooB,GAAAK,GACA5hB,EAAA7G,EAAAwoB,EAAA9B,GAAA+B,EACAI,IAAAz4B,IAAAgf,GAAAvI,EAAA+hB,IAGAV,GAAAH,EAAAI,GAAAO,EAAAJ,GAAAK,EASA,QAAAG,IAAAC,GACA,OAAA3Z,GAAA2Z,EAAA,GAAAA,EAAA,IAAAxC,GAAAwC,EAAA,KAGA,QAAAA,IAAAD,GACA,GAAAf,GAAAe,EAAA,GAAAd,EAAAc,EAAA,GAAAJ,EAAAN,GAAAJ,EACA,QAAAU,EAAAN,GAAAL,GAAAW,EAAAhC,GAAAqB,GAAArB,GAAAsB,IAGA,QAAAgB,IAAAhtB,EAAApK,GACA,MAAAoK,GAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAGA,QAAAq3B,IAAAjtB,EAAApK,GACA,OAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,IAIA,QAAAs3B,IAAAltB,EAAApK,GACAoK,EAAA,IAAApK,EAAA,GAAAoK,EAAA,IAAApK,EAAA,GAAAoK,EAAA,IAAApK,EAAA,GAGA,QAAAu3B,IAAAC,EAAAppB,GACA,OAAAopB,EAAA,GAAAppB,EAAAopB,EAAA,GAAAppB,EAAAopB,EAAA,GAAAppB,GAIA,QAAAqpB,IAAA13B,GACA,GAAA8b,GAAA6B,GAAA3d,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAA,GAAA,IAAA8b,EAAA9b,EAAA,IAAA8b,EAAA9b,EAAA,IAAA8b,EAsCA,QAAA6b,IAAAvB,EAAAC,GACAuB,GAAA7xB,KAAAiH,IAAA6qB,GAAAzB,EAAA0B,GAAA1B,IACAC,EAAA0B,QAAA1B,GACAA,EAAA2B,QAAA3B,GAGA,QAAA4B,IAAA7B,EAAAC,GACA,GAAAj2B,GAAAg3B,IAAAhB,EAAAE,GAAAD,EAAAC,IACA,IAAA4B,GAAA,CACA,GAAAC,GAAAb,GAAAY,GAAA93B,GACAg4B,GAAAD,EAAA,IAAAA,EAAA,MACAE,EAAAf,GAAAc,EAAAD,EACAT,IAAAW,GACAA,EAAAlB,GAAAkB,EACA,IAGAC,GAHAC,EAAAnC,EAAAoC,GACAC,EAAAF,EAAA,OACAG,EAAAL,EAAA,GAAAM,GAAAF,EAEAG,EAAAttB,GAAAitB,GAAA,GACAK,IAAAH,EAAAD,GAAAE,KAAAD,EAAArC,IACAkC,EAAAD,EAAA,GAAAM,IACAX,QAAAM,IACKI,KAAA,aAAAE,GAAAH,EAAAD,GAAAE,KAAAD,EAAArC,IACLkC,GAAAD,EAAA,GAAAM,IACAZ,QAAAO,IAEAjC,EAAA0B,QAAA1B,GACAA,EAAA2B,QAAA3B,KAEAuC,EACAxC,EAAAoC,GACAK,GAAAhB,GAAAzB,GAAAyC,GAAAhB,GAAAC,SAAA1B,GAEAyC,GAAAzC,EAAA0B,IAAAe,GAAAhB,GAAAC,MAAAD,GAAAzB,GAGA0B,IAAAD,IACAzB,EAAAyB,QAAAzB,GACAA,EAAA0B,QAAA1B,IAEAA,EAAAoC,GACAK,GAAAhB,GAAAzB,GAAAyC,GAAAhB,GAAAC,SAAA1B,GAEAyC,GAAAzC,EAAA0B,IAAAe,GAAAhB,GAAAC,MAAAD,GAAAzB,OAKAwB,IAAA7xB,KAAAiH,IAAA6qB,GAAAzB,EAAA0B,GAAA1B,GAEAC,GAAA0B,QAAA1B,GACAA,EAAA2B,QAAA3B,GACA6B,GAAA93B,EAAAo4B,GAAApC,EAGA,QAAA0C,MACAC,GAAA9M,MAAAgM,GAGA,QAAAe,MACAhsB,GAAA,GAAA6qB,GAAA7qB,GAAA,GAAA8qB,GACAiB,GAAA9M,MAAA0L,GACAO,GAAA,KAGA,QAAAe,IAAA7C,EAAAC,GACA,GAAA6B,GAAA,CACA,GAAAK,GAAAnC,EAAAoC,EACAU,IAAAz6B,IAAA6M,GAAAitB,GAAA,IAAAA,KAAA,YAAAA,OAEAY,IAAA/C,EAAAgD,GAAA/C,CAEAP,IAAA7J,MAAAmK,EAAAC,GACA4B,GAAA7B,EAAAC,GAGA,QAAAgD,MACAvD,GAAAN,YAGA,QAAA8D,MACAL,GAAAE,GAAAC,IACAtD,GAAAL,UACAnqB,GAAA4tB,IAAAK,KAAA1B,KAAAC,GAAA,MACA9qB,GAAA,GAAA6qB,GAAA7qB,GAAA,GAAA8qB,GACAI,GAAA,KAMA,QAAAW,IAAAtC,EAAAuB,GACA,OAAAA,GAAAvB,GAAA,EAAAuB,EAAA,IAAAA,EAGA,QAAA0B,IAAAnvB,EAAApK,GACA,MAAAoK,GAAA,GAAApK,EAAA,GAGA,QAAAw5B,IAAAzsB,EAAA1D,GACA,MAAA0D,GAAA,IAAAA,EAAA,GAAAA,EAAA,IAAA1D,MAAA0D,EAAA,GAAA1D,EAAA0D,EAAA,IAAAA,EAAA,GAAA1D,EAyEA,QAAAowB,IAAAtD,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAS,GAAAN,GAAAJ,EACAsD,IAAA5C,EAAAN,GAAAL,GAAAW,EAAAhC,GAAAqB,GAAArB,GAAAsB,IAGA,QAAAsD,IAAArwB,EAAAoC,EAAAkuB,KACAC,GACAC,KAAAxwB,EAAAwwB,IAAAD,GACAE,KAAAruB,EAAAquB,IAAAF,GACAG,KAAAJ,EAAAI,IAAAH,GAGA,QAAAI,MACAC,GAAAjO,MAAAkO,GAGA,QAAAA,IAAA/D,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAS,GAAAN,GAAAJ,EACA1E,IAAAoF,EAAAN,GAAAL,GACAxE,GAAAmF,EAAAhC,GAAAqB,GACAgE,GAAArF,GAAAsB,GACA6D,GAAAjO,MAAAoO,GACAV,GAAAhI,GAAAC,GAAAwI,IAGA,QAAAC,IAAAjE,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAS,GAAAN,GAAAJ,GACA/sB,EAAAytB,EAAAN,GAAAL,GACA1qB,EAAAqrB,EAAAhC,GAAAqB,GACAwD,EAAA7E,GAAAsB,GACAiE,EAAA7c,GAAAE,IAAA2c,EAAA1I,GAAAgI,EAAAQ,GAAA1uB,GAAA4uB,KAAAF,GAAA9wB,EAAAqoB,GAAAiI,GAAAU,KAAA3I,GAAAjmB,EAAAkmB,GAAAtoB,GAAAgxB,GAAA3I,GAAAroB,EAAAsoB,GAAAlmB,EAAA0uB,GAAAR,EACAW,KAAAD,EACAE,IAAAF,GAAA3I,OAAAroB,IACAmxB,IAAAH,GAAA1I,OAAAlmB,IACAgvB,IAAAJ,GAAAF,OAAAR,IACAD,GAAAhI,GAAAC,GAAAwI,IAGA,QAAAO,MACAT,GAAAjO,MAAAyN,GAKA,QAAAkB,MACAV,GAAAjO,MAAA4O,GAGA,QAAAC,MACAC,GAAAC,GAAAC,IACAf,GAAAjO,MAAAyN,GAGA,QAAAmB,IAAAzE,EAAAC,GACA2E,GAAA5E,EAAA6E,GAAA5E,EACAD,GAAAE,GAAAD,GAAAC,GACA4D,GAAAjO,MAAA8O,EACA,IAAAhE,GAAAN,GAAAJ,EACA1E,IAAAoF,EAAAN,GAAAL,GACAxE,GAAAmF,EAAAhC,GAAAqB,GACAgE,GAAArF,GAAAsB,GACAsD,GAAAhI,GAAAC,GAAAwI,IAGA,QAAAW,IAAA3E,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAS,GAAAN,GAAAJ,GACA/sB,EAAAytB,EAAAN,GAAAL,GACA1qB,EAAAqrB,EAAAhC,GAAAqB,GACAwD,EAAA7E,GAAAsB,GACA6E,EAAAtJ,GAAAgI,EAAAQ,GAAA1uB,EACAyvB,EAAAf,GAAA9wB,EAAAqoB,GAAAiI,EACAwB,EAAAzJ,GAAAjmB,EAAAkmB,GAAAtoB,EACAuJ,EAAA8K,GAAAud,IAAAC,IAAAC,KACAd,EAAA1F,GAAA/hB,GACAqC,EAAArC,IAAAynB,EAAAznB,CACAwoB,KAAAnmB,EAAAgmB,EACAI,IAAApmB,EAAAimB,EACAI,IAAArmB,EAAAkmB,EACAb,IAAAD,EACAE,IAAAF,GAAA3I,OAAAroB,IACAmxB,IAAAH,GAAA1I,OAAAlmB,IACAgvB,IAAAJ,GAAAF,OAAAR,IACAD,GAAAhI,GAAAC,GAAAwI,IA+CA,QAAAoB,IAAApF,EAAAC,GACA,OAAAD,EAAAzB,GAAAyB,EAAAqF,GAAArF,GAAAzB,GAAAyB,EAAAqF,GAAArF,EAAAC,GAKA,QAAAqF,IAAAC,EAAAC,EAAAC,GACA,OAAAF,GAAAF,IAAAG,GAAAC,EAAAC,GAAAC,GAAAJ,GAAAK,GAAAJ,EAAAC,IACAE,GAAAJ,GACAC,GAAAC,EAAAG,GAAAJ,EAAAC,GACAL,GAGA,QAAAS,IAAAN,GACA,gBAAAvF,EAAAC,GACA,MAAAD,IAAAuF,GAAAvF,EAAAzB,GAAAyB,EAAAqF,GAAArF,GAAAzB,GAAAyB,EAAAqF,GAAArF,EAAAC,IAIA,QAAA0F,IAAAJ,GACA,GAAAO,GAAAD,GAAAN,EAEA,OADAO,GAAAC,OAAAF,IAAAN,GACAO,EAGA,QAAAF,IAAAJ,EAAAC,GAMA,QAAAK,GAAA9F,EAAAC,GACA,GAAAU,GAAAN,GAAAJ,GACA/sB,EAAAmtB,GAAAL,GAAAW,EACArrB,EAAAqpB,GAAAqB,GAAAW,EACA6C,EAAA7E,GAAAsB,GACAhoB,EAAAurB,EAAAwC,EAAA9yB,EAAA+yB,CACA,QACA5e,GAAA/R,EAAA4wB,EAAAjuB,EAAAkuB,EAAAjzB,EAAA8yB,EAAAxC,EAAAyC,GACAzH,GAAAvmB,EAAAiuB,EAAA5wB,EAAA6wB,IAbA,GAAAH,GAAA3F,GAAAmF,GACAS,EAAAtH,GAAA6G,GACAU,EAAA7F,GAAAoF,GACAU,EAAAxH,GAAA8G,EA0BA,OAZAK,GAAAC,OAAA,SAAA/F,EAAAC,GACA,GAAAU,GAAAN,GAAAJ,GACA/sB,EAAAmtB,GAAAL,GAAAW,EACArrB,EAAAqpB,GAAAqB,GAAAW,EACA6C,EAAA7E,GAAAsB,GACAhoB,EAAAurB,EAAA0C,EAAA5wB,EAAA6wB,CACA,QACA9e,GAAA/R,EAAA4wB,EAAA1C,EAAA2C,EAAAjzB,EAAA8yB,EAAA/tB,EAAAguB,GACAzH,GAAAvmB,EAAA+tB,EAAA9yB,EAAA+yB,KAIAH,EAoBA,QAAAM,IAAArH,EAAAvF,EAAA2I,EAAAkE,EAAArf,EAAAE,GACA,GAAAib,EAAA,CACA,GAAAmE,GAAAjG,GAAA7G,GACA+M,EAAA5H,GAAAnF,GACAnlB,EAAAgyB,EAAAlE,CACA,OAAAnb,GACAA,EAAAwS,EAAA6M,EAAAhB,GACAne,EAAAsS,EAAAnlB,EAAA,IAEA2S,EAAAwf,GAAAF,EAAAtf,GACAE,EAAAsf,GAAAF,EAAApf,IACAmf,EAAA,EAAArf,EAAAE,EAAAF,EAAAE,KAAAF,GAAAqf,EAAAhB,IAEA,QAAAxP,GAAAvc,EAAA0N,EAAyBqf,EAAA,EAAA/sB,EAAA4N,EAAA5N,EAAA4N,EAAiC5N,GAAAjF,EAC1DwhB,EAAAkL,IAAAuF,GAAAC,EAAAlG,GAAA/mB,IAAAitB,EAAA5H,GAAArlB,KACAylB,EAAAlJ,QAAA,GAAAA,EAAA,KAKA,QAAA2Q,IAAAF,EAAAzQ,GACAA,EAAAmL,GAAAnL,KAAA,IAAAyQ,EACAhF,GAAAzL,EACA,IAAA2D,GAAA8E,IAAAzI,EAAA,GACA,UAAAA,EAAA,MAAA2D,KAAA6L,GAAAlC,IAAAkC,GAkIA,QAAAoB,IAAA5Q,EAAA6Q,EAAAC,EAAAC,GACAr/B,KAAA2L,EAAA2iB,EACAtuB,KAAAi8B,EAAAkD,EACAn/B,KAAAgV,EAAAoqB,EACAp/B,KAAAiI,EAAAo3B,EACAr/B,KAAAuX,GAAA,EACAvX,KAAAgS,EAAAhS,KAAAyC,EAAA,KA+EA,QAAA68B,IAAAx0B,GACA,GAAAkH,EAAAlH,EAAAzH,OAAA,CAKA,IAJA,GAAA2O,GAGA1P,EAFA2D,EAAA,EACAyG,EAAA5B,EAAA,KAEA7E,EAAA+L,GACAtF,EAAAsF,EAAA1P,EAAAwI,EAAA7E,GACA3D,EAAAG,EAAAiK,EACAA,EAAApK,CAEAoK,GAAAsF,EAAA1P,EAAAwI,EAAA,GACAxI,EAAAG,EAAAiK,GASA,QAAA6yB,IAAAvL,EAAAC,EAAAC,EAAAC,GAEA,QAAAqL,GAAA7zB,EAAAoC,GACA,MAAAimB,IAAAroB,MAAAuoB,GAAAD,GAAAlmB,MAAAomB,EAGA,QAAAsL,GAAAC,EAAAC,EAAAb,EAAAtH,GACA,GAAA9qB,GAAA,EAAAkzB,EAAA,CACA,UAAAF,IACAhzB,EAAAmzB,EAAAH,EAAAZ,OAAAc,EAAAC,EAAAF,EAAAb,KACAgB,EAAAJ,EAAAC,GAAA,EAAAb,EAAA,EACA,GAAAtH,EAAAlJ,MAAA,IAAA5hB,GAAA,IAAAA,EAAAsnB,EAAAE,EAAAxnB,EAAA,EAAAynB,EAAAF,UACAvnB,KAAAoyB,EAAA,QAAAc,OAEApI,GAAAlJ,MAAAqR,EAAA,GAAAA,EAAA,IAIA,QAAAE,GAAAp9B,EAAAq8B,GACA,MAAAnxB,IAAAlL,EAAA,GAAAuxB,GAAA4H,GAAAkD,EAAA,MACAnxB,GAAAlL,EAAA,GAAAyxB,GAAA0H,GAAAkD,EAAA,MACAnxB,GAAAlL,EAAA,GAAAwxB,GAAA2H,GAAAkD,EAAA,MACAA,EAAA,MAGA,QAAAiB,GAAArzB,EAAApK,GACA,MAAAw9B,GAAApzB,EAAAf,EAAArJ,EAAAqJ,GAGA,QAAAm0B,GAAApzB,EAAApK,GACA,GAAA09B,GAAAH,EAAAnzB,EAAA,GACAuzB,EAAAJ,EAAAv9B,EAAA,EACA,OAAA09B,KAAAC,EAAAD,EAAAC,EACA,IAAAD,EAAA19B,EAAA,GAAAoK,EAAA,GACA,IAAAszB,EAAAtzB,EAAA,GAAApK,EAAA,GACA,IAAA09B,EAAAtzB,EAAA,GAAApK,EAAA,GACAA,EAAA,GAAAoK,EAAA,GAGA,gBAAA8qB,GAmBA,QAAAlJ,GAAA3iB,EAAAoC,GACAyxB,EAAA7zB,EAAAoC,IAAAmyB,EAAA5R,MAAA3iB,EAAAoC,GAGA,QAAAoyB,KAGA,OAFAC,GAAA,EAEAn6B,EAAA,EAAA+L,EAAAquB,EAAAh9B,OAAyC4C,EAAA+L,IAAO/L,EAChD,OAAAq6B,GAAAV,EAAAW,EAAAF,EAAAp6B,GAAAgP,EAAA,EAAAC,EAAAqrB,EAAAl9B,OAAAirB,EAAAiS,EAAA,GAAAlV,EAAAiD,EAAA,GAAAlD,EAAAkD,EAAA,GAAkHrZ,EAAAC,IAAOD,EACzHqrB,EAAAjV,EAAAuU,EAAAxU,EAAAkD,EAAAiS,EAAAtrB,GAAAoW,EAAAiD,EAAA,GAAAlD,EAAAkD,EAAA,GACAsR,GAAAzL,EAAyB/I,EAAA+I,IAAA9I,EAAAiV,IAAAnM,EAAAyL,IAAAxU,EAAAwU,IAAA5L,EAAAsM,MAAAF,EACThV,GAAA+I,IAAA9I,EAAAiV,IAAAnM,EAAAyL,IAAAxU,EAAAwU,IAAA5L,EAAAsM,MAAAF,CAIhB,OAAAA,GAIA,QAAApI,KACAkI,EAAAM,EAAAC,KAAAJ,KAAAK,GAAA,EAGA,QAAAzI,KACA,GAAA0I,GAAAR,IACAS,EAAAF,GAAAC,EACAnB,GAAAiB,EAAAjwB,GAAAiwB,IAAAp9B,QACAu9B,GAAApB,KACAhI,EAAAQ,eACA4I,IACApJ,EAAAK,YACA4H,EAAA,YAAAjI,GACAA,EAAAM,WAEA0H,GACAqB,GAAAJ,EAAAV,EAAAY,EAAAlB,EAAAjI,GAEAA,EAAAS,cAEAiI,EAAA1I,EAAAiJ,EAAAJ,EAAAE,EAAA,KAGA,QAAA1I,KACAiJ,EAAAxS,MAAAgM,EACA+F,KAAAj4B,KAAAm4B,MACAQ,GAAA,EACAC,GAAA,EACAC,EAAAC,EAAArqB,IAMA,QAAAihB,KACA2I,IACAnG,EAAA6G,EAAAC,GACAC,GAAAL,GAAAR,EAAAc,SACAb,EAAAr4B,KAAAo4B,EAAA76B,WAEAm7B,EAAAxS,QACA0S,GAAAd,EAAApI,UAGA,QAAAwC,GAAA3uB,EAAAoC,GACA,GAAAwJ,GAAAioB,EAAA7zB,EAAAoC,EAEA,IADAsyB,GAAAE,EAAAn4B,MAAAuD,EAAAoC,IACAgzB,EACAI,EAAAx1B,EAAAy1B,EAAArzB,EAAAszB,EAAA9pB,EACAwpB,GAAA,EACAxpB,IACA2oB,EAAArI,YACAqI,EAAA5R,MAAA3iB,EAAAoC,QAGA,IAAAwJ,GAAAypB,EAAAd,EAAA5R,MAAA3iB,EAAAoC,OACA,CACA,GAAArB,IAAAu0B,EAAAl0B,KAAAC,IAAAu0B,GAAAx0B,KAAAuR,IAAAkjB,GAAAP,IAAAC,EAAAn0B,KAAAC,IAAAu0B,GAAAx0B,KAAAuR,IAAAkjB,GAAAN,KACA5+B,GAAAqJ,EAAAoB,KAAAC,IAAAu0B,GAAAx0B,KAAAuR,IAAAkjB,GAAA71B,IAAAoC,EAAAhB,KAAAC,IAAAu0B,GAAAx0B,KAAAuR,IAAAkjB,GAAAzzB,IACA0zB,IAAA/0B,EAAApK,EAAA0xB,EAAAC,EAAAC,EAAAC,IACA6M,IACAd,EAAArI,YACAqI,EAAA5R,MAAA5hB,EAAA,GAAAA,EAAA,KAEAwzB,EAAA5R,MAAAhsB,EAAA,GAAAA,EAAA,IACAiV,GAAA2oB,EAAApI,UACA4I,GAAA,GACWnpB,IACX2oB,EAAArI,YACAqI,EAAA5R,MAAA3iB,EAAAoC,GACA2yB,GAAA,GAIAO,EAAAt1B,EAAAu1B,EAAAnzB,EAAAizB,EAAAzpB,EA/GA,GAEAkpB,GACAJ,EACAE,EACAY,EAAAC,EAAAC,EACAJ,EAAAC,EAAAF,EACAD,EACAL,EARAR,EAAA1I,EACAgJ,EAAAkB,KASAZ,GACAxS,QACAuJ,YACAC,UACAE,eACAC,aAmGA,OAAA6I,IAsGA,QAAAa,MACAC,GAAAtT,MAAAuT,GACAD,GAAA9J,QAAAgK,GAGA,QAAAA,MACAF,GAAAtT,MAAAsT,GAAA9J,QAAAT,GAGA,QAAAwK,IAAApJ,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,GACAoJ,GAAAtJ,EAAAuJ,GAAA5K,GAAAsB,GAAAuJ,GAAAnJ,GAAAJ,GACAkJ,GAAAtT,MAAA4T,GAGA,QAAAA,IAAAzJ,EAAAC,GACAD,GAAAE,GAAAD,GAAAC,EACA,IAAAU,GAAAjC,GAAAsB,GACAU,EAAAN,GAAAJ,GACAkC,EAAAjtB,GAAA8qB,EAAAsJ,IACAI,EAAArJ,GAAA8B,GACAwH,EAAAhL,GAAAwD,GACAjvB,EAAAytB,EAAAgJ,EACAr0B,EAAAk0B,GAAA5I,EAAA2I,GAAA5I,EAAA+I,EACAlG,EAAA+F,GAAA3I,EAAA4I,GAAA7I,EAAA+I,CACAE,IAAAvhC,IAAAgf,GAAAE,GAAArU,IAAAoC,KAAAkuB,IACA8F,GAAAtJ,EAAAuJ,GAAA3I,EAAA4I,GAAA7I,EAgEA,QAAAkJ,IAAA/K,EAAAjJ,GACA,SAAAiJ,IAAAgL,GAAA7/B,eAAA60B,EAAA9kB,QACA8vB,GAAAhL,EAAA9kB,MAAA8kB,EAAAjJ,GAIA,QAAAkU,IAAA7K,EAAArJ,GACA,WAAAmU,GAAA9K,EAAArJ,GAGA,QAAAoU,IAAA/K,EAAArJ,GACA,GAAAqU,GAAAF,GAAA9K,EAAA,GAAAA,EAAA,GAGA,OAFA8K,IAAA9K,EAAA,GAAArJ,GACAmU,GAAAnU,EAAAqJ,EAAA,KACAgL,EAAA/G,GAGA,QAAAgH,IAAAjL,EAAArJ,GACA,QAAAuU,GAAAlL,EAAAplB,IAAAuwB,IAAAC,GAAAzU,IAGA,QAAAwU,IAAAvC,GACA,MAAAA,KAAAhuB,IAAAwwB,IAAAxC,EAAAp1B,MAAAo1B,EAGA,QAAAwC,IAAAzU,GACA,OAAAA,EAAA,GAAAqK,GAAArK,EAAA,GAAAqK,IASA,QAAAqK,IAAA/O,EAAAE,EAAAlY,GACA,GAAAlO,GAAAk1B,GAAAhP,EAAAE,EAAAyH,GAAA3f,GAAA7U,OAAA+sB,EACA,iBAAAxoB,GAAsB,MAAAoC,GAAAwE,IAAA,SAAAxE,GAA2B,OAAApC,EAAAoC,MAGjD,QAAAm1B,IAAAlP,EAAAE,EAAAlY,GACA,GAAArQ,GAAAs3B,GAAAjP,EAAAE,EAAA0H,GAAA5f,GAAA5U,OAAA8sB,EACA,iBAAAnmB,GAAsB,MAAApC,GAAA4G,IAAA,SAAA5G,GAA2B,OAAAA,EAAAoC,MAGjD,QAAAo1B,MAOA,QAAAA,KACA,OAAY1wB,KAAA,kBAAAklB,YAAAyL,KAGZ,QAAAA,KACA,MAAAH,IAAAI,GAAAlH,EAAAmH,KAAAzG,EAAAyG,GAAA/wB,IAAA0a,GACA7lB,OAAA67B,GAAAI,GAAAjH,EAAAmH,KAAAzG,EAAAyG,GAAAhxB,IAAA4a,IACA/lB,OAAA67B,GAAAI,GAAArP,EAAAhY,KAAAkY,EAAAlY,GAAA1K,OAAA,SAAA3F,GAAyE,MAAAgC,IAAAhC,EAAA23B,GAAA1H,KAAkCrpB,IAAA5G,IAC3GvE,OAAA67B,GAAAI,GAAApP,EAAAhY,KAAAkY,EAAAlY,GAAA3K,OAAA,SAAAvD,GAAyE,MAAAJ,IAAAI,EAAAw1B,GAAA3H,KAAkCrpB,IAAAxE,IAd3G,GAAAmmB,GAAAF,EAAA6I,EAAAV,EACAhI,EAAAF,EAAA6I,EAAAV,EAEAzwB,EAAAoC,EAAAkf,EAAAE,EADAnR,EAAA,GAAAC,EAAAD,EAAAsnB,EAAA,GAAAC,EAAA,IAEApN,EAAA,GA+EA,OAlEAgN,GAAAC,MAAA,WACA,MAAAA,KAAA7wB,IAAA,SAAAolB,GAA8C,OAASllB,KAAA,aAAAklB,kBAGvDwL,EAAAK,QAAA,WACA,OACA/wB,KAAA,UACAklB,aACA1K,EAAAkP,GAAA/0B,OACA+lB,EAAA2P,GAAAtzB,MAAA,GACAyjB,EAAA4P,GAAA4G,UAAAj6B,MAAA,GACA2jB,EAAAiP,GAAAqH,UAAAj6B,MAAA,OAKA25B,EAAAxW,OAAA,SAAAnb,GACA,MAAApO,WAAAC,OACA8/B,EAAAO,YAAAlyB,GAAAmyB,YAAAnyB,GADA2xB,EAAAQ,eAIAR,EAAAO,YAAA,SAAAlyB,GACA,MAAApO,WAAAC,QACA84B,GAAA3qB,EAAA,MAAAqrB,GAAArrB,EAAA,MACA4qB,GAAA5qB,EAAA,MAAAsrB,GAAAtrB,EAAA,MACA2qB,EAAAU,IAAArrB,EAAA2qB,IAAAU,IAAArrB,GACA4qB,EAAAU,IAAAtrB,EAAA4qB,IAAAU,IAAAtrB,GACA2xB,EAAAhN,gBALAgG,EAAAC,IAAAS,EAAAC,KAQAqG,EAAAQ,YAAA,SAAAnyB,GACA,MAAApO,WAAAC,QACA2wB,GAAAxiB,EAAA,MAAA0iB,GAAA1iB,EAAA,MACAyiB,GAAAziB,EAAA,MAAA2iB,GAAA3iB,EAAA,MACAwiB,EAAAE,IAAA1iB,EAAAwiB,IAAAE,IAAA1iB,GACAyiB,EAAAE,IAAA3iB,EAAAyiB,IAAAE,IAAA3iB,GACA2xB,EAAAhN,gBALAnC,EAAAC,IAAAC,EAAAC,KAQAgP,EAAAr2B,KAAA,SAAA0E,GACA,MAAApO,WAAAC,OACA8/B,EAAAS,UAAApyB,GAAAqyB,UAAAryB,GADA2xB,EAAAU,aAIAV,EAAAS,UAAA,SAAApyB,GACA,MAAApO,WAAAC,QACAigC,GAAA9xB,EAAA,GAAA+xB,GAAA/xB,EAAA,GACA2xB,IAFAG,EAAAC,IAKAJ,EAAAU,UAAA,SAAAryB,GACA,MAAApO,WAAAC,QACA2Y,GAAAxK,EAAA,GAAAyK,GAAAzK,EAAA,GACA2xB,IAFAnnB,EAAAC,IAKAknB,EAAAhN,UAAA,SAAA3kB,GACA,MAAApO,WAAAC,QACA8yB,GAAA3kB,EACA7F,EAAAq3B,GAAA/O,EAAAE,EAAA,IACApmB,EAAAm1B,GAAAlP,EAAAE,EAAAiC,GACAlJ,EAAA+V,GAAA5G,EAAAU,EAAA,IACA3P,EAAA+V,GAAA/G,EAAAU,EAAA1G,GACAgN,GANAhN,GASAgN,EACAO,eAAA,QAAA9H,KAAA,OAAAA,MACA+H,eAAA,QAAA/H,KAAA,OAAAA,MAGA,QAAAkI,MACA,MAAAX,QAqEA,QAAAY,MACAC,GAAA1V,MAAA2V,GAGA,QAAAA,IAAAt4B,EAAAoC,GACAi2B,GAAA1V,MAAA4V,GACAC,GAAAC,GAAAz4B,EAAA04B,GAAAC,GAAAv2B,EAGA,QAAAm2B,IAAAv4B,EAAAoC,GACAw2B,GAAAzjC,IAAAwjC,GAAA34B,EAAAy4B,GAAAr2B,GACAq2B,GAAAz4B,EAAA24B,GAAAv2B,EAGA,QAAAy2B,MACAN,GAAAC,GAAAE,IAqBA,QAAAI,IAAA94B,EAAAoC,GACApC,EAAA+4B,QAAA/4B,GACAA,EAAAuoB,QAAAvoB,GACAoC,EAAA42B,QAAA52B,GACAA,EAAAomB,QAAApmB,GA4CA,QAAA62B,IAAAj5B,EAAAoC,GACA82B,IAAAl5B,EACAm5B,IAAA/2B,IACAg3B,GAGA,QAAAC,MACAC,GAAA3W,MAAA4W,GAGA,QAAAA,IAAAv5B,EAAAoC,GACAk3B,GAAA3W,MAAA6W,GACAP,GAAAQ,GAAAz5B,EAAA05B,GAAAt3B,GAGA,QAAAo3B,IAAAx5B,EAAAoC,GACA,GAAAiO,GAAArQ,EAAAy5B,GAAAnpB,EAAAlO,EAAAs3B,GAAApJ,EAAAjc,GAAAhE,IAAAC,IACAqpB,KAAArJ,GAAAmJ,GAAAz5B,GAAA,EACA45B,IAAAtJ,GAAAoJ,GAAAt3B,GAAA,EACAy3B,IAAAvJ,EACA2I,GAAAQ,GAAAz5B,EAAA05B,GAAAt3B,GAGA,QAAA03B,MACAR,GAAA3W,MAAAsW,GAGA,QAAAc,MACAT,GAAA3W,MAAAqX,GAGA,QAAAC,MACAC,GAAAC,GAAAC,IAGA,QAAAJ,IAAAh6B,EAAAoC,GACAk3B,GAAA3W,MAAAuX,GACAjB,GAAAkB,GAAAV,GAAAz5B,EAAAo6B,GAAAV,GAAAt3B,GAGA,QAAA83B,IAAAl6B,EAAAoC,GACA,GAAAiO,GAAArQ,EAAAy5B,GACAnpB,EAAAlO,EAAAs3B,GACApJ,EAAAjc,GAAAhE,IAAAC,IAEAqpB,KAAArJ,GAAAmJ,GAAAz5B,GAAA,EACA45B,IAAAtJ,GAAAoJ,GAAAt3B,GAAA,EACAy3B,IAAAvJ,EAEAA,EAAAoJ,GAAA15B,EAAAy5B,GAAAr3B,EACAi4B,IAAA/J,GAAAmJ,GAAAz5B,GACAs6B,IAAAhK,GAAAoJ,GAAAt3B,GACAm4B,IAAA,EAAAjK,EACA2I,GAAAQ,GAAAz5B,EAAA05B,GAAAt3B,GAGA,QAAAo4B,IAAA/hC,GACApE,KAAAuE,SAAAH,EAuEA,QAAAgiC,IAAAz6B,EAAAoC,GACAs4B,GAAA/X,MAAAgY,GACAC,GAAAC,GAAA76B,EAAA86B,GAAAC,GAAA34B,EAGA,QAAAu4B,IAAA36B,EAAAoC,GACAy4B,IAAA76B,EAAA+6B,IAAA34B,EACA44B,GAAA7lC,IAAAkf,GAAAwmB,MAAAE,QACAF,GAAA76B,EAAA+6B,GAAA34B,EAGA,QAAA64B,MACA5mC,KAAA6mC,WAoDA,QAAAC,IAAA7U,GACA,YAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,eAAAA,EACA,IAAAA,EAAA,IAAAA,EAAA,cAAAA,EACA,IA+KA,QAAA8U,IAAAC,GACA,MAAAA,GAAA3jC,OAAA,EAKA,QAAA08B,IAAArzB,EAAApK,GACA,QAAAoK,IAAAf,GAAA,KAAAe,EAAA,GAAAwqB,GAAA0E,GAAA1E,GAAAxqB,EAAA,MACApK,IAAAqJ,GAAA,KAAArJ,EAAA,GAAA40B,GAAA0E,GAAA1E,GAAA50B,EAAA,IAaA,QAAA2kC,IAAAzP,GACA,GAGAkJ,GAHA9H,EAAA/hB,IACAujB,EAAAvjB,IACAqwB,EAAArwB,GAGA,QACAghB,UAAA,WACAL,EAAAK,YACA6I,EAAA,GAEApS,MAAA,SAAA6L,EAAAE,GACA,GAAA8M,GAAAhN,EAAA,EAAAnD,OACA4D,EAAAjtB,GAAAwsB,EAAAvB,EACAjrB,IAAAitB,EAAA5D,IAAA4E,IACApE,EAAAlJ,MAAAsK,EAAAwB,KAAAC,GAAA,IAAAnD,QACAM,EAAAlJ,MAAA4Y,EAAA9M,GACA5C,EAAAM,UACAN,EAAAK,YACAL,EAAAlJ,MAAA6Y,EAAA/M,GACA5C,EAAAlJ,MAAA6L,EAAAC,GACAsG,EAAA,GACOwG,IAAAC,GAAAvM,GAAA5D,KACPrpB,GAAAirB,EAAAsO,GAAAtL,KAAAhD,GAAAsO,EAAAtL,IACAjuB,GAAAwsB,EAAAgN,GAAAvL,KAAAzB,GAAAgN,EAAAvL,IACAxB,EAAAgN,GAAAxO,EAAAwB,EAAAD,EAAAE,GACA7C,EAAAlJ,MAAA4Y,EAAA9M,GACA5C,EAAAM,UACAN,EAAAK,YACAL,EAAAlJ,MAAA6Y,EAAA/M,GACAsG,EAAA,GAEAlJ,EAAAlJ,MAAAsK,EAAAuB,EAAAC,EAAAC,GACA6M,EAAAC,GAEArP,QAAA,WACAN,EAAAM,UACAc,EAAAwB,EAAAvjB,KAEA6pB,MAAA,WACA,SAAAA,IAKA,QAAA0G,IAAAxO,EAAAwB,EAAAD,EAAAE,GACA,GAAAxB,GACAwO,EACAC,EAAAlQ,GAAAwB,EAAAuB,EACA,OAAAxsB,IAAA25B,GAAA1L,GACA2L,IAAAnQ,GAAAgD,IAAAiN,EAAAvO,GAAAuB,IAAAjD,GAAA+C,GACA/C,GAAAiD,IAAAxB,EAAAC,GAAAsB,IAAAhD,GAAAwB,KACAC,EAAAwO,EAAAC,KACAlN,EAAAC,GAAA,EAGA,QAAAmN,IAAA9H,EAAAC,EAAAb,EAAAtH,GACA,GAAAkB,EACA,UAAAgH,EACAhH,EAAAoG,EAAA5H,GACAM,EAAAlJ,OAAA0I,GAAA0B,GACAlB,EAAAlJ,MAAA,EAAAoK,GACAlB,EAAAlJ,MAAA0I,GAAA0B,GACAlB,EAAAlJ,MAAA0I,GAAA,GACAQ,EAAAlJ,MAAA0I,IAAA0B,GACAlB,EAAAlJ,MAAA,GAAAoK,GACAlB,EAAAlJ,OAAA0I,IAAA0B,GACAlB,EAAAlJ,OAAA0I,GAAA,GACAQ,EAAAlJ,OAAA0I,GAAA0B,OACG,IAAA/qB,GAAA+xB,EAAA,GAAAC,EAAA,IAAA/D,GAAA,CACH,GAAAnD,GAAAiH,EAAA,GAAAC,EAAA,GAAA3I,MACA0B,GAAAoG,EAAArG,EAAA,EACAjB,EAAAlJ,OAAAmK,EAAAC,GACAlB,EAAAlJ,MAAA,EAAAoK,GACAlB,EAAAlJ,MAAAmK,EAAAC,OAEAlB,GAAAlJ,MAAAqR,EAAA,GAAAA,EAAA,IA0LA,QAAA8H,IAAAC,GACA,gBAAAlQ,GACA,GAAAtZ,GAAA,GAAAypB,GACA,QAAApxB,KAAAmxB,GAAAxpB,EAAA3H,GAAAmxB,EAAAnxB,EAEA,OADA2H,GAAAsZ,SACAtZ,GAIA,QAAAypB,OAYA,QAAAC,IAAAC,EAAAlb,EAAA6F,GACA,GAAAmK,GAAAhQ,EAAA,MAAAA,EAAA,MACA1O,EAAA0O,EAAA,MAAAA,EAAA,MACAmb,EAAAD,EAAAtI,YAAAsI,EAAAtI,YAEAsI,GACA55B,MAAA,KACA6U,WAAA,MAEA,MAAAglB,GAAAD,EAAAtI,WAAA,MAEAwI,GAAAvV,EAAAqV,EAAArQ,OAAAwQ,IAEA,IAAA1lC,GAAA0lC,GAAAriC,SACA+K,EAAA3D,KAAAuR,IAAAqe,GAAAr6B,EAAA,MAAAA,EAAA,OAAA2b,GAAA3b,EAAA,MAAAA,EAAA,QACAqJ,GAAAghB,EAAA,OAAAgQ,EAAAjsB,GAAApO,EAAA,MAAAA,EAAA,UACAyL,GAAA4e,EAAA,OAAA1O,EAAAvN,GAAApO,EAAA,MAAAA,EAAA,SAIA,OAFA,OAAAwlC,GAAAD,EAAAtI,WAAAuI,GAEAD,EACA55B,MAAA,IAAAyC,GACAoS,WAAAnX,EAAAoC,IAGA,QAAAk6B,IAAAJ,EAAAK,EAAA1V,GACA,MAAAoV,IAAAC,IAAA,KAAAK,GAAA1V,GAUA,QAAA2V,IAAAC,GACA,MAAAX,KACAnZ,MAAA,SAAA3iB,EAAAoC,GACApC,EAAAy8B,EAAAz8B,EAAAoC,GACA/N,KAAAw3B,OAAAlJ,MAAA3iB,EAAA,GAAAA,EAAA,OAKA,QAAA08B,IAAAD,EAAAE,GAEA,QAAAC,GAAAvU,EAAAC,EAAA2E,EAAA0H,EAAAjV,EAAAmd,EAAAtU,EAAAC,EAAAgG,EAAAyF,EAAAxU,EAAAqd,EAAAC,EAAAlR,GACA,GAAAxb,GAAAkY,EAAAF,EACA/X,EAAAkY,EAAAF,EACA0U,EAAA3sB,IAAAC,GACA,IAAA0sB,EAAA,EAAAL,GAAAI,IAAA,CACA,GAAAh8B,GAAA4zB,EAAAV,EACAt9B,EAAA+oB,EAAAD,EACAzY,EAAA61B,EAAAC,EACAvzB,EAAA8K,GAAAtT,IAAApK,IAAAqQ,KACAi2B,EAAA3R,GAAAtkB,GAAAuC,GACA2lB,EAAAltB,MAAAgF,GAAA,GAAAipB,IAAAjuB,GAAAirB,EAAAuB,GAAAyB,IAAAhD,EAAAuB,GAAA,EAAAra,GAAAxd,EAAAoK,GACAjK,EAAA2lC,EAAAvN,EAAA+N,GACAC,EAAApmC,EAAA,GACAqmC,EAAArmC,EAAA,GACAsmC,EAAAF,EAAA7U,EACAgV,EAAAF,EAAA7U,EACAgV,EAAAhtB,EAAA8sB,EAAA/sB,EAAAgtB,GACAC,IAAAN,EAAAL,GACA36B,IAAAqO,EAAA+sB,EAAA9sB,EAAA+sB,GAAAL,EAAA,QACArI,EAAAV,EAAAvU,EAAAD,EAAAod,EAAAC,EAAAS,MACAX,EAAAvU,EAAAC,EAAA2E,EAAA0H,EAAAjV,EAAAmd,EAAAK,EAAAC,EAAAjO,EAAAnuB,GAAAwI,EAAA5S,GAAA4S,EAAAvC,EAAA+1B,EAAAlR,GACAA,EAAAlJ,MAAAua,EAAAC,GACAP,EAAAM,EAAAC,EAAAjO,EAAAnuB,EAAApK,EAAAqQ,EAAAuhB,EAAAC,EAAAgG,EAAAyF,EAAAxU,EAAAqd,EAAAC,EAAAlR,KAIA,gBAAAA,GAYA,QAAAlJ,GAAA3iB,EAAAoC,GACApC,EAAAy8B,EAAAz8B,EAAAoC,GACAypB,EAAAlJ,MAAA3iB,EAAA,GAAAA,EAAA,IAGA,QAAAksB,KACA7D,EAAAnd,IACAsyB,EAAA7a,MAAAgM,EACA9C,EAAAK,YAGA,QAAAyC,GAAA7B,EAAAC,GACA,GAAA/lB,GAAA8mB,IAAAhB,EAAAC,IAAAj2B,EAAA2lC,EAAA3P,EAAAC,EACA6P,GAAAvU,EAAAC,EAAA2E,EAAA0H,EAAAjV,EAAAmd,EAAAxU,EAAAvxB,EAAA,GAAAwxB,EAAAxxB,EAAA,GAAAm2B,EAAAH,EAAA6H,EAAA3tB,EAAA,GAAA0Y,EAAA1Y,EAAA,GAAA61B,EAAA71B,EAAA,GAAAy2B,GAAA5R,GACAA,EAAAlJ,MAAA0F,EAAAC,GAGA,QAAA6D,KACAqR,EAAA7a,QACAkJ,EAAAM,UAGA,QAAAuR,KACAxR,IACAsR,EAAA7a,MAAAgb,EACAH,EAAArR,QAAAyR,EAGA,QAAAD,GAAA7Q,EAAAC,GACA4B,EAAA/B,EAAAE,EAAAC,GAAAyL,EAAAnQ,EAAAqQ,EAAApQ,EAAAuV,EAAAlJ,EAAAmJ,EAAApe,EAAAqe,EAAAlB,EACAW,EAAA7a,MAAAgM,EAGA,QAAAiP,KACAhB,EAAAvU,EAAAC,EAAA2E,EAAA0H,EAAAjV,EAAAmd,EAAArE,EAAAE,EAAA9L,EAAAiR,EAAAC,EAAAC,EAAAN,GAAA5R,GACA2R,EAAArR,UACAA,IA/CA,GAAAS,GAAA4L,EAAAE,EAAAmF,EAAAC,EAAAC,EACA9Q,EAAA5E,EAAAC,EAAAqM,EAAAjV,EAAAmd,EAEAW,GACA7a,QACAuJ,YACAC,UACAE,aAAA,WAAgCR,EAAAQ,eAAuBmR,EAAAtR,UAAAwR,GACvDpR,WAAA,WAA8BT,EAAAS,aAAqBkR,EAAAtR,aA0CnD,OAAAsR,IAUA,QAAAtB,IAAAO,GACA,MAAAuB,IAAA,WAAuC,MAAAvB,OAGvC,QAAAuB,IAAAC,GAYA,QAAA/B,GAAAvZ,GAEA,MADAA,GAAAub,EAAAvb,EAAA,GAAAqK,GAAArK,EAAA,GAAAqK,KACArK,EAAA,GAAA5d,EAAAsL,EAAAC,EAAAqS,EAAA,GAAA5d,GAGA,QAAA8tB,GAAAlQ,GAEA,OADAA,EAAAub,EAAArL,QAAAlQ,EAAA,GAAAtS,GAAAtL,GAAAuL,EAAAqS,EAAA,IAAA5d,MACA4d,EAAA,GAAA0M,GAAA1M,EAAA,GAAA0M,IAGA,QAAA8O,GAAAn+B,EAAAoC,GACA,MAAApC,GAAAy8B,EAAAz8B,EAAAoC,IAAApC,EAAA,GAAA+E,EAAAsL,EAAAC,EAAAtQ,EAAA,GAAA+E,GA2CA,QAAAq5B,KACAF,EAAA1L,GAAA9a,EAAA0a,GAAAC,EAAAC,EAAAC,GAAAkK,EACA,IAAAl6B,GAAAk6B,EAAA3P,EAAAC,EAGA,OAFA1c,GAAArQ,EAAAuC,EAAA,GAAAwC,EACAuL,EAAAlO,EAAAG,EAAA,GAAAwC,EACAgmB,IAGA,QAAAA,KAEA,MADAsT,GAAAC,EAAA,KACApC,EA3EA,GAAAO,GAGApsB,EAAAC,EACAoH,EAAAwmB,EAEA5V,EAAAC,EAAAC,EAEA6V,EACAC,EARAv5B,EAAA,IACA/E,EAAA,IAAAoC,EAAA,IACA0qB,EAAA,EAAAC,EAAA,EACAsF,EAAA,EAAAC,EAAA,EAAAC,EAAA,EACAgM,EAAA,KAAAC,EAAAC,GACApW,EAAA,KAAAqW,EAAAC,GACAhC,EAAA,GAAAiC,EAAAC,GAAAV,EAAAxB,EAuEA,OArDAT,GAAArQ,OAAA,SAAAA,GACA,MAAAwS,IAAAC,IAAAzS,EAAAwS,IAAAS,GAAAN,EAAA9mB,EAAAknB,EAAAF,EAAAJ,EAAAzS,OAGAqQ,EAAA6C,UAAA,SAAAl5B,GACA,MAAApO,WAAAC,QAAA8mC,GAAA34B,EAAAm5B,GAAAT,EAAA14B,EAAAmnB,GAAA,EAAAA,KAAAuR,EAAA,KAAAE,IAAA1T,KAAAwT,EAAAlP,IAGA6M,EAAAtI,WAAA,SAAA/tB,GACA,MAAApO,WAAAC,QAAAgnC,EAAA,MAAA74B,GAAAwiB,EAAAC,EAAAC,EAAAC,EAAA,KAAAmW,IAAA/K,GAAAvL,GAAAxiB,EAAA,MAAAyiB,GAAAziB,EAAA,MAAA0iB,GAAA1iB,EAAA,MAAA2iB,GAAA3iB,EAAA,OAAAklB,KAAA,MAAA1C,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAGA0T,EAAA55B,MAAA,SAAAuD,GACA,MAAApO,WAAAC,QAAAqN,GAAAc,EAAAu4B,KAAAr5B,GAGAm3B,EAAA/kB,UAAA,SAAAtR,GACA,MAAApO,WAAAC,QAAAsI,GAAA6F,EAAA,GAAAzD,GAAAyD,EAAA,GAAAu4B,MAAAp+B,EAAAoC,IAGA85B,EAAA35B,OAAA,SAAAsD,GACA,MAAApO,WAAAC,QAAAo1B,EAAAjnB,EAAA,OAAAmnB,GAAAD,EAAAlnB,EAAA,OAAAmnB,GAAAoR,MAAAtR,EAAAuC,GAAAtC,EAAAsC,KAGA6M,EAAAxkB,OAAA,SAAA7R,GACA,MAAApO,WAAAC,QAAA26B,EAAAxsB,EAAA,OAAAmnB,GAAAsF,EAAAzsB,EAAA,OAAAmnB,GAAAuF,EAAA1sB,EAAAnO,OAAA,EAAAmO,EAAA,OAAAmnB,GAAA,EAAAoR,MAAA/L,EAAAhD,GAAAiD,EAAAjD,GAAAkD,EAAAlD,KAGA6M,EAAA1R,UAAA,SAAA3kB,GACA,MAAApO,WAAAC,QAAAknC,EAAAC,GAAAV,EAAAxB,EAAA92B,KAAAklB,KAAA1W,GAAAsoB,IAGAT,EAAAD,UAAA,SAAAjb,EAAA6F,GACA,MAAAoV,IAAAC,EAAAlb,EAAA6F,IAGAqV,EAAAI,QAAA,SAAAC,EAAA1V,GACA,MAAAyV,IAAAJ,EAAAK,EAAA1V,IAgBA,WAGA,MAFA4V,GAAAwB,EAAA5kC,MAAAhF,KAAAoD,WACAykC,EAAArJ,OAAA4J,EAAA5J,UACAuL,KAIA,QAAAa,IAAAhB,GACA,GAAAxP,GAAA,EACAC,EAAArD,GAAA,EACA9hB,EAAAy0B,GAAAC,GACAnnC,EAAAyS,EAAAklB,EAAAC,EAMA,OAJA53B,GAAAooC,UAAA,SAAAr5B,GACA,MAAApO,WAAAC,OAAA6R,EAAAklB,EAAA5oB,EAAA,GAAAmnB,GAAA0B,EAAA7oB,EAAA,GAAAmnB,KAAAyB,EAAAY,GAAAX,EAAAW,KAGAv4B,EAGA,QAAAqoC,IAAA1Q,GAGA,QAAA2Q,GAAAtS,EAAAC,GACA,OAAAD,EAAAI,EAAAzB,GAAAsB,GAAAG,GAHA,GAAAA,GAAAC,GAAAsB,EAUA,OAJA2Q,GAAAvM,OAAA,SAAA7yB,EAAAoC,GACA,OAAApC,EAAAktB,EAAA5B,GAAAlpB,EAAA8qB,KAGAkS,EAGA,QAAAC,IAAA/W,EAAAE,GAQA,QAAAiU,GAAAz8B,EAAAoC,GACA,GAAA6P,GAAAoC,GAAArN,EAAA,EAAAX,EAAAolB,GAAArpB,IAAAiE,CACA,QAAA4L,EAAAwZ,GAAAzrB,GAAAqG,GAAAi5B,EAAArtB,EAAAkb,GAAAntB,IATA,GAAAu/B,GAAA9T,GAAAnD,GAAAjiB,GAAAk5B,EAAA9T,GAAAjD,IAAA,CAGA,IAAAxmB,GAAAqE,GAAA4pB,GAAA,MAAAkP,IAAA7W,EAEA,IAAAthB,GAAA,EAAAu4B,GAAA,EAAAl5B,EAAAk5B,GAAAD,EAAAjrB,GAAArN,GAAAX,CAYA,OALAo2B,GAAA5J,OAAA,SAAA7yB,EAAAoC,GACA,GAAAo9B,GAAAF,EAAAl9B,CACA,QAAA+R,GAAAnU,EAAAgC,GAAAw9B,IAAAn5B,EAAAgkB,GAAAmV,GAAAlU,IAAAtkB,GAAAhH,IAAAw/B,KAAAn5B,MAAA,EAAAA,MAGAo2B,EAoBA,QAAAgD,IAAAC,GACA,GAAAr5B,GAAAq5B,EAAAhoC,MACA,QACAirB,MAAA,SAAA3iB,EAAAoC,GAAuC,IAAZ,GAAA9H,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAAqoB,MAAA3iB,EAAAoC,IACvCu9B,OAAA,WAAoC,IAAZ,GAAArlC,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAAqlC,UACpCzT,UAAA,WAAuC,IAAZ,GAAA5xB,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAA4xB,aACvCC,QAAA,WAAqC,IAAZ,GAAA7xB,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAA6xB,WACrCE,aAAA,WAA0C,IAAZ,GAAA/xB,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAA+xB,gBAC1CC,WAAA,WAAwC,IAAZ,GAAAhyB,IAAA,IAAYA,EAAA+L,GAAAq5B,EAAAplC,GAAAgyB,eAyFxC,QAAAsT,IAAAt9B,GACA,gBAAAtC,EAAAoC,GACA,GAAAwvB,GAAAzE,GAAAntB,GACA6xB,EAAA1E,GAAA/qB,GACA2C,EAAAzC,EAAAsvB,EAAAC,EACA,QACA9sB,EAAA8sB,EAAApG,GAAAzrB,GACA+E,EAAA0mB,GAAArpB,KAKA,QAAAy9B,IAAAtQ,GACA,gBAAAvvB,EAAAoC,GACA,GAAAkuB,GAAAjc,GAAArU,IAAAoC,KACA4E,EAAAuoB,EAAAe,GACAwP,EAAArU,GAAAzkB,GACA+4B,EAAA5S,GAAAnmB,EACA,QACAmN,GAAAnU,EAAA8/B,EAAAxP,EAAAyP,GACAzU,GAAAgF,GAAAluB,EAAA09B,EAAAxP,KAiCA,QAAA0P,IAAAlT,EAAAC,GACA,OAAAD,EAAAtrB,GAAAy+B,IAAA1U,GAAAwB,GAAA,KAYA,QAAAmT,IAAAzD,GAwBA,QAAA0D,KACA,GAAAp7B,GAAAsmB,GAAA/oB,IACA8D,EAAAmD,EAAAqpB,GAAArpB,EAAAmO,UAAAmb,QAAA,MACA,OAAAe,GAAA,MAAAvL,IACAjiB,EAAA,GAAArB,EAAAqB,EAAA,GAAArB,IAAAqB,EAAA,GAAArB,EAAAqB,EAAA,GAAArB,IAAA03B,IAAAuD,KACA5+B,KAAAC,IAAA+E,EAAA,GAAArB,EAAAsjB,GAAAC,IAAAlnB,KAAAuR,IAAAvM,EAAA,GAAArB,EAAAwjB,GAAAC,MACAH,EAAAjnB,KAAAC,IAAA+E,EAAA,GAAArB,EAAAujB,KAAAC,EAAAnnB,KAAAuR,IAAAvM,EAAA,GAAArB,EAAAyjB,MA7BA,GAKAF,GAAAC,EAAAC,EALAjf,EAAA2yB,GAAAO,GACAl6B,EAAAgH,EAAAhH,OACAD,EAAAiH,EAAAjH,MACA6U,EAAA5N,EAAA4N,UACAyc,EAAArqB,EAAAqqB,WACAvL,EAAA,IA2BA,OAzBA9e,GAAAjH,MAAA,SAAAuD,GACA,MAAApO,WAAAC,QAAA4K,EAAAuD,GAAAs6B,KAAA79B,KAGAiH,EAAA4N,UAAA,SAAAtR,GACA,MAAApO,WAAAC,QAAAyf,EAAAtR,GAAAs6B,KAAAhpB,KAGA5N,EAAAhH,OAAA,SAAAsD,GACA,MAAApO,WAAAC,QAAA6K,EAAAsD,GAAAs6B,KAAA59B,KAGAgH,EAAAqqB,WAAA,SAAA/tB,GACA,MAAApO,WAAAC,QAAA,MAAAmO,EAAAwiB,EAAAC,EAAAC,EAAAC,EAAA,MAAAH,GAAAxiB,EAAA,MAAAyiB,GAAAziB,EAAA,MAAA0iB,GAAA1iB,EAAA,MAAA2iB,GAAA3iB,EAAA,OAAAs6B,KAAA,MAAA9X,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAYA2X,IAGA,QAAAC,IAAAh+B,GACA,MAAA69B,KAAA1U,GAAAnpB,GAAA,GAGA,QAAAi+B,IAAA/X,EAAAE,GAOA,QAAAiU,GAAAz8B,EAAAoC,GACAxB,EAAA,EAAgBwB,GAAAmpB,GAAA0E,KAAA7tB,GAAAmpB,GAAA0E,IACN7tB,EAAAmpB,GAAA0E,KAAA7tB,EAAAmpB,GAAA0E,GACV,IAAAhe,GAAArR,EAAAc,GAAA0+B,GAAAh+B,GAAAiE,EACA,QAAA4L,EAAAwZ,GAAAplB,EAAArG,GAAAY,EAAAqR,EAAAkb,GAAA9mB,EAAArG,IAVA,GAAAsgC,GAAAnT,GAAA7E,GACAjiB,EAAAiiB,IAAAE,EAAAiD,GAAAnD,GAAA9mB,GAAA8+B,EAAAnT,GAAA3E,IAAAhnB,GAAA4+B,GAAA5X,GAAA4X,GAAA9X,IACA1nB,EAAA0/B,EAAA5+B,GAAA0+B,GAAA9X,GAAAjiB,IAEA,OAAAA,IASAo2B,EAAA5J,OAAA,SAAA7yB,EAAAoC,GACA,GAAAm+B,GAAA3/B,EAAAwB,EAAA6P,EAAAoY,GAAAhkB,GAAAgO,GAAArU,IAAAugC,IACA,QAAApsB,GAAAnU,EAAAgC,GAAAu+B,IAAAl6B,EAAAgkB,GAAAkW,GAAA,EAAA3E,GAAAl6B,GAAAd,EAAAqR,EAAA,EAAA5L,IAAAklB,KAGAkR,GAdAuD,GAuBA,QAAAQ,IAAA1T,EAAAC,GACA,OAAAD,EAAAC,GAUA,QAAA0T,IAAAnY,EAAAE,GAOA,QAAAiU,GAAAz8B,EAAAoC,GACA,GAAAs+B,GAAAxuB,EAAA9P,EAAAu+B,EAAAt6B,EAAArG,CACA,QAAA0gC,EAAAjV,GAAAkV,GAAAzuB,EAAAwuB,EAAAvT,GAAAwT,IARA,GAAAL,GAAAnT,GAAA7E,GACAjiB,EAAAiiB,IAAAE,EAAAiD,GAAAnD,IAAAgY,EAAAnT,GAAA3E,OAAAF,GACApW,EAAAouB,EAAAj6B,EAAAiiB,CAEA,OAAAtmB,IAAAqE,GAAA4pB,GAAAuQ,IAOA/D,EAAA5J,OAAA,SAAA7yB,EAAAoC,GACA,GAAAs+B,GAAAxuB,EAAA9P,CACA,QAAA+R,GAAAnU,EAAAgC,GAAA0+B,IAAAr6B,EAAAgkB,GAAAqW,GAAAxuB,EAAAmY,GAAAhkB,GAAAgO,GAAArU,IAAA0gC,OAGAjE,GASA,QAAAmE,IAAA5gC,EAAAoC,GACA,GAAAyvB,GAAA1E,GAAA/qB,GAAA2C,EAAAooB,GAAAntB,GAAA6xB,CACA,QAAAA,EAAApG,GAAAzrB,GAAA+E,EAAA0mB,GAAArpB,GAAA2C,GAWA,QAAA87B,IAAAC,EAAAC,EAAAC,EAAAC,GACA,WAAAH,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,EAAAtC,GAAA7C,IACAnZ,MAAA,SAAA3iB,EAAAoC,GACA/N,KAAAw3B,OAAAlJ,MAAA3iB,EAAA8gC,EAAAE,EAAA5+B,EAAA2+B,EAAAE,MA6CA,QAAAC,IAAAlhC,EAAAoC,GACA,OAAA+qB,GAAA/qB,GAAAqpB,GAAAzrB,GAAAyrB,GAAArpB,IAWA,QAAA++B,IAAAnhC,EAAAoC,GACA,GAAAyvB,GAAA1E,GAAA/qB,GAAA2C,EAAA,EAAAooB,GAAAntB,GAAA6xB,CACA,QAAAA,EAAApG,GAAAzrB,GAAA+E,EAAA0mB,GAAArpB,GAAA2C,GAaA,QAAAq8B,IAAAtU,EAAAC,GACA,OAAAvrB,GAAAy+B,IAAA1U,GAAAwB,GAAA,KAAAD,GAwBA,QAAAuU,IAAAtgC,EAAApK,GACA,MAAAoK,GAAA9H,SAAAtC,EAAAsC,OAAA,IAGA,QAAAqoC,IAAAC,GACA,MAAAA,GAAAhmC,OAAAimC,GAAA,GAAAD,EAAA7pC,OAGA,QAAA8pC,IAAAxhC,EAAAgH,GACA,MAAAhH,GAAAgH,EAAAhH,EAGA,QAAAyhC,IAAAF,GACA,SAAAA,EAAAhmC,OAAAmmC,GAAA,GAGA,QAAAA,IAAAt/B,EAAA4E,GACA,MAAA5F,MAAAC,IAAAe,EAAA4E,EAAA5E,GAGA,QAAAu/B,IAAAn3B,GAEA,IADA,GAAA+2B,GACAA,EAAA/2B,EAAA+2B,UAAA/2B,EAAA+2B,EAAA,EACA,OAAA/2B,GAGA,QAAAo3B,IAAAp3B,GAEA,IADA,GAAA+2B,GACAA,EAAA/2B,EAAA+2B,UAAA/2B,EAAA+2B,IAAA7pC,OAAA,EACA,OAAA8S,GAwDA,QAAA3K,IAAA2K,GACA,GAAAq3B,GAAA,EACAN,EAAA/2B,EAAA+2B,SACAjnC,EAAAinC,KAAA7pC,MACA,IAAA4C,EACA,OAAAA,GAAA,GAAAunC,GAAAN,EAAAjnC,GAAAjE,UADAwrC,GAAA,CAEAr3B,GAAAnU,MAAAwrC,EAgFA,QAAAC,IAAA/gC,EAAApK,GACA,GAAAoK,IAAApK,EAAA,MAAAoK,EACA,IAAAghC,GAAAhhC,EAAAihC,YACAC,EAAAtrC,EAAAqrC,YACAh7B,EAAA,IAGA,KAFAjG,EAAAghC,EAAAviC,MACA7I,EAAAsrC,EAAAziC,MACAuB,IAAApK,GACAqQ,EAAAjG,EACAA,EAAAghC,EAAAviC,MACA7I,EAAAsrC,EAAAziC,KAEA,OAAAwH,GAuCA,QAAAk7B,IAAAj+B,EAAAs9B,GACA,GAEA/2B,GAEA23B,EACAC,EACA9nC,EACA+L,EAPAxQ,EAAA,GAAAwsC,IAAAp+B,GACAq+B,GAAAr+B,EAAA5N,QAAAR,EAAAQ,MAAA4N,EAAA5N,OAEA8yB,GAAAtzB,EAQA,KAFA,MAAA0rC,MAAAgB,IAEA/3B,EAAA2e,EAAA3pB,OAEA,GADA8iC,IAAA93B,EAAAnU,OAAAmU,EAAAvG,KAAA5N,QACA+rC,EAAAb,EAAA/2B,EAAAvG,SAAAoC,EAAA+7B,EAAA1qC,QAEA,IADA8S,EAAA+2B,SAAA,GAAAxhC,OAAAsG,GACA/L,EAAA+L,EAAA,EAAqB/L,GAAA,IAAQA,EAC7B6uB,EAAA1sB,KAAA0lC,EAAA33B,EAAA+2B,SAAAjnC,GAAA,GAAA+nC,IAAAD,EAAA9nC,KACA6nC,EAAAlpC,OAAAuR,EACA23B,EAAApF,MAAAvyB,EAAAuyB,MAAA,CAKA,OAAAlnC,GAAA2sC,WAAAC,IAGA,QAAAC,MACA,MAAAR,IAAA7tC,MAAAmuC,WAAAG,IAGA,QAAAJ,IAAA7rC,GACA,MAAAA,GAAA6qC,SAGA,QAAAoB,IAAAn4B,GACAA,EAAAvG,KAAAuG,EAAAvG,UAGA,QAAAw+B,IAAAj4B,GACA,GAAAqW,GAAA,CACA,IAAArW,EAAAqW,gBACArW,IAAAvR,SAAAuR,EAAAqW,YAGA,QAAAwhB,IAAAp+B,GACA5P,KAAA4P,OACA5P,KAAA0oC,MACA1oC,KAAAwsB,OAAA,EACAxsB,KAAA4E,OAAA,KAqBA,QAAA2pC,IAAAzjC,GAKA,IAJA,GACAiH,GACA9L,EAFAiP,EAAApK,EAAAzH,OAIA6R,GACAjP,EAAA8G,KAAAyhC,SAAAt5B,IAAA,EACAnD,EAAAjH,EAAAoK,GACApK,EAAAoK,GAAApK,EAAA7E,GACA6E,EAAA7E,GAAA8L,CAGA,OAAAjH,GAeA,QAAA2jC,IAAAC,EAAAjsC,GACA,GAAAwD,GAAAgP,CAEA,IAAA05B,GAAAlsC,EAAAisC,GAAA,OAAAjsC,EAGA,KAAAwD,EAAA,EAAaA,EAAAyoC,EAAArrC,SAAc4C,EAC3B,GAAA2oC,GAAAnsC,EAAAisC,EAAAzoC,KACA0oC,GAAAE,GAAAH,EAAAzoC,GAAAxD,GAAAisC,GACA,OAAAA,EAAAzoC,GAAAxD,EAKA,KAAAwD,EAAA,EAAaA,EAAAyoC,EAAArrC,OAAA,IAAkB4C,EAC/B,IAAAgP,EAAAhP,EAAA,EAAmBgP,EAAAy5B,EAAArrC,SAAc4R,EACjC,GAAA25B,GAAAC,GAAAH,EAAAzoC,GAAAyoC,EAAAz5B,IAAAxS,IACAmsC,GAAAC,GAAAH,EAAAzoC,GAAAxD,GAAAisC,EAAAz5B,KACA25B,GAAAC,GAAAH,EAAAz5B,GAAAxS,GAAAisC,EAAAzoC,KACA0oC,GAAAG,GAAAJ,EAAAzoC,GAAAyoC,EAAAz5B,GAAAxS,GAAAisC,GACA,OAAAA,EAAAzoC,GAAAyoC,EAAAz5B,GAAAxS,EAMA,UAAAb,OAGA,QAAAgtC,IAAAliC,EAAApK,GACA,GAAAysC,GAAAriC,EAAAkR,EAAAtb,EAAAsb,EAAA5B,EAAA1Z,EAAAqJ,EAAAe,EAAAf,EAAAsQ,EAAA3Z,EAAAyL,EAAArB,EAAAqB,CACA,OAAAghC,GAAA,GAAAA,IAAA/yB,IAAAC,IAGA,QAAA+yB,IAAAtiC,EAAApK,GACA,GAAAysC,GAAAriC,EAAAkR,EAAAtb,EAAAsb,EAAA,KAAA5B,EAAA1Z,EAAAqJ,EAAAe,EAAAf,EAAAsQ,EAAA3Z,EAAAyL,EAAArB,EAAAqB,CACA,OAAAghC,GAAA,GAAAA,IAAA/yB,IAAAC,IAGA,QAAA0yB,IAAAjiC,EAAAgiC,GACA,OAAAzoC,GAAA,EAAiBA,EAAAyoC,EAAArrC,SAAc4C,EAC/B,IAAA+oC,GAAAtiC,EAAAgiC,EAAAzoC,IACA,QAGA,UAGA,QAAAgpC,IAAAP,GACA,OAAAA,EAAArrC,QACA,aAAA6rC,IAAAR,EAAA,GACA,cAAAG,IAAAH,EAAA,GAAAA,EAAA,GACA,cAAAI,IAAAJ,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAIA,QAAAQ,IAAAxiC,GACA,OACAf,EAAAe,EAAAf,EACAoC,EAAArB,EAAAqB,EACA6P,EAAAlR,EAAAkR,GAIA,QAAAixB,IAAAniC,EAAApK,GACA,GAAA4xB,GAAAxnB,EAAAf,EAAAwoB,EAAAznB,EAAAqB,EAAAohC,EAAAziC,EAAAkR,EACAirB,EAAAvmC,EAAAqJ,EAAAm9B,EAAAxmC,EAAAyL,EAAAqhC,EAAA9sC,EAAAsb,EACAyxB,EAAAxG,EAAA3U,EAAAob,EAAAxG,EAAA3U,EAAAob,EAAAH,EAAAD,EACAhxB,EAAApR,KAAAiT,KAAAqvB,IAAAC,IACA,QACA3jC,GAAAuoB,EAAA2U,EAAAwG,EAAAlxB,EAAAoxB,GAAA,EACAxhC,GAAAomB,EAAA2U,EAAAwG,EAAAnxB,EAAAoxB,GAAA,EACA3xB,GAAAO,EAAAgxB,EAAAC,GAAA,GAIA,QAAAN,IAAApiC,EAAApK,EAAAqQ,GACA,GAAAuhB,GAAAxnB,EAAAf,EAAAwoB,EAAAznB,EAAAqB,EAAAohC,EAAAziC,EAAAkR,EACAirB,EAAAvmC,EAAAqJ,EAAAm9B,EAAAxmC,EAAAyL,EAAAqhC,EAAA9sC,EAAAsb,EACA4xB,EAAA78B,EAAAhH,EAAA8jC,EAAA98B,EAAA5E,EAAA2hC,EAAA/8B,EAAAiL,EACA+xB,EAAAzb,EAAA2U,EACA+G,EAAA1b,EAAAsb,EACAjkB,EAAA4I,EAAA2U,EACAxd,EAAA6I,EAAAsb,EACAI,EAAAT,EAAAD,EACAW,EAAAJ,EAAAP,EACAY,EAAA7b,IAAAC,IAAAgb,IACAxG,EAAAoH,EAAAlH,IAAAC,IAAAsG,IACAY,EAAAD,EAAAP,IAAAC,IAAAC,IACA/M,EAAAiN,EAAArkB,EAAAokB,EAAArkB,EACAvI,GAAAwI,EAAAykB,EAAA1kB,EAAAqd,IAAA,EAAAhG,GAAAzO,EACAjR,GAAAqI,EAAAukB,EAAAtkB,EAAAukB,GAAAnN,EACA3f,GAAA4sB,EAAAjH,EAAAgH,EAAAK,IAAA,EAAArN,GAAAxO,EACAjR,GAAAysB,EAAAG,EAAAF,EAAAC,GAAAlN,EACAsN,EAAAhtB,IAAAC,IAAA,EACAwrB,EAAA,GAAAS,EAAApsB,EAAAE,EAAAD,EAAAE,GACAzC,EAAAsC,IAAAC,IAAAmsB,IACAvxB,IAAAqyB,GAAAvB,EAAA3hC,KAAAiT,KAAA0uB,IAAA,EAAAuB,EAAAxvB,KAAA,EAAAwvB,GAAAxvB,EAAAiuB,EACA,QACA/iC,EAAAuoB,EAAAnR,EAAAE,EAAArF,EACA7P,EAAAomB,EAAAnR,EAAAE,EAAAtF,EACAA,KAIA,QAAAsyB,IAAAxjC,EAAApK,EAAAqQ,GACA,GAAAw9B,GAAAzjC,EAAAf,EACAykC,EAAA1jC,EAAAqB,EACAsiC,EAAA/tC,EAAAsb,EAAAjL,EAAAiL,EACA0yB,EAAA5jC,EAAAkR,EAAAjL,EAAAiL,EACA5B,EAAA1Z,EAAAqJ,EAAAwkC,EACAl0B,EAAA3Z,EAAAyL,EAAAqiC,EACAG,EAAAv0B,IAAAC,GACA,IAAAs0B,EAAA,CACA,GAAA5kC,GAAA,KAAA2kC,OAAAD,QAAA,EAAAE,GACAxiC,EAAAhB,KAAAiT,KAAAjT,KAAAC,IAAA,IAAAqjC,GAAAC,EAAAC,IAAAD,GAAAC,GAAAD,EAAAD,OAAA,EAAAE,EACA59B,GAAAhH,EAAAwkC,EAAAxkC,EAAAqQ,EAAAjO,EAAAkO,EACAtJ,EAAA5E,EAAAqiC,EAAAzkC,EAAAsQ,EAAAlO,EAAAiO,MAEArJ,GAAAhH,EAAAwkC,EAAAG,EACA39B,EAAA5E,EAAAqiC,EAIA,QAAAI,IAAA9jC,EAAApK,GACA,GAAA0Z,GAAA1Z,EAAAqJ,EAAAe,EAAAf,EACAsQ,EAAA3Z,EAAAyL,EAAArB,EAAAqB,EACAghC,EAAAriC,EAAAkR,EAAAtb,EAAAsb,CACA,OAAAmxB,KAAA,KAAA/yB,IAAAC,IAGA,QAAAw0B,IAAAt6B,GACA,GAAAzJ,GAAAyJ,EAAA3E,EACAlP,EAAA6T,EAAA9U,KAAAmQ,EACAmxB,EAAAj2B,EAAAkR,EAAAtb,EAAAsb,EACA5B,GAAAtP,EAAAf,EAAArJ,EAAAsb,EAAAtb,EAAAqJ,EAAAe,EAAAkR,GAAA+kB,EACA1mB,GAAAvP,EAAAqB,EAAAzL,EAAAsb,EAAAtb,EAAAyL,EAAArB,EAAAkR,GAAA+kB,CACA,OAAA3mB,KAAAC,IAGA,QAAAy0B,IAAAC,GACA3wC,KAAAwR,EAAAm/B,EACA3wC,KAAAqB,KAAA,KACArB,KAAA4wC,SAAA,KAGA,QAAAC,IAAAC,GACA,KAAA9+B,EAAA8+B,EAAAztC,QAAA,QAEA,IAAAqJ,GAAApK,EAAAqQ,EAAAX,EAAA++B,EAAA/Q,EAAA/5B,EAAAgP,EAAAvE,EAAAsgC,EAAAC,CAIA,IADAvkC,EAAAokC,EAAA,GAAApkC,EAAAf,EAAA,EAAAe,EAAAqB,EAAA,IACAiE,EAAA,SAAAtF,GAAAkR,CAIA,IADAtb,EAAAwuC,EAAA,GAAApkC,EAAAf,GAAArJ,EAAAsb,EAAAtb,EAAAqJ,EAAAe,EAAAkR,EAAAtb,EAAAyL,EAAA,IACAiE,EAAA,SAAAtF,GAAAkR,EAAAtb,EAAAsb,CAGAsyB,IAAA5tC,EAAAoK,EAAAiG,EAAAm+B,EAAA,IAGApkC,EAAA,GAAAgkC,IAAAhkC,GAAApK,EAAA,GAAAouC,IAAApuC,GAAAqQ,EAAA,GAAA+9B,IAAA/9B,GACAjG,EAAArL,KAAAsR,EAAAi+B,SAAAtuC,EACAA,EAAAjB,KAAAqL,EAAAkkC,SAAAj+B,EACAA,EAAAtR,KAAAiB,EAAAsuC,SAAAlkC,CAGAwkC,GAAA,IAAAjrC,EAAA,EAAmBA,EAAA+L,IAAO/L,EAAA,CAC1BiqC,GAAAxjC,EAAA8E,EAAAlP,EAAAkP,EAAAmB,EAAAm+B,EAAA7qC,IAAA0M,EAAA,GAAA+9B,IAAA/9B,GAKAsC,EAAA3S,EAAAjB,KAAAqP,EAAAhE,EAAAkkC,SAAAI,EAAA1uC,EAAAkP,EAAAoM,EAAAqzB,EAAAvkC,EAAA8E,EAAAoM,CACA,IACA,GAAAozB,GAAAC,EAAA,CACA,GAAAT,GAAAv7B,EAAAzD,EAAAmB,EAAAnB,GAAA,CACAlP,EAAA2S,EAAAvI,EAAArL,KAAAiB,IAAAsuC,SAAAlkC,IAAAzG,CACA,SAAAirC,GAEAF,GAAA/7B,EAAAzD,EAAAoM,EAAA3I,IAAA5T,SACO,CACP,GAAAmvC,GAAA9/B,EAAAc,EAAAmB,EAAAnB,GAAA,CACA9E,EAAAgE,EAAAhE,EAAArL,KAAAiB,IAAAsuC,SAAAlkC,IAAAzG,CACA,SAAAirC,GAEAD,GAAAvgC,EAAAc,EAAAoM,EAAAlN,IAAAkgC,gBAEK37B,IAAAvE,EAAArP,KAOL,KAJAsR,EAAAi+B,SAAAlkC,EAAAiG,EAAAtR,KAAAiB,EAAAoK,EAAArL,KAAAiB,EAAAsuC,SAAAtuC,EAAAqQ,EAGAo+B,EAAAN,GAAA/jC,IACAiG,IAAAtR,QAAAiB,IACA09B,EAAAyQ,GAAA99B,IAAAo+B,IACArkC,EAAAiG,EAAAo+B,EAAA/Q,EAGA19B,GAAAoK,EAAArL,KAImB,IAAnBqL,GAAApK,EAAAkP,GAAAmB,EAAArQ,GAAmBqQ,IAAAtR,QAAAiB,GAAAoK,EAAAtE,KAAAuK,EAAAnB,EAGnB,KAH2DmB,EAAAw+B,GAAAzkC,GAG3DzG,EAAA,EAAaA,EAAA+L,IAAO/L,EAAAyG,EAAAokC,EAAA7qC,GAAAyG,EAAAf,GAAAgH,EAAAhH,EAAAe,EAAAqB,GAAA4E,EAAA5E,CAEpB,OAAA4E,GAAAiL,EAQA,QAAAwzB,IAAA7kC,GACA,aAAAA,EAAA,KAAA8kC,GAAA9kC,GAGA,QAAA8kC,IAAA9kC,GACA,qBAAAA,GAAA,SAAA3K,MACA,OAAA2K,GAGA,QAAA+kC,MACA,SASA,QAAAC,IAAAlvC,GACA,MAAA0K,MAAAiT,KAAA3d,EAAAL,OAuCA,QAAAwvC,IAAAvf,GACA,gBAAA9b,GACAA,EAAA+2B,WACA/2B,EAAAyH,EAAA7Q,KAAAC,IAAA,GAAAilB,EAAA9b,IAAA,KAKA,QAAAs7B,IAAAC,EAAAhhC,GACA,gBAAAyF,GACA,GAAA+2B,EAAA/2B,EAAA+2B,SAAA,CACA,GAAAA,GACAjnC,EAGAgC,EAFA+J,EAAAk7B,EAAA7pC,OACAua,EAAA8zB,EAAAv7B,GAAAzF,GAAA,CAGA,IAAAkN,EAAA,IAAA3X,EAAA,EAAwBA,EAAA+L,IAAO/L,EAAAinC,EAAAjnC,GAAA2X,IAE/B,IADA3V,EAAA4oC,GAAA3D,GACAtvB,EAAA,IAAA3X,EAAA,EAAwBA,EAAA+L,IAAO/L,EAAAinC,EAAAjnC,GAAA2X,IAC/BzH,GAAAyH,EAAA3V,EAAA2V,IAKA,QAAA+zB,IAAAjhC,GACA,gBAAAyF,GACA,GAAAvR,GAAAuR,EAAAvR,MACAuR,GAAAyH,GAAAlN,EACA9L,IACAuR,EAAAxK,EAAA/G,EAAA+G,EAAA+E,EAAAyF,EAAAxK,EACAwK,EAAApI,EAAAnJ,EAAAmJ,EAAA2C,EAAAyF,EAAApI,IA+EA,QAAA6jC,IAAAvvC,GACA,MAAAA,GAAAyZ,GAGA,QAAA+1B,IAAAxvC,GACA,MAAAA,GAAAyvC,SA8DA,QAAAC,IAAArlC,EAAApK,GACA,MAAAoK,GAAA9H,SAAAtC,EAAAsC,OAAA,IAWA,QAAAotC,IAAAz6B,GACA,GAAA21B,GAAA31B,EAAA21B,QACA,OAAAA,KAAA,GAAA31B,EAAAxF,EAIA,QAAAkgC,IAAA16B,GACA,GAAA21B,GAAA31B,EAAA21B,QACA,OAAAA,OAAA7pC,OAAA,GAAAkU,EAAAxF,EAKA,QAAAmgC,IAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAD,GAAAD,EAAAnsC,EAAAksC,EAAAlsC,EACAmsC,GAAAz/B,GAAA2/B,EACAF,EAAAl0B,GAAAm0B,EACAF,EAAAx/B,GAAA2/B,EACAF,EAAAnW,GAAAoW,EACAD,EAAAl9B,GAAAm9B,EAMA,QAAAE,IAAAh7B,GAMA,IALA,GAIAolB,GAJA0V,EAAA,EACAC,EAAA,EACApF,EAAA31B,EAAA21B,SACAjnC,EAAAinC,EAAA7pC,SAEA4C,GAAA,GACA02B,EAAAuQ,EAAAjnC,GACA02B,EAAAV,GAAAoW,EACA1V,EAAAznB,GAAAm9B,EACAA,GAAA1V,EAAAze,GAAAo0B,GAAA3V,EAAAhqB,GAMA,QAAA6/B,IAAAC,EAAAl7B,EAAAm7B,GACA,MAAAD,GAAA/lC,EAAA9H,SAAA2S,EAAA3S,OAAA6tC,EAAA/lC,EAAAgmC,EAGA,QAAAC,IAAAx8B,EAAAlQ,GACAjG,KAAAwR,EAAA2E,EACAnW,KAAA4E,OAAA,KACA5E,KAAAktC,SAAA,KACAltC,KAAAiwC,EAAA,KACAjwC,KAAA0M,EAAA1M,KACAA,KAAAi8B,EAAA,EACAj8B,KAAAkV,EAAA,EACAlV,KAAA2S,EAAA,EACA3S,KAAAke,EAAA,EACAle,KAAA+R,EAAA,KACA/R,KAAAiG,IAKA,QAAA2sC,IAAApxC,GASA,IARA,GACA2U,GAEA23B,EACAZ,EACAjnC,EACA+L,EANA0hB,EAAA,GAAAif,IAAAnxC,EAAA,GAEAszB,GAAApB,GAMAvd,EAAA2e,EAAA3pB,OACA,GAAA+hC,EAAA/2B,EAAA3E,EAAA07B,SAEA,IADA/2B,EAAA+2B,SAAA,GAAAxhC,OAAAsG,EAAAk7B,EAAA7pC,QACA4C,EAAA+L,EAAA,EAAqB/L,GAAA,IAAQA,EAC7B6uB,EAAA1sB,KAAA0lC,EAAA33B,EAAA+2B,SAAAjnC,GAAA,GAAA0sC,IAAAzF,EAAAjnC,OACA6nC,EAAAlpC,OAAAuR,CAMA,QADAud,EAAA9uB,OAAA,GAAA+tC,IAAA,SAAAzF,UAAAxZ,GACAA,EA8JA,QAAAmf,IAAAC,EAAAluC,EAAAovB,EAAAC,EAAAC,EAAAC,GAkBA,IAjBA,GAEAd,GACA0f,EAIA/2B,EAAAC,EAEA+2B,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAfA/f,KACAuB,EAAAlwB,EAAAsoC,SAGAqG,EAAA,EACAC,EAAA,EACAxhC,EAAA8iB,EAAAzxB,OAEArB,EAAA4C,EAAA5C,MASAuxC,EAAAvhC,GAAA,CACAgK,EAAAkY,EAAAF,EAAA/X,EAAAkY,EAAAF,CAGA,IAAA+e,EAAAle,EAAA0e,KAAAxxC,aAAoCgxC,GAAAQ,EAAAxhC,EAOpC,KANAihC,EAAAC,EAAAF,EACAK,EAAAtmC,KAAAC,IAAAiP,EAAAD,IAAAC,IAAAja,EAAA8wC,GACAQ,EAAAN,IAAAK,EACAD,EAAArmC,KAAAC,IAAAkmC,EAAAI,IAAAL,GAGUO,EAAAxhC,IAAQwhC,EAAA,CAMlB,GALAR,GAAAD,EAAAje,EAAA0e,GAAAxxC,MACA+wC,EAAAE,MAAAF,GACAA,EAAAG,MAAAH,GACAO,EAAAN,IAAAK,GACAF,EAAApmC,KAAAC,IAAAkmC,EAAAI,IAAAL,IACAG,EAAA,CAAgCJ,GAAAD,CAAuB,OACvDK,EAAAD,EAIA5f,EAAAnrB,KAAAirB,GAAqBrxB,MAAAgxC,EAAAS,KAAAz3B,EAAAC,EAAAixB,SAAApY,EAAAtrB,MAAA+pC,EAAAC,KACrBngB,EAAAogB,KAAAC,GAAArgB,EAAAW,EAAAC,EAAAC,EAAAlyB,EAAAiyB,GAAAhY,EAAA+2B,EAAAhxC,EAAAmyB,GACAwf,GAAAtgB,EAAAW,EAAAC,EAAAjyB,EAAAgyB,GAAAhY,EAAAg3B,EAAAhxC,EAAAkyB,EAAAC,GACAnyB,GAAAgxC,EAAAO,EAAAC,EAGA,MAAAjgB,GA2OA,QAAAqgB,IAAAlnC,EAAApK,GACA,MAAAoK,GAAA,GAAApK,EAAA,IAAAoK,EAAA,GAAApK,EAAA,GAMA,QAAAuxC,IAAA1U,GAKA,OAJAntB,GAAAmtB,EAAA97B,OACAywC,GAAA,KACA5L,EAAA,EAEAjiC,EAAA,EAAiBA,EAAA+L,IAAO/L,EAAA,CACxB,KAAAiiC,EAAA,GAAA6L,GAAA5U,EAAA2U,EAAA5L,EAAA,IAAA/I,EAAA2U,EAAA5L,EAAA,IAAA/I,EAAAl5B,KAAA,KAAAiiC,CACA4L,GAAA5L,KAAAjiC,EAGA,MAAA6tC,GAAAtqC,MAAA,EAAA0+B,GA4EA,QAAA8L,IAAA9L,GACAloC,KAAAi0C,MAAA/L,EACAloC,KAAA6kB,MACA7kB,KAAA2D,OAAA,KACA3D,KAAAk0C,UACAl0C,KAAAm0C,SACAn0C,KAAAo0C,SACAp0C,KAAAq0C,QACAr0C,KAAAs0C,OACAt0C,KAAAu0C,OAAA,EAmCA,QAAAC,IAAArxB,GACA,IAAAA,EAAAoxB,OACA,IAASE,GAAAtxB,GACT,MAAAlb,GACA,GAAAkb,EAAA+wB,OAAA/wB,EAAAmxB,OAAAnxB,EAAAkxB,QAAA,GAAAK,GAAAvxB,EAAAlb,OACA,KAAAkb,EAAAgxB,MAAA,KAAAlsC,IAKA,QAAAwsC,IAAAtxB,GACA,KAAAA,EAAAoxB,OAAApxB,EAAAixB,UAAAjxB,EAAAkxB,QAAAlxB,EAAA8wB,OAAA,CACA,GAAAhuC,GAAAkd,EAAAmxB,OAAAnxB,EAAAkxB,QACAtiC,EAAAoR,EAAA+wB,OAAAjuC,GACAgP,EAAAlD,EAAA1O,OAAA,EACAsP,EAAAZ,EAAAkD,EACAlD,GAAAkD,GAAA+O,GAAAb,EAAAld,KACAkd,EAAAixB,WAAAjxB,EAAAkxB,QACAtiC,EAAAY,EAAA3N,MAAA,KAAA+M,GACAoR,EAAA+wB,OAAAjuC,KACAkd,EAAA+wB,OAAAjuC,GAAA8L,GAAA4iC,KAIA,QAAA3wB,IAAAb,EAAAld,GACA,gBAAAgC,EAAA2V,GACAuF,EAAA+wB,OAAAjuC,OACAkd,EAAAkxB,UAAAlxB,EAAAmxB,OACAnxB,EAAA+wB,OAAAjuC,GAAA,KACA,MAAAkd,EAAAxf,SACA,MAAAsE,EACAysC,GAAAvxB,EAAAlb,IAEAkb,EAAAgxB,MAAAluC,GAAA2X,EACAuF,EAAAixB,SAAAI,GAAArxB,GACAyxB,GAAAzxB,OAKA,QAAAuxB,IAAAvxB,EAAAlb,GACA,GAAA8J,GAAA9L,EAAAkd,EAAA+wB,OAAA7wC,MAKA,KAJA8f,EAAAxf,OAAAsE,EACAkb,EAAAgxB,UAAAnf,GACA7R,EAAAixB,SAAAv9B,MAEA5Q,GAAA,GACA,IAAA8L,EAAAoR,EAAA+wB,OAAAjuC,MACAkd,EAAA+wB,OAAAjuC,GAAA,KACA8L,EAAA2iC,OACA,IAAa3iC,EAAA2iC,QACb,MAAAzsC,IAKAkb,EAAAkxB,QAAAx9B,IACA+9B,GAAAzxB,GAGA,QAAAyxB,IAAAzxB,GACA,IAAAA,EAAAkxB,SAAAlxB,EAAA0B,MAAA,CACA,GAAAxiB,GAAA8gB,EAAAgxB,KACAhxB,GAAAgxB,UAAAnf,GACA7R,EAAA0B,MAAA1B,EAAAxf,OAAAtB,IAIA,QAAAwyC,IAAAC,GACA,SAAAA,IAAAlvB,QACA,OAAAkvB,OAAA,YAAAlzC,OAAA,sBACA,WAAAoyC,IAAAc,GA6OA,QAAAC,IAAAliC,GACA,gBAAApS,EAAAu0C,GACAniC,EAAA,MAAApS,EAAAu0C,EAAA,OAIA,QAAAC,IAAAD,GACA,GAAAviC,GAAAuiC,EAAAE,YACA,OAAAziC,IAAA,SAAAA,EACAuiC,EAAAG,SACAH,EAAAI,aA0CA,QAAAC,IAAA3yB,EAAA2Q,GACA,gBAAAiiB,GACA,MAAA5yB,GAAA4yB,EAAAF,aAAA/hB,IAeA,QAAAkiB,IAAAlmC,GAOA,QAAApB,GAAA5L,GACA,GAAAkU,GAAAlU,EAAA,GAAA4D,EAAA2B,EAAA8K,IAAA6D,EACA,KAAAtQ,EAAA,CACA,GAAAuvC,IAAAC,GAAA,MAAAD,EACA5tC,GAAAgL,IAAA2D,EAAAtQ,EAAA6I,EAAA1G,KAAA/F,IAEA,MAAAgN,IAAApJ,EAAA,GAAAoJ,EAAAhM,QAZA,GAAAuE,GAAA2qB,KACAzjB,KACA0mC,EAAAC,EAoCA,OAlCApmC,GAAA,MAAAA,KAAAqmC,GAAA70C,KAAAwO,GAWApB,EAAAa,OAAA,SAAA0C,GACA,IAAApO,UAAAC,OAAA,MAAAyL,GAAAtF,OACAsF,MAAAlH,EAAA2qB,IAEA,KADA,GAAAlwB,GAAAkU,EAAAtQ,GAAA,EAAA+L,EAAAR,EAAAnO,SACA4C,EAAA+L,GAAApK,EAAA+tC,IAAAp/B,GAAAlU,EAAAmP,EAAAvL,IAAA,KAAA2B,EAAAgL,IAAA2D,EAAAzH,EAAA1G,KAAA/F,GACA,OAAA4L,IAGAA,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAgM,EAAAqmC,GAAA70C,KAAA2Q,GAAAvD,GAAAoB,EAAA7F,SAGAyE,EAAAunC,QAAA,SAAAhkC,GACA,MAAApO,WAAAC,QAAAmyC,EAAAhkC,EAAAvD,GAAAunC,GAGAvnC,EAAA1E,KAAA,WACA,MAAAgsC,MACAzmC,UACAO,SACAmmC,YAGAvnC,EAGA,QAAA2nC,MAcA,QAAAC,KACA,GAAA7jC,GAAAlD,IAAAzL,OACAogC,EAAAp0B,EAAA,GAAAA,EAAA,GACAzC,EAAAyC,EAAAo0B,EAAA,GACA52B,EAAAwC,EAAA,EAAAo0B,EACA32B,IAAAD,EAAAD,GAAAG,KAAAC,IAAA,EAAAgF,EAAA8jC,EAAA,EAAAC,GACA1nC,IAAAvB,EAAAC,KAAAG,MAAAJ,IACAF,IAAAC,EAAAD,EAAAE,GAAAkF,EAAA8jC,IAAA/f,EACA3nB,EAAAtB,GAAA,EAAAgpC,GACAznC,IAAAzB,EAAAG,KAAAsB,MAAAzB,GAAAwB,EAAArB,KAAAsB,MAAAD,GACA,IAAAM,GAAAu0B,GAAAjxB,GAAAO,IAAA,SAAAtM,GAA8C,MAAA2G,GAAAE,EAAA7G,GAC9C,OAAA+vC,GAAAvS,EAAA/0B,EAAA+0B,UAAA/0B,GAxBA,GAIA5B,GACAsB,EALAH,EAAAsnC,KAAAC,YAAAxgB,IACAlmB,EAAAb,EAAAa,OACAknC,EAAA/nC,EAAAoB,MACAA,GAAA,KAGAhB,GAAA,EACAynC,EAAA,EACAC,EAAA,EACAhgB,EAAA,EAoEA,cAlEA9nB,GAAAunC,QAgBAvnC,EAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAAyL,EAAA0C,GAAAqkC,KAAA/mC,KAGAb,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAgM,IAAAmC,EAAA,IAAAA,EAAA,IAAAqkC,KAAAxmC,EAAA7F,SAGAyE,EAAAgoC,WAAA,SAAAzkC,GACA,MAAAnC,KAAAmC,EAAA,IAAAA,EAAA,IAAAnD,GAAA,EAAAwnC,KAGA5nC,EAAAG,UAAA,WACA,MAAAA,IAGAH,EAAAnB,KAAA,WACA,MAAAA,IAGAmB,EAAAI,MAAA,SAAAmD,GACA,MAAApO,WAAAC,QAAAgL,IAAAmD,EAAAqkC,KAAAxnC,GAGAJ,EAAAyjC,QAAA,SAAAlgC,GACA,MAAApO,WAAAC,QAAAyyC,EAAAC,EAAAhpC,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAA9M,IAAAqkC,KAAAC,GAGA7nC,EAAA6nC,aAAA,SAAAtkC,GACA,MAAApO,WAAAC,QAAAyyC,EAAA/oC,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAA9M,IAAAqkC,KAAAC,GAGA7nC,EAAA8nC,aAAA,SAAAvkC,GACA,MAAApO,WAAAC,QAAA0yC,EAAAhpC,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAA9M,IAAAqkC,KAAAE,GAGA9nC,EAAA8nB,MAAA,SAAAvkB,GACA,MAAApO,WAAAC,QAAA0yB,EAAAhpB,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAA9M,IAAAqkC,KAAA9f,GAGA9nB,EAAA1E,KAAA,WACA,MAAAqsC,MACA9mC,YACAO,SACAhB,SACAynC,gBACAC,gBACAhgB,UAGA8f,IAGA,QAAAK,IAAAjoC,GACA,GAAA1E,GAAA0E,EAAA1E,IAUA,OARA0E,GAAAyjC,QAAAzjC,EAAA8nC,mBACA9nC,GAAA6nC,mBACA7nC,GAAA8nC,aAEA9nC,EAAA1E,KAAA,WACA,MAAA2sC,IAAA3sC,MAGA0E,EAGA,QAAAkoC,MACA,MAAAD,IAAAN,KAAAE,aAAA,IAeA,QAAAM,IAAA1pC,EAAApK,GACA,OAAAA,GAAAoK,MACA,SAAAf,GAAqB,OAAAA,EAAAe,GAAApK,GACrB+zC,GAAA/zC,GAGA,QAAAg0C,IAAAC,GACA,gBAAA7pC,EAAApK,GACA,GAAAD,GAAAk0C,EAAA7pC,KAAApK,KACA,iBAAAqJ,GAAwB,MAAAA,IAAAe,EAAA,EAAAf,GAAArJ,EAAA,EAAAD,EAAAsJ,KAIxB,QAAA6qC,IAAAC,GACA,gBAAA/pC,EAAApK,GACA,GAAAsb,GAAA64B,EAAA/pC,KAAApK,KACA,iBAAAyP,GAAwB,MAAAA,IAAA,EAAArF,EAAAqF,GAAA,EAAAzP,EAAAsb,EAAA7L,KAIxB,QAAA2kC,IAAA5nC,EAAAO,EAAAknC,EAAAE,GACA,GAAAE,GAAA7nC,EAAA,GAAAihC,EAAAjhC,EAAA,GAAAm8B,EAAA57B,EAAA,GAAA8/B,EAAA9/B,EAAA,EAGA,OAFA0gC,GAAA4G,KAAAJ,EAAAxG,EAAA4G,GAAA1L,EAAAwL,EAAAtH,EAAAlE,KACA0L,EAAAJ,EAAAI,EAAA5G,GAAA9E,EAAAwL,EAAAxL,EAAAkE,IACA,SAAAxjC,GAAsB,MAAAs/B,GAAA0L,EAAAhrC,KAGtB,QAAAirC,IAAA9nC,EAAAO,EAAAknC,EAAAE,GACA,GAAAxhC,GAAAlI,KAAAuR,IAAAxP,EAAAzL,OAAAgM,EAAAhM,QAAA,EACAhB,EAAA,GAAAqJ,OAAAuJ,GACA2I,EAAA,GAAAlS,OAAAuJ,GACAhP,GAAA,CAQA,KALA6I,EAAAmG,GAAAnG,EAAA,KACAA,IAAAtF,QAAAi6B,UACAp0B,IAAA7F,QAAAi6B,aAGAx9B,EAAAgP,GACA5S,EAAA4D,GAAAswC,EAAAznC,EAAA7I,GAAA6I,EAAA7I,EAAA,IACA2X,EAAA3X,GAAAwwC,EAAApnC,EAAApJ,GAAAoJ,EAAApJ,EAAA,GAGA,iBAAA0F,GACA,GAAA1F,GAAA4wC,GAAA/nC,EAAAnD,EAAA,EAAAsJ,GAAA,CACA,OAAA2I,GAAA3X,GAAA5D,EAAA4D,GAAA0F,KAIA,QAAApC,IAAAhJ,EAAAsb,GACA,MAAAA,GACA/M,OAAAvO,EAAAuO,UACAO,MAAA9O,EAAA8O,SACAowB,YAAAl/B,EAAAk/B,eACAqX,MAAAv2C,EAAAu2C,SAKA,QAAAC,IAAAR,EAAAE,GASA,QAAAZ,KAGA,MAFAmB,GAAAjqC,KAAAuR,IAAAxP,EAAAzL,OAAAgM,EAAAhM,QAAA,EAAAuzC,GAAAF,GACA5pB,EAAAoE,EAAA,KACAjjB,EAGA,QAAAA,GAAAtC,GACA,OAAAmhB,MAAAkqB,EAAAloC,EAAAO,EAAAynC,EAAAR,GAAAC,KAAA9W,MAAA9zB,GAfA,GAIAqrC,GACAlqB,EACAoE,EANApiB,EAAAmoC,GACA5nC,EAAA4nC,GACAxX,EAAAtO,GACA2lB,GAAA,CAuCA,OAxBA7oC,GAAAuwB,OAAA,SAAAzwB,GACA,OAAAmjB,MAAA8lB,EAAA3nC,EAAAP,EAAAsnC,GAAAU,EAAAN,GAAAC,SAAA1oC,IAGAE,EAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAAyL,EAAAooC,GAAAr2C,KAAA2Q,EAAA2lC,IAAAtB,KAAA/mC,EAAAtF,SAGAyE,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAgM,EAAAqmC,GAAA70C,KAAA2Q,GAAAqkC,KAAAxmC,EAAA7F,SAGAyE,EAAAgoC,WAAA,SAAAzkC,GACA,MAAAnC,GAAAqmC,GAAA70C,KAAA2Q,GAAAiuB,EAAA2X,GAAAvB,KAGA5nC,EAAA6oC,MAAA,SAAAtlC,GACA,MAAApO,WAAAC,QAAAyzC,IAAAtlC,EAAAqkC,KAAAiB,GAGA7oC,EAAAwxB,YAAA,SAAAjuB,GACA,MAAApO,WAAAC,QAAAo8B,EAAAjuB,EAAAqkC,KAAApW,GAGAoW,IAgCA,QAAAwB,IAAAppC,GACA,GAAAa,GAAAb,EAAAa,MAmDA,OAjDAb,GAAAW,MAAA,SAAApD,GACA,GAAAnJ,GAAAyM,GACA,OAAAF,IAAAvM,EAAA,GAAAA,IAAAgB,OAAA,SAAAmI,EAAA,GAAAA,IAGAyC,EAAAe,WAAA,SAAAxD,EAAAkqB,GACA,MAAA1mB,IAAAF,IAAAtD,EAAAkqB,IAGAznB,EAAAqpC,KAAA,SAAA9rC,GACA,MAAAA,MAAA,GAEA,IAKAsB,GALAzK,EAAAyM,IACAykC,EAAA,EACAC,EAAAnxC,EAAAgB,OAAA,EACAuJ,EAAAvK,EAAAkxC,GACA1mC,EAAAxK,EAAAmxC,EA8BA,OA3BA3mC,GAAAD,IACAE,EAAAF,IAAAC,IAAAC,EACAA,EAAAymC,IAAAC,IAAA1mC,GAGAA,EAAAH,EAAAC,EAAAC,EAAArB,GAEAsB,EAAA,GACAF,EAAAG,KAAAG,MAAAN,EAAAE,KACAD,EAAAE,KAAAs2B,KAAAx2B,EAAAC,KACAA,EAAAH,EAAAC,EAAAC,EAAArB,IACKsB,EAAA,IACLF,EAAAG,KAAAs2B,KAAAz2B,EAAAE,KACAD,EAAAE,KAAAG,MAAAL,EAAAC,KACAA,EAAAH,EAAAC,EAAAC,EAAArB,IAGAsB,EAAA,GACAzK,EAAAkxC,GAAAxmC,KAAAG,MAAAN,EAAAE,KACAzK,EAAAmxC,GAAAzmC,KAAAs2B,KAAAx2B,EAAAC,KACAgC,EAAAzM,IACKyK,EAAA,IACLzK,EAAAkxC,GAAAxmC,KAAAs2B,KAAAz2B,EAAAE,KACAzK,EAAAmxC,GAAAzmC,KAAAG,MAAAL,EAAAC,KACAgC,EAAAzM,IAGA4L,GAGAA,EAGA,QAAAspC,MACA,GAAAtpC,GAAA8oC,GAAAX,GAAAhzB,GAMA,OAJAnV,GAAA1E,KAAA,WACA,MAAAA,IAAA0E,EAAAspC,OAGAF,GAAAppC,GAGA,QAAAupC,MAGA,QAAAvpC,GAAAtC,GACA,OAAAA,EAHA,GAAAmD,IAAA,IAgBA,OAVAb,GAAAuwB,OAAAvwB,EAEAA,EAAAa,OAAAb,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAyL,EAAAooC,GAAAr2C,KAAA2Q,EAAA2lC,IAAAlpC,GAAAa,EAAAtF,SAGAyE,EAAA1E,KAAA,WACA,MAAAiuC,MAAA1oC,WAGAuoC,GAAAppC,GAsBA,QAAAsoC,IAAA7pC,EAAApK,GACA,OAAAA,EAAAyK,KAAAI,IAAA7K,EAAAoK,IACA,SAAAf,GAAqB,MAAAoB,MAAAI,IAAAxB,EAAAe,GAAApK,GACrB+zC,GAAA/zC,GAGA,QAAAm1C,IAAA/qC,EAAApK,GACA,MAAAoK,GAAA,EACA,SAAAqF,GAAqB,OAAAhF,KAAAM,KAAA/K,EAAAyP,GAAAhF,KAAAM,KAAAX,EAAA,EAAAqF,IACrB,SAAAA,GAAqB,MAAAhF,MAAAM,IAAA/K,EAAAyP,GAAAhF,KAAAM,IAAAX,EAAA,EAAAqF,IAGrB,QAAA2lC,IAAA/rC,GACA,MAAAoF,UAAApF,KAAA,KAAAA,KAAA,IAAAA,EAGA,QAAAgsC,IAAAC,GACA,YAAAA,EAAAF,GACAE,IAAA7qC,KAAAyT,EAAAzT,KAAA4W,IACA,SAAAhY,GAAqB,MAAAoB,MAAAM,IAAAuqC,EAAAjsC,IAGrB,QAAAksC,IAAAD,GACA,MAAAA,KAAA7qC,KAAAyT,EAAAzT,KAAAI,IACA,KAAAyqC,GAAA7qC,KAAA+qC,OACA,IAAAF,GAAA7qC,KAAAgrC,OACAH,EAAA7qC,KAAAI,IAAAyqC,GAAA,SAAAjsC,GAA8C,MAAAoB,MAAAI,IAAAxB,GAAAisC,IAG9C,QAAAI,IAAAzrC,GACA,gBAAAZ,GACA,OAAAY,GAAAZ,IAIA,QAAAssC,MAOA,QAAApC,KAGA,MAFAqC,GAAAL,GAAAD,GAAAO,EAAAR,GAAAC,GACA9oC,IAAA,OAAAopC,EAAAF,GAAAE,GAAAC,EAAAH,GAAAG,IACAlqC,EATA,GAAAA,GAAA8oC,GAAAR,GAAAkB,IAAA3oC,QAAA,OACAA,EAAAb,EAAAa,OACA8oC,EAAA,GACAM,EAAAL,GAAA,IACAM,EAAAR,GAAA,GAgFA,OAxEA1pC,GAAA2pC,KAAA,SAAApmC,GACA,MAAApO,WAAAC,QAAAu0C,GAAApmC,EAAAqkC,KAAA+B,GAGA3pC,EAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAAyL,EAAA0C,GAAAqkC,KAAA/mC,KAGAb,EAAAW,MAAA,SAAApD,GACA,GAGAoS,GAHAvb,EAAAyM,IACAwqB,EAAAj3B,EAAA,GACAkV,EAAAlV,IAAAgB,OAAA,IAGAua,EAAArG,EAAA+hB,KAAArzB,EAAAqzB,IAAA/hB,IAAAtR,EAEA,IAEAxD,GACAiO,EACAqB,EAJA9L,EAAAiyC,EAAA5e,GACArkB,EAAAijC,EAAA3gC,GAIAvF,EAAA,MAAAxG,EAAA,IAAAA,EACAywB,IAEA,MAAA2b,EAAA,IAAA3iC,EAAAhP,EAAA+L,GAEA,GADA/L,EAAA8G,KAAAsB,MAAApI,GAAA,EAAAgP,EAAAlI,KAAAsB,MAAA4G,GAAA,EACAqkB,EAAA,QAAuBrzB,EAAAgP,IAAOhP,EAC9B,IAAAyK,EAAA,EAAAjO,EAAA01C,EAAAlyC,GAAgCyK,EAAAknC,IAAUlnC,EAE1C,MADAqB,EAAAtP,EAAAiO,GACA4oB,GAAA,CACA,GAAAvnB,EAAAwF,EAAA,KACA0kB,GAAA7zB,KAAA2J,QAEO,MAAY9L,EAAAgP,IAAOhP,EAC1B,IAAAyK,EAAAknC,EAAA,EAAAn1C,EAAA01C,EAAAlyC,GAAuCyK,GAAA,IAAQA,EAE/C,MADAqB,EAAAtP,EAAAiO,GACA4oB,GAAA,CACA,GAAAvnB,EAAAwF,EAAA,KACA0kB,GAAA7zB,KAAA2J,QAIAkqB,GAAArtB,GAAA3I,EAAAgP,EAAAlI,KAAAuR,IAAArJ,EAAAhP,EAAA+L,IAAAO,IAAA4lC,EAGA,OAAAv6B,GAAAqe,EAAAwH,UAAAxH,GAGAhuB,EAAAe,WAAA,SAAAxD,EAAAkqB,GAGA,GAFA,MAAAA,MAAA,KAAAkiB,EAAA,WACA,kBAAAliB,OAAAj2B,EAAAsP,OAAA2mB,IACAlqB,IAAAoa,IAAA,MAAA8P,EACA,OAAAlqB,MAAA,GACA,IAAAkF,GAAA3D,KAAAC,IAAA,EAAA4qC,EAAApsC,EAAAyC,EAAAW,QAAAvL,OACA,iBAAAhB,GACA,GAAA4D,GAAA5D,EAAA81C,EAAAprC,KAAAsB,MAAA6pC,EAAA71C,IAEA,OADA4D,GAAA2xC,IAAA,KAAA3xC,GAAA2xC,GACA3xC,GAAAyK,EAAAglB,EAAArzB,GAAA,KAIA4L,EAAAqpC,KAAA,WACA,MAAAxoC,GAAAwoC,GAAAxoC,KACA5B,MAAA,SAAAvB,GAA0B,MAAAwsC,GAAAprC,KAAAG,MAAAgrC,EAAAvsC,MAC1B03B,KAAA,SAAA13B,GAAyB,MAAAwsC,GAAAprC,KAAAs2B,KAAA6U,EAAAvsC,UAIzBsC,EAAA1E,KAAA,WACA,MAAAA,IAAA0E,EAAAgqC,KAAAL,UAGA3pC,EAGA,QAAAmqC,IAAAzsC,EAAA0sC,GACA,MAAA1sC,GAAA,GAAAoB,KAAAM,KAAA1B,EAAA0sC,GAAAtrC,KAAAM,IAAA1B,EAAA0sC,GAGA,QAAAC,MAKA,QAAA/B,GAAA7pC,EAAApK,GACA,OAAAA,EAAA81C,GAAA91C,EAAA+1C,IAAA3rC,EAAA0rC,GAAA1rC,EAAA2rC,KACA,SAAA1sC,GAAuB,OAAAysC,GAAAzsC,EAAA0sC,GAAA3rC,GAAApK,GACvB+zC,GAAA/zC,GAGA,QAAA8gB,GAAA1W,EAAApK,GAEA,MADAA,GAAA81C,GAAA91C,EAAA+1C,IAAA3rC,EAAA0rC,GAAA1rC,EAAA2rC,IACA,SAAAtmC,GAAwB,MAAAqmC,IAAA1rC,EAAApK,EAAAyP,EAAA,EAAAsmC,IAZxB,GAAAA,GAAA,EACApqC,EAAA8oC,GAAAR,EAAAnzB,GACAtU,EAAAb,EAAAa,MAqBA,OARAb,GAAAoqC,SAAA,SAAA7mC,GACA,MAAApO,WAAAC,QAAAg1C,GAAA7mC,EAAA1C,QAAAupC,GAGApqC,EAAA1E,KAAA,WACA,MAAAA,IAAA0E,EAAAqqC,KAAAD,cAGAhB,GAAAppC,GAGA,QAAAsqC,MACA,MAAAD,MAAAD,SAAA,IAGA,QAAAG,MAKA,QAAA3C,KACA,GAAA5vC,GAAA,EAAA+L,EAAAjF,KAAAC,IAAA,EAAAqC,EAAAhM,OAEA,KADAo1C,EAAA,GAAA/sC,OAAAsG,EAAA,KACA/L,EAAA+L,GAAAymC,EAAAxyC,EAAA,GAAAyyC,GAAA5pC,EAAA7I,EAAA+L,EACA,OAAA/D,GAGA,QAAAA,GAAAtC,GACA,IAAA0V,MAAA1V,MAAA,MAAA0D,GAAAwnC,GAAA4B,EAAA9sC,IAZA,GAAAmD,MACAO,KACAopC,IA2CA,OA9BAxqC,GAAA0qC,aAAA,SAAA5qC,GACA,GAAA9H,GAAAoJ,EAAA1G,QAAAoF,EACA,OAAA9H,GAAA,GAAA4Q,UACA5Q,EAAA,EAAAwyC,EAAAxyC,EAAA,GAAA6I,EAAA,GACA7I,EAAAwyC,EAAAp1C,OAAAo1C,EAAAxyC,GAAA6I,IAAAzL,OAAA,KAIA4K,EAAAa,OAAA,SAAA0C,GACA,IAAApO,UAAAC,OAAA,MAAAyL,GAAAtF,OACAsF,KACA,QAAAzM,GAAA4D,EAAA,EAAA+L,EAAAR,EAAAnO,OAAoC4C,EAAA+L,IAAO/L,EAAA,OAAA5D,EAAAmP,EAAAvL,KAAAob,MAAAhf,OAAAyM,EAAA1G,KAAA/F,EAE3C,OADAyM,GAAA8pC,KAAApsC,IACAqpC,KAGA5nC,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAgM,EAAAqmC,GAAA70C,KAAA2Q,GAAAqkC,KAAAxmC,EAAA7F,SAGAyE,EAAA4qC,UAAA,WACA,MAAAJ,GAAAjvC,SAGAyE,EAAA1E,KAAA,WACA,MAAAivC,MACA1pC,UACAO,UAGApB,EAGA,QAAA6qC,MAOA,QAAA7qC,GAAAtC,GACA,GAAAA,KAAA,MAAA0D,GAAAwnC,GAAA/nC,EAAAnD,EAAA,EAAAqG,IAGA,QAAA6jC,KACA,GAAA5vC,IAAA,CAEA,KADA6I,EAAA,GAAApD,OAAAsG,KACA/L,EAAA+L,GAAAlD,EAAA7I,OAAA,GAAAiuB,GAAAjuB,EAAA+L,GAAAgiB,IAAAhiB,EAAA,EACA,OAAA/D,GAdA,GAAA+lB,GAAA,EACAE,EAAA,EACAliB,EAAA,EACAlD,GAAA,IACAO,GAAA,IAmCA,OAtBApB,GAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAA2wB,GAAAxiB,EAAA,GAAA0iB,GAAA1iB,EAAA,GAAAqkC,MAAA7hB,EAAAE,IAGAjmB,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAA2O,GAAA3C,EAAAqmC,GAAA70C,KAAA2Q,IAAAnO,OAAA,EAAAwyC,KAAAxmC,EAAA7F,SAGAyE,EAAA0qC,aAAA,SAAA5qC,GACA,GAAA9H,GAAAoJ,EAAA1G,QAAAoF,EACA,OAAA9H,GAAA,GAAA4Q,SACA5Q,EAAA,GAAA+tB,EAAAllB,EAAA,IACA7I,GAAA+L,GAAAlD,EAAAkD,EAAA,GAAAkiB,IACAplB,EAAA7I,EAAA,GAAA6I,EAAA7I,KAGAgI,EAAA1E,KAAA,WACA,MAAAuvC,MACAhqC,QAAAklB,EAAAE,IACA7kB,UAGAgoC,GAAAppC,GAGA,QAAA8qC,MAKA,QAAA9qC,GAAAtC,GACA,GAAAA,KAAA,MAAA0D,GAAAwnC,GAAA/nC,EAAAnD,EAAA,EAAAqG,IALA,GAAAlD,IAAA,IACAO,GAAA,KACA2C,EAAA,CAyBA,OAnBA/D,GAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAAyL,EAAA4mC,GAAA70C,KAAA2Q,GAAAQ,EAAAjF,KAAAuR,IAAAxP,EAAAzL,OAAAgM,EAAAhM,OAAA,GAAA4K,GAAAa,EAAAtF,SAGAyE,EAAAoB,MAAA,SAAAmC,GACA,MAAApO,WAAAC,QAAAgM,EAAAqmC,GAAA70C,KAAA2Q,GAAAQ,EAAAjF,KAAAuR,IAAAxP,EAAAzL,OAAAgM,EAAAhM,OAAA,GAAA4K,GAAAoB,EAAA7F,SAGAyE,EAAA0qC,aAAA,SAAA5qC,GACA,GAAA9H,GAAAoJ,EAAA1G,QAAAoF,EACA,QAAAe,EAAA7I,EAAA,GAAA6I,EAAA7I,KAGAgI,EAAA1E,KAAA,WACA,MAAAwvC,MACAjqC,UACAO,UAGApB,EAMA,QAAA+qC,IAAAC,EAAAC,EAAA1tC,EAAA2tC,GAEA,QAAAnzB,GAAAozB,GACA,MAAAH,GAAAG,EAAA,GAAAC,OAAAD,MA2DA,MAxDApzB,GAAA9Y,MAAA8Y,EAEAA,EAAAqd,KAAA,SAAA+V,GACA,MAAAH,GAAAG,EAAA,GAAAC,MAAAD,EAAA,IAAAF,EAAAE,EAAA,GAAAH,EAAAG,MAGApzB,EAAA3X,MAAA,SAAA+qC,GACA,GAAAzC,GAAA3wB,EAAAozB,GACArJ,EAAA/pB,EAAAqd,KAAA+V,EACA,OAAAA,GAAAzC,EAAA5G,EAAAqJ,EAAAzC,EAAA5G,GAGA/pB,EAAA7X,OAAA,SAAAirC,EAAAtsC,GACA,MAAAosC,GAAAE,EAAA,GAAAC,OAAAD,GAAA,MAAAtsC,EAAA,EAAAC,KAAAG,MAAAJ,IAAAssC,GAGApzB,EAAA3W,MAAA,SAAAzC,EAAAC,EAAAC,GACA,GAAAuC,KAGA,IAFAzC,EAAAoZ,EAAAqd,KAAAz2B,GACAE,EAAA,MAAAA,EAAA,EAAAC,KAAAG,MAAAJ,KACAF,EAAAC,GAAAC,EAAA,SAAAuC,EACA,IAAAA,EAAAjH,KAAA,GAAAixC,OAAAzsC,UAAoCssC,EAAAtsC,EAAAE,GAAAmsC,EAAArsC,KAAAC,EACpC,OAAAwC,IAGA2W,EAAA1U,OAAA,SAAAgoC,GACA,MAAAN,IAAA,SAAAI,GACA,GAAAA,KAAA,KAAAH,EAAAG,IAAAE,EAAAF,MAAAG,QAAAH,EAAA,IACK,SAAAA,EAAAtsC,GACL,GAAAssC,KACA,GAAAtsC,EAAA,SAAAA,GAAA,GACA,KAAAosC,EAAAE,GAAA,IAAAE,EAAAF,SACS,QAAAtsC,GAAA,GACT,KAAAosC,EAAAE,EAAA,IAAAE,EAAAF,SAMA5tC,IACAwa,EAAAxa,MAAA,SAAAoB,EAAAoX,GAGA,MAFAw1B,IAAAD,SAAA3sC,GAAA6sC,GAAAF,SAAAv1B,GACAi1B,EAAAO,IAAAP,EAAAQ,IACA1sC,KAAAG,MAAA1B,EAAAguC,GAAAC,MAGAzzB,EAAAgD,MAAA,SAAAlc,GAEA,MADAA,GAAAC,KAAAG,MAAAJ,GACAiE,SAAAjE,MAAA,EACAA,EAAA,EACAkZ,EAAA1U,OAAA6nC,EACA,SAAA92C,GAA6B,MAAA82C,GAAA92C,GAAAyK,GAAA,GAC7B,SAAAzK,GAA6B,MAAA2jB,GAAAxa,MAAA,EAAAnJ,GAAAyK,GAAA,IAH7BkZ,EADA,OAQAA,EAmFA,QAAA0zB,IAAAzzC,GACA,MAAA+yC,IAAA,SAAAI,GACAA,EAAAO,QAAAP,EAAAQ,WAAAR,EAAAS,SAAA,EAAA5zC,GAAA,GACAmzC,EAAAU,SAAA,UACG,SAAAV,EAAAtsC,GACHssC,EAAAO,QAAAP,EAAAQ,UAAA,EAAA9sC,IACG,SAAAF,EAAAoX,GACH,OAAAA,EAAApX,GAAAoX,EAAA+1B,oBAAAntC,EAAAmtC,qBAAAC,IAAAC,KA6FA,QAAAC,IAAAj0C,GACA,MAAA+yC,IAAA,SAAAI,GACAA,EAAAe,WAAAf,EAAAgB,cAAAhB,EAAAiB,YAAA,EAAAp0C,GAAA,GACAmzC,EAAAkB,YAAA,UACG,SAAAlB,EAAAtsC,GACHssC,EAAAe,WAAAf,EAAAgB,aAAA,EAAAttC,IACG,SAAAF,EAAAoX,GACH,OAAAA,EAAApX,GAAAqtC,KAyDA,QAAAM,IAAAl4C,GACA,MAAAA,EAAA0L,GAAA1L,EAAA0L,EAAA,KACA,GAAAqrC,GAAA,GAAAC,OAAA,EAAAh3C,EAAA6S,EAAA7S,MAAAm4C,EAAAn4C,EAAAo4C,EAAAp4C,EAAAktB,EAAAltB,EAAAq4C,EAEA,OADAtB,GAAAuB,YAAAt4C,EAAA0L,GACAqrC,EAEA,UAAAC,MAAAh3C,EAAA0L,EAAA1L,EAAA6S,EAAA7S,MAAAm4C,EAAAn4C,EAAAo4C,EAAAp4C,EAAAktB,EAAAltB,EAAAq4C,GAGA,QAAAE,IAAAv4C,GACA,MAAAA,EAAA0L,GAAA1L,EAAA0L,EAAA,KACA,GAAAqrC,GAAA,GAAAC,WAAAwB,KAAA,EAAAx4C,EAAA6S,EAAA7S,MAAAm4C,EAAAn4C,EAAAo4C,EAAAp4C,EAAAktB,EAAAltB,EAAAq4C,GAEA,OADAtB,GAAA0B,eAAAz4C,EAAA0L,GACAqrC,EAEA,UAAAC,WAAAwB,IAAAx4C,EAAA0L,EAAA1L,EAAA6S,EAAA7S,MAAAm4C,EAAAn4C,EAAAo4C,EAAAp4C,EAAAktB,EAAAltB,EAAAq4C,IAGA,QAAAK,IAAAhtC,GACA,OAAUA,IAAAmH,EAAA,EAAA7S,EAAA,EAAAm4C,EAAA,EAAAC,EAAA,EAAAlrB,EAAA,EAAAmrB,EAAA,GAGV,QAAAM,IAAAC,GA8GA,QAAAC,GAAAxlB,EAAAylB,GACA,gBAAA/B,GACA,GAIAzmC,GACAyoC,EACArsC,EANAyJ,KACAvS,GAAA,EACAgP,EAAA,EACAjD,EAAA0jB,EAAAryB,MAOA,KAFA+1C,YAAAC,QAAAD,EAAA,GAAAC,OAAAD,MAEAnzC,EAAA+L,GACA,KAAA0jB,EAAA2lB,WAAAp1C,KACAuS,EAAApQ,KAAAstB,EAAAlsB,MAAAyL,EAAAhP,IACA,OAAAm1C,EAAAE,GAAA3oC,EAAA+iB,EAAA6lB,SAAAt1C,KAAA0M,EAAA+iB,EAAA6lB,SAAAt1C,GACAm1C,EAAA,MAAAzoC,EAAA,SACA5D,EAAAosC,EAAAxoC,QAAA5D,EAAAqqC,EAAAgC,IACA5iC,EAAApQ,KAAAuK,GACAsC,EAAAhP,EAAA,EAKA,OADAuS,GAAApQ,KAAAstB,EAAAlsB,MAAAyL,EAAAhP,IACAuS,EAAAiL,KAAA,KAIA,QAAA+3B,GAAA9lB,EAAA+lB,GACA,gBAAAjjC,GACA,GAAAnW,GAAA04C,GAAA,KAEA,IADAW,EAAAr5C,EAAAqzB,EAAAld,GAAA,OACAA,EAAAnV,OAAA,WAMA,IAHA,KAAAhB,OAAAm4C,EAAAn4C,EAAAm4C,EAAA,MAAAn4C,EAAAI,GAGA,KAAAJ,IAAA,KAAAA,GAAA,CACA,KAAAA,OAAAs6B,EAAA,KAAAt6B,GAAA,IACA,IAAAs5C,GAAA,KAAAt5C,GAAAu4C,GAAAG,GAAA14C,EAAA0L,IAAAssC,YAAAoB,EAAAV,GAAA14C,EAAA0L,IAAA8rC,QACAx3C,GAAA6S,EAAA,EACA7S,IAAA,KAAAA,MAAAs6B,EAAA,OAAAt6B,EAAA0sB,GAAA4sB,EAAA,KAAAt5C,EAAAs6B,EAAA,EAAAt6B,EAAAu5C,GAAAD,EAAA,KAKA,WAAAt5C,IACAA,EAAAm4C,GAAAn4C,EAAAw5C,EAAA,MACAx5C,EAAAo4C,GAAAp4C,EAAAw5C,EAAA,IACAjB,GAAAv4C,IAIAo5C,EAAAp5C,IAIA,QAAAq5C,GAAAr5C,EAAAqzB,EAAAld,EAAAvD,GAOA,IANA,GAGAtC,GACA+P,EAJAzc,EAAA,EACA+L,EAAA0jB,EAAAryB,OACA6R,EAAAsD,EAAAnV,OAIA4C,EAAA+L,GAAA,CACA,GAAAiD,GAAAC,EAAA,QAEA,UADAvC,EAAA+iB,EAAA2lB,WAAAp1C,OAIA,GAFA0M,EAAA+iB,EAAA6lB,OAAAt1C,OACAyc,EAAAo5B,EAAAnpC,IAAA2oC,IAAA5lB,EAAA6lB,OAAAt1C,KAAA0M,MACAsC,EAAAyN,EAAArgB,EAAAmW,EAAAvD,IAAA,eACO,IAAAtC,GAAA6F,EAAA6iC,WAAApmC,KACP,SAIA,MAAAA,GAGA,QAAA8mC,GAAA15C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAgqC,EAAAl/B,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAAI,EAAAw5C,EAAAjqC,EAAA,GAAA4K,eAAA3W,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA64C,GAAA75C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmqC,EAAAr/B,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAAs6B,EAAAyf,EAAApqC,EAAA,GAAA4K,eAAA3W,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAg5C,GAAAh6C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAsqC,EAAAx/B,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAAs6B,EAAA4f,EAAAvqC,EAAA,GAAA4K,eAAA3W,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAm5C,GAAAn6C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAyqC,EAAA3/B,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAA6S,EAAAwnC,EAAA1qC,EAAA,GAAA4K,eAAA3W,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAs5C,GAAAt6C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAA4qC,EAAA9/B,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAA6S,EAAA2nC,EAAA7qC,EAAA,GAAA4K,eAAA3W,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAy5C,GAAAz6C,EAAAmW,EAAAvS,GACA,MAAAy1C,GAAAr5C,EAAA06C,EAAAvkC,EAAAvS,GAGA,QAAA+2C,GAAA36C,EAAAmW,EAAAvS,GACA,MAAAy1C,GAAAr5C,EAAA46C,EAAAzkC,EAAAvS,GAGA,QAAAi3C,GAAA76C,EAAAmW,EAAAvS,GACA,MAAAy1C,GAAAr5C,EAAA86C,EAAA3kC,EAAAvS,GAGA,QAAAm3C,GAAA/6C,GACA,MAAAg7C,GAAAh7C,EAAAw3C,UAGA,QAAAyD,GAAAj7C,GACA,MAAAk7C,GAAAl7C,EAAAw3C,UAGA,QAAA2D,GAAAn7C,GACA,MAAAo7C,GAAAp7C,EAAAq7C,YAGA,QAAAC,GAAAt7C,GACA,MAAAu7C,GAAAv7C,EAAAq7C,YAGA,QAAAG,GAAAx7C,GACA,MAAAy7C,KAAAz7C,EAAA07C,YAAA,KAGA,QAAAC,GAAA37C,GACA,MAAAg7C,GAAAh7C,EAAAg4C,aAGA,QAAA4D,GAAA57C,GACA,MAAAk7C,GAAAl7C,EAAAg4C,aAGA,QAAA6D,GAAA77C,GACA,MAAAo7C,GAAAp7C,EAAA87C,eAGA,QAAAC,GAAA/7C,GACA,MAAAu7C,GAAAv7C,EAAA87C,eAGA,QAAAE,GAAAh8C,GACA,MAAAy7C,KAAAz7C,EAAAi8C,eAAA,KAvQA,GAAAvB,GAAA9B,EAAAsD,SACAtB,EAAAhC,EAAA7B,KACA+D,EAAAlC,EAAAh2B,KACA64B,EAAA7C,EAAAuD,QACAjB,EAAAtC,EAAAwD,KACApB,EAAApC,EAAAyD,UACAd,EAAA3C,EAAA0D,OACAlB,EAAAxC,EAAA2D,YAEA5C,EAAA6C,GAAAf,GACA7B,EAAA6C,GAAAhB,GACAxB,EAAAuC,GAAAtB,GACAhB,EAAAuC,GAAAvB,GACApB,EAAA0C,GAAAxB,GACAjB,EAAA0C,GAAAzB,GACAT,EAAAiC,GAAAjB,GACAf,EAAAiC,GAAAlB,GACAnB,EAAAoC,GAAApB,GACAf,EAAAoC,GAAArB,GAEAtC,GACAzuC,EAAA0wC,EACAnN,EAAAqN,EACAh7C,EAAAk7C,EACA9O,EAAAiP,EACAhrC,EAAA,KACAtQ,EAAA08C,GACA92C,EAAA82C,GACAvE,EAAAwE,GACAC,EAAAC,GACAjqC,EAAAkqC,GACAzE,EAAA0E,GACAlqC,EAAAmqC,GACA5E,EAAA6E,GACA78C,EAAAo7C,EACAtuB,EAAAgwB,GACA3D,EAAA4D,GACA7iB,EAAA8iB,GACA1wB,EAAA2wB,GACA/zC,EAAA,KACAshB,EAAA,KACAlf,EAAA4xC,GACAxyB,EAAAyyB,GACA/D,EAAAgE,GACAC,IAAAC,IAGAC,GACAtzC,EAAAsxC,EACA/N,EAAAgO,EACA37C,EAAA47C,EACAxP,EAAA0P,EACAzrC,EAAA,KACAtQ,EAAA49C,GACAh4C,EAAAg4C,GACAzF,EAAA0F,GACAjB,EAAAkB,GACAlrC,EAAAmrC,GACA1F,EAAA2F,GACAnrC,EAAAorC,GACA7F,EAAA8F,GACA99C,EAAA47C,EACA9uB,EAAAixB,GACA5E,EAAA6E,GACA9jB,EAAA+jB,GACA3xB,EAAA4xB,GACAh1C,EAAA,KACAshB,EAAA,KACAlf,EAAA6yC,GACAzzB,EAAA0zB,GACAhF,EAAAiF,GACAhB,IAAAC,IAGAjE,GACApvC,EAAAwvC,EACAjM,EAAAoM,EACA/5C,EAAAk6C,EACA9N,EAAAiO,EACAhqC,EAAAmqC,EACAz6C,EAAA0+C,GACA94C,EAAA84C,GACAvG,EAAAwG,GACA/B,EAAA+B,GACA/rC,EAAAgsC,GACAvG,EAAAwG,GACAhsC,EAAAisC,GACA1G,EAAA2G,GACA3+C,EAAAs5C,EACAxsB,EAAA8xB,GACAzF,EAAA0F,GACA3kB,EAAA4kB,GACAxyB,EAAAyyB,GACA71C,EAAAqxC,EACA/vB,EAAAiwB,EACAnvC,EAAA0zC,GACAt0B,EAAAu0B,GACA7F,EAAA8F,GACA7B,IAAA8B,GAwKA,OApKAzG,GAAAxvC,EAAAuvC,EAAA+B,EAAA9B,GACAA,EAAAluB,EAAAiuB,EAAAiC,EAAAhC,GACAA,EAAAxoC,EAAAuoC,EAAA6B,EAAA5B,GACA6E,EAAAr0C,EAAAuvC,EAAA+B,EAAA+C,GACAA,EAAA/yB,EAAAiuB,EAAAiC,EAAA6C,GACAA,EAAArtC,EAAAuoC,EAAA6B,EAAAiD,IAgKAjxC,OAAA,SAAA2mB,GACA,GAAAnpB,GAAA2uC,EAAAxlB,GAAA,GAAAylB,EAEA,OADA5uC,GAAAwH,SAAA,WAA+B,MAAA2hB,IAC/BnpB,GAEAmW,MAAA,SAAAgT,GACA,GAAAjzB,GAAA+4C,EAAA9lB,GAAA,GAAA6kB,GAEA,OADA93C,GAAAsR,SAAA,WAA+B,MAAA2hB,IAC/BjzB,GAEAo/C,UAAA,SAAAnsB,GACA,GAAAnpB,GAAA2uC,EAAAxlB,GAAA,GAAAsqB,EAEA,OADAzzC,GAAAwH,SAAA,WAA+B,MAAA2hB,IAC/BnpB,GAEAu1C,SAAA,SAAApsB,GACA,GAAAjzB,GAAA+4C,EAAA9lB,EAAAklB,GAEA,OADAn4C,GAAAsR,SAAA,WAA+B,MAAA2hB,IAC/BjzB,IAUA,QAAA24C,IAAAp5C,EAAA8zB,EAAAvJ,GACA,GAAAyJ,GAAAh0B,EAAA,SACAwW,GAAAwd,GAAAh0B,KAAA,GACAqB,EAAAmV,EAAAnV,MACA,OAAA2yB,IAAA3yB,EAAAkpB,EAAA,GAAA7gB,OAAA6gB,EAAAlpB,EAAA,GAAAogB,KAAAqS,GAAAtd,KAGA,QAAAupC,IAAA7jC,GACA,MAAAA,GAAA8jC,QAAAC,GAAA,QAGA,QAAApD,IAAA/lC,GACA,UAAAopC,QAAA,OAAAppC,EAAAvG,IAAAwvC,IAAAt+B,KAAA,cAGA,QAAAq7B,IAAAhmC,GAEA,IADA,GAAAvG,MAActM,GAAA,EAAA+L,EAAA8G,EAAAzV,SACd4C,EAAA+L,GAAAO,EAAAuG,EAAA7S,GAAA2W,eAAA3W,CACA,OAAAsM,GAGA,QAAAgvC,IAAAl/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAs6B,GAAA3qB,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAi+C,IAAAj/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAAu5C,GAAA5pC,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAm+C,IAAAn/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,GACA,OAAA+L,IAAA3P,EAAA0sB,GAAA/c,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAq+C,IAAAr/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAA0L,GAAAiE,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAo+C,IAAAp/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAA0L,GAAAiE,EAAA,KAAAA,EAAA,gBAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAs+C,IAAAt/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAA,gCAAA8K,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAw5C,EAAA7pC,EAAA,OAAAA,EAAA,IAAAA,EAAA,WAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA89C,IAAA9+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAA6S,EAAAlD,EAAA,KAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA09C,IAAA1+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,KAAA2P,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA49C,IAAA5+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAA6S,EAAA,EAAA7S,KAAA2P,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA29C,IAAA3+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAm4C,GAAAxoC,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA+9C,IAAA/+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAo4C,GAAAzoC,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAg+C,IAAAh/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAktB,GAAAvd,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAA69C,IAAA7+C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAmwC,GAAArlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,IAAA3P,EAAAq4C,GAAA1oC,EAAA,GAAA/L,EAAA+L,EAAA,GAAA3O,SAAA,EAGA,QAAAu+C,IAAAv/C,EAAAmW,EAAAvS,GACA,GAAA+L,GAAAowC,GAAAtlC,KAAAtE,EAAAhP,MAAAvD,IAAA,GACA,OAAA+L,GAAA/L,EAAA+L,EAAA,GAAA3O,QAAA,EAGA,QAAA07C,IAAA18C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAu3C,UAAAn3C,EAAA,GAGA,QAAAu8C,IAAA38C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA07C,WAAAt7C,EAAA,GAGA,QAAAy8C,IAAA78C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA07C,WAAA,OAAAt7C,EAAA,GAGA,QAAA08C,IAAA98C,EAAAI,GACA,MAAA24C,IAAA,EAAAiH,GAAA72C,MAAA82C,GAAAjgD,MAAAI,EAAA,GAGA,QAAA28C,IAAA/8C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAkgD,kBAAA9/C,EAAA,GAGA,QAAA48C,IAAAh9C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAq7C,WAAA,EAAAj7C,EAAA,GAGA,QAAA68C,IAAAj9C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAmgD,aAAA//C,EAAA,GAGA,QAAA88C,IAAAl9C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAogD,aAAAhgD,EAAA,GAGA,QAAA+8C,IAAAn9C,EAAAI,GACA,MAAA24C,IAAAsH,GAAAl3C,MAAA82C,GAAAjgD,MAAAI,EAAA,GAGA,QAAAg9C,IAAAp9C,GACA,MAAAA,GAAAw3C,SAGA,QAAA6F,IAAAr9C,EAAAI,GACA,MAAA24C,IAAAuH,GAAAn3C,MAAA82C,GAAAjgD,MAAAI,EAAA,GAGA,QAAAk9C,IAAAt9C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAugD,cAAA,IAAAngD,EAAA,GAGA,QAAAm9C,IAAAv9C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAugD,cAAA,IAAAngD,EAAA,GAGA,QAAAo9C,IAAAx9C,GACA,GAAA45B,GAAA55B,EAAA03C,mBACA,QAAA9d,EAAA,OAAAA,IAAA,QACAmf,GAAAnf,EAAA,YACAmf,GAAAnf,EAAA,UAGA,QAAAgkB,IAAA59C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA+3C,aAAA33C,EAAA,GAGA,QAAAy9C,IAAA79C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAi8C,cAAA77C,EAAA,GAGA,QAAA09C,IAAA99C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAAi8C,cAAA,OAAA77C,EAAA,GAGA,QAAA29C,IAAA/9C,EAAAI,GACA,MAAA24C,IAAA,EAAAyH,GAAAr3C,MAAAs3C,GAAAzgD,MAAAI,EAAA,GAGA,QAAA49C,IAAAh+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA0gD,qBAAAtgD,EAAA,GAGA,QAAA69C,IAAAj+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA87C,cAAA,EAAA17C,EAAA,GAGA,QAAA89C,IAAAl+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA2gD,gBAAAvgD,EAAA,GAGA,QAAA+9C,IAAAn+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA4gD,gBAAAxgD,EAAA,GAGA,QAAAg+C,IAAAp+C,EAAAI,GACA,MAAA24C,IAAA8H,GAAA13C,MAAAs3C,GAAAzgD,MAAAI,EAAA,GAGA,QAAAi+C,IAAAr+C,GACA,MAAAA,GAAAg4C,YAGA,QAAAsG,IAAAt+C,EAAAI,GACA,MAAA24C,IAAA+H,GAAA33C,MAAAs3C,GAAAzgD,MAAAI,EAAA,GAGA,QAAAm+C,IAAAv+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA+gD,iBAAA,IAAA3gD,EAAA,GAGA,QAAAo+C,IAAAx+C,EAAAI,GACA,MAAA24C,IAAA/4C,EAAA+gD,iBAAA,IAAA3gD,EAAA,GAGA,QAAAq+C,MACA,cAGA,QAAAf,MACA,UAoBA,QAAAsD,IAAA5mC,GAMA,MALA6mC,IAAAtI,GAAAv+B,GACAhd,EAAA8jD,WAAAD,GAAAv0C,OACAtP,EAAA+jD,UAAAF,GAAA5gC,MACAjjB,EAAAoiD,UAAAyB,GAAAzB,UACApiD,EAAAqiD,SAAAwB,GAAAxB,SACAwB,GAKA,QAAAG,IAAArK,GACA,MAAAA,GAAAsK,cAOA,QAAAC,IAAAnrC,GACA,GAAA4gC,GAAA,GAAAC,MAAA7gC,EACA,OAAA6I,OAAA+3B,GAAA,KAAAA,EAeA,QAAAwK,IAAA7xC,GACA,UAAAsnC,MAAAtnC,GAGA,QAAA8xC,IAAA9xC,GACA,MAAAA,aAAAsnC,OAAAtnC,GAAA,GAAAsnC,OAAAtnC,GAGA,QAAA+xC,IAAAC,EAAAC,EAAAC,EAAAtI,EAAAuI,EAAAC,EAAAC,EAAAC,EAAAt1C,GAmCA,QAAAC,GAAAs1C,GACA,OAAAF,EAAAE,KAAAC,EACAJ,EAAAG,KAAAE,EACAN,EAAAI,KAAAG,EACA9I,EAAA2I,KAAAI,EACAV,EAAAM,KAAAL,EAAAK,KAAAK,EAAAC,EACAb,EAAAO,KAAA3G,EACAgC,GAAA2E,GAGA,QAAAO,GAAAC,EAAAl4C,EAAAC,EAAAC,GAMA,GALA,MAAAg4C,MAAA,IAKA,gBAAAA,GAAA,CACA,GAAAjpC,GAAA9O,KAAAY,IAAAd,EAAAD,GAAAk4C,EACA7+C,EAAA8+C,GAAA,SAAA9+C,GAAoC,MAAAA,GAAA,KAAemL,MAAA4zC,EAAAnpC,EACnD5V,KAAA++C,EAAA3hD,QACAyJ,EAAAW,EAAAb,EAAAq4C,GAAAp4C,EAAAo4C,GAAAH,GACAA,EAAAf,GACO99C,GACPA,EAAA++C,EAAAnpC,EAAAmpC,EAAA/+C,EAAA,MAAA++C,EAAA/+C,GAAA,GAAA4V,EAAA5V,EAAA,EAAAA,GACA6G,EAAA7G,EAAA,GACA6+C,EAAA7+C,EAAA,KAEA6G,EAAAW,EAAAb,EAAAC,EAAAi4C,GACAA,EAAAT,GAIA,aAAAv3C,EAAAg4C,IAAA97B,MAAAlc,GAlEA,GAAAmB,GAAA8oC,GAAAX,GAAAhzB,IACAob,EAAAvwB,EAAAuwB,OACA1vB,EAAAb,EAAAa,OAEAy1C,EAAAx1C,EAAA,OACAy1C,EAAAz1C,EAAA,OACA01C,EAAA11C,EAAA,SACA21C,EAAA31C,EAAA,SACA41C,EAAA51C,EAAA,SACA61C,EAAA71C,EAAA,SACA4uC,EAAA5uC,EAAA,MACA4wC,EAAA5wC,EAAA,MAEAi2C,IACAZ,EAAA,EAAAc,KACAd,EAAA,IAAAc,KACAd,EAAA,MAAAc,KACAd,EAAA,MAAAc,KACAf,EAAA,EAAAgB,KACAhB,EAAA,IAAAgB,KACAhB,EAAA,MAAAgB,KACAhB,EAAA,MAAAgB,KACAjB,EAAA,EAAAkB,KACAlB,EAAA,IAAAkB,KACAlB,EAAA,IAAAkB,KACAlB,EAAA,MAAAkB,KACAzJ,EAAA,EAAA0J,KACA1J,EAAA,IAAA0J,KACApB,EAAA,EAAAqB,KACAtB,EAAA,EAAAuB,KACAvB,EAAA,IAAAuB,KACAxB,EAAA,EAAAkB,IAyEA,OAnCAh3C,GAAAuwB,OAAA,SAAAzwB,GACA,UAAAsrC,MAAA7a,EAAAzwB,KAGAE,EAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,OAAAyL,EAAAooC,GAAAr2C,KAAA2Q,EAAAqyC,KAAA/0C,IAAAyD,IAAAqxC,KAGA31C,EAAAW,MAAA,SAAAk2C,EAAAh4C,GACA,GAIAiF,GAJA1P,EAAAyM,IACA2Q,EAAApd,EAAA,GACAsd,EAAAtd,IAAAgB,OAAA,GACAua,EAAA+B,EAAAF,CAKA,OAHA7B,KAAA7L,EAAA0N,IAAAE,IAAA5N,GACAA,EAAA8yC,EAAAC,EAAArlC,EAAAE,EAAA7S,GACAiF,MAAA1C,MAAAoQ,EAAAE,EAAA,MACA/B,EAAA7L,EAAA0xB,UAAA1xB,GAGA9D,EAAAe,WAAA,SAAAxD,EAAAkqB,GACA,aAAAA,EAAA1mB,EAAAD,EAAA2mB,IAGAznB,EAAAqpC,KAAA,SAAAwN,EAAAh4C,GACA,GAAAzK,GAAAyM,GACA,QAAAg2C,EAAAD,EAAAC,EAAAziD,EAAA,GAAAA,IAAAgB,OAAA,GAAAyJ,IACAgC,EAAAwoC,GAAAj1C,EAAAyiD,IACA72C,GAGAA,EAAA1E,KAAA,WACA,MAAAA,IAAA0E,EAAA61C,GAAAC,EAAAC,EAAAC,EAAAtI,EAAAuI,EAAAC,EAAAC,EAAAC,EAAAt1C,KAGAd,EA0CA,QAAAu3C,IAAAn2C,GACA,GAAA2C,GAAA3C,EAAAhM,MACA,iBAAA0O,GACA,MAAA1C,GAAAtC,KAAAC,IAAA,EAAAD,KAAAuR,IAAAtM,EAAA,EAAAjF,KAAAG,MAAA6E,EAAAC,OAYA,QAAAyzC,IAAAC,GAKA,QAAAz3C,GAAAtC,GACA,GAAAoG,IAAApG,EAAAqoB,IAAAE,EAAAF,EACA,OAAA0xB,GAAA5O,EAAA/pC,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAAvM,OANA,GAAAiiB,GAAA,EACAE,EAAA,EACA4iB,GAAA,CAuBA,OAhBA7oC,GAAAa,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAA2wB,GAAAxiB,EAAA,GAAA0iB,GAAA1iB,EAAA,GAAAvD,IAAA+lB,EAAAE,IAGAjmB,EAAA6oC,MAAA,SAAAtlC,GACA,MAAApO,WAAAC,QAAAyzC,IAAAtlC,EAAAvD,GAAA6oC,GAGA7oC,EAAAy3C,aAAA,SAAAl0C,GACA,MAAApO,WAAAC,QAAAqiD,EAAAl0C,EAAAvD,GAAAy3C,GAGAz3C,EAAA1E,KAAA,WACA,MAAAk8C,IAAAC,GAAA52C,QAAAklB,EAAAE,IAAA4iB,UAGAO,GAAAppC,GAsBA,QAAA03C,IAAAh6C,GACA,MAAAA,GAAA,IAAAA,GAAA,EAAAi6C,GAAA74C,KAAAgqB,KAAAprB,GAGA,QAAAk6C,IAAAl6C,GACA,MAAAA,IAAA,EAAAm6C,GAAAn6C,IAAA,GAAAm6C,GAAA/4C,KAAAkqB,KAAAtrB,GAGA,QAAAo6C,IAAA1jD,GACA,MAAAA,GAAA2jD,YAGA,QAAAC,IAAA5jD,GACA,MAAAA,GAAA6jD,YAGA,QAAAC,IAAA9jD,GACA,MAAAA,GAAA8vB,WAGA,QAAAi0B,IAAA/jD,GACA,MAAAA,GAAAgwB,SAGA,QAAAg0B,IAAAhkD,GACA,MAAAA,MAAAikD,SAGA,QAAAC,IAAAvyB,EAAAC,EAAAC,EAAAC,EAAA0U,EAAAC,EAAA0G,EAAAC,GACA,GAAA+W,GAAAtyB,EAAAF,EAAAyyB,EAAAtyB,EAAAF,EACAyyB,EAAAlX,EAAA3G,EAAA8d,EAAAlX,EAAA3G,EACA/2B,GAAA20C,GAAAzyB,EAAA6U,GAAA6d,GAAA3yB,EAAA6U,KAAA8d,EAAAH,EAAAE,EAAAD,EACA,QAAAzyB,EAAAjiB,EAAAy0C,EAAAvyB,EAAAliB,EAAA00C,GAKA,QAAAG,IAAA5yB,EAAAC,EAAAC,EAAAC,EAAAgb,EAAA0X,EAAAC,GACA,GAAAC,GAAA/yB,EAAAE,EACA8yB,EAAA/yB,EAAAE,EACA8yB,GAAAH,EAAAD,MAAAK,GAAAH,IAAAC,KACAG,EAAAF,EAAAD,EACAI,GAAAH,EAAAF,EACAM,EAAArzB,EAAAmzB,EACAG,EAAArzB,EAAAmzB,EACAZ,EAAAtyB,EAAAizB,EACAV,EAAAtyB,EAAAizB,EACAjjB,GAAAkjB,EAAAb,GAAA,EACAniB,GAAAijB,EAAAb,GAAA,EACAzqC,EAAAwqC,EAAAa,EACAprC,EAAAwqC,EAAAa,EACA3e,EAAA3sB,IAAAC,IACA2B,EAAAuxB,EAAA0X,EACAnmC,EAAA2mC,EAAAZ,EAAAD,EAAAc,EACAjlD,GAAA4Z,EAAA,QAAAirC,GAAAK,GAAA,EAAA3pC,IAAA+qB,EAAAjoB,MACA8mC,GAAA9mC,EAAAzE,EAAAD,EAAA3Z,GAAAsmC,EACAsD,IAAAvrB,EAAA1E,EAAAC,EAAA5Z,GAAAsmC,EACA8e,GAAA/mC,EAAAzE,EAAAD,EAAA3Z,GAAAsmC,EACA+e,IAAAhnC,EAAA1E,EAAAC,EAAA5Z,GAAAsmC,EACAgf,EAAAH,EAAArjB,EACAyjB,EAAA3b,EAAA5H,EACAwjB,EAAAJ,EAAAtjB,EACA2jB,EAAAJ,EAAArjB,CAMA,OAFAsjB,KAAAC,IAAAC,IAAAC,MAAAN,EAAAC,EAAAxb,EAAAyb,IAGAnqB,GAAAiqB,EACAhqB,GAAAyO,EACA8a,KAAAI,EACAH,KAAAI,EACAC,IAAAG,GAAArY,EAAAvxB,EAAA,GACA0pC,IAAArb,GAAAkD,EAAAvxB,EAAA,IA8LA,QAAAmqC,IAAA3jD,GACApE,KAAAuE,SAAAH,EA+BA,QAAA4jD,IAAAvlD,GACA,MAAAA,GAAA,GAGA,QAAAwlD,IAAAxlD,GACA,MAAAA,GAAA,GAmPA,QAAAylD,IAAAC,GACAnoD,KAAAooD,OAAAD,EAqBA,QAAAE,IAAAF,GAEA,QAAAG,GAAAlkD,GACA,UAAA8jD,IAAAC,EAAA/jD,IAKA,MAFAkkD,GAAAF,OAAAD,EAEAG,EAGA,QAAAC,IAAApqC,GACA,GAAAxL,GAAAwL,EAAAgqC,KASA,OAPAhqC,GAAA+c,MAAA/c,EAAAxS,QAAAwS,GAAAxS,EACAwS,EAAA8T,OAAA9T,EAAApQ,QAAAoQ,GAAApQ,EAEAoQ,EAAAgqC,MAAA,SAAA32C,GACA,MAAApO,WAAAC,OAAAsP,EAAA01C,GAAA72C,IAAAmB,IAAAy1C,QAGAjqC,EAuCA,QAAAqqC,IAAAnmD,GACA,MAAAA,GAAA9B,OAGA,QAAAkoD,IAAApmD,GACA,MAAAA,GAAAwZ,OAGA,QAAA6sC,IAAAP,GAOA,QAAAQ,KACA,GAAAC,GAAAC,EAAAC,GAAAjoD,KAAAuC,WAAA8a,EAAA3d,EAAAyE,MAAAhF,KAAA6oD,GAAA92C,EAAA8J,EAAA7W,MAAAhF,KAAA6oD,EAGA,IAFAzkD,MAAAwkD,EAAAl5C,MACAy4C,EAAA/jD,GAAAuH,EAAA3G,MAAAhF,MAAA6oD,EAAA,GAAA3qC,EAAA2qC,KAAA96C,EAAA/I,MAAAhF,KAAA6oD,IAAAl9C,EAAA3G,MAAAhF,MAAA6oD,EAAA,GAAA92C,EAAA82C,KAAA96C,EAAA/I,MAAAhF,KAAA6oD,IACAD,EAAA,MAAAxkD,GAAA,KAAAwkD,EAAA,SAVA,GAAAroD,GAAAioD,GACA3sC,EAAA4sC,GACA98C,EAAAq8C,GACAj6C,EAAAk6C,GACA7jD,EAAA,IA6BA,OApBAukD,GAAApoD,OAAA,SAAAiR,GACA,MAAApO,WAAAC,QAAA9C,EAAAiR,EAAAm3C,GAAApoD,GAGAooD,EAAA9sC,OAAA,SAAArK,GACA,MAAApO,WAAAC,QAAAwY,EAAArK,EAAAm3C,GAAA9sC,GAGA8sC,EAAAh9C,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAAsI,EAAA,kBAAA6F,KAAAu3C,IAAAv3C,GAAAm3C,GAAAh9C,GAGAg9C,EAAA56C,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA0K,EAAA,kBAAAyD,KAAAu3C,IAAAv3C,GAAAm3C,GAAA56C,GAGA46C,EAAAvkD,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAAe,EAAA,MAAAoN,EAAA,KAAAA,EAAAm3C,GAAAvkD,GAGAukD,EAGA,QAAAK,IAAA5kD,EAAA4vB,EAAAC,EAAAC,EAAAC,GACA/vB,EAAA6kD,OAAAj1B,EAAAC,GACA7vB,EAAA8kD,cAAAl1B,KAAAE,GAAA,EAAAD,EAAAD,EAAAG,EAAAD,EAAAC,GAGA,QAAAg1B,IAAA/kD,EAAA4vB,EAAAC,EAAAC,EAAAC,GACA/vB,EAAA6kD,OAAAj1B,EAAAC,GACA7vB,EAAA8kD,cAAAl1B,EAAAC,KAAAE,GAAA,EAAAD,EAAAD,EAAAC,EAAAC,GAGA,QAAAi1B,IAAAhlD,EAAA4vB,EAAAC,EAAAC,EAAAC,GACA,GAAAoG,GAAA8uB,GAAAr1B,EAAAC,GACAq1B,EAAAD,GAAAr1B,EAAAC,KAAAE,GAAA,GACAo1B,EAAAF,GAAAn1B,EAAAD,GACAu1B,EAAAH,GAAAn1B,EAAAC,EACA/vB,GAAA6kD,OAAA1uB,EAAA,GAAAA,EAAA,IACAn2B,EAAA8kD,cAAAI,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,IAGA,QAAAC,MACA,MAAAf,IAAAM,IAGA,QAAAU,MACA,MAAAhB,IAAAS,IAGA,QAAAQ,MACA,GAAAxrC,GAAAuqC,GAAAU,GAGA,OAFAjrC,GAAA+c,MAAA/c,EAAAxS,QAAAwS,GAAAxS,EACAwS,EAAA8T,OAAA9T,EAAApQ,QAAAoQ,GAAApQ,EACAoQ,EA0JA,QAAAyrC,IAAAl0C,EAAA/J,EAAAoC,GACA2H,EAAAnR,SAAA2kD,eACA,EAAAxzC,EAAAgc,IAAAhc,EAAAkc,KAAA,GACA,EAAAlc,EAAAic,IAAAjc,EAAAmc,KAAA,GACAnc,EAAAgc,IAAA,EAAAhc,EAAAkc,KAAA,GACAlc,EAAAic,IAAA,EAAAjc,EAAAmc,KAAA,GACAnc,EAAAgc,IAAA,EAAAhc,EAAAkc,IAAAjmB,GAAA,GACA+J,EAAAic,IAAA,EAAAjc,EAAAmc,IAAA9jB,GAAA,GAIA,QAAA87C,IAAAzlD,GACApE,KAAAuE,SAAAH,EAwCA,QAAA0lD,IAAA1lD,GACApE,KAAAuE,SAAAH,EAiDA,QAAA2lD,IAAA3lD,GACApE,KAAAuE,SAAAH,EAqCA,QAAA4lD,IAAA5lD,EAAAkvC,GACAtzC,KAAAiqD,OAAA,GAAAJ,IAAAzlD,GACApE,KAAAkqD,MAAA5W,EAqDA,QAAA6W,IAAAz0C,EAAA/J,EAAAoC,GACA2H,EAAAnR,SAAA2kD,cACAxzC,EAAAkc,IAAAlc,EAAA00C,IAAA10C,EAAA20C,IAAA30C,EAAAgc,KACAhc,EAAAmc,IAAAnc,EAAA00C,IAAA10C,EAAA40C,IAAA50C,EAAAic,KACAjc,EAAA20C,IAAA30C,EAAA00C,IAAA10C,EAAAkc,IAAAjmB,GACA+J,EAAA40C,IAAA50C,EAAA00C,IAAA10C,EAAAmc,IAAA9jB,GACA2H,EAAA20C,IACA30C,EAAA40C,KAIA,QAAAC,IAAAnmD,EAAAomD,GACAxqD,KAAAuE,SAAAH,EACApE,KAAAoqD,IAAA,EAAAI,GAAA,EAiDA,QAAAC,IAAArmD,EAAAomD,GACAxqD,KAAAuE,SAAAH,EACApE,KAAAoqD,IAAA,EAAAI,GAAA,EAyDA,QAAAE,IAAAtmD,EAAAomD,GACAxqD,KAAAuE,SAAAH,EACApE,KAAAoqD,IAAA,EAAAI,GAAA,EA8CA,QAAAG,IAAAj1C,EAAA/J,EAAAoC,GACA,GAAAmmB,GAAAxe,EAAAkc,IACAuC,EAAAze,EAAAmc,IACAgX,EAAAnzB,EAAA20C,IACAvhB,EAAApzB,EAAA40C,GAEA,IAAA50C,EAAAk1C,OAAAC,GAAA,CACA,GAAAn+C,GAAA,EAAAgJ,EAAAo1C,QAAA,EAAAp1C,EAAAk1C,OAAAl1C,EAAAq1C,OAAAr1C,EAAAs1C,QACAh5C,EAAA,EAAA0D,EAAAk1C,QAAAl1C,EAAAk1C,OAAAl1C,EAAAq1C,OACA72B,MAAAxnB,EAAAgJ,EAAAgc,IAAAhc,EAAAs1C,QAAAt1C,EAAA20C,IAAA30C,EAAAo1C,SAAA94C,EACAmiB,KAAAznB,EAAAgJ,EAAAic,IAAAjc,EAAAs1C,QAAAt1C,EAAA40C,IAAA50C,EAAAo1C,SAAA94C,EAGA,GAAA0D,EAAAu1C,OAAAJ,GAAA,CACA,GAAAvoD,GAAA,EAAAoT,EAAAw1C,QAAA,EAAAx1C,EAAAu1C,OAAAv1C,EAAAq1C,OAAAr1C,EAAAs1C,QACA91C,EAAA,EAAAQ,EAAAu1C,QAAAv1C,EAAAu1C,OAAAv1C,EAAAq1C,OACAliB,MAAAvmC,EAAAoT,EAAAkc,IAAAlc,EAAAw1C,QAAAv/C,EAAA+J,EAAAs1C,SAAA91C,EACA4zB,KAAAxmC,EAAAoT,EAAAmc,IAAAnc,EAAAw1C,QAAAn9C,EAAA2H,EAAAs1C,SAAA91C,EAGAQ,EAAAnR,SAAA2kD,cAAAh1B,EAAAC,EAAA0U,EAAAC,EAAApzB,EAAA20C,IAAA30C,EAAA40C,KAGA,QAAAa,IAAA/mD,EAAAivC,GACArzC,KAAAuE,SAAAH,EACApE,KAAAorD,OAAA/X,EA6DA,QAAAgY,IAAAjnD,EAAAivC,GACArzC,KAAAuE,SAAAH,EACApE,KAAAorD,OAAA/X,EAqEA,QAAAiY,IAAAlnD,EAAAivC,GACArzC,KAAAuE,SAAAH,EACApE,KAAAorD,OAAA/X,EA0DA,QAAAkY,IAAAnnD,GACApE,KAAAuE,SAAAH,EAuBA,QAAAonD,IAAA7/C,GACA,MAAAA,GAAA,OAOA,QAAA8/C,IAAA/1C,EAAAmzB,EAAAC,GACA,GAAA4iB,GAAAh2C,EAAAkc,IAAAlc,EAAAgc,IACAi6B,EAAA9iB,EAAAnzB,EAAAkc,IACApC,GAAA9Z,EAAAmc,IAAAnc,EAAAic,MAAA+5B,GAAAC,EAAA,OACAj8B,GAAAoZ,EAAApzB,EAAAmc,MAAA85B,GAAAD,EAAA,OACAjpD,GAAA+sB,EAAAm8B,EAAAj8B,EAAAg8B,MAAAC,EACA,QAAAH,GAAAh8B,GAAAg8B,GAAA97B,IAAA3iB,KAAAuR,IAAAvR,KAAAY,IAAA6hB,GAAAziB,KAAAY,IAAA+hB,GAAA,GAAA3iB,KAAAY,IAAAlL,KAAA,EAIA,QAAAmpD,IAAAl2C,EAAA3D,GACA,GAAAkM,GAAAvI,EAAAkc,IAAAlc,EAAAgc,GACA,OAAAzT,IAAA,GAAAvI,EAAAmc,IAAAnc,EAAAic,KAAA1T,EAAAlM,GAAA,EAAAA,EAMA,QAAA85C,IAAAn2C,EAAA+J,EAAAE,GACA,GAAAqU,GAAAte,EAAAgc,IACAuC,EAAAve,EAAAic,IACAuC,EAAAxe,EAAAkc,IACAuC,EAAAze,EAAAmc,IACA7V,GAAAkY,EAAAF,GAAA,CACAte,GAAAnR,SAAA2kD,cAAAl1B,EAAAhY,EAAAiY,EAAAjY,EAAAyD,EAAAyU,EAAAlY,EAAAmY,EAAAnY,EAAA2D,EAAAuU,EAAAC,GAGA,QAAA23B,IAAA1nD,GACApE,KAAAuE,SAAAH,EA0CA,QAAA2nD,IAAA3nD,GACApE,KAAAuE,SAAA,GAAAynD,IAAA5nD,GAOA,QAAA4nD,IAAA5nD,GACApE,KAAAuE,SAAAH,EAUA,QAAA6nD,IAAA7nD,GACA,UAAA0nD,IAAA1nD,GAGA,QAAA8nD,IAAA9nD,GACA,UAAA2nD,IAAA3nD,GAGA,QAAA+nD,IAAA/nD,GACApE,KAAAuE,SAAAH,EA2CA,QAAAgoD,IAAAzgD,GACA,GAAA1F,GAEAiP,EADAlD,EAAArG,EAAAtI,OAAA,EAEAqJ,EAAA,GAAAhB,OAAAsG,GACA1P,EAAA,GAAAoJ,OAAAsG,GACA4L,EAAA,GAAAlS,OAAAsG,EAEA,KADAtF,EAAA,KAAApK,EAAA,KAAAsb,EAAA,GAAAjS,EAAA,KAAAA,EAAA,GACA1F,EAAA,EAAaA,EAAA+L,EAAA,IAAW/L,EAAAyG,EAAAzG,GAAA,EAAA3D,EAAA2D,GAAA,EAAA2X,EAAA3X,GAAA,EAAA0F,EAAA1F,GAAA,EAAA0F,EAAA1F,EAAA,EAExB,KADAyG,EAAAsF,EAAA,KAAA1P,EAAA0P,EAAA,KAAA4L,EAAA5L,EAAA,KAAArG,EAAAqG,EAAA,GAAArG,EAAAqG,GACA/L,EAAA,EAAaA,EAAA+L,IAAO/L,EAAAiP,EAAAxI,EAAAzG,GAAA3D,EAAA2D,EAAA,GAAA3D,EAAA2D,IAAAiP,EAAA0I,EAAA3X,IAAAiP,EAAA0I,EAAA3X,EAAA,EAEpB,KADAyG,EAAAsF,EAAA,GAAA4L,EAAA5L,EAAA,GAAA1P,EAAA0P,EAAA,GACA/L,EAAA+L,EAAA,EAAiB/L,GAAA,IAAQA,EAAAyG,EAAAzG,IAAA2X,EAAA3X,GAAAyG,EAAAzG,EAAA,IAAA3D,EAAA2D,EAEzB,KADA3D,EAAA0P,EAAA,IAAArG,EAAAqG,GAAAtF,EAAAsF,EAAA,MACA/L,EAAA,EAAaA,EAAA+L,EAAA,IAAW/L,EAAA3D,EAAA2D,GAAA,EAAA0F,EAAA1F,EAAA,GAAAyG,EAAAzG,EAAA,EACxB,QAAAyG,EAAApK,GAOA,QAAA+pD,IAAAjoD,EAAA2N,GACA/R,KAAAuE,SAAAH,EACApE,KAAAssD,GAAAv6C,EA4CA,QAAAw6C,IAAAnoD,GACA,UAAAioD,IAAAjoD,EAAA,GAGA,QAAAooD,IAAApoD,GACA,UAAAioD,IAAAjoD,EAAA,GAmBA,QAAAqoD,IAAApqD,EAAAkU,GACA,MAAAlU,GAAAkU,GAiHA,QAAAm2C,IAAAC,GAEA,IADA,GAAAp1C,GAAA2G,EAAA,EAAAjY,GAAA,EAAA+L,EAAA26C,EAAAtpD,SACA4C,EAAA+L,IAAAuF,GAAAo1C,EAAA1mD,GAAA,MAAAiY,GAAA3G,EACA,OAAA2G,GA0CA,QAAA0uC,IAAAvqD,GACA,MAAAA,GAAA,GAGA,QAAAwqD,IAAAxqD,GACA,MAAAA,GAAA,GAGA,QAAAyqD,MACA9sD,KAAAwR,EAAA,KAGA,QAAAu7C,IAAA52C,GACAA,EAAAylC,EACAzlC,EAAAsK,EACAtK,EAAAukC,EACAvkC,EAAA62C,EACA72C,EAAA82C,EACA92C,EAAAkZ,EAAA,KAuLA,QAAA69B,IAAAx5B,EAAAvd,GACA,GAAA1T,GAAA0T,EACAgN,EAAAhN,EAAA62C,EACApoD,EAAAnC,EAAAm5C,CAEAh3C,GACAA,EAAA81C,IAAAj4C,EAAAmC,EAAA81C,EAAAv3B,EACAve,EAAAooD,EAAA7pC,EAEAuQ,EAAAliB,EAAA2R,EAGAA,EAAAy4B,EAAAh3C,EACAnC,EAAAm5C,EAAAz4B,EACA1gB,EAAAuqD,EAAA7pC,EAAAu3B,EACAj4C,EAAAuqD,IAAAvqD,EAAAuqD,EAAApR,EAAAn5C,GACA0gB,EAAAu3B,EAAAj4C,EAGA,QAAA0qD,IAAAz5B,EAAAvd,GACA,GAAA1T,GAAA0T,EACAgN,EAAAhN,EAAAukC,EACA91C,EAAAnC,EAAAm5C,CAEAh3C,GACAA,EAAA81C,IAAAj4C,EAAAmC,EAAA81C,EAAAv3B,EACAve,EAAAooD,EAAA7pC,EAEAuQ,EAAAliB,EAAA2R,EAGAA,EAAAy4B,EAAAh3C,EACAnC,EAAAm5C,EAAAz4B,EACA1gB,EAAAi4C,EAAAv3B,EAAA6pC,EACAvqD,EAAAi4C,IAAAj4C,EAAAi4C,EAAAkB,EAAAn5C,GACA0gB,EAAA6pC,EAAAvqD,EAGA,QAAA2qD,IAAAj3C,GACA,KAAAA,EAAAukC,GAAAvkC,IAAAukC,CACA,OAAAvkC,GAGA,QAAAk3C,IAAAl8C,EAAAC,EAAAyP,EAAAC,GACA,GAAAwsC,IAAA,WACA1lD,EAAA2lD,GAAAnlD,KAAAklD,GAAA,CAOA,OANAA,GAAAn8C,OACAm8C,EAAAl8C,QACAyP,GAAA2sC,GAAAF,EAAAn8C,EAAAC,EAAAyP,GACAC,GAAA0sC,GAAAF,EAAAl8C,EAAAD,EAAA2P,GACA2sC,GAAAt8C,EAAAvJ,OAAA8lD,UAAAtlD,KAAAR,GACA6lD,GAAAr8C,EAAAxJ,OAAA8lD,UAAAtlD,KAAAR,GACA0lD,EAGA,QAAAK,IAAAx8C,EAAA0P,EAAAC,GACA,GAAAwsC,IAAAzsC,EAAAC,EAEA,OADAwsC,GAAAn8C,OACAm8C,EAGA,QAAAE,IAAAF,EAAAn8C,EAAAC,EAAAw8C,GACAN,EAAA,IAAAA,EAAA,GAIGA,EAAAn8C,OAAAC,EACHk8C,EAAA,GAAAM,EAEAN,EAAA,GAAAM,GANAN,EAAA,GAAAM,EACAN,EAAAn8C,OACAm8C,EAAAl8C,SASA,QAAAy8C,IAAAP,EAAAt5B,EAAAC,EAAAC,EAAAC,GACA,GAUAvW,GAVAlR,EAAA4gD,EAAA,GACAhrD,EAAAgrD,EAAA,GACAnd,EAAAzjC,EAAA,GACA0jC,EAAA1jC,EAAA,GACAohD,EAAAxrD,EAAA,GACAyrD,EAAAzrD,EAAA,GACAmd,EAAA,EACAE,EAAA,EACA3D,EAAA8xC,EAAA3d,EACAl0B,EAAA8xC,EAAA3d,CAIA,IADAxyB,EAAAoW,EAAAmc,EACAn0B,KAAA4B,EAAA,IAEA,GADAA,GAAA5B,EACAA,EAAA,GACA,GAAA4B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,OACG,IAAA5B,EAAA,GACH,GAAA4B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,GAIA,GADAA,EAAAsW,EAAAic,EACAn0B,KAAA4B,EAAA,IAEA,GADAA,GAAA5B,EACAA,EAAA,GACA,GAAA4B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,OACG,IAAA5B,EAAA,GACH,GAAA4B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,GAIA,GADAA,EAAAqW,EAAAmc,EACAn0B,KAAA2B,EAAA,IAEA,GADAA,GAAA3B,EACAA,EAAA,GACA,GAAA2B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,OACG,IAAA3B,EAAA,GACH,GAAA2B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,GAIA,GADAA,EAAAuW,EAAAic,EACAn0B,KAAA2B,EAAA,IAEA,GADAA,GAAA3B,EACAA,EAAA,GACA,GAAA2B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,OACG,IAAA3B,EAAA,GACH,GAAA2B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,GAGA,QAAA6B,EAAA,GAAAE,EAAA,KAEAF,EAAA,IAAA6tC,EAAA,IAAAnd,EAAA1wB,EAAAzD,EAAAo0B,EAAA3wB,EAAAxD,IACA0D,EAAA,IAAA2tC,EAAA,IAAAnd,EAAAxwB,EAAA3D,EAAAo0B,EAAAzwB,EAAA1D,KACA,OAGA,QAAA+xC,IAAAV,EAAAt5B,EAAAC,EAAAC,EAAAC,GACA,GAAArT,GAAAwsC,EAAA,EACA,IAAAxsC,EAAA,QAEA,IASAmtC,GACAC,EAVArtC,EAAAysC,EAAA,GACAn8C,EAAAm8C,EAAAn8C,KACAC,EAAAk8C,EAAAl8C,MACA+8C,EAAAh9C,EAAA,GACAi9C,EAAAj9C,EAAA,GACAk9C,EAAAj9C,EAAA,GACAk9C,EAAAl9C,EAAA,GACAm9C,GAAAJ,EAAAE,GAAA,EACAniB,GAAAkiB,EAAAE,GAAA,CAIA,IAAAA,IAAAF,EAAA,CACA,GAAAG,EAAAv6B,GAAAu6B,GAAAr6B,EAAA,MACA,IAAAi6B,EAAAE,EAAA,CACA,GAAAxtC,GACA,GAAAA,EAAA,IAAAsT,EAAA,WADAtT,IAAA0tC,EAAAt6B,EAEAnT,IAAAytC,EAAAp6B,OACK,CACL,GAAAtT,GACA,GAAAA,EAAA,GAAAoT,EAAA,WADApT,IAAA0tC,EAAAp6B,EAEArT,IAAAytC,EAAAt6B,QAKA,IAFAg6B,GAAAE,EAAAE,IAAAC,EAAAF,GACAF,EAAAhiB,EAAA+hB,EAAAM,EACAN,GAAA,GAAAA,EAAA,EACA,GAAAE,EAAAE,EAAA,CACA,GAAAxtC,GACA,GAAAA,EAAA,IAAAsT,EAAA,WADAtT,KAAAoT,EAAAi6B,GAAAD,EAAAh6B,EAEAnT,KAAAqT,EAAA+5B,GAAAD,EAAA95B,OACO,CACP,GAAAtT,GACA,GAAAA,EAAA,GAAAoT,EAAA,WADApT,KAAAsT,EAAA+5B,GAAAD,EAAA95B,EAEArT,KAAAmT,EAAAi6B,GAAAD,EAAAh6B,OAGA,IAAAm6B,EAAAE,EAAA,CACA,GAAAztC,GACA,GAAAA,EAAA,IAAAqT,EAAA,WADArT,IAAAmT,EAAAi6B,EAAAj6B,EAAAk6B,EAEAptC,IAAAoT,EAAA+5B,EAAA/5B,EAAAg6B,OACO,CACP,GAAArtC,GACA,GAAAA,EAAA,GAAAmT,EAAA,WADAnT,IAAAqT,EAAA+5B,EAAA/5B,EAAAg6B,EAEAptC,IAAAkT,EAAAi6B,EAAAj6B,EAAAk6B,GAOA,MAFAZ,GAAA,GAAAzsC,EACAysC,EAAA,GAAAxsC,GACA,EAGA,QAAA0tC,IAAAx6B,EAAAC,EAAAC,EAAAC,GAIA,IAHA,GACAm5B,GADArnD,EAAAsnD,GAAAlqD,OAGA4C,KACA+nD,GAAAV,EAAAC,GAAAtnD,GAAA+tB,EAAAC,EAAAC,EAAAC,IACA05B,GAAAP,EAAAt5B,EAAAC,EAAAC,EAAAC,KACApnB,KAAAY,IAAA2/C,EAAA,MAAAA,EAAA,OAAAmB,IACA1hD,KAAAY,IAAA2/C,EAAA,MAAAA,EAAA,OAAAmB,WACAlB,IAAAtnD,GAKA,QAAAyoD,IAAAC,GACA,MAAAlB,IAAAkB,EAAA/mD,QACA+mD,OACAjB,cAIA,QAAAkB,IAAAC,EAAAvB,GACA,GAAAqB,GAAAE,EAAAF,KACAG,EAAAxB,EAAAn8C,KACA49C,EAAAzB,EAAAl8C,KAEA,OADAu9C,KAAAI,MAAAD,IAAAH,GACAI,EAAAhiD,KAAA+S,MAAAivC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,KACAH,IAAAG,KAAAxB,EAAA,GAAAyB,EAAAzB,EAAA,KACAwB,EAAAxB,EAAA,GAAAyB,EAAAzB,EAAA,IACAvgD,KAAA+S,MAAAgvC,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAAD,EAAA,KAGA,QAAAE,IAAAH,EAAAvB,GACA,MAAAA,OAAAn8C,OAAA09C,EAAAF,OAGA,QAAAM,IAAAJ,EAAAvB,GACA,MAAAA,OAAAn8C,OAAA09C,EAAAF,OAGA,QAAAO,MACA,OAAAL,GAAAnB,EAAAz4C,EAAAC,EAAAjP,EAAA,EAAA+L,EAAAy7C,GAAApqD,OAA0D4C,EAAA+L,IAAO/L,EACjE,IAAA4oD,EAAApB,GAAAxnD,MAAAiP,GAAAw4C,EAAAmB,EAAAnB,WAAArqD,QAAA,CACA,GAAAuE,GAAA,GAAA8D,OAAAwJ,GACApK,EAAA,GAAAY,OAAAwJ,EACA,KAAAD,EAAA,EAAiBA,EAAAC,IAAOD,EAAArN,EAAAqN,KAAAnK,EAAAmK,GAAA25C,GAAAC,EAAAtB,GAAAG,EAAAz4C,IAExB,KADArN,EAAAgxC,KAAA,SAAA3yC,EAAAgP,GAAiC,MAAAnK,GAAAmK,GAAAnK,EAAA7E,KACjCgP,EAAA,EAAiBA,EAAAC,IAAOD,EAAAnK,EAAAmK,GAAAy4C,EAAA9lD,EAAAqN,GACxB,KAAAA,EAAA,EAAiBA,EAAAC,IAAOD,EAAAy4C,EAAAz4C,GAAAnK,EAAAmK,IAKxB,QAAAk6C,IAAAn7B,EAAAC,EAAAC,EAAAC,GACA,GACAi7B,GACAP,EACAF,EACAU,EACA3B,EACA4B,EACA1iD,EACA2iD,EACAC,EACAxrC,EACAyrC,EACAC,EAZAC,EAAAlC,GAAApqD,OAaAoxB,GAAA,CAEA,KAAA26B,EAAA,EAAiBA,EAAAO,IAAgBP,EACjC,GAAAP,EAAApB,GAAA2B,GAAA,CAMA,IALAT,EAAAE,EAAAF,KACAjB,EAAAmB,EAAAnB,UACA2B,EAAA3B,EAAArqD,OAGAgsD,KACA9B,GAAAG,EAAA2B,KACA3B,EAAA9kD,OAAAymD,EAAA,EAMA,KADAA,EAAA,EAAAC,EAAA5B,EAAArqD,OACAgsD,EAAAC,GACAtrC,EAAAirC,GAAAJ,EAAAtB,GAAAG,EAAA2B,KAAAI,EAAAzrC,EAAA,GAAA0rC,EAAA1rC,EAAA,GACApX,EAAAoiD,GAAAH,EAAAtB,GAAAG,IAAA2B,EAAAC,KAAAC,EAAA3iD,EAAA,GAAA4iD,EAAA5iD,EAAA,IACAG,KAAAY,IAAA8hD,EAAAF,GAAAd,IAAA1hD,KAAAY,IAAA+hD,EAAAF,GAAAf,MACAf,EAAA9kD,OAAAymD,EAAA,EAAA9B,GAAAnlD,KAAAulD,GAAAgB,EAAA3qC,EACAjX,KAAAY,IAAA8hD,EAAAz7B,GAAAy6B,IAAAt6B,EAAAu7B,EAAAjB,IAAAz6B,EAAAjnB,KAAAY,IAAA4hD,EAAAv7B,GAAAy6B,GAAAe,EAAAr7B,GACApnB,KAAAY,IAAA+hD,EAAAv7B,GAAAs6B,IAAAv6B,EAAAu7B,EAAAhB,IAAA1hD,KAAAY,IAAA6hD,EAAAr7B,GAAAs6B,GAAAc,EAAAr7B,EAAAC,GACApnB,KAAAY,IAAA8hD,EAAAv7B,GAAAu6B,IAAAiB,EAAAz7B,EAAAw6B,IAAAv6B,EAAAnnB,KAAAY,IAAA4hD,EAAAr7B,GAAAu6B,GAAAe,EAAAv7B,GACAlnB,KAAAY,IAAA+hD,EAAAz7B,GAAAw6B,IAAAgB,EAAAz7B,EAAAy6B,IAAA1hD,KAAAY,IAAA6hD,EAAAv7B,GAAAw6B,GAAAc,EAAAv7B,EAAAC,GACA,YACAq7B,EAIAA,KAAA76B,GAAA,GAMA,GAAAA,EAAA,CACA,GAAAzY,GAAAC,EAAA0sB,EAAA4H,EAAA3qB,GAEA,KAAAwpC,EAAA,EAAA36B,EAAA,KAAiC26B,EAAAO,IAAgBP,GACjDP,EAAApB,GAAA2B,MACAT,EAAAE,EAAAF,KACA3yC,EAAA2yC,EAAA,GAAA36B,EACA/X,EAAA0yC,EAAA,GAAA16B,GACA0U,EAAA3sB,IAAAC,KACAs0B,MAAA5H,EAAAlU,EAAAo6B,GAIA,IAAAp6B,EAAA,CACA,GAAAm7B,IAAA57B,EAAAC,GAAA47B,GAAA77B,EAAAG,GAAA27B,GAAA57B,EAAAC,GAAA47B,GAAA77B,EAAAD,EACAQ,GAAAi5B,UAAAtlD,KACAmlD,GAAAnlD,KAAAulD,GAAAgB,EAAAl6B,EAAAk6B,KAAAiB,EAAAC,IAAA,EACAtC,GAAAnlD,KAAAulD,GAAAgB,EAAAkB,EAAAC,IAAA,EACAvC,GAAAnlD,KAAAulD,GAAAgB,EAAAmB,EAAAC,IAAA,EACAxC,GAAAnlD,KAAAulD,GAAAgB,EAAAoB,EAAAH,IAAA,IAMA,IAAAR,EAAA,EAAiBA,EAAAO,IAAgBP,GACjCP,EAAApB,GAAA2B,MACAP,EAAAnB,UAAArqD,cACAoqD,IAAA2B,IAUA,QAAAY,MACAjD,GAAA/sD,MACAA,KAAA2L,EACA3L,KAAA+N,EACA/N,KAAAiwD,IACAjwD,KAAA2uD,KACA3uD,KAAAw9B,GAAA,KAGA,QAAA0yB,IAAAD,GACA,GAAAE,GAAAF,EAAAhD,EACAmD,EAAAH,EAAA5gC,CAEA,IAAA8gC,GAAAC,EAAA,CAEA,GAAAC,GAAAF,EAAAxB,KACA2B,EAAAL,EAAAtB,KACA4B,EAAAH,EAAAzB,IAEA,IAAA0B,IAAAE,EAAA,CAEA,GAAAzC,GAAAwC,EAAA,GACAvC,EAAAuC,EAAA,GACAngB,EAAAkgB,EAAA,GAAAvC,EACA1d,EAAAigB,EAAA,GAAAtC,EACAxwB,EAAAgzB,EAAA,GAAAzC,EACAtwB,EAAA+yB,EAAA,GAAAxC,EAEA1rD,EAAA,GAAA8tC,EAAA3S,EAAA4S,EAAA7S,EACA,MAAAl7B,IAAAmuD,IAAA,CAEA,GAAAC,GAAAtgB,IAAAC,IACAsgB,EAAAnzB,IAAAC,IACA7xB,GAAA6xB,EAAAizB,EAAArgB,EAAAsgB,GAAAruD,EACA0L,GAAAoiC,EAAAugB,EAAAnzB,EAAAkzB,GAAApuD,EAEAsuC,EAAAggB,GAAAxlD,OAAA,GAAA6kD,GACArf,GAAAsf,MACAtf,EAAAge,KAAA2B,EACA3f,EAAAhlC,IAAAmiD,EACAnd,EAAA5iC,GAAA4iC,EAAAnT,GAAAzvB,EAAAggD,GAAAhhD,KAAAiT,KAAArU,IAAAoC,KAEAkiD,EAAAtf,QAKA,KAHA,GAAAigB,GAAA,KACAz6C,EAAA26B,GAAAt/B,EAEA2E,GACA,GAAAw6B,EAAA5iC,EAAAoI,EAAApI,GAAA4iC,EAAA5iC,IAAAoI,EAAApI,GAAA4iC,EAAAhlC,GAAAwK,EAAAxK,EAAA,CACA,IAAAwK,EAAAukC,EACA,CAAYkW,EAAAz6C,EAAA82C,CAAiB,OAD7B92C,IAAAukC,MAEK,CACL,IAAAvkC,EAAA62C,EACA,CAAY4D,EAAAz6C,CAAe,OAD3BA,IAAA62C,EAKAlc,GAAArgC,OAAAmgD,EAAAjgB,GACAigB,IAAAC,GAAAlgB,MAGA,QAAAmgB,IAAAb,GACA,GAAAtf,GAAAsf,EAAAtf,MACAA,KACAA,EAAAsc,IAAA4D,GAAAlgB,EAAAthB,GACAyhB,GAAAjpC,OAAA8oC,GACAggB,GAAAvoD,KAAAuoC,GACAoc,GAAApc,GACAsf,EAAAtf,OAAA,MAMA,QAAAogB,MACAhE,GAAA/sD,MACAA,KAAAstD,KACAttD,KAAA2uD,KACA3uD,KAAA2wC,OAAA,KAGA,QAAAqgB,IAAArC,GACA,GAAAsC,GAAAC,GAAA/lD,OAAA,GAAA4lD,GAEA,OADAE,GAAAtC,OACAsC,EAGA,QAAAE,IAAAF,GACAH,GAAAG,GACAG,GAAAvpD,OAAAopD,GACAC,GAAA9oD,KAAA6oD,GACAlE,GAAAkE,GAGA,QAAAI,IAAAJ,GACA,GAAAtgB,GAAAsgB,EAAAtgB,OACAhlC,EAAAglC,EAAAhlC,EACAoC,EAAA4iC,EAAAnT,GACAowB,GAAAjiD,EAAAoC,GACA6iC,EAAAqgB,EAAAhE,EACA5rD,EAAA4vD,EAAA5hC,EACAiiC,GAAAL,EAEAE,IAAAF,EAGA,KADA,GAAAd,GAAAvf,EACAuf,EAAAxf,QACA5jC,KAAAY,IAAAhC,EAAAwkD,EAAAxf,OAAAhlC,GAAA8iD,IACA1hD,KAAAY,IAAAI,EAAAoiD,EAAAxf,OAAAnT,IAAAixB,IACA7d,EAAAuf,EAAAlD,EACAqE,EAAAC,QAAApB,GACAgB,GAAAhB,GACAA,EAAAvf,CAGA0gB,GAAAC,QAAApB,GACAW,GAAAX,EAGA,KADA,GAAAC,GAAA/uD,EACA+uD,EAAAzf,QACA5jC,KAAAY,IAAAhC,EAAAykD,EAAAzf,OAAAhlC,GAAA8iD,IACA1hD,KAAAY,IAAAI,EAAAqiD,EAAAzf,OAAAnT,IAAAixB,IACAptD,EAAA+uD,EAAA/gC,EACAiiC,EAAAlpD,KAAAgoD,GACAe,GAAAf,GACAA,EAAA/uD,CAGAiwD,GAAAlpD,KAAAgoD,GACAU,GAAAV,EAEA,IACAoB,GADAC,EAAAH,EAAAjuD,MAEA,KAAAmuD,EAAA,EAAgBA,EAAAC,IAAcD,EAC9BpB,EAAAkB,EAAAE,GACArB,EAAAmB,EAAAE,EAAA,GACAhE,GAAA4C,EAAA9C,KAAA6C,EAAAxB,KAAAyB,EAAAzB,KAAAf,EAGAuC,GAAAmB,EAAA,GACAlB,EAAAkB,EAAAG,EAAA,GACArB,EAAA9C,KAAAD,GAAA8C,EAAAxB,KAAAyB,EAAAzB,KAAA,KAAAf,GAEAsC,GAAAC,GACAD,GAAAE,GAGA,QAAAsB,IAAA/C,GASA,IARA,GAEAwB,GACAC,EACAuB,EACAC,EALAjmD,EAAAgjD,EAAA,GACAkD,EAAAlD,EAAA,GAKAx4C,EAAAi7C,GAAA5/C,EAEA2E,GAEA,IADAw7C,EAAAG,GAAA37C,EAAA07C,GAAAlmD,GACA8iD,GAAAt4C,IAAAukC,MAAuC,CAEvC,MADAkX,EAAAjmD,EAAAomD,GAAA57C,EAAA07C,IACApD,IAMO,CACPkD,GAAAlD,IACA0B,EAAAh6C,EAAA82C,EACAmD,EAAAj6C,GACSy7C,GAAAnD,IACT0B,EAAAh6C,EACAi6C,EAAAj6C,EAAAkZ,GAEA8gC,EAAAC,EAAAj6C,CAEA,OAfA,IAAAA,EAAA62C,EAAA,CACAmD,EAAAh6C,CACA,OAEAA,IAAA62C,EAgBA0B,GAAAC,EACA,IAAAqD,GAAAhB,GAAArC,EAGA,IAFAyC,GAAA3gD,OAAA0/C,EAAA6B,GAEA7B,GAAAC,EAAA,CAEA,GAAAD,IAAAC,EAOA,MANAU,IAAAX,GACAC,EAAAY,GAAAb,EAAAxB,MACAyC,GAAA3gD,OAAAuhD,EAAA5B,GACA4B,EAAA1E,KAAA8C,EAAA9C,KAAAD,GAAA8C,EAAAxB,KAAAqD,EAAArD,MACAuB,GAAAC,OACAD,IAAAE,EAIA,KAAAA,EAEA,YADA4B,EAAA1E,KAAAD,GAAA8C,EAAAxB,KAAAqD,EAAArD,MAKAmC,IAAAX,GACAW,GAAAV,EAEA,IAAAC,GAAAF,EAAAxB,KACAxe,EAAAkgB,EAAA,GACAjgB,EAAAigB,EAAA,GACAvC,EAAAa,EAAA,GAAAxe,EACA4d,EAAAY,EAAA,GAAAve,EACAmgB,EAAAH,EAAAzB,KACApxB,EAAAgzB,EAAA,GAAApgB,EACA3S,EAAA+yB,EAAA,GAAAngB,EACA/tC,EAAA,GAAAyrD,EAAAtwB,EAAAuwB,EAAAxwB,GACA00B,EAAAnE,IAAAC,IACA2C,EAAAnzB,IAAAC,IACAowB,IAAApwB,EAAAy0B,EAAAlE,EAAA2C,GAAAruD,EAAA8tC,GAAA2d,EAAA4C,EAAAnzB,EAAA00B,GAAA5vD,EAAA+tC,EAEAod,IAAA4C,EAAA9C,KAAA+C,EAAAE,EAAA3C,GACAoE,EAAA1E,KAAAD,GAAAgD,EAAA1B,EAAA,KAAAf,GACAwC,EAAA9C,KAAAD,GAAAsB,EAAA4B,EAAA,KAAA3C,GACAsC,GAAAC,GACAD,GAAAE,IAGA,QAAA0B,IAAA7B,EAAA4B,GACA,GAAAlD,GAAAsB,EAAAtB,KACAuD,EAAAvD,EAAA,GACAwD,EAAAxD,EAAA,GACAyD,EAAAD,EAAAN,CAEA,KAAAO,EAAA,MAAAF,EAEA,IAAA/B,GAAAF,EAAAhD,CACA,KAAAkD,EAAA,OAAAvqC,GAEA+oC,GAAAwB,EAAAxB,IACA,IAAA0D,GAAA1D,EAAA,GACA2D,EAAA3D,EAAA,GACA4D,EAAAD,EAAAT,CAEA,KAAAU,EAAA,MAAAF,EAEA,IAAAG,GAAAH,EAAAH,EACAO,EAAA,EAAAL,EAAA,EAAAG,EACAjwD,EAAAkwD,EAAAD,CAEA,OAAAE,KAAAnwD,EAAAyK,KAAAiT,KAAA1d,IAAA,EAAAmwD,GAAAD,MAAA,EAAAD,GAAAD,EAAAC,EAAA,EAAAJ,EAAAC,EAAA,KAAAK,EAAAP,GAEAA,EAAAG,GAAA,EAGA,QAAAN,IAAA9B,EAAA4B,GACA,GAAAzB,GAAAH,EAAA5gC,CACA,IAAA+gC,EAAA,MAAA0B,IAAA1B,EAAAyB,EACA,IAAAlD,GAAAsB,EAAAtB,IACA,OAAAA,GAAA,KAAAkD,EAAAlD,EAAA,GAAA/oC,IAUA,QAAA8sC,IAAAhmD,EAAApK,EAAAqQ,GACA,OAAAjG,EAAA,GAAAiG,EAAA,KAAArQ,EAAA,GAAAoK,EAAA,KAAAA,EAAA,GAAApK,EAAA,KAAAqQ,EAAA,GAAAjG,EAAA,IAGA,QAAAimD,IAAAjmD,EAAApK,GACA,MAAAA,GAAA,GAAAoK,EAAA,IACApK,EAAA,GAAAoK,EAAA,GAGA,QAAAkmD,IAAAC,EAAAlmC,GACA,GACAhhB,GACAoC,EACA4iC,EAHAge,EAAAkE,EAAAja,KAAA+Z,IAAAxnD,KAUA,KALAoiD,MACAE,GAAA,GAAA/hD,OAAAmnD,EAAAxvD,QACA+tD,GAAA,GAAAtE,IACAhc,GAAA,GAAAgc,MAIA,GADAnc,EAAAkgB,GACAlC,KAAAhe,GAAAge,EAAA,GAAAhe,EAAA5iC,GAAA4gD,EAAA,KAAAhe,EAAA5iC,GAAA4gD,EAAA,GAAAhe,EAAAhlC,GACAgjD,EAAA,KAAAhjD,GAAAgjD,EAAA,KAAA5gD,IACA2jD,GAAA/C,GACAhjD,EAAAgjD,EAAA,GAAA5gD,EAAA4gD,EAAA,IAEAA,EAAAkE,EAAA1nD,UACK,KAAAwlC,EAGL,KAFA0gB,IAAA1gB,EAAAsf,KAQA,GAFAf,KAEAviC,EAAA,CACA,GAAAqH,IAAArH,EAAA,MACAsH,GAAAtH,EAAA,MACAuH,GAAAvH,EAAA,MACAwH,GAAAxH,EAAA,KACA6hC,IAAAx6B,EAAAC,EAAAC,EAAAC,GACAg7B,GAAAn7B,EAAAC,EAAAC,EAAAC,GAGAn0B,KAAAutD,SACAvtD,KAAAytD,SAEA2D,GACAtgB,GACAyc,GACAE,GAAA,KAiIA,QAAAqF,IAAAj3C,EAAApJ,EAAAzB,GACAhR,KAAA6b,SACA7b,KAAAyS,OACAzS,KAAAgR,YAGA,QAAA+hD,IAAAriD,EAAA/E,EAAAoC,GACA/N,KAAA0Q,IACA1Q,KAAA2L,IACA3L,KAAA+N,IA4CA,QAAAilD,IAAA78C,GACA,MAAAA,GAAA88C,QAAAC,GAGA,QAAAC,MACA1zD,EAAA2U,MAAAgH,2BASA,QAAAg4C,MACA,OAAA3zD,EAAA2U,MAAAgI,OAGA,QAAAi3C,MACA,GAAA12B,GAAA1e,EAAAhW,EAAAjI,IASA,OARAiI,aAAAqrD,aACArrD,IAAAqkB,iBAAArkB,EACA00B,EAAA10B,EAAAskB,MAAAjK,QAAAtgB,MACAic,EAAAhW,EAAAukB,OAAAlK,QAAAtgB,QAEA26B,EAAA10B,EAAAsrD,YACAt1C,EAAAhW,EAAAurD,gBAEA,MAAA72B,EAAA1e,IAGA,QAAAw1C,MACA,MAAAzzD,MAAAizD,QAAAC,GAGA,QAAAQ,MACA,OAAAj0D,EAAA2U,MAAAu/C,QAAAl0D,EAAA2U,MAAAw/C,UAAA,WAGA,QAAAC,MACA,sBAAA7zD,MAhwfA,GAEAwM,IAAA,SAAAE,EAAApK,GACA,MAAAoK,GAAApK,GAAA,EAAAoK,EAAApK,EAAA,EAAAoK,GAAApK,EAAA,EAAAuU,KAGAkuC,GAAA,SAAAvzB,GAEA,MADA,KAAAA,EAAAnuB,SAAAmuB,EAAAllB,EAAAklB,KAEArgB,KAAA,SAAAzE,EAAAf,EAAAs7C,EAAA6M,GAGA,IAFA,MAAA7M,MAAA,GACA,MAAA6M,MAAApnD,EAAArJ,QACA4jD,EAAA6M,GAAA,CACA,GAAAC,GAAA9M,EAAA6M,IAAA,CACAtiC,GAAA9kB,EAAAqnD,GAAApoD,GAAA,EAAAs7C,EAAA8M,EAAA,EACAD,EAAAC,EAEA,MAAA9M,IAEA71C,MAAA,SAAA1E,EAAAf,EAAAs7C,EAAA6M,GAGA,IAFA,MAAA7M,MAAA,GACA,MAAA6M,MAAApnD,EAAArJ,QACA4jD,EAAA6M,GAAA,CACA,GAAAC,GAAA9M,EAAA6M,IAAA,CACAtiC,GAAA9kB,EAAAqnD,GAAApoD,GAAA,EAAAmoD,EAAAC,EACA9M,EAAA8M,EAAA,EAEA,MAAA9M,MAWA+M,GAAAjP,GAAAv4C,IACAqqC,GAAAmd,GAAA5iD,MACA6iD,GAAAD,GAAA7iD,KAEA+iD,GAAA,SAAAppD,EAAAyB,GACA,MAAAA,MAAAE,EAEA,KADA,GAAAxG,GAAA,EAAA+L,EAAAlH,EAAAzH,OAAA,EAAAZ,EAAAqI,EAAA,GAAAopD,EAAA,GAAAxoD,OAAAsG,EAAA,IAAAA,GACA/L,EAAA+L,GAAAkiD,EAAAjuD,GAAAsG,EAAA9J,IAAAqI,IAAA7E,GACA,OAAAiuD,IAOAC,GAAA,SAAAC,EAAAC,EAAAntD,GACA,GAGAqsC,GACAC,EACAvtC,EACAiiB,EANAoH,EAAA8kC,EAAA/wD,OACAosB,EAAA4kC,EAAAhxD,OACAqL,EAAA,GAAAhD,OAAA4jB,EAAAG,EAQA,KAFA,MAAAvoB,MAAAuF,GAEA8mC,EAAAttC,EAAA,EAAkBstC,EAAAjkB,IAASikB,EAC3B,IAAArrB,EAAAksC,EAAA7gB,GAAAC,EAAA,EAAsCA,EAAA/jB,IAAS+jB,IAAAvtC,EAC/CyI,EAAAzI,GAAAiB,EAAAghB,EAAAmsC,EAAA7gB,GAIA,OAAA9kC,IAGA4lD,GAAA,SAAA5nD,EAAApK,GACA,MAAAA,GAAAoK,GAAA,EAAApK,EAAAoK,EAAA,EAAApK,GAAAoK,EAAA,EAAAmK,KAGA09C,GAAA,SAAA5oD,GACA,cAAAA,EAAAkL,KAAAlL,GAGA6oD,GAAA,SAAA9lD,EAAA+lD,GACA,GAIAzyD,GACA44B,EALA5oB,EAAAtD,EAAArL,OACA6R,EAAA,EACAjP,GAAA,EACAyuD,EAAA,EAGAlnB,EAAA,CAEA,UAAAinB,EACA,OAAAxuD,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAA7lD,EAAAzI,OACA20B,EAAA54B,EAAA0yD,EACAA,GAAA95B,IAAA1lB,EACAs4B,GAAA5S,GAAA54B,EAAA0yD,QAMA,QAAAzuD,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAAE,EAAA/lD,EAAAzI,KAAAyI,OACAksB,EAAA54B,EAAA0yD,EACAA,GAAA95B,IAAA1lB,EACAs4B,GAAA5S,GAAA54B,EAAA0yD,GAKA,IAAAx/C,EAAA,QAAAs4B,IAAAt4B,EAAA,IAGAy/C,GAAA,SAAA7pD,EAAAyB,GACA,GAAAgL,GAAAi9C,GAAA1pD,EAAAyB,EACA,OAAAgL,GAAAxK,KAAAiT,KAAAzI,MAGAoV,GAAA,SAAAje,EAAA+lD,GACA,GAEAzyD,GACAsc,EACAtR,EAJAgF,EAAAtD,EAAArL,OACA4C,GAAA,CAKA,UAAAwuD,GACA,OAAAxuD,EAAA+L,GACA,UAAAhQ,EAAA0M,EAAAzI,KAAAjE,KAEA,IADAsc,EAAAtR,EAAAhL,IACAiE,EAAA+L,GACA,OAAAhQ,EAAA0M,EAAAzI,MACAqY,EAAAtc,IAAAsc,EAAAtc,GACAgL,EAAAhL,IAAAgL,EAAAhL,QAQA,QAAAiE,EAAA+L,GACA,UAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,KAAA1M,KAEA,IADAsc,EAAAtR,EAAAhL,IACAiE,EAAA+L,GACA,OAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,MACA4P,EAAAtc,IAAAsc,EAAAtc,GACAgL,EAAAhL,IAAAgL,EAAAhL,GAOA,QAAAsc,EAAAtR,IAGAlC,GAAAY,MAAAvL,UAEAqJ,GAAAsB,GAAAtB,MACA+I,GAAAzH,GAAAyH,IAEAqiD,GAAA,SAAAjpD,GACA,kBACA,MAAAA,KAIAkpD,GAAA,SAAAlpD,GACA,MAAAA,IAGAs3B,GAAA,SAAAr2B,EAAAC,EAAAC,GACAF,KAAAC,KAAAC,GAAAkF,EAAA5O,UAAAC,QAAA,GAAAwJ,EAAAD,IAAA,KAAAoF,EAAA,KAAAlF,CAMA,KAJA,GAAA7G,IAAA,EACA+L,EAAA,EAAAjF,KAAAC,IAAA,EAAAD,KAAAs2B,MAAAx2B,EAAAD,GAAAE,IACAuC,EAAA,GAAA3D,OAAAsG,KAEA/L,EAAA+L,GACA3C,EAAApJ,GAAA2G,EAAA3G,EAAA6G,CAGA,OAAAuC,IAGA/B,GAAAP,KAAAiT,KAAA,IACAzS,GAAAR,KAAAiT,KAAA,IACAxS,GAAAT,KAAAiT,KAAA,GAEApR,GAAA,SAAAhC,EAAAC,EAAArB,GACA,GAEAwG,GACApD,EACA9B,EAJA22B,EAAA52B,EAAAD,EACA3G,GAAA,CAOA,IAFAw9B,IAAAzxB,EAAApF,IAAAC,IAAAmF,GAEA,KAAAlF,EAAAH,EAAAC,EAAAC,EAAArB,MAAAuF,SAAAjE,GAAA,QAEA,IAAAA,EAAA,EAIA,IAHAF,EAAAG,KAAAs2B,KAAAz2B,EAAAE,GACAD,EAAAE,KAAAG,MAAAL,EAAAC,GACA8B,EAAA,GAAAlD,OAAAsG,EAAAjF,KAAAs2B,KAAAx2B,EAAAD,EAAA,MACA3G,EAAA+L,GAAApD,EAAA3I,IAAA2G,EAAA3G,GAAA6G,MAKA,KAHAF,EAAAG,KAAAG,MAAAN,EAAAE,GACAD,EAAAE,KAAAs2B,KAAAx2B,EAAAC,GACA8B,EAAA,GAAAlD,OAAAsG,EAAAjF,KAAAs2B,KAAAz2B,EAAAC,EAAA,MACA5G,EAAA+L,GAAApD,EAAA3I,IAAA2G,EAAA3G,GAAA6G,CAKA,OAFA22B,IAAA70B,EAAA60B,UAEA70B,GAsBAkmD,GAAA,SAAApmD,GACA,MAAA3B,MAAAs2B,KAAAt2B,KAAAI,IAAAuB,EAAArL,QAAA0J,KAAAgoD,KAAA,GAGAC,GAAA,WAKA,QAAAA,GAAAplD,GACA,GAAA3J,GAEA0F,EADAqG,EAAApC,EAAAvM,OAEAqL,EAAA,GAAAhD,OAAAsG,EAEA,KAAA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EACtByI,EAAAzI,GAAAjE,EAAA4N,EAAA3J,KAAA2J,EAGA,IAAA2kB,GAAAzlB,EAAAJ,GACAslB,EAAAO,EAAA,GACAL,EAAAK,EAAA,GACA0gC,EAAAvc,EAAAhqC,EAAAslB,EAAAE,EAGAxoB,OAAAxD,QAAA+sD,KACAA,EAAAxnD,EAAAumB,EAAAE,EAAA+gC,GACAA,EAAAhyB,GAAAl2B,KAAAs2B,KAAArP,EAAAihC,KAAAloD,KAAAG,MAAAgnB,EAAA+gC,QAKA,KADA,GAAA//C,GAAA+/C,EAAA5xD,OACA4xD,EAAA,IAAAjhC,GAAAihC,EAAA5iB,UAAAn9B,CACA,MAAA+/C,EAAA//C,EAAA,GAAAgf,GAAA+gC,EAAA9pD,QAAA+J,CAEA,IACAggD,GADAC,EAAA,GAAAzpD,OAAAwJ,EAAA,EAIA,KAAAjP,EAAA,EAAeA,GAAAiP,IAAQjP,EACvBivD,EAAAC,EAAAlvD,MACAivD,EAAAlhC,GAAA/tB,EAAA,EAAAgvD,EAAAhvD,EAAA,GAAA+tB,EACAkhC,EAAAhhC,GAAAjuB,EAAAiP,EAAA+/C,EAAAhvD,GAAAiuB,CAIA,KAAAjuB,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB0F,EAAA+C,EAAAzI,GACA+tB,GAAAroB,MAAAuoB,GACAihC,EAAAte,GAAAoe,EAAAtpD,EAAA,EAAAuJ,IAAA9M,KAAAwH,EAAA3J,GAIA,OAAAkvD,GAhDA,GAAAnzD,GAAA6yD,GACA/lD,EAAA6d,GACA+rB,EAAAoc,EA6DA,OAZAE,GAAAhzD,MAAA,SAAAwP,GACA,MAAApO,WAAAC,QAAArB,EAAA,kBAAAwP,KAAAojD,GAAApjD,GAAAwjD,GAAAhzD,GAGAgzD,EAAAlmD,OAAA,SAAA0C,GACA,MAAApO,WAAAC,QAAAyL,EAAA,kBAAA0C,KAAAojD,IAAApjD,EAAA,GAAAA,EAAA,KAAAwjD,GAAAlmD,GAGAkmD,EAAAvc,WAAA,SAAAjnC,GACA,MAAApO,WAAAC,QAAAq1C,EAAA,kBAAAlnC,KAAAojD,GAAAlpD,MAAAxD,QAAAsJ,GAAAhI,GAAA3I,KAAA2Q,MAAAwjD,GAAAtc,GAGAsc,GAGAtc,GAAA,SAAAhqC,EAAAjM,EAAAgyD,GAEA,GADA,MAAAA,MAAAF,IACAviD,EAAAtD,EAAArL,OAAA,CACA,IAAAZ,OAAA,GAAAuP,EAAA,SAAAyiD,EAAA/lD,EAAA,KAAAA,EACA,IAAAjM,GAAA,SAAAgyD,EAAA/lD,EAAAsD,EAAA,GAAAA,EAAA,EAAAtD,EACA,IAAAsD,GACA/L,GAAA+L,EAAA,GAAAvP,EACA8wC,EAAAxmC,KAAAG,MAAAjH,GACAiiB,GAAAusC,EAAA/lD,EAAA6kC,KAAA7kC,EAEA,OAAAwZ,KADAusC,EAAA/lD,EAAA6kC,EAAA,GAAAA,EAAA,EAAA7kC,GACAwZ,IAAAjiB,EAAAstC,KAGA6hB,GAAA,SAAA1mD,EAAA4P,EAAAtR,GAEA,MADA0B,GAAA6D,GAAA1R,KAAA6N,EAAA6lD,IAAA3b,KAAApsC,IACAO,KAAAs2B,MAAAr2B,EAAAsR,IAAA,GAAAo6B,GAAAhqC,EAAA,KAAAgqC,GAAAhqC,EAAA,MAAA3B,KAAAM,IAAAqB,EAAArL,QAAA,QAGAgyD,GAAA,SAAA3mD,EAAA4P,EAAAtR,GACA,MAAAD,MAAAs2B,MAAAr2B,EAAAsR,IAAA,IAAAq2C,GAAAjmD,GAAA3B,KAAAM,IAAAqB,EAAArL,QAAA,QAGA2J,GAAA,SAAA0B,EAAA+lD,GACA,GAEAzyD,GACAgL,EAHAgF,EAAAtD,EAAArL,OACA4C,GAAA,CAIA,UAAAwuD,GACA,OAAAxuD,EAAA+L,GACA,UAAAhQ,EAAA0M,EAAAzI,KAAAjE,KAEA,IADAgL,EAAAhL,IACAiE,EAAA+L,GACA,OAAAhQ,EAAA0M,EAAAzI,KAAAjE,EAAAgL,IACAA,EAAAhL,OAQA,QAAAiE,EAAA+L,GACA,UAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,KAAA1M,KAEA,IADAgL,EAAAhL,IACAiE,EAAA+L,GACA,OAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,KAAA1M,EAAAgL,IACAA,EAAAhL,EAOA,OAAAgL,IAGA0nD,GAAA,SAAAhmD,EAAA+lD,GACA,GAGAzyD,GAHAgQ,EAAAtD,EAAArL,OACA6R,EAAAlD,EACA/L,GAAA,EAEAunC,EAAA,CAEA,UAAAinB,EACA,OAAAxuD,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAA7lD,EAAAzI,OACAiP,EADAs4B,GAAAxrC,MAMA,QAAAiE,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAAE,EAAA/lD,EAAAzI,KAAAyI,OACAwG,EADAs4B,GAAAxrC,CAKA,IAAAkT,EAAA,MAAAs4B,GAAAt4B,GAGAogD,GAAA,SAAA5mD,EAAA+lD,GACA,GAEAzyD,GAFAgQ,EAAAtD,EAAArL,OACA4C,GAAA,EAEAsvD,IAEA,UAAAd,EACA,OAAAxuD,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAA7lD,EAAAzI,MACAsvD,EAAAntD,KAAApG,OAMA,QAAAiE,EAAA+L,GACAqP,MAAArf,EAAAuyD,GAAAE,EAAA/lD,EAAAzI,KAAAyI,MACA6mD,EAAAntD,KAAApG,EAKA,OAAA02C,IAAA6c,EAAA3c,KAAApsC,IAAA,KAGAgE,GAAA,SAAAglD,GAQA,IAPA,GACAtgD,GAGAugD,EACA3qD,EALAkH,EAAAwjD,EAAAnyD,OAEA4C,GAAA,EACAgP,EAAA,IAIAhP,EAAA+L,GAAAiD,GAAAugD,EAAAvvD,GAAA5C,MAGA,KAFAoyD,EAAA,GAAA/pD,OAAAuJ,KAEAjD,GAAA,GAGA,IAFAlH,EAAA0qD,EAAAxjD,GACAkD,EAAApK,EAAAzH,SACA6R,GAAA,GACAugD,IAAAxgD,GAAAnK,EAAAoK,EAIA,OAAAugD,IAGAn3C,GAAA,SAAA5P,EAAA+lD,GACA,GAEAzyD,GACAsc,EAHAtM,EAAAtD,EAAArL,OACA4C,GAAA,CAIA,UAAAwuD,GACA,OAAAxuD,EAAA+L,GACA,UAAAhQ,EAAA0M,EAAAzI,KAAAjE,KAEA,IADAsc,EAAAtc,IACAiE,EAAA+L,GACA,OAAAhQ,EAAA0M,EAAAzI,KAAAqY,EAAAtc,IACAsc,EAAAtc,OAQA,QAAAiE,EAAA+L,GACA,UAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,KAAA1M,KAEA,IADAsc,EAAAtc,IACAiE,EAAA+L,GACA,OAAAhQ,EAAAyyD,EAAA/lD,EAAAzI,KAAAyI,KAAA4P,EAAAtc,IACAsc,EAAAtc,EAOA,OAAAsc,IAGAo3C,GAAA,SAAA5qD,EAAAgpC,GAEA,IADA,GAAA7tC,GAAA6tC,EAAAzwC,OAAAsyD,EAAA,GAAAjqD,OAAAzF,GACAA,KAAA0vD,EAAA1vD,GAAA6E,EAAAgpC,EAAA7tC,GACA,OAAA0vD,IAGAC,GAAA,SAAAlnD,EAAA8iB,GACA,GAAAxf,EAAAtD,EAAArL,OAAA,CACA,GAAA2O,GAGA6jD,EAFA5vD,EAAA,EACAgP,EAAA,EAEA6gD,EAAApnD,EAAAuG,EAIA,KAFA,MAAAuc,MAAAhlB,MAEAvG,EAAA+L,IACAwf,EAAAqkC,EAAAnnD,EAAAzI,GAAA6vD,GAAA,OAAAtkC,EAAAskC,QACAA,EAAAD,EAAA5gD,EAAAhP,EAIA,YAAAurB,EAAAskC,KAAA7gD,MAAA,KAGA8gD,GAAA,SAAAjrD,EAAAyoC,EAAAC,GAKA,IAJA,GACAzhC,GACA9L,EAFAiP,GAAA,MAAAs+B,EAAA1oC,EAAAzH,OAAAmwC,IAAAD,EAAA,MAAAA,EAAA,GAAAA,GAIAr+B,GACAjP,EAAA8G,KAAAyhC,SAAAt5B,IAAA,EACAnD,EAAAjH,EAAAoK,EAAAq+B,GACAzoC,EAAAoK,EAAAq+B,GAAAzoC,EAAA7E,EAAAstC,GACAzoC,EAAA7E,EAAAstC,GAAAxhC,CAGA,OAAAjH,IAGA0iC,GAAA,SAAA9+B,EAAA+lD,GACA,GAEAzyD,GAFAgQ,EAAAtD,EAAArL,OACA4C,GAAA,EAEAunC,EAAA,CAEA,UAAAinB,EACA,OAAAxuD,EAAA+L,IACAhQ,GAAA0M,EAAAzI,MAAAunC,GAAAxrC,OAKA,QAAAiE,EAAA+L,IACAhQ,GAAAyyD,EAAA/lD,EAAAzI,KAAAyI,MAAA8+B,GAAAxrC,EAIA,OAAAwrC,IAGAwoB,GAAA,SAAAxzC,GACA,KAAAxQ,EAAAwQ,EAAAnf,QAAA,QACA,QAAA4C,IAAA,EAAAiP,EAAAoJ,GAAAkE,EAAAnf,GAAA2yD,EAAA,GAAAtqD,OAAAwJ,KAAqEjP,EAAAiP,GACrE,OAAAlD,GAAAiD,GAAA,EAAAoe,EAAA2iC,EAAA/vD,GAAA,GAAAyF,OAAAsG,KAA0DiD,EAAAjD,GAC1DqhB,EAAApe,GAAAuN,EAAAvN,GAAAhP,EAGA,OAAA+vD,IAOAC,GAAA,WACA,MAAAD,IAAA5yD,YAGAqO,GAAA/F,MAAAvL,UAAAqJ,MAEAyF,GAAA,SAAAtD,GACA,MAAAA,IAGAgF,GAAA,EACAS,GAAA,EACAR,GAAA,EACAO,GAAA,EACAL,GAAA,KAwKAgC,IAAY9Q,MAAA,aAuBZiQ,GAAA9R,UAAAmL,EAAAnL,WACAqC,YAAAyP,EACA6C,GAAA,SAAAD,EAAAhC,GACA,GAEAd,GAFAP,EAAAxR,KAAAwR,EACA0kD,EAAAhkD,EAAA2C,EAAA,GAAArD,GAEAvL,GAAA,EACA+L,EAAAkkD,EAAA7yD,MAGA,OAAAD,UAAAC,OAAA,IAOA,SAAAwP,GAAA,kBAAAA,GAAA,SAAAjR,OAAA,qBAAAiR,EACA,QAAA5M,EAAA+L,GACA,GAAAD,GAAA8C,EAAAqhD,EAAAjwD,IAAAwM,KAAAjB,EAAAO,GAAAa,EAAApB,EAAAO,GAAA8C,EAAArC,KAAAK,OACA,UAAAA,EAAA,IAAAd,IAAAP,KAAAO,GAAAa,EAAApB,EAAAO,GAAA8C,EAAArC,KAAA,KAGA,OAAAxS,MAZA,OAAAiG,EAAA+L,GAAA,IAAAD,GAAA8C,EAAAqhD,EAAAjwD,IAAAwM,QAAAV,EAAAW,EAAAlB,EAAAO,GAAA8C,EAAArC,OAAA,MAAAT,KAcAxI,KAAA,WACA,GAAAA,MAAiBiI,EAAAxR,KAAAwR,CACjB,QAAAO,KAAAP,GAAAjI,EAAAwI,GAAAP,EAAAO,GAAAvI,OACA,WAAAyI,GAAA1I,IAEA1I,KAAA,SAAA4R,EAAAiD,GACA,IAAA1D,EAAA5O,UAAAC,OAAA,YAAA2O,GAAAD,EAAA4D,EAAA,GAAAjK,OAAAsG,GAAA/L,EAAA,EAAkFA,EAAA+L,IAAO/L,EAAA0P,EAAA1P,GAAA7C,UAAA6C,EAAA,EACzF,KAAAjG,KAAAwR,EAAA9O,eAAA+P,GAAA,SAAA7Q,OAAA,iBAAA6Q,EACA,KAAAV,EAAA/R,KAAAwR,EAAAiB,GAAAxM,EAAA,EAAA+L,EAAAD,EAAA1O,OAA+C4C,EAAA+L,IAAO/L,EAAA8L,EAAA9L,GAAAjE,MAAAgD,MAAA0Q,EAAAC,IAEtD3Q,MAAA,SAAAyN,EAAAiD,EAAAC,GACA,IAAA3V,KAAAwR,EAAA9O,eAAA+P,GAAA,SAAA7Q,OAAA,iBAAA6Q,EACA,QAAAV,GAAA/R,KAAAwR,EAAAiB,GAAAxM,EAAA,EAAA+L,EAAAD,EAAA1O,OAAmD4C,EAAA+L,IAAO/L,EAAA8L,EAAA9L,GAAAjE,MAAAgD,MAAA0Q,EAAAC,IAuB1D,IAAAvC,IAAA,+BAEA+iD,IACA9pC,IAAA,6BACAjZ,SACAgjD,MAAA,+BACAC,IAAA,uCACAC,MAAA,iCAGAC,GAAA,SAAA/jD,GACA,GAAAgkD,GAAAhkD,GAAA,GAAAvM,EAAAuwD,EAAA7tD,QAAA,IAEA,OADA1C,IAAA,cAAAuwD,EAAAhkD,EAAAhJ,MAAA,EAAAvD,MAAAuM,IAAAhJ,MAAAvD,EAAA,IACAkwD,GAAAzzD,eAAA8zD,IAA8C9iD,MAAAyiD,GAAAK,GAAA7iD,MAAAnB,GAAuCA,GAmBrFikD,GAAA,SAAAjkD,GACA,GAAAiB,GAAA8iD,GAAA/jD,EACA,QAAAiB,EAAAE,MACAH,EACAT,GAAAU,IAGAK,GAAA,CAUAD,GAAA1T,UAAAyT,EAAAzT,WACAqC,YAAAqR,EACAnB,IAAA,SAAAyD,GAEA,IADA,GAAA2F,GAAA9b,KAAAwR,IACAsK,IAAA3F,KAAA,KAAAA,IAAAjF,YAAA,MACA,OAAAiF,GAAA2F,IAEAlJ,IAAA,SAAAuD,EAAAnU,GACA,MAAAmU,GAAAnW,KAAAwR,GAAAxP,GAEA6F,OAAA,SAAAsO,GACA,MAAAnW,MAAAwR,IAAA2E,aAAAnW,KAAAwR,IAEAuC,SAAA,WACA,MAAA/T,MAAAwR,GAIA,IAAAklD,IAAA,SAAA3qD,GACA,kBACA,MAAA/L,MAAA22D,QAAA5qD,IAIA,uBAAAiH,UAAA,CACA,GAAA4jD,IAAA5jD,SAAAK,eACA,KAAAujD,GAAAD,QAAA,CACA,GAAAE,IAAAD,GAAAE,uBACAF,GAAAG,mBACAH,GAAAI,oBACAJ,GAAAK,gBACAP,IAAA,SAAA3qD,GACA,kBACA,MAAA8qD,IAAAh2D,KAAAb,KAAA+L,MAMA,GAAAmrD,IAAAR,GAEAnhD,KAIA,IAFA9V,EAAA2U,MAAA,KAEA,mBAAApB,UAAA,CAEA,gBADAA,UAAAK,kBAEAkC,IAAoB4hD,WAAA,YAAAC,WAAA,aAqEpB,GAAAC,IAAA,SAAAxiD,EAAA7S,EAAAoT,GACA,GAAAnP,GAAA8L,EAAAI,EAAAwC,EAAAE,EAAA,IAAA7C,EAAAG,EAAA9O,MAEA,OAAAD,UAAAC,OAAA,IAcA,IAFAyR,EAAA9S,EAAAqT,EAAAT,EACA,MAAAQ,OAAA,GACAnP,EAAA,EAAaA,EAAA+L,IAAO/L,EAAAjG,KAAAuR,KAAAuD,EAAA3C,EAAAlM,GAAAjE,EAAAoT,GACpB,OAAApV,MAdA,GAAA8U,GAAA9U,KAAAmW,OAAApB,IACA,IAAAD,EAAA,OAAAE,GAAAC,EAAA,EAAAC,EAAAJ,EAAAzR,OAA6C4R,EAAAC,IAAOD,EACpD,IAAAhP,EAAA,EAAA+O,EAAAF,EAAAG,GAA4BhP,EAAA+L,IAAO/L,EACnC,IAAA8L,EAAAI,EAAAlM,IAAAwM,OAAAuC,EAAAvC,MAAAV,EAAAS,OAAAwC,EAAAxC,KACA,MAAAwC,GAAAhT,QAwBA4T,GAAA,WAEA,IADA,GAAArV,GAAA+2D,EAAA73D,EAAA2U,MACA7T,EAAA+2D,EAAA1hD,aAAA0hD,EAAA/2D,CACA,OAAA+2D,IAGAhpC,GAAA,SAAAnY,EAAA/B,GACA,GAAAiY,GAAAlW,EAAAmW,iBAAAnW,CAEA,IAAAkW,EAAAkrC,eAAA,CACA,GAAAjpC,GAAAjC,EAAAkrC,gBAGA,OAFAjpC,GAAA3iB,EAAAyI,EAAAojD,QAAAlpC,EAAAvgB,EAAAqG,EAAAqjD,QACAnpC,IAAAopC,gBAAAvhD,EAAAwhD,eAAAC,YACAtpC,EAAA3iB,EAAA2iB,EAAAvgB,GAGA,GAAA8pD,GAAA1hD,EAAA2hD,uBACA,QAAA1jD,EAAAojD,QAAAK,EAAA1mD,KAAAgF,EAAA4hD,WAAA3jD,EAAAqjD,QAAAI,EAAAlnD,IAAAwF,EAAA6hD,YAGA9pC,GAAA,SAAA/X,GACA,GAAA/B,GAAAwB,IAEA,OADAxB,GAAAmc,iBAAAnc,IAAAmc,eAAA,IACAjC,GAAAnY,EAAA/B,IAKArI,GAAA,SAAAA,GACA,aAAAA,EAAA8J,EAAA,WACA,MAAA7V,MAAAi4D,cAAAlsD,KAIAmsD,GAAA,SAAA5nD,GACA,kBAAAA,OAAAvE,GAAAuE,GAEA,QAAA0K,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,EAAA,GAAAzsD,OAAAwJ,GAAAD,EAAA,EAAqFA,EAAAC,IAAOD,EAC5F,OAAAkB,GAAAiiD,EAAAlkD,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAAg1D,EAAAF,EAAAljD,GAAA,GAAAvJ,OAAAsG,GAAA/L,EAAA,EAA+GA,EAAA+L,IAAO/L,GACtHkQ,EAAAjC,EAAAjO,MAAAmyD,EAAA9nD,EAAAzP,KAAAsV,IAAAzB,SAAAzO,EAAAiO,MACA,YAAAiC,KAAAiiD,EAAA1jD,SAAAyB,EAAAzB,UACA2jD,EAAApyD,GAAAmyD,EAKA,WAAAr9C,IAAAo9C,EAAAn4D,KAAAiE,WAOAq0D,GAAA,SAAAvsD,GACA,aAAAA,EAAA+J,EAAA,WACA,MAAA9V,MAAAu4D,iBAAAxsD,KAIAysD,GAAA,SAAAloD,GACA,kBAAAA,OAAAgoD,GAAAhoD,GAEA,QAAA0K,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,KAAAl9C,KAAAhG,EAAA,EAAyFA,EAAAC,IAAOD,EAChG,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAA4C,EAAA,EAA8DA,EAAA+L,IAAO/L,GACrEkQ,EAAAjC,EAAAjO,MACAkyD,EAAA/vD,KAAAkI,EAAAzP,KAAAsV,IAAAzB,SAAAzO,EAAAiO,IACA+G,EAAA7S,KAAA+N,GAKA,WAAA4E,IAAAo9C,EAAAl9C,IAGAw9C,GAAA,SAAA7iC,GACA,kBAAAA,OAAAshC,GAAAthC,GAEA,QAAA5a,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,EAAA,GAAAzsD,OAAAwJ,GAAAD,EAAA,EAAqFA,EAAAC,IAAOD,EAC5F,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAAg1D,EAAAF,EAAAljD,MAAAhP,EAAA,EAA4FA,EAAA+L,IAAO/L,GACnGkQ,EAAAjC,EAAAjO,KAAA2vB,EAAA/0B,KAAAsV,IAAAzB,SAAAzO,EAAAiO,IACAmkD,EAAAjwD,KAAA+N,EAKA,WAAA4E,IAAAo9C,EAAAn4D,KAAAiE,WAGAy0D,GAAA,SAAAxiD,GACA,UAAAxK,OAAAwK,EAAA7S,SAGAs1D,GAAA,WACA,UAAA59C,IAAA/a,KAAA44D,QAAA54D,KAAAkb,QAAA3I,IAAAmmD,IAAA14D,KAAAiE,UAWA8R,GAAA5V,WACAqC,YAAAuT,EACA+D,YAAA,SAAAg0B,GAAgC,MAAA9tC,MAAAgE,QAAAiW,aAAA6zB,EAAA9tC,KAAA0D,QAChCuW,aAAA,SAAA6zB,EAAAzsC,GAAuC,MAAArB,MAAAgE,QAAAiW,aAAA6zB,EAAAzsC,IACvC42D,cAAA,SAAAlsD,GAAqC,MAAA/L,MAAAgE,QAAAi0D,cAAAlsD,IACrCwsD,iBAAA,SAAAxsD,GAAwC,MAAA/L,MAAAgE,QAAAu0D,iBAAAxsD,IAGxC,IAAA8sD,IAAA,SAAAltD,GACA,kBACA,MAAAA,KAIAgL,GAAA,IAwEAmiD,GAAA,SAAA92D,EAAAuU,GACA,IAAAvU,EAGA,MAFA4N,GAAA,GAAAlE,OAAA1L,KAAAkoC,QAAAjzB,GAAA,EACAjV,KAAAuR,KAAA,SAAAlP,GAA2BuN,IAAAqF,GAAA5S,IAC3BuN,CAGA,IAAAtL,GAAAiS,EAAAD,EAAAL,EACAgF,EAAAjb,KAAAiE,SACA+W,EAAAhb,KAAAkb,OAEA,mBAAAlZ,OAAA62D,GAAA72D,GAEA,QAAAkT,GAAA8F,EAAA3X,OAAA6S,EAAA,GAAAxK,OAAAwJ,GAAAhF,EAAA,GAAAxE,OAAAwJ,GAAAlF,EAAA,GAAAtE,OAAAwJ,GAAAD,EAAA,EAAsGA,EAAAC,IAAOD,EAAA,CAC7G,GAAArQ,GAAAqW,EAAAhG,GACAf,EAAA8G,EAAA/F,GACAmB,EAAAlC,EAAA7Q,OACAuM,EAAA5N,EAAAnB,KAAA+D,OAAA8P,SAAAO,EAAAgG,GACA5E,EAAAzG,EAAAvM,OACA01D,EAAA7oD,EAAA+E,GAAA,GAAAvJ,OAAA2K,GACA2iD,EAAA9iD,EAAAjB,GAAA,GAAAvJ,OAAA2K,EAGA/R,GAAAM,EAAAsP,EAAA6kD,EAAAC,EAFAhpD,EAAAiF,GAAA,GAAAvJ,OAAA0K,GAEAxG,EAAA2G,EAKA,QAAAq6B,GAAAvvC,EAAAkyC,EAAA,EAAAC,EAAA,EAA4CD,EAAAl9B,IAAiBk9B,EAC7D,GAAA3C,EAAAmoB,EAAAxlB,GAAA,CAEA,IADAA,GAAAC,MAAAD,EAAA,KACAlyC,EAAA23D,EAAAxlB,SAAAn9B,IACAu6B,EAAAltC,MAAArC,GAAA,MAQA,MAHA6U,GAAA,GAAA6E,IAAA7E,EAAA+E,GACA/E,EAAA0iD,OAAA1oD,EACAgG,EAAA+iD,MAAAjpD,EACAkG,GAGAgjD,GAAA,WACA,UAAAn+C,IAAA/a,KAAAi5D,OAAAj5D,KAAAkb,QAAA3I,IAAAmmD,IAAA14D,KAAAiE,WAGAk1D,GAAA,SAAA39C,GAEA,OAAA49C,GAAAp5D,KAAAkb,QAAAm+C,EAAA79C,EAAAN,QAAAo+C,EAAAF,EAAA/1D,OAAAob,EAAA46C,EAAAh2D,OAAA6R,EAAAnI,KAAAuR,IAAAg7C,EAAA76C,GAAA86C,EAAA,GAAA7tD,OAAA4tD,GAAArkD,EAAA,EAAiKA,EAAAC,IAAOD,EACxK,OAAAkB,GAAAqjD,EAAAJ,EAAAnkD,GAAAwkD,EAAAJ,EAAApkD,GAAAjD,EAAAwnD,EAAAn2D,OAAAmN,EAAA+oD,EAAAtkD,GAAA,GAAAvJ,OAAAsG,GAAA/L,EAAA,EAAwHA,EAAA+L,IAAO/L,GAC/HkQ,EAAAqjD,EAAAvzD,IAAAwzD,EAAAxzD,MACAuK,EAAAvK,GAAAkQ,EAKA,MAAQlB,EAAAqkD,IAAQrkD,EAChBskD,EAAAtkD,GAAAmkD,EAAAnkD,EAGA,WAAA8F,IAAAw+C,EAAAv5D,KAAAiE,WAGAy1D,GAAA,WAEA,OAAA1+C,GAAAhb,KAAAkb,QAAAjG,GAAA,EAAAC,EAAA8F,EAAA3X,SAA4D4R,EAAAC,GAC5D,OAAAiB,GAAAjC,EAAA8G,EAAA/F,GAAAhP,EAAAiO,EAAA7Q,OAAA,EAAAhC,EAAA6S,EAAAjO,KAA4EA,GAAA,IAC5EkQ,EAAAjC,EAAAjO,MACA5E,OAAA8U,EAAA0D,aAAAxY,EAAA6P,WAAA+I,aAAA9D,EAAA9U,GACAA,EAAA8U,EAKA,OAAAnW,OAGA25D,GAAA,SAAAnoC,GAGA,QAAAooC,GAAAltD,EAAApK,GACA,MAAAoK,IAAApK,EAAAkvB,EAAA9kB,EAAAgI,SAAApS,EAAAoS,WAAAhI,GAAApK,EAHAkvB,MAAA5a,EAMA,QAAAoE,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAAw2D,EAAA,GAAAnuD,OAAAwJ,GAAAD,EAAA,EAAsFA,EAAAC,IAAOD,EAAA,CAC7F,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAAy2D,EAAAD,EAAA5kD,GAAA,GAAAvJ,OAAAsG,GAAA/L,EAAA,EAAwGA,EAAA+L,IAAO/L,GAC/GkQ,EAAAjC,EAAAjO,MACA6zD,EAAA7zD,GAAAkQ,EAGA2jD,GAAAlhB,KAAAghB,GAGA,UAAA7+C,IAAA8+C,EAAA75D,KAAAiE,UAAA6L,SAOAiqD,GAAA,WACA,GAAAlnD,GAAAzP,UAAA,EAGA,OAFAA,WAAA,GAAApD,KACA6S,EAAA7N,MAAA,KAAA5B,WACApD,MAGAg6D,GAAA,WACA,GAAAllC,GAAA,GAAAppB,OAAA1L,KAAAkoC,QAAAjiC,GAAA,CAEA,OADAjG,MAAAuR,KAAA,WAAwBujB,IAAA7uB,GAAAjG,OACxB80B,GAGAmlC,GAAA,WAEA,OAAAj/C,GAAAhb,KAAAkb,QAAAjG,EAAA,EAAAC,EAAA8F,EAAA3X,OAA2D4R,EAAAC,IAAOD,EAClE,OAAAf,GAAA8G,EAAA/F,GAAAhP,EAAA,EAAA+L,EAAAkC,EAAA7Q,OAAwD4C,EAAA+L,IAAO/L,EAAA,CAC/D,GAAAkQ,GAAAjC,EAAAjO,EACA,IAAAkQ,EAAA,MAAAA,GAIA,aAGA+jD,GAAA,WACA,GAAAhyB,GAAA,CAEA,OADAloC,MAAAuR,KAAA,aAAwB22B,IACxBA,GAGAiyB,GAAA,WACA,OAAAn6D,KAAAmW,QAGAikD,GAAA,SAAAvnD,GAEA,OAAAmI,GAAAhb,KAAAkb,QAAAjG,EAAA,EAAAC,EAAA8F,EAAA3X,OAA2D4R,EAAAC,IAAOD,EAClE,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAhP,EAAA,EAAA+L,EAAAkC,EAAA7Q,OAA8D4C,EAAA+L,IAAO/L,GACrEkQ,EAAAjC,EAAAjO,KAAA4M,EAAAhS,KAAAsV,IAAAzB,SAAAzO,EAAAiO,EAIA,OAAAlU,OA2CAq6D,GAAA,SAAA7nD,EAAAxQ,GACA,GAAAyR,GAAA8iD,GAAA/jD,EAEA,IAAApP,UAAAC,OAAA,GACA,GAAA8S,GAAAnW,KAAAmW,MACA,OAAA1C,GAAAE,MACAwC,EAAAiS,eAAA3U,EAAAC,MAAAD,EAAAE,OACAwC,EAAAlF,aAAAwC,GAGA,MAAAzT,MAAAuR,MAAA,MAAAvP,EACAyR,EAAAE,MAAAqD,EAAAF,EAAA,kBAAA9U,GACAyR,EAAAE,MAAA6D,EAAAF,EACA7D,EAAAE,MAAAyD,EAAAF,GAAAzD,EAAAzR,KAGAkW,GAAA,SAAA/B,GACA,MAAAA,GAAAlD,eAAAkD,EAAAlD,cAAAiF,aACA/B,EAAAnD,UAAAmD,GACAA,EAAA+B,aAuBAoiD,GAAA,SAAA9nD,EAAAxQ,EAAA6V,GACA,MAAAzU,WAAAC,OAAA,EACArD,KAAAuR,MAAA,MAAAvP,EACAyV,EAAA,kBAAAzV,GACA+V,EACAH,GAAApF,EAAAxQ,EAAA,MAAA6V,EAAA,GAAAA,IACAG,EAAAhY,KAAAmW,OAAA3D,IA4BA+nD,GAAA,SAAA/nD,EAAAxQ,GACA,MAAAoB,WAAAC,OAAA,EACArD,KAAAuR,MAAA,MAAAvP,EACAoW,EAAA,kBAAApW,GACAsW,EACAD,GAAA7F,EAAAxQ,IACAhC,KAAAmW,OAAA3D,GAgBAkG,GAAAvY,WACAW,IAAA,SAAA0R,GACAxS,KAAA4Y,OAAAjQ,QAAA6J,GACA,IACAxS,KAAA4Y,OAAAxQ,KAAAoK,GACAxS,KAAA2Y,MAAAxB,aAAA,QAAAnX,KAAA4Y,OAAA6K,KAAA,QAGA5b,OAAA,SAAA2K,GACA,GAAAvM,GAAAjG,KAAA4Y,OAAAjQ,QAAA6J,EACAvM,IAAA,IACAjG,KAAA4Y,OAAAhQ,OAAA3C,EAAA,GACAjG,KAAA2Y,MAAAxB,aAAA,QAAAnX,KAAA4Y,OAAA6K,KAAA,QAGA+2C,SAAA,SAAAhoD,GACA,MAAAxS,MAAA4Y,OAAAjQ,QAAA6J,IAAA,GAgCA,IAAAioD,IAAA,SAAAjoD,EAAAxQ,GACA,GAAA8W,GAAAP,EAAA/F,EAAA,GAEA,IAAApP,UAAAC,OAAA,GAEA,IADA,GAAA0V,GAAAN,EAAAzY,KAAAmW,QAAAlQ,GAAA,EAAA+L,EAAA8G,EAAAzV,SACA4C,EAAA+L,GAAA,IAAA+G,EAAAyhD,SAAA1hD,EAAA7S,IAAA,QACA,UAGA,MAAAjG,MAAAuR,MAAA,kBAAAvP,GACAmX,GAAAnX,EACAiX,GACAC,IAAAJ,EAAA9W,KAoBA04D,GAAA,SAAA14D,GACA,MAAAoB,WAAAC,OACArD,KAAAuR,KAAA,MAAAvP,EACAoX,IAAA,kBAAApX,GACAuX,GACAD,IAAAtX,IACAhC,KAAAmW,OAAAkD,aAoBAshD,GAAA,SAAA34D,GACA,MAAAoB,WAAAC,OACArD,KAAAuR,KAAA,MAAAvP,EACAwX,IAAA,kBAAAxX,GACA2X,GACAD,IAAA1X,IACAhC,KAAAmW,OAAAsD,WAOAmhD,GAAA,WACA,MAAA56D,MAAAuR,KAAAqI,KAOAihD,GAAA,WACA,MAAA76D,MAAAuR,KAAAwI,KAGA+gD,GAAA,SAAAtoD,GACA,GAAArQ,GAAA,kBAAAqQ,KAAAikD,GAAAjkD,EACA,OAAAxS,MAAAsQ,OAAA,WACA,MAAAtQ,MAAA8Z,YAAA3X,EAAA6C,MAAAhF,KAAAoD,eAQA23D,GAAA,SAAAvoD,EAAAo+C,GACA,GAAAzuD,GAAA,kBAAAqQ,KAAAikD,GAAAjkD,GACAlC,EAAA,MAAAsgD,EAAAz2C,GAAA,kBAAAy2C,KAAA7kD,GAAA6kD,EACA,OAAA5wD,MAAAsQ,OAAA,WACA,MAAAtQ,MAAAia,aAAA9X,EAAA6C,MAAAhF,KAAAoD,WAAAkN,EAAAtL,MAAAhF,KAAAoD,YAAA,SASA43D,GAAA,WACA,MAAAh7D,MAAAuR,KAAA1J,KAGAozD,GAAA,SAAAj5D,GACA,MAAAoB,WAAAC,OACArD,KAAAstB,SAAA,WAAAtrB,GACAhC,KAAAmW,OAAAzB,UA8BAwmD,GAAA,SAAAzoD,EAAA6H,GACA,MAAAta,MAAAuR,MAAA,kBAAA+I,GACAQ,GACAD,IAAApI,EAAA6H,KAGA9Y,IAAA,KAWAuZ,IAAA5a,UAAAsP,GAAAtP,WACAqC,YAAAuY,GACAzK,OAAA4nD,GACAvoD,UAAA6oD,GACAlnD,OAAAmnD,GACA7oD,KAAAkpD,GACA5oD,MAAAyoD,GACA3oD,KAAAkpD,GACA1oD,MAAA2oD,GACArpD,MAAA4pD,GACA9gB,KAAA+gB,GACA94D,KAAAk5D,GACAjlC,MAAAklC,GACA7jD,KAAA8jD,GACA/xB,KAAAgyB,GACA32D,MAAA42D,GACA5oD,KAAA6oD,GACAhqD,KAAAiqD,GACA3iD,MAAA4iD,GACAhtC,SAAAitC,GACAY,QAAAV,GACAlqD,KAAAmqD,GACAU,KAAAT,GACA/gD,MAAAghD,GACA7gD,MAAA8gD,GACA1qD,OAAA2qD,GACArqD,OAAAsqD,GACAlzD,OAAAmzD,GACAhlD,MAAAilD,GACAnmD,GAAAuiD,GACA/rD,SAAA4vD,GAGA,IAAA5qD,IAAA,SAAAvE,GACA,sBAAAA,GACA,GAAAgP,MAAA/H,SAAAilD,cAAAlsD,MAAAiH,SAAAK,kBACA,GAAA0H,MAAAhP,IAAAvK,KAGAmO,GAAA,SAAA5D,GACA,sBAAAA,GACA,GAAAgP,KAAA/H,SAAAulD,iBAAAxsD,KAAAiH,SAAAK,kBACA,GAAA0H,KAAA,MAAAhP,QAAAvK,KAGA65D,GAAA,SAAAllD,EAAA8Z,EAAA/T,GACA9Y,UAAAC,OAAA,IAAA6Y,EAAA+T,IAAAra,KAAA2a,eAEA,QAAA8qC,GAAAp1D,EAAA,EAAA+L,EAAAie,IAAA5sB,OAAA,EAA0D4C,EAAA+L,IAAO/L,EACjE,IAAAo1D,EAAAprC,EAAAhqB,IAAAiW,eACA,MAAAoS,IAAAnY,EAAAklD,EAIA,cAGAprC,GAAA,SAAA9Z,EAAA8Z,GACA,MAAAA,MAAAra,KAAAqa,QAEA,QAAAhqB,GAAA,EAAA+L,EAAAie,IAAA5sB,OAAA,EAAA87B,EAAA,GAAAzzB,OAAAsG,GAA0E/L,EAAA+L,IAAO/L,EACjFk5B,EAAAl5B,GAAAqoB,GAAAnY,EAAA8Z,EAAAhqB,GAGA,OAAAk5B,IAOA1jB,GAAA,WACAhc,EAAA2U,MAAAknD,iBACA77D,EAAA2U,MAAAgH,4BAGAyV,GAAA,SAAAvV,GACA,GAAA9Z,GAAA8Z,EAAAtI,SAAAK,gBACAmI,EAAAlL,GAAAgL,GAAAxG,GAAA,iBAAA2G,IAAA,EACA,kBAAAja,GACAga,EAAA1G,GAAA,mBAAA2G,IAAA,IAEAja,EAAAma,WAAAna,EAAAkW,MAAAgE,cACAla,EAAAkW,MAAAgE,cAAA,SAmBA6/C,GAAA,SAAA5vD,GACA,kBACA,MAAAA,IAiBAiQ,IAAAzb,UAAA2U,GAAA,WACA,GAAA9S,GAAAhC,KAAAwR,EAAAsD,GAAA9P,MAAAhF,KAAAwR,EAAApO,UACA,OAAApB,KAAAhC,KAAAwR,EAAAxR,KAAAgC,EAoBA,IAAAw5D,IAAA,WAaA,QAAAA,GAAA/rD,GACAA,EACAqF,GAAA,iBAAA2mD,GACAnqD,OAAAiL,IACAzH,GAAA,kBAAA4mD,GACA5mD,GAAA,iBAAA6mD,GACA7mD,GAAA,iCAAA8mD,GACAlkD,MAAA,uBACAA,MAAA,+CAGA,QAAA+jD,KACA,IAAAvrC,GAAA5e,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAAAy4D,GAAAjrC,EAAA,QAAAkrC,EAAA92D,MAAAhF,KAAAoD,WAAA8qB,GAAAluB,KAAAoD,UACAy4D,KACAvrD,GAAA7Q,EAAA2U,MAAAkH,MAAAxG,GAAA,iBAAAinD,GAAA,GAAAjnD,GAAA,eAAAknD,GAAA,GACAnrC,GAAApxB,EAAA2U,MAAAkH,MACAH,KACA8gD,GAAA,EACAC,EAAAz8D,EAAA2U,MAAAojD,QACA2E,EAAA18D,EAAA2U,MAAAqjD,QACAoE,EAAA,WAGA,QAAAE,KAEA,GADAtgD,MACAwgD,EAAA,CACA,GAAAjgD,GAAAvc,EAAA2U,MAAAojD,QAAA0E,EAAAjgD,EAAAxc,EAAA2U,MAAAqjD,QAAA0E,CACAF,GAAAjgD,IAAAC,IAAAmgD,EAEAC,EAAAnuC,MAAA,QAGA,QAAA8tC,KACA1rD,GAAA7Q,EAAA2U,MAAAkH,MAAAxG,GAAA,oCACAuG,GAAA5b,EAAA2U,MAAAkH,KAAA2gD,GACAxgD,KACA4gD,EAAAnuC,MAAA,OAGA,QAAAwtC,KACA,GAAApqD,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAEA6C,GAAA41D,EAFAS,EAAA78D,EAAA2U,MAAAmc,eACA5d,EAAAmpD,EAAA92D,MAAAhF,KAAAoD,WACA4O,EAAAsqD,EAAAj5D,MAEA,KAAA4C,EAAA,EAAeA,EAAA+L,IAAO/L,GACtB41D,EAAAjrC,EAAA0rC,EAAAr2D,GAAAiW,WAAAvJ,EAAA0oD,GAAAr7D,KAAAoD,cACA+X,KACA0gD,EAAA,WAKA,QAAAF,KACA,GACA11D,GAAA41D,EADAS,EAAA78D,EAAA2U,MAAAmc,eACAve,EAAAsqD,EAAAj5D,MAEA,KAAA4C,EAAA,EAAeA,EAAA+L,IAAO/L,GACtB41D,EAAAQ,EAAAC,EAAAr2D,GAAAiW,eACAT,KACAogD,EAAA,SAKA,QAAAD,KACA,GACA31D,GAAA41D,EADAS,EAAA78D,EAAA2U,MAAAmc,eACAve,EAAAsqD,EAAAj5D,MAIA,KAFA6sB,GAAAnK,aAAAmK,GACAA,EAAA5pB,WAAA,WAAyC4pB,EAAA,MAAsB,KAC/DjqB,EAAA,EAAeA,EAAA+L,IAAO/L,GACtB41D,EAAAQ,EAAAC,EAAAr2D,GAAAiW,eACAf,KACA0gD,EAAA,QAKA,QAAAjrC,GAAA9U,EAAAggD,EAAAxtC,EAAA5Y,EAAAC,GACA,GAAAuI,GAAAlC,EAAAC,EAAAxZ,EAAA6rB,EAAAwtC,EAAAhgD,GACAygD,EAAAxrC,EAAAxnB,MAEA,IAAAkM,EAAA,GAAAmG,IAAA4/C,EAAA,cAAAt9C,EAAApC,EAAAC,EAAAtZ,EAAA,GAAAA,EAAA,OAAA85D,GAAA,WACA,cAAA98D,EAAA2U,MAAAhL,QAAA8U,EAAA9U,EAAApE,MAAA0Q,EAAAC,MACAqG,EAAAkC,EAAAvS,EAAAlJ,EAAA,MACAwZ,EAAAiC,EAAAnQ,EAAAtL,EAAA,OACA,KAGA,eAAAo5D,GAAAppD,GACA,GAAAT,GAAAuoB,EAAA93B,CACA,QAAAgQ,GACA,YAAA4pD,EAAAvgD,GAAA+/C,EAAA7pD,EAAA+J,GAA2D,MAC3D,iBAAAsgD,GAAAvgD,KAAAC,CACA,YAAAtZ,EAAA6rB,EAAAwtC,EAAAhgD,GAAA9J,EAAA+J,EAEAtG,EAAA,GAAAmG,IAAA4/C,EAAA/oD,EAAAyL,EAAApC,EAAA9J,EAAAvP,EAAA,GAAAuZ,EAAAvZ,EAAA,GAAAwZ,EAAAxZ,EAAA,GAAA83B,EAAA,GAAA93B,EAAA,GAAA83B,EAAA,GAAAgiC,KAAAv3D,MAAAu3D,GAAA9pD,EAAAiD,EAAAC,KA9GA,GAMAumD,GACAC,EACAF,EACA/rC,EATA5e,EAAA6K,GACA2/C,EAAAz/C,GACAjT,EAAAkT,GACA+/C,KACAtrC,EAAAzlB,EAAA,sBACAyQ,EAAA,EAKAqgD,EAAA,CA6HA,OArBAZ,GAAAlqD,OAAA,SAAAE,GACA,MAAApO,WAAAC,QAAAiO,EAAA,kBAAAE,KAAA+pD,KAAA/pD,GAAAgqD,GAAAlqD,GAGAkqD,EAAAM,UAAA,SAAAtqD,GACA,MAAApO,WAAAC,QAAAy4D,EAAA,kBAAAtqD,KAAA+pD,GAAA/pD,GAAAgqD,GAAAM,GAGAN,EAAApyD,QAAA,SAAAoI,GACA,MAAApO,WAAAC,QAAA+F,EAAA,kBAAAoI,KAAA+pD,GAAA/pD,GAAAgqD,GAAApyD,GAGAoyD,EAAA1mD,GAAA,WACA,GAAA9S,GAAA+uB,EAAAjc,GAAA9P,MAAA+rB,EAAA3tB,UACA,OAAApB,KAAA+uB,EAAAyqC,EAAAx5D,GAGAw5D,EAAAgB,cAAA,SAAAhrD,GACA,MAAApO,WAAAC,QAAA+4D,GAAA5qD,QAAAgqD,GAAAzuD,KAAAiT,KAAAo8C,IAGAZ,GAGAiB,GAAA,SAAAj6D,EAAA6J,EAAAlM,GACAqC,EAAArC,UAAAkM,EAAAlM,YACAA,EAAAqC,eAcAk6D,GAAA,sBACAC,GAAA,gDACAC,GAAA,iDACA//C,GAAA,mBACAI,GAAA,mBACAE,GAAA,GAAA+kC,QAAA,WAAAwa,UAAA,QACAt/C,GAAA,GAAA8kC,QAAA,WAAA0a,UAAA,QACAv/C,GAAA,GAAA6kC,QAAA,YAAAwa,SAAAC,IAAA,QACAp/C,GAAA,GAAA2kC,QAAA,YAAA0a,SAAAD,IAAA,QACAn/C,GAAA,GAAA0kC,QAAA,WAAAya,GAAAC,OAAA,QACAl/C,GAAA,GAAAwkC,QAAA,YAAAya,GAAAC,MAAAD,IAAA,QAEAh/C,IACAk/C,UAAA,SACAC,aAAA,SACAC,KAAA,MACAC,WAAA,QACAC,MAAA,SACAC,MAAA,SACAC,OAAA,SACAC,MAAA,EACAC,eAAA,SACAC,KAAA,IACAC,WAAA,QACAC,MAAA,SACAC,UAAA,SACAC,UAAA,QACAC,WAAA,QACAC,UAAA,SACAC,MAAA,SACAC,eAAA,QACAC,SAAA,SACAC,QAAA,SACAC,KAAA,MACAC,SAAA,IACAC,SAAA,MACAC,cAAA,SACAC,SAAA,SACAC,UAAA,MACAC,SAAA,SACAC,UAAA,SACAC,YAAA,QACAC,eAAA,QACAC,WAAA,SACAC,WAAA,SACAC,QAAA,QACAC,WAAA,SACAC,aAAA,QACAC,cAAA,QACAC,cAAA,QACAC,cAAA,QACAC,cAAA,MACAC,WAAA,QACAC,SAAA,SACAC,YAAA,MACAC,QAAA,QACAC,QAAA,QACAC,WAAA,QACAC,UAAA,SACAC,YAAA,SACAC,YAAA,QACAC,QAAA,SACAC,UAAA,SACAC,WAAA,SACAC,KAAA,SACAC,UAAA,SACAC,KAAA,QACAC,MAAA,MACAC,YAAA,SACAC,KAAA,QACAC,SAAA,SACAC,QAAA,SACAC,UAAA,SACAC,OAAA,QACAC,MAAA,SACAC,MAAA,SACAC,SAAA,SACAC,cAAA,SACAC,UAAA,QACAC,aAAA,SACAC,UAAA,SACAC,WAAA,SACAC,UAAA,SACAC,qBAAA,SACAC,UAAA,SACAC,WAAA,QACAC,UAAA,SACAC,UAAA,SACAC,YAAA,SACAC,cAAA,QACAC,aAAA,QACAC,eAAA,QACAC,eAAA,QACAC,eAAA,SACAC,YAAA,SACAC,KAAA,MACAC,UAAA,QACAC,MAAA,SACAC,QAAA,SACAC,OAAA,QACAC,iBAAA,QACAC,WAAA,IACAC,aAAA,SACAC,aAAA,QACAC,eAAA,QACAC,gBAAA,QACAC,kBAAA,MACAC,gBAAA,QACAC,gBAAA,SACAC,aAAA,QACAC,UAAA,SACAC,UAAA,SACAC,SAAA,SACAC,YAAA,SACAC,KAAA,IACAC,QAAA,SACAC,MAAA,QACAC,UAAA,QACAC,OAAA,SACAC,UAAA,SACAC,OAAA,SACAC,cAAA,SACAC,UAAA,SACAC,cAAA,SACAC,cAAA,SACAC,WAAA,SACAC,UAAA,SACAC,KAAA,SACAC,KAAA,SACAC,KAAA,SACAC,WAAA,SACAC,OAAA,QACAC,cAAA,QACAC,IAAA,SACAC,UAAA,SACAC,UAAA,QACAC,YAAA,QACAC,OAAA,SACAC,WAAA,SACAC,SAAA,QACAC,SAAA,SACAC,OAAA,SACAC,OAAA,SACAC,QAAA,QACAC,UAAA,QACAC,UAAA,QACAC,UAAA,QACAC,KAAA,SACAC,YAAA,MACAC,UAAA,QACAz5B,IAAA,SACA05B,KAAA,MACAC,QAAA,SACAC,OAAA,SACAC,UAAA,QACAC,OAAA,SACAC,MAAA,SACAC,MAAA,SACAC,WAAA,SACAC,OAAA,SACAC,YAAA,SAGAtJ,IAAA//C,GAAAC,IACAqpD,YAAA,WACA,MAAAhmE,MAAA+d,MAAAioD,eAEAjyD,SAAA,WACA,MAAA/T,MAAA+d,MAAA,MA+CA0+C,GAAAz/C,GAAAe,GAAAvB,GAAAE,IACAupD,SAAA,SAAAv1D,GAEA,MADAA,GAAA,MAAAA,EA3NA,EADA,GA4NA3D,KAAAM,IA3NA,EADA,GA4NAqD,GACA,GAAAsM,IAAAhd,KAAA4d,EAAAlN,EAAA1Q,KAAA6d,EAAAnN,EAAA1Q,KAAAsC,EAAAoO,EAAA1Q,KAAAge,UAEAkoD,OAAA,SAAAx1D,GAEA,MADAA,GAAA,MAAAA,EAhOA,GAgOA3D,KAAAM,IAhOA,GAgOAqD,GACA,GAAAsM,IAAAhd,KAAA4d,EAAAlN,EAAA1Q,KAAA6d,EAAAnN,EAAA1Q,KAAAsC,EAAAoO,EAAA1Q,KAAAge,UAEAD,IAAA,WACA,MAAA/d,OAEAgmE,YAAA,WACA,UAAAhmE,KAAA4d,GAAA5d,KAAA4d,GAAA,KACA,GAAA5d,KAAA6d,GAAA7d,KAAA6d,GAAA,KACA,GAAA7d,KAAAsC,GAAAtC,KAAAsC,GAAA,KACA,GAAAtC,KAAAge,SAAAhe,KAAAge,SAAA,GAEAjK,SAAA,WACA,GAAArH,GAAA1M,KAAAge,OACA,OADyBtR,GAAA2U,MAAA3U,GAAA,EAAAK,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,EAAA5R,KACzB,IAAAA,EAAA,gBACAK,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,IAAAvR,KAAAsB,MAAArO,KAAA4d,IAAA,SACA7Q,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,IAAAvR,KAAAsB,MAAArO,KAAA6d,IAAA,SACA9Q,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,IAAAvR,KAAAsB,MAAArO,KAAAsC,IAAA,KACA,IAAAoK,EAAA,SAAAA,EAAA,SAgDA+vD,GAAAr+C,GAAAG,GAAA/B,GAAAE,IACAupD,SAAA,SAAAv1D,GAEA,MADAA,GAAA,MAAAA,EAnSA,EADA,GAoSA3D,KAAAM,IAnSA,EADA,GAoSAqD,GACA,GAAA0N,IAAApe,KAAAie,EAAAje,KAAAke,EAAAle,KAAAme,EAAAzN,EAAA1Q,KAAAge,UAEAkoD,OAAA,SAAAx1D,GAEA,MADAA,GAAA,MAAAA,EAxSA,GAwSA3D,KAAAM,IAxSA,GAwSAqD,GACA,GAAA0N,IAAApe,KAAAie,EAAAje,KAAAke,EAAAle,KAAAme,EAAAzN,EAAA1Q,KAAAge,UAEAD,IAAA,WACA,GAAAE,GAAAje,KAAAie,EAAA,SAAAje,KAAAie,EAAA,GACAC,EAAAmD,MAAApD,IAAAoD,MAAArhB,KAAAke,GAAA,EAAAle,KAAAke,EACAC,EAAAne,KAAAme,EACAO,EAAAP,KAAA,GAAAA,EAAA,EAAAA,GAAAD,EACAO,EAAA,EAAAN,EAAAO,CACA,WAAA1B,IACAwB,GAAAP,GAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAQ,EAAAC,GACAF,GAAAP,EAAAQ,EAAAC,GACAF,GAAAP,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAQ,EAAAC,GACA1e,KAAAge,UAGAgoD,YAAA,WACA,UAAAhmE,KAAAke,GAAAle,KAAAke,GAAA,GAAAmD,MAAArhB,KAAAke,KACA,GAAAle,KAAAme,GAAAne,KAAAme,GAAA,GACA,GAAAne,KAAAge,SAAAhe,KAAAge,SAAA,KAYA,IAAAc,IAAA/R,KAAAo5D,GAAA,IACApmD,GAAA,IAAAhT,KAAAo5D,GAGAhnD,GAAA,OACAC,GAAA,EACAC,GAAA,QACAI,GAAA,KACAE,GAAA,KACAH,GAAA,EAAAG,MACAJ,GAAAI,QA6BA88C,IAAA79C,GAAAU,GAAA9C,GAAAE,IACAupD,SAAA,SAAAv1D,GACA,UAAAkO,IAAA5e,KAAAme,EAtCA,IAsCA,MAAAzN,EAAA,EAAAA,GAAA1Q,KAAA0M,EAAA1M,KAAAsC,EAAAtC,KAAAge,UAEAkoD,OAAA,SAAAx1D,GACA,UAAAkO,IAAA5e,KAAAme,EAzCA,IAyCA,MAAAzN,EAAA,EAAAA,GAAA1Q,KAAA0M,EAAA1M,KAAAsC,EAAAtC,KAAAge,UAEAD,IAAA,WACA,GAAAhQ,IAAA/N,KAAAme,EAAA,QACAxS,EAAA0V,MAAArhB,KAAA0M,GAAAqB,IAAA/N,KAAA0M,EAAA,IACAuvB,EAAA5a,MAAArhB,KAAAsC,GAAAyL,IAAA/N,KAAAsC,EAAA,GAIA,OAHAyL,GAAAqR,GAAAM,GAAA3R,GACApC,EAAAwT,GAAAO,GAAA/T,GACAswB,EAAA5c,GAAAK,GAAAuc,GACA,GAAAjf,IACA4C,GAAA,UAAAjU,EAAA,UAAAoC,EAAA,SAAAkuB,GACArc,IAAA,QAAAjU,EAAA,UAAAoC,EAAA,QAAAkuB,GACArc,GAAA,SAAAjU,EAAA,SAAAoC,EAAA,UAAAkuB,GACAj8B,KAAAge,aAuCAy+C,GAAA59C,GAAAoB,GAAAzD,GAAAE,IACAupD,SAAA,SAAAv1D,GACA,UAAAmO,IAAA7e,KAAAie,EAAAje,KAAA2S,EAAA3S,KAAAme,EA/FA,IA+FA,MAAAzN,EAAA,EAAAA,GAAA1Q,KAAAge,UAEAkoD,OAAA,SAAAx1D,GACA,UAAAmO,IAAA7e,KAAAie,EAAAje,KAAA2S,EAAA3S,KAAAme,EAlGA,IAkGA,MAAAzN,EAAA,EAAAA,GAAA1Q,KAAAge,UAEAD,IAAA,WACA,MAAAY,IAAA3e,MAAA+d,SAIA,IAAAkyB,KAAA,OACAvB,GAAA,QACAjuB,IAAA,OACAC,IAAA,OACAF,GAAA,QACAH,GAAAG,GAAAE,GACAJ,GAAAE,GAAAkuB,GACAtuB,GAAAsuB,GAAAjuB,GAAAC,GAAAuvB,EA2BAwsB,IAAAt8C,GAAAQ,GAAAnE,GAAAE,IACAupD,SAAA,SAAAv1D,GAEA,MADAA,GAAA,MAAAA,EAtdA,EADA,GAudA3D,KAAAM,IAtdA,EADA,GAudAqD,GACA,GAAAyP,IAAAngB,KAAAie,EAAAje,KAAAke,EAAAle,KAAAme,EAAAzN,EAAA1Q,KAAAge,UAEAkoD,OAAA,SAAAx1D,GAEA,MADAA,GAAA,MAAAA,EA3dA,GA2dA3D,KAAAM,IA3dA,GA2dAqD,GACA,GAAAyP,IAAAngB,KAAAie,EAAAje,KAAAke,EAAAle,KAAAme,EAAAzN,EAAA1Q,KAAAge,UAEAD,IAAA,WACA,GAAAE,GAAAoD,MAAArhB,KAAAie,GAAA,GAAAje,KAAAie,EAAA,KAAAa,GACAX,GAAAne,KAAAme,EACAzR,EAAA2U,MAAArhB,KAAAke,GAAA,EAAAle,KAAAke,EAAAC,GAAA,EAAAA,GACAuF,EAAA3W,KAAAgS,IAAAd,GACA2F,EAAA7W,KAAAiS,IAAAf,EACA,WAAAjB,IACA,KAAAmB,EAAAzR,GAAAujC,GAAAvsB,EAAAgrB,GAAA9qB,IACA,KAAAzF,EAAAzR,GAAA+T,GAAAiD,EAAAhD,GAAAkD,IACA,KAAAzF,EAAAzR,GAAA8T,GAAAkD,IACA1jB,KAAAge,YAaA,IA4QAgE,IACAC,GACAC,GACAG,GA4OAgD,GACAQ,GA5fAugD,GAAA,SAAA13D,GACA,GAAAsD,GAAAtD,EAAArL,OAAA,CACA,iBAAA0O,GACA,GAAA9L,GAAA8L,GAAA,EAAAA,EAAA,EAAAA,GAAA,GAAAA,EAAA,EAAAC,EAAA,GAAAjF,KAAAG,MAAA6E,EAAAC,GACA8O,EAAApS,EAAAzI,GACA8a,EAAArS,EAAAzI,EAAA,GACA4a,EAAA5a,EAAA,EAAAyI,EAAAzI,EAAA,KAAA6a,EAAAC,EACAC,EAAA/a,EAAA+L,EAAA,EAAAtD,EAAAzI,EAAA,KAAA8a,EAAAD,CACA,OAAAF,KAAA7O,EAAA9L,EAAA+L,KAAA6O,EAAAC,EAAAC,EAAAC,KAIAqlD,GAAA,SAAA33D,GACA,GAAAsD,GAAAtD,EAAArL,MACA,iBAAA0O,GACA,GAAA9L,GAAA8G,KAAAG,QAAA6E,GAAA,OAAAA,KAAAC,GACA6O,EAAAnS,GAAAzI,EAAA+L,EAAA,GAAAA,GACA8O,EAAApS,EAAAzI,EAAA+L,GACA+O,EAAArS,GAAAzI,EAAA,GAAA+L,GACAgP,EAAAtS,GAAAzI,EAAA,GAAA+L,EACA,OAAA4O,KAAA7O,EAAA9L,EAAA+L,KAAA6O,EAAAC,EAAAC,EAAAC,KAIAI,GAAA,SAAAzV,GACA,kBACA,MAAAA,KAgCA26D,GAAA,QAAAC,GAAAx4D,GAGA,QAAAy4D,GAAA55D,EAAAoX,GACA,GAAApG,GAAA+D,GAAA/U,EAAAmR,GAAAnR,IAAAgR,GAAAoG,EAAAjG,GAAAiG,IAAApG,GACAC,EAAA8D,EAAA/U,EAAAiR,EAAAmG,EAAAnG,GACAvb,EAAAqf,EAAA/U,EAAAtK,EAAA0hB,EAAA1hB,GACA0b,EAAAuD,GAAA3U,EAAAoR,QAAAgG,EAAAhG,QACA,iBAAAjM,GAKA,MAJAnF,GAAAgR,IAAA7L,GACAnF,EAAAiR,IAAA9L,GACAnF,EAAAtK,IAAAyP,GACAnF,EAAAoR,UAAAjM,GACAnF,EAAA,IAZA,GAAA+U,GAAAL,GAAAvT,EAkBA,OAFAy4D,GAAAllD,MAAAilD,EAEAC,GACC,GA4BDC,GAAAjlD,GAAA4kD,IACAM,GAAAllD,GAAA6kD,IAEAM,GAAA,SAAAj6D,EAAApK,GACA,GAIA2D,GAJA2gE,EAAAtkE,IAAAe,OAAA,EACAwjE,EAAAn6D,EAAAK,KAAAuR,IAAAsoD,EAAAl6D,EAAArJ,QAAA,EACAsI,EAAA,GAAAD,OAAAk7D,GACAj0D,EAAA,GAAAjH,OAAAk7D,EAGA,KAAA3gE,EAAA,EAAaA,EAAA4gE,IAAQ5gE,EAAA0F,EAAA1F,GAAAkrB,GAAAzkB,EAAAzG,GAAA3D,EAAA2D,GACrB,MAAQA,EAAA2gE,IAAQ3gE,EAAA0M,EAAA1M,GAAA3D,EAAA2D,EAEhB,iBAAA8L,GACA,IAAA9L,EAAA,EAAeA,EAAA4gE,IAAQ5gE,EAAA0M,EAAA1M,GAAA0F,EAAA1F,GAAA8L,EACvB,OAAAY,KAIAymC,GAAA,SAAA1sC,EAAApK,GACA,GAAAD,GAAA,GAAAg3C,KACA,OAAA3sC,MAAApK,GAAAoK,EAAA,SAAAqF,GACA,MAAA1P,GAAAk3C,QAAA7sC,EAAApK,EAAAyP,GAAA1P,IAIA+gB,GAAA,SAAA1W,EAAApK,GACA,MAAAoK,MAAApK,GAAAoK,EAAA,SAAAqF,GACA,MAAArF,GAAApK,EAAAyP,IAIAygB,GAAA,SAAA9lB,EAAApK,GACA,GAEAoO,GAFAzK,KACA0M,IAGA,QAAAjG,GAAA,gBAAAA,WACA,OAAApK,GAAA,gBAAAA,UAEA,KAAAoO,IAAApO,GACAoO,IAAAhE,GACAzG,EAAAyK,GAAAygB,GAAAzkB,EAAAgE,GAAApO,EAAAoO,IAEAiC,EAAAjC,GAAApO,EAAAoO,EAIA,iBAAAqB,GACA,IAAArB,IAAAzK,GAAA0M,EAAAjC,GAAAzK,EAAAyK,GAAAqB,EACA,OAAAY,KAIAm0D,GAAA,8CACAC,GAAA,GAAA7kB,QAAA4kB,GAAAvmE,OAAA,KAcAymE,GAAA,SAAAt6D,EAAApK,GACA,GACA2kE,GACAC,EACAC,EAHAC,EAAAN,GAAAO,UAAAN,GAAAM,UAAA,EAIAphE,GAAA,EACAiY,KACAiF,IAMA,KAHAzW,GAAA,GAAApK,GAAA,IAGA2kE,EAAAH,GAAAhqD,KAAApQ,MACAw6D,EAAAH,GAAAjqD,KAAAxa,MACA6kE,EAAAD,EAAAt/D,OAAAw/D,IACAD,EAAA7kE,EAAAkH,MAAA49D,EAAAD,GACAjpD,EAAAjY,GAAAiY,EAAAjY,IAAAkhE,EACAjpD,IAAAjY,GAAAkhE,IAEAF,IAAA,OAAAC,IAAA,IACAhpD,EAAAjY,GAAAiY,EAAAjY,IAAAihE,EACAhpD,IAAAjY,GAAAihE,GAEAhpD,IAAAjY,GAAA,KACAkd,EAAA/a,MAAcnC,IAAA0F,EAAAyX,GAAA6jD,EAAAC,MAEdE,EAAAL,GAAAM,SAYA,OARAD,GAAA9kE,EAAAe,SACA8jE,EAAA7kE,EAAAkH,MAAA49D,GACAlpD,EAAAjY,GAAAiY,EAAAjY,IAAAkhE,EACAjpD,IAAAjY,GAAAkhE,GAKAjpD,EAAA7a,OAAA,EAAA8f,EAAA,GACAtB,GAAAsB,EAAA,GAAAxX,GACAiW,GAAAtf,IACAA,EAAA6gB,EAAA9f,OAAA,SAAA0O,GACA,OAAAiD,GAAA/O,EAAA,EAA4BA,EAAA3D,IAAO2D,EAAAiY,GAAAlJ,EAAAmO,EAAAld,OAAA+O,EAAArJ,EAAAoG,EACnC,OAAAmM,GAAAuF,KAAA,OAIA0N,GAAA,SAAAzkB,EAAApK,GACA,GAAAqQ,GAAAZ,QAAAzP,EACA,cAAAA,GAAA,YAAAyP,EAAAqP,GAAA9e,IACA,WAAAyP,EAAAqR,GACA,WAAArR,GAAAY,EAAAgK,GAAAra,OAAAqQ,EAAA2zD,IAAAU,GACA1kE,YAAAqa,IAAA2pD,GACAhkE,YAAA+2C,MAAAD,GACA1tC,MAAAxD,QAAA5F,GAAAqkE,GACA,kBAAArkE,GAAAglE,SAAA,kBAAAhlE,GAAAyR,UAAAsN,MAAA/e,GAAAkwB,GACApP,IAAA1W,EAAApK,IAGA80C,GAAA,SAAA1qC,EAAApK,GACA,MAAAoK,MAAApK,GAAAoK,EAAA,SAAAqF,GACA,MAAAhF,MAAAsB,MAAA3B,EAAApK,EAAAyP,KAIAw1D,GAAA,IAAAx6D,KAAAo5D,GAEApkD,IACAlU,WAAA,EACAC,WAAA,EACAuV,OAAA,EACAC,MAAA,EACAC,OAAA,EACAC,OAAA,GAGArB,GAAA,SAAAzV,EAAApK,EAAAqQ,EAAAtQ,EAAA4F,EAAAsE,GACA,GAAAgX,GAAAC,EAAAF,CAKA,QAJAC,EAAAxW,KAAAiT,KAAAtT,IAAApK,QAAAoK,GAAA6W,EAAAjhB,GAAAihB,IACAD,EAAA5W,EAAAiG,EAAArQ,EAAAD,KAAAsQ,GAAAjG,EAAA4W,EAAAjhB,GAAAC,EAAAghB,IACAE,EAAAzW,KAAAiT,KAAArN,IAAAtQ,QAAAsQ,GAAA6Q,EAAAnhB,GAAAmhB,EAAAF,GAAAE,GACA9W,EAAArK,EAAAC,EAAAqQ,IAAAjG,KAAApK,KAAAghB,KAAAC,OAEA1V,WAAA5F,EACA6F,WAAAvB,EACA8W,OAAAtW,KAAA+S,MAAAxd,EAAAoK,GAAA66D,GACAjkD,MAAAvW,KAAAw6B,KAAAjkB,GAAAikD,GACAhkD,SACAC,WAsFAgkD,GAAA/kD,GAAAX,GAAA,qBACA2lD,GAAAhlD,GAAAL,GAAA,cAEAslD,GAAA36D,KAAA46D,MAmBAC,GAAA,SAAArtC,EAAA+uB,GACA,GAKArjD,GACAspB,EANAs4C,EAAAttC,EAAA,GAAAutC,EAAAvtC,EAAA,GAAAvL,EAAAuL,EAAA,GACAwtC,EAAAze,EAAA,GAAA0e,EAAA1e,EAAA,GAAAp6B,EAAAo6B,EAAA,GACAttC,EAAA+rD,EAAAF,EACA5rD,EAAA+rD,EAAAF,EACAn/B,EAAA3sB,IAAAC,GAKA,IAAA0sB,EA1BA,MA2BApZ,EAAAxiB,KAAAI,IAAA+hB,EAAAF,GAAA04C,GACAzhE,EAAA,SAAA8L,GACA,OACA81D,EAAA91D,EAAAiK,EACA8rD,EAAA/1D,EAAAkK,EACA+S,EAAAjiB,KAAA4W,IAAA+jD,GAAA31D,EAAAwd,SAMA,CACA,GAAAwgB,GAAAhjC,KAAAiT,KAAA2oB,GACAtd,GAAA6D,IAAAF,IAzCA,EAyCA2Z,IAAA,EAAA3Z,EA1CA,EA0CA+gB,GACA3kB,GAAA8D,IAAAF,IA1CA,EA0CA2Z,IAAA,EAAAzZ,EA3CA,EA2CA6gB,GACA9E,EAAAl+B,KAAAI,IAAAJ,KAAAiT,KAAAqL,IAAA,GAAAA,GACA8jB,EAAApiC,KAAAI,IAAAJ,KAAAiT,KAAAoL,IAAA,GAAAA,EACAmE,IAAA4f,EAAAlE,GAAAy8B,GACAzhE,EAAA,SAAA8L,GACA,GAAAmM,GAAAnM,EAAAwd,EACA04C,EAAAvkD,GAAAunB,GACA3R,EAAAtK,GAlDA,EAkDA+gB,IAAAk4B,EAAApkD,GAAA6jD,GAAAxpD,EAAA+sB,GAAArnB,GAAAqnB,GACA,QACA48B,EAAAvuC,EAAAtd,EACA8rD,EAAAxuC,EAAArd,EACA+S,EAAAi5C,EAAAvkD,GAAAgkD,GAAAxpD,EAAA+sB,KAOA,MAFAhlC,GAAAghB,SAAA,IAAAsI,EAEAtpB,GAmBAiiE,GAAApkD,GAAA3C,IACAgnD,GAAArkD,GAAAvC,IAgCA6mD,GAAAlkD,GAAA/C,IACAknD,GAAAnkD,GAAA3C,IA0BA+mD,GAAAnkD,GAAAhD,IACAonD,GAAApkD,GAAA5C,IAEAinD,GAAA,SAAA9iB,EAAA1zC,GAEA,OADAy2D,GAAA,GAAA/8D,OAAAsG,GACA/L,EAAA,EAAiBA,EAAA+L,IAAO/L,EAAAwiE,EAAAxiE,GAAAy/C,EAAAz/C,GAAA+L,EAAA,GACxB,OAAAy2D,IAGArjD,GAAA,EACAI,GAAA,EACAQ,GAAA,EACAL,GAAA,IAGAJ,GAAA,EACAhB,GAAA,EACAI,GAAA,EACAD,GAAA,gBAAAgkD,0BAAApkD,IAAAokD,YAAArvB,KACA70B,GAAA,gBAAA3a,gBAAA8+D,sBAAA9+D,OAAA8+D,sBAAArkE,KAAAuF,QAAA,SAAA0C,GAAqIjG,WAAAiG,EAAA,IAgBrIqY,IAAAzkB,UAAA4kB,GAAA5kB,WACAqC,YAAAoiB,GACAM,QAAA,SAAArS,EAAAmS,EAAAC,GACA,qBAAApS,GAAA,SAAAjM,WAAA,6BACAqe,IAAA,MAAAA,EAAAX,MAAAW,IAAA,MAAAD,EAAA,GAAAA,GACAhlB,KAAA0D,OAAAmiB,KAAA7lB,OACA6lB,MAAAniB,MAAA1D,KACAqlB,GAAArlB,KACA6lB,GAAA7lB,MAEAA,KAAA6kB,MAAAhS,EACA7S,KAAA8kB,MAAAG,EACAa,MAEAjZ,KAAA,WACA7M,KAAA6kB,QACA7kB,KAAA6kB,MAAA,KACA7kB,KAAA8kB,MAAAc,IACAE,OAmEA,IAAAe,IAAA,SAAAhU,EAAAmS,EAAAC,GACA,GAAAlT,GAAA,GAAA6S,GAMA,OALAI,GAAA,MAAAA,EAAA,GAAAA,EACAjT,EAAAmT,QAAA,SAAAuB,GACA1U,EAAAlF,OACAgG,EAAA4T,EAAAzB,IACGA,EAAAC,GACHlT,GAGA62D,GAAA,SAAA/1D,EAAAmS,EAAAC,GACA,GAAAlT,GAAA,GAAA6S,IAAAikD,EAAA7jD,CACA,cAAAA,GAAAjT,EAAAmT,QAAArS,EAAAmS,EAAAC,GAAAlT,IACAiT,KAAAC,EAAA,MAAAA,EAAAX,MAAAW,EACAlT,EAAAmT,QAAA,QAAArV,GAAA4W,GACAA,GAAAoiD,EACA92D,EAAAmT,QAAArV,EAAAg5D,GAAA7jD,EAAAC,GACApS,EAAA4T,IACGzB,EAAAC,GACHlT,IAGA+2D,GAAAx9D,EAAA,2BACAy9D,MAEA1iD,GAAA,EACAK,GAAA,EACAH,GAAA,EACAK,GAAA,EACAE,GAAA,EACAK,GAAA,EACAJ,GAAA,EAEAtb,GAAA,SAAA0K,EAAA3D,EAAAsJ,EAAAlU,EAAAsM,EAAA8X,GACA,GAAArF,GAAAxQ,EAAAiQ,YACA,IAAAO,GACA,GAAA7K,IAAA6K,GAAA,WADAxQ,GAAAiQ,eAEAjkB,IAAAgU,EAAA2F,GACAtJ,OACA5K,QACAsM,QACAY,GAAAg0D,GACA9hD,MAAA+hD,GACA9jD,KAAA+G,EAAA/G,KACAD,MAAAgH,EAAAhH,MACAiC,SAAA+E,EAAA/E,SACAC,KAAA8E,EAAA9E,KACAnC,MAAA,KACAxZ,MAAA8a,MA+HAyK,GAAA,SAAA3a,EAAA3D,GACA,GACA+U,GACAxL,EAEA9V,EAJA0gB,EAAAxQ,EAAAiQ,aAGA7iB,GAAA,CAGA,IAAAojB,EAAA,CAEAnU,EAAA,MAAAA,EAAA,KAAAA,EAAA,EAEA,KAAAvM,IAAA0gB,IACAY,EAAAZ,EAAA1gB,IAAAuM,UACAuJ,EAAAwL,EAAAhc,MAAAgb,IAAAgB,EAAAhc,MAAA4b,GACAI,EAAAhc,MAAAwb,GACAQ,EAAAxC,MAAAlY,OACAkP,GAAAwL,EAAAzS,GAAAjU,KAAA,YAAAsV,IAAAzB,SAAA6S,EAAA3f,MAAA2f,EAAArT,aACAyS,GAAA1gB,IALqD1C,GAAA,CAQrDA,UAAA4S,GAAAiQ,eAGA4iD,GAAA,SAAAx2D,GACA,MAAAxS,MAAAuR,KAAA,WACAuf,GAAA9wB,KAAAwS,MAqDAy2D,GAAA,SAAAz2D,EAAAxQ,GACA,GAAA8Z,GAAA9b,KAAA0nB,GAIA,IAFAlV,GAAA,GAEApP,UAAAC,OAAA,GAEA,OAAA0O,GADAiV,EAAAR,GAAAxmB,KAAAmW,OAAA2F,GAAAkL,MACA/gB,EAAA,EAAA+L,EAAAgV,EAAA3jB,OAAwC4C,EAAA+L,IAAO/L,EAC/C,IAAA8L,EAAAiV,EAAA/gB,IAAAuM,SACA,MAAAT,GAAA/P,KAGA,aAGA,MAAAhC,MAAAuR,MAAA,MAAAvP,EAAAolB,GAAAI,IAAA1L,EAAAtJ,EAAAxQ,KAgBAy9B,GAAA,SAAA/yB,EAAApK,GACA,GAAAqQ,EACA,wBAAArQ,GAAA8gB,GACA9gB,YAAAqa,IAAA2pD,IACA3zD,EAAAgK,GAAAra,OAAAqQ,EAAA2zD,IACAU,IAAAt6D,EAAApK,IAiEA4mE,GAAA,SAAA12D,EAAAxQ,GACA,GAAAyR,GAAA8iD,GAAA/jD,GAAAvM,EAAA,cAAAwN,EAAAg0D,GAAAhoC,EACA,OAAAz/B,MAAA0oB,UAAAlW,EAAA,kBAAAxQ,IACAyR,EAAAE,MAAA4U,GAAAF,IAAA5U,EAAAxN,EAAAwhB,GAAAznB,KAAA,QAAAwS,EAAAxQ,IACA,MAAAA,GAAAyR,EAAAE,MAAAiU,GAAAD,IAAAlU,IACAA,EAAAE,MAAAwU,GAAAN,IAAApU,EAAAxN,EAAAjE,EAAA,MAyBAmnE,GAAA,SAAA32D,EAAAxQ,GACA,GAAAuU,GAAA,QAAA/D,CACA,IAAApP,UAAAC,OAAA,SAAAkT,EAAAvW,KAAAgnB,MAAAzQ,OAAAkS,MACA,UAAAzmB,EAAA,MAAAhC,MAAAgnB,MAAAzQ,EAAA,KACA,sBAAAvU,GAAA,SAAAJ,MACA,IAAA6R,GAAA8iD,GAAA/jD,EACA,OAAAxS,MAAAgnB,MAAAzQ,GAAA9C,EAAAE,MAAA6U,GAAAE,IAAAjV,EAAAzR,KAeAonE,GAAA,SAAApnE,GACA,GAAA8Z,GAAA9b,KAAA0nB,GAEA,OAAAtkB,WAAAC,OACArD,KAAAuR,MAAA,kBAAAvP,GACA2mB,GACAC,IAAA9M,EAAA9Z,IACAwkB,GAAAxmB,KAAAmW,OAAA2F,GAAAkJ,OAeAqkD,GAAA,SAAArnE,GACA,GAAA8Z,GAAA9b,KAAA0nB,GAEA,OAAAtkB,WAAAC,OACArD,KAAAuR,MAAA,kBAAAvP,GACA6mB,GACAC,IAAAhN,EAAA9Z,IACAwkB,GAAAxmB,KAAAmW,OAAA2F,GAAAmL,UAUAqiD,GAAA,SAAAtnE,GACA,GAAA8Z,GAAA9b,KAAA0nB,GAEA,OAAAtkB,WAAAC,OACArD,KAAAuR,KAAAwX,GAAAjN,EAAA9Z,IACAwkB,GAAAxmB,KAAAmW,OAAA2F,GAAAoL,MAGAqiD,GAAA,SAAA3zC,GACA,kBAAAA,OAAAshC,GAAAthC,GAEA,QAAA5a,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,EAAA,GAAAzsD,OAAAwJ,GAAAD,EAAA,EAAqFA,EAAAC,IAAOD,EAC5F,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAAg1D,EAAAF,EAAAljD,MAAAhP,EAAA,EAA4FA,EAAA+L,IAAO/L,GACnGkQ,EAAAjC,EAAAjO,KAAA2vB,EAAA/0B,KAAAsV,IAAAzB,SAAAzO,EAAAiO,IACAmkD,EAAAjwD,KAAA+N,EAKA,WAAA0T,IAAAsuC,EAAAn4D,KAAAiE,SAAAjE,KAAA8pB,MAAA9pB,KAAA0nB,MAGA8hD,GAAA,SAAAC,GACA,GAAAA,EAAA/hD,MAAA1nB,KAAA0nB,IAAA,SAAA9lB,MAEA,QAAAw3D,GAAAp5D,KAAAkb,QAAAm+C,EAAAoQ,EAAAvuD,QAAAo+C,EAAAF,EAAA/1D,OAAAob,EAAA46C,EAAAh2D,OAAA6R,EAAAnI,KAAAuR,IAAAg7C,EAAA76C,GAAA86C,EAAA,GAAA7tD,OAAA4tD,GAAArkD,EAAA,EAAkKA,EAAAC,IAAOD,EACzK,OAAAkB,GAAAqjD,EAAAJ,EAAAnkD,GAAAwkD,EAAAJ,EAAApkD,GAAAjD,EAAAwnD,EAAAn2D,OAAAmN,EAAA+oD,EAAAtkD,GAAA,GAAAvJ,OAAAsG,GAAA/L,EAAA,EAAwHA,EAAA+L,IAAO/L,GAC/HkQ,EAAAqjD,EAAAvzD,IAAAwzD,EAAAxzD,MACAuK,EAAAvK,GAAAkQ,EAKA,MAAQlB,EAAAqkD,IAAQrkD,EAChBskD,EAAAtkD,GAAAmkD,EAAAnkD,EAGA,WAAA4U,IAAA0vC,EAAAv5D,KAAAiE,SAAAjE,KAAA8pB,MAAA9pB,KAAA0nB,MA0BAgiD,GAAA,SAAAl3D,EAAAyB,GACA,GAAA6H,GAAA9b,KAAA0nB,GAEA,OAAAtkB,WAAAC,OAAA,EACAmjB,GAAAxmB,KAAAmW,OAAA2F,GAAAhH,MAAAtC,GACAxS,KAAAuR,KAAA0X,GAAAnN,EAAAtJ,EAAAyB,KAWA01D,GAAA,WACA,MAAA3pE,MAAA8U,GAAA,aAAAuU,GAAArpB,KAAA0nB,OAGAkiD,GAAA,SAAAC,GACA,GAAAr3D,GAAAxS,KAAA8pB,MACAhO,EAAA9b,KAAA0nB,GAEA,mBAAAmiD,OAAA99D,GAAA89D,GAEA,QAAA7uD,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,EAAA,GAAAzsD,OAAAwJ,GAAAD,EAAA,EAAqFA,EAAAC,IAAOD,EAC5F,OAAAkB,GAAAiiD,EAAAlkD,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAAg1D,EAAAF,EAAAljD,GAAA,GAAAvJ,OAAAsG,GAAA/L,EAAA,EAA+GA,EAAA+L,IAAO/L,GACtHkQ,EAAAjC,EAAAjO,MAAAmyD,EAAAyR,EAAAhpE,KAAAsV,IAAAzB,SAAAzO,EAAAiO,MACA,YAAAiC,KAAAiiD,EAAA1jD,SAAAyB,EAAAzB,UACA2jD,EAAApyD,GAAAmyD,EACA3sD,GAAA4sD,EAAApyD,GAAAuM,EAAAsJ,EAAA7V,EAAAoyD,EAAA7xC,GAAArQ,EAAA2F,IAKA,WAAA+N,IAAAsuC,EAAAn4D,KAAAiE,SAAAuO,EAAAsJ,IAGAguD,GAAA,SAAAD,GACA,GAAAr3D,GAAAxS,KAAA8pB,MACAhO,EAAA9b,KAAA0nB,GAEA,mBAAAmiD,OAAAvR,GAAAuR,GAEA,QAAA7uD,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA80D,KAAAl9C,KAAAhG,EAAA,EAAyFA,EAAAC,IAAOD,EAChG,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAA4C,EAAA,EAA8DA,EAAA+L,IAAO/L,EACrE,GAAAkQ,EAAAjC,EAAAjO,GAAA,CACA,OAAA6nC,GAAAZ,EAAA28B,EAAAhpE,KAAAsV,IAAAzB,SAAAzO,EAAAiO,GAAA6X,EAAAvF,GAAArQ,EAAA2F,GAAApL,EAAA,EAAAyN,EAAA+uB,EAAA7pC,OAAwIqN,EAAAyN,IAAOzN,GAC/Io9B,EAAAZ,EAAAx8B,KACAjF,GAAAqiC,EAAAt7B,EAAAsJ,EAAApL,EAAAw8B,EAAAnhB,EAGAosC,GAAA/vD,KAAA8kC,GACAjyB,EAAA7S,KAAA+N,GAKA,UAAA0T,IAAAsuC,EAAAl9C,EAAAzI,EAAAsJ,IAGAiuD,GAAAt6D,GAAAtP,UAAAqC,YAEAwnE,GAAA,WACA,UAAAD,IAAA/pE,KAAAkb,QAAAlb,KAAAiE,WA+CAgmE,GAAA,SAAAz3D,EAAAxQ,EAAA6V,GACA,GAAA5R,GAAA,cAAAuM,GAAA,IAAAg1D,GAAA/nC,EACA,cAAAz9B,EAAAhC,KACA0pB,WAAAlX,EAAA8W,GAAA9W,EAAAvM,IACA6O,GAAA,aAAAtC,EAAA+W,GAAA/W,IACAxS,KAAA0pB,WAAAlX,EAAA,kBAAAxQ,GACAynB,GAAAjX,EAAAvM,EAAAwhB,GAAAznB,KAAA,SAAAwS,EAAAxQ,IACAwnB,GAAAhX,EAAAvM,EAAAjE,EAAA,IAAA6V,IAcAqyD,GAAA,SAAA13D,EAAAxQ,EAAA6V,GACA,GAAAtB,GAAA,UAAA/D,GAAA,GACA,IAAApP,UAAAC,OAAA,SAAAkT,EAAAvW,KAAAgnB,MAAAzQ,OAAAkS,MACA,UAAAzmB,EAAA,MAAAhC,MAAAgnB,MAAAzQ,EAAA,KACA,sBAAAvU,GAAA,SAAAJ,MACA,OAAA5B,MAAAgnB,MAAAzQ,EAAAmT,GAAAlX,EAAAxQ,EAAA,MAAA6V,EAAA,GAAAA,KAgBAsyD,GAAA,SAAAnoE,GACA,MAAAhC,MAAAgnB,MAAA,yBAAAhlB,GACA4nB,GAAAnC,GAAAznB,KAAA,OAAAgC,IACA2nB,GAAA,MAAA3nB,EAAA,GAAAA,EAAA,MAGAooE,GAAA,WAKA,OAJA53D,GAAAxS,KAAA8pB,MACAugD,EAAArqE,KAAA0nB,IACA4iD,EAAAvgD,KAEA/O,EAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA4R,EAAA,EAA2DA,EAAAC,IAAOD,EAClE,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAA4C,EAAA,EAA8DA,EAAA+L,IAAO/L,EACrE,GAAAkQ,EAAAjC,EAAAjO,GAAA,CACA,GAAA8lB,GAAAvF,GAAArQ,EAAAk0D,EACA5+D,IAAA0K,EAAA3D,EAAA83D,EAAArkE,EAAAiO,GACA+Q,KAAA8G,EAAA9G,KAAA8G,EAAA/G,MAAA+G,EAAA9E,SACAjC,MAAA,EACAiC,SAAA8E,EAAA9E,SACAC,KAAA6E,EAAA7E,OAMA,UAAA2C,IAAA7O,EAAAhb,KAAAiE,SAAAuO,EAAA83D,IAGAxuD,GAAA,EAiBAyuD,GAAA96D,GAAAtP,SAEA0pB,IAAA1pB,UAAA0Q,GAAA1Q,WACAqC,YAAAqnB,GACAvZ,OAAAs5D,GACAj6D,UAAAm6D,GACAx4D,OAAAi4D,GACA/4D,MAAAg5D,GACA/5D,UAAAu6D,GACAn5D,WAAAu5D,GACAvpE,KAAA0pE,GAAA1pE,KACAi0B,MAAAy1C,GAAAz1C,MACA3e,KAAAo0D,GAAAp0D,KACA+xB,KAAAqiC,GAAAriC,KACA3kC,MAAAgnE,GAAAhnE,MACAgO,KAAAg5D,GAAAh5D,KACAuD,GAAA40D,GACAt5D,KAAA84D,GACAxgD,UAAAygD,GACAzxD,MAAAuyD,GACAvgD,WAAAwgD,GACA35D,KAAA45D,GACAtiE,OAAA8hE,GACA3iD,MAAAiiD,GACAjkD,MAAAokD,GACAniD,SAAAoiD,GACAniD,KAAAoiD,GA+BA,IAEAkB,IAAA,QAAAC,GAAAxiE,GAGA,QAAAuiE,GAAAz4D,GACA,MAAAhF,MAAAM,IAAA0E,EAAA9J,GAKA,MARAA,MAMAuiE,EAAAnyB,SAAAoyB,EAEAD,GAXA,GAcAE,GAAA,QAAAD,GAAAxiE,GAGA,QAAAyiE,GAAA34D,GACA,SAAAhF,KAAAM,IAAA,EAAA0E,EAAA9J,GAKA,MARAA,MAMAyiE,EAAAryB,SAAAoyB,EAEAC,GAvBA,GA0BAC,GAAA,QAAAF,GAAAxiE,GAGA,QAAA0iE,GAAA54D,GACA,QAAAA,GAAA,MAAAhF,KAAAM,IAAA0E,EAAA9J,GAAA,EAAA8E,KAAAM,IAAA,EAAA0E,EAAA9J,IAAA,EAKA,MARAA,MAMA0iE,EAAAtyB,SAAAoyB,EAEAE,GAnCA,GAsCAhgD,GAAA5d,KAAAo5D,GACA37C,GAAAG,GAAA,EAsCAS,GAAA,KACAG,GAAA,KACAD,GAAA,KACAE,GAAA,IACAE,GAAA,KACAD,GAAA,MACAE,GAAA,MACAC,GAAA,MACAC,GAAA,MACAR,GAAA,EAAAD,MAgBAw/C,GAAA,QAAAH,GAAAvsD,GAGA,QAAA0sD,GAAA74D,GACA,MAAAA,OAAAmM,EAAA,GAAAnM,EAAAmM,GAKA,MARAA,MAMA0sD,EAAAC,UAAAJ,EAEAG,GAXA,SAcAE,GAAA,QAAAL,GAAAvsD,GAGA,QAAA4sD,GAAA/4D,GACA,QAAAA,MAAAmM,EAAA,GAAAnM,EAAAmM,GAAA,EAKA,MARAA,MAMA4sD,EAAAD,UAAAJ,EAEAK,GAvBA,SA0BAC,GAAA,QAAAN,GAAAvsD,GAGA,QAAA6sD,GAAAh5D,GACA,QAAAA,GAAA,KAAAA,MAAAmM,EAAA,GAAAnM,EAAAmM,IAAAnM,GAAA,GAAAA,IAAAmM,EAAA,GAAAnM,EAAAmM,GAAA,KAKA,MARAA,MAMA6sD,EAAAF,UAAAJ,EAEAM,GAnCA,SAsCAC,GAAA,EAAAj+D,KAAAo5D,GAIA8E,GAAA,QAAAR,GAAA/9D,EAAAjK,GAGA,QAAAwoE,GAAAl5D,GACA,MAAArF,GAAAK,KAAAM,IAAA,OAAA0E,GAAAhF,KAAAiS,KAAAd,EAAAnM,GAAAtP,GAHA,GAAAyb,GAAAnR,KAAAkqB,KAAA,GAAAvqB,EAAAK,KAAAC,IAAA,EAAAN,MAAAjK,GAAAuoE,GASA,OAHAC,GAAAC,UAAA,SAAAx+D,GAAqC,MAAA+9D,GAAA/9D,EAAAjK,EAAAuoE,KACrCC,EAAAE,OAAA,SAAA1oE,GAAkC,MAAAgoE,GAAA/9D,EAAAjK,IAElCwoE,GAbA,EACA,IAeAG,GAAA,QAAAX,GAAA/9D,EAAAjK,GAGA,QAAA2oE,GAAAr5D,GACA,SAAArF,EAAAK,KAAAM,IAAA,OAAA0E,OAAAhF,KAAAiS,KAAAjN,EAAAmM,GAAAzb,GAHA,GAAAyb,GAAAnR,KAAAkqB,KAAA,GAAAvqB,EAAAK,KAAAC,IAAA,EAAAN,MAAAjK,GAAAuoE,GASA,OAHAI,GAAAF,UAAA,SAAAx+D,GAAsC,MAAA+9D,GAAA/9D,EAAAjK,EAAAuoE,KACtCI,EAAAD,OAAA,SAAA1oE,GAAmC,MAAAgoE,GAAA/9D,EAAAjK,IAEnC2oE,GA1BA,EACA,IA4BAC,GAAA,QAAAZ,GAAA/9D,EAAAjK,GAGA,QAAA4oE,GAAAt5D,GACA,QAAAA,EAAA,EAAAA,EAAA,KACArF,EAAAK,KAAAM,IAAA,KAAA0E,GAAAhF,KAAAiS,KAAAd,EAAAnM,GAAAtP,GACA,EAAAiK,EAAAK,KAAAM,IAAA,MAAA0E,GAAAhF,KAAAiS,KAAAd,EAAAnM,GAAAtP,IAAA,EALA,GAAAyb,GAAAnR,KAAAkqB,KAAA,GAAAvqB,EAAAK,KAAAC,IAAA,EAAAN,MAAAjK,GAAAuoE,GAWA,OAHAK,GAAAH,UAAA,SAAAx+D,GAAwC,MAAA+9D,GAAA/9D,EAAAjK,EAAAuoE,KACxCK,EAAAF,OAAA,SAAA1oE,GAAqC,MAAAgoE,GAAA/9D,EAAAjK,IAErC4oE,GAzCA,EACA,IA2CAp/C,IACAhH,KAAA,KACAD,MAAA,EACAiC,SAAA,IACAC,KAAAoD,IAaAghD,GAAA,SAAA94D,GACA,GAAAsJ,GACAkQ,CAEAxZ,aAAAqX,KACA/N,EAAAtJ,EAAAkV,IAAAlV,IAAAsX,QAEAhO,EAAAiO,MAAAiC,EAAAC,IAAAhH,KAAAX,KAAA9R,EAAA,MAAAA,EAAA,KAAAA,EAAA,GAGA,QAAAwI,GAAAhb,KAAAkb,QAAAhG,EAAA8F,EAAA3X,OAAA4R,EAAA,EAA2DA,EAAAC,IAAOD,EAClE,OAAAkB,GAAAjC,EAAA8G,EAAA/F,GAAAjD,EAAAkC,EAAA7Q,OAAA4C,EAAA,EAA8DA,EAAA+L,IAAO/L,GACrEkQ,EAAAjC,EAAAjO,KACAwF,GAAA0K,EAAA3D,EAAAsJ,EAAA7V,EAAAiO,EAAA8X,GAAAD,GAAA5V,EAAA2F,GAKA,WAAA+N,IAAA7O,EAAAhb,KAAAiE,SAAAuO,EAAAsJ,GAGArM,IAAAtP,UAAA2wB,UAAAk4C,GACAv5D,GAAAtP,UAAA0Q,WAAAy6D,EAEA,IAAAC,KAAA,MAEAxvD,GAAA,SAAA5F,EAAA3D,GACA,GACA+U,GACAthB,EAFA0gB,EAAAxQ,EAAAiQ,YAIA,IAAAO,EAAA,CACAnU,EAAA,MAAAA,EAAA,KAAAA,EAAA,EACA,KAAAvM,IAAA0gB,GACA,IAAAY,EAAAZ,EAAA1gB,IAAAsF,MAAAmb,IAAAa,EAAA/U,SACA,UAAAqX,MAAA1T,IAAAo1D,GAAA/4D,GAAAvM,GAKA,aAGAqrB,GAAA,SAAA3lB,GACA,kBACA,MAAAA,KAIA0lB,GAAA,SAAAxV,EAAApJ,EAAAhD,GACAzP,KAAA6b,SACA7b,KAAAyS,OACAzS,KAAAyP,aAOA+e,GAAA,WACA/uB,EAAA2U,MAAAknD,iBACA77D,EAAA2U,MAAAgH,4BAGAyT,IAAiBrc,KAAA,QACjBoc,IAAkBpc,KAAA,SAClBmd,IAAmBnd,KAAA,UACnBod,IAAmBpd,KAAA,UAEnBya,IACAza,KAAA,IACAkb,SAAA,SAAAnb,IAAAE,IACAye,MAAA,SAAAvlB,EAAA1D,GAAyB,MAAA0D,QAAA,GAAA1D,EAAA,QAAA0D,EAAA,GAAA1D,EAAA,SACzB6kB,OAAA,SAAA0+C,GAAwB,MAAAA,OAAA,MAAAA,EAAA,SAGxBr+C,IACA3a,KAAA,IACAkb,SAAA,SAAAnb,IAAAE,IACAye,MAAA,SAAAnjB,EAAA9F,GAAyB,MAAA8F,MAAA9F,EAAA,MAAA8F,EAAA,KAAA9F,EAAA,MAAA8F,EAAA,MACzB+e,OAAA,SAAA0+C,GAAwB,MAAAA,OAAA,MAAAA,EAAA,SAGxBC,IACAj5D,KAAA,KACAkb,SAAA,qCAAAnb,IAAAE,IACAye,MAAA,SAAAs6C,GAAuB,MAAAA,IACvB1+C,OAAA,SAAA0+C,GAAwB,MAAAA,KAGxBh+C,IACAH,QAAA,YACA5d,UAAA,OACAuC,EAAA,YACA/J,EAAA,YACAiW,EAAA,YACAye,EAAA,YACA+uC,GAAA,cACAC,GAAA,cACAC,GAAA,cACAC,GAAA,eAGAh8C,IACA5nB,EAAA,IACA00B,EAAA,IACA+uC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,MAGA/7C,IACA9d,EAAA,IACAkM,EAAA,IACAwtD,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,MAGAp7C,IACApD,QAAA,EACA5d,UAAA,EACAuC,EAAA,KACA/J,EAAA,EACAiW,EAAA,KACAye,GAAA,EACA+uC,IAAA,EACAC,GAAA,EACAC,GAAA,EACAC,IAAA,GAGAn7C,IACArD,QAAA,EACA5d,UAAA,EACAuC,GAAA,EACA/J,EAAA,KACAiW,EAAA,EACAye,EAAA,KACA+uC,IAAA,EACAC,IAAA,EACAC,GAAA,EACAC,GAAA,GAyCAz+C,GAAA,WACA,MAAAJ,IAAAy+C,KAyZA1sD,GAAAhS,KAAAgS,IACAC,GAAAjS,KAAAiS,IACA8sD,GAAA/+D,KAAAo5D,GACA4F,GAAAD,GAAA,EACAE,GAAA,EAAAF,GACAG,GAAAl/D,KAAAC,IAWAk/D,GAAA,WAMA,QAAAA,GAAA1pD,GACA,GAOA9R,GACA/E,EACAqoB,EACAhY,EACA/V,EACAgP,EAZAjD,EAAAwQ,EAAAnf,OACA8oE,KACAC,EAAAnpC,GAAAjxB,GACAq6D,KACAC,KACAtxD,EAAAsxD,EAAAtxD,OAAA,GAAAtP,OAAAsG,GACAmmD,EAAA,GAAAzsD,OAAAsG,IASkB,KAAlBtB,EAAA,EAAAzK,GAAA,IAAkBA,EAAA+L,GAAA,CACE,IAApBrG,EAAA,EAAAsJ,GAAA,IAAoBA,EAAAjD,GACpBrG,GAAA6W,EAAAvc,GAAAgP,EAEAk3D,GAAA/jE,KAAAuD,GACA0gE,EAAAjkE,KAAA66B,GAAAjxB,IACAtB,GAAA/E,EAuBkB,IAnBlB4gE,GAAAH,EAAAxzB,KAAA,SAAAlsC,EAAApK,GACA,MAAAiqE,GAAAJ,EAAAz/D,GAAAy/D,EAAA7pE,MAIAkqE,GAAAH,EAAAjrE,QAAA,SAAAiB,EAAA4D,GACA5D,EAAAu2C,KAAA,SAAAlsC,EAAApK,GACA,MAAAkqE,GAAAhqD,EAAAvc,GAAAyG,GAAA8V,EAAAvc,GAAA3D,QAOAoO,EAAAu7D,GAAA,EAAAD,GAAA1lB,EAAAt0C,GAAAtB,EACAsL,EAAAtL,EAAA41C,EAAA0lB,GAAAh6D,EAIArG,EAAA,EAAA1F,GAAA,IAAkBA,EAAA+L,GAAA,CACG,IAArBgiB,EAAAroB,EAAAsJ,GAAA,IAAqBA,EAAAjD,GAAA,CACrB,GAAAy6D,GAAAL,EAAAnmE,GACAymE,EAAAL,EAAAI,GAAAx3D,GACAsC,EAAAiL,EAAAiqD,GAAAC,GACApsC,EAAA30B,EACAi0B,EAAAj0B,GAAA4L,EAAA7G,CACAynD,GAAAuU,EAAA16D,EAAAy6D,IACA7kE,MAAA6kE,EACAE,SAAAD,EACAv6C,WAAAmO,EACAjO,SAAAuN,EACA59B,MAAAuV,GAGAyD,EAAAyxD,IACA7kE,MAAA6kE,EACAt6C,WAAA6B,EACA3B,SAAA1mB,EACA3J,MAAAmqE,EAAAM,IAEA9gE,GAAAqQ,EAIW,IAAX/V,GAAA,IAAWA,EAAA+L,GACK,IAAhBiD,EAAAhP,EAAA,IAAgBgP,EAAAjD,GAAA,CAChB,GAAAzR,GAAA43D,EAAAljD,EAAAjD,EAAA/L,GACA4V,EAAAs8C,EAAAlyD,EAAA+L,EAAAiD,IACA1U,EAAAyB,OAAA6Z,EAAA7Z,QACAsqE,EAAAlkE,KAAA7H,EAAAyB,MAAA6Z,EAAA7Z,OACiBzB,OAAAsb,SAAAtb,IACAA,SAAAsb,WAKjB,MAAA+wD,GAAAN,EAAA1zB,KAAAg0B,GAAAN,EAvFA,GAAAhmB,GAAA,EACAimB,EAAA,KACAC,EAAA,KACAI,EAAA,IAuGA,OAhBAV,GAAA5lB,SAAA,SAAA90C,GACA,MAAApO,WAAAC,QAAAijD,EAAA2lB,GAAA,EAAAz6D,GAAA06D,GAAA5lB,GAGA4lB,EAAAK,WAAA,SAAA/6D,GACA,MAAApO,WAAAC,QAAAkpE,EAAA/6D,EAAA06D,GAAAK,GAGAL,EAAAM,cAAA,SAAAh7D,GACA,MAAApO,WAAAC,QAAAmpE,EAAAh7D,EAAA06D,GAAAM,GAGAN,EAAAU,WAAA,SAAAp7D,GACA,MAAApO,WAAAC,QAAA,MAAAmO,EAAAo7D,EAAA,MAAAA,EAAAr7C,GAAA/f,QAAA06D,GAAAU,KAAAp7D,GAGA06D,GAGAW,GAAAnhE,MAAAvL,UAAAqJ,MAEAsjE,GAAA,SAAAnhE,GACA,kBACA,MAAAA,KAIAohE,GAAAhgE,KAAAo5D,GACA6G,GAAA,EAAAD,GAEAE,GAAAD,GADA,IAaAv7C,IAAAtxB,UAAAuP,GAAAvP,WACAqC,YAAAivB,GACAw3B,OAAA,SAAAt9C,EAAAoC,GACA/N,KAAAwR,GAAA,KAAAxR,KAAA0xB,IAAA1xB,KAAA4xB,KAAAjmB,GAAA,KAAA3L,KAAA2xB,IAAA3xB,KAAA6xB,KAAA9jB,IAEAm/D,UAAA,WACA,OAAAltE,KAAA4xB,MACA5xB,KAAA4xB,IAAA5xB,KAAA0xB,IAAA1xB,KAAA6xB,IAAA7xB,KAAA2xB,IACA3xB,KAAAwR,GAAA,MAGA27D,OAAA,SAAAxhE,EAAAoC,GACA/N,KAAAwR,GAAA,KAAAxR,KAAA4xB,KAAAjmB,GAAA,KAAA3L,KAAA6xB,KAAA9jB,IAEAq/D,iBAAA,SAAAl5C,EAAAC,EAAAxoB,EAAAoC,GACA/N,KAAAwR,GAAA,MAAA0iB,EAAA,MAAAC,EAAA,KAAAn0B,KAAA4xB,KAAAjmB,GAAA,KAAA3L,KAAA6xB,KAAA9jB,IAEAm7C,cAAA,SAAAh1B,EAAAC,EAAA0U,EAAAC,EAAAn9B,EAAAoC,GACA/N,KAAAwR,GAAA,MAAA0iB,EAAA,MAAAC,EAAA,MAAA0U,EAAA,MAAAC,EAAA,KAAA9oC,KAAA4xB,KAAAjmB,GAAA,KAAA3L,KAAA6xB,KAAA9jB,IAEAs/D,MAAA,SAAAn5C,EAAAC,EAAA0U,EAAAC,EAAAlrB,GACAsW,KAAAC,KAAA0U,KAAAC,KAAAlrB,IACA,IAAAoW,GAAAh0B,KAAA4xB,IACAqC,EAAAj0B,KAAA6xB,IACAwd,EAAAxG,EAAA3U,EACAob,EAAAxG,EAAA3U,EACA4yB,EAAA/yB,EAAAE,EACA8yB,EAAA/yB,EAAAE,EACAm5C,EAAAvmB,IAAAC,GAGA,IAAAppC,EAAA,WAAAhc,OAAA,oBAAAgc,EAGA,WAAA5d,KAAA4xB,IACA5xB,KAAAwR,GAAA,KAAAxR,KAAA4xB,IAAAsC,GAAA,KAAAl0B,KAAA6xB,IAAAsC,OAIA,IAAAm5C,EApDA,KAyDA,GAAAvgE,KAAAY,IAAAq5C,EAAA3X,EAAAC,EAAAyX,GAzDA,MAyDAnpC,EAKA,CACA,GAAA2vD,GAAA1kC,EAAA7U,EACAw5C,EAAA1kC,EAAA7U,EACAw5C,EAAAp+B,IAAAC,IACAo+B,EAAAH,IAAAC,IACAG,EAAA5gE,KAAAiT,KAAAytD,GACAG,EAAA7gE,KAAAiT,KAAAstD,GACAnvD,EAAAP,EAAA7Q,KAAA6+B,KAAAmhC,GAAAhgE,KAAAgqB,MAAA02C,EAAAH,EAAAI,IAAA,EAAAC,EAAAC,KAAA,GACAC,EAAA1vD,EAAAyvD,EACAE,EAAA3vD,EAAAwvD,CAGA5gE,MAAAY,IAAAkgE,EAAA,GA1EA,OA2EA7tE,KAAAwR,GAAA,KAAA0iB,EAAA25C,EAAA9mB,GAAA,KAAA5yB,EAAA05C,EAAA7mB,IAGAhnD,KAAAwR,GAAA,IAAAoM,EAAA,IAAAA,EAAA,WAAAopC,EAAAumB,EAAAxmB,EAAAymB,GAAA,KAAAxtE,KAAA4xB,IAAAsC,EAAA45C,EAAAz+B,GAAA,KAAArvC,KAAA6xB,IAAAsC,EAAA25C,EAAAx+B,OApBAtvC,MAAAwR,GAAA,KAAAxR,KAAA4xB,IAAAsC,GAAA,KAAAl0B,KAAA6xB,IAAAsC,UAuBA87B,IAAA,SAAAtkD,EAAAoC,EAAA6P,EAAA0iB,EAAAV,EAAAmuC,GACApiE,KAAAoC,KAAA6P,IACA,IAAA5B,GAAA4B,EAAA7Q,KAAAgS,IAAAuhB,GACArkB,EAAA2B,EAAA7Q,KAAAiS,IAAAshB,GACAtM,EAAAroB,EAAAqQ,EACAiY,EAAAlmB,EAAAkO,EACA6qC,EAAA,EAAAinB,EACA19B,EAAA09B,EAAAztC,EAAAV,IAAAU,CAGA,IAAA1iB,EAAA,WAAAhc,OAAA,oBAAAgc,EAGA,QAAA5d,KAAA4xB,IACA5xB,KAAAwR,GAAA,IAAAwiB,EAAA,IAAAC,GAIAlnB,KAAAY,IAAA3N,KAAA4xB,IAAAoC,GAnGA,MAmGAjnB,KAAAY,IAAA3N,KAAA6xB,IAAAoC,GAnGA,QAoGAj0B,KAAAwR,GAAA,IAAAwiB,EAAA,IAAAC,GAIArW,IAGAyyB,EAAA,IAAAA,IAAA28B,OAGA38B,EAAA48B,GACAjtE,KAAAwR,GAAA,IAAAoM,EAAA,IAAAA,EAAA,QAAAkpC,EAAA,KAAAn7C,EAAAqQ,GAAA,KAAAjO,EAAAkO,GAAA,IAAA2B,EAAA,IAAAA,EAAA,QAAAkpC,EAAA,KAAA9mD,KAAA4xB,IAAAoC,GAAA,KAAAh0B,KAAA6xB,IAAAoC,GAIAoc,EAnHA,OAoHArwC,KAAAwR,GAAA,IAAAoM,EAAA,IAAAA,EAAA,SAAAyyB,GAAA08B,IAAA,IAAAjmB,EAAA,KAAA9mD,KAAA4xB,IAAAjmB,EAAAiS,EAAA7Q,KAAAgS,IAAA6gB,IAAA,KAAA5/B,KAAA6xB,IAAA9jB,EAAA6P,EAAA7Q,KAAAiS,IAAA4gB,OAGAi4B,KAAA,SAAAlsD,EAAAoC,EAAA4uB,EAAA1e,GACAje,KAAAwR,GAAA,KAAAxR,KAAA0xB,IAAA1xB,KAAA4xB,KAAAjmB,GAAA,KAAA3L,KAAA2xB,IAAA3xB,KAAA6xB,KAAA9jB,GAAA,MAAA4uB,EAAA,MAAA1e,EAAA,KAAA0e,EAAA,KAEA5oB,SAAA,WACA,MAAA/T,MAAAwR,GAwBA,IAAAw8D,IAAA,WAQA,QAAAA,KACA,GAAAplB,GACAC,EAAAgkB,GAAAhsE,KAAAuC,WACA8a,EAAA3d,EAAAyE,MAAAhF,KAAA6oD,GACA92C,EAAA8J,EAAA7W,MAAAhF,KAAA6oD,GACAolB,GAAAh8C,EAAAjtB,MAAAhF,MAAA6oD,EAAA,GAAA3qC,EAAA2qC,IACAqlB,EAAA/7C,EAAAntB,MAAAhF,KAAA6oD,GAAAkjB,GACAoC,EAAA97C,EAAArtB,MAAAhF,KAAA6oD,GAAAkjB,GACAqC,EAAAH,EAAAlvD,GAAAmvD,GACAhjC,EAAA+iC,EAAAjvD,GAAAkvD,GACAG,GAAAp8C,EAAAjtB,MAAAhF,MAAA6oD,EAAA,GAAA92C,EAAA82C,IACAylB,EAAAn8C,EAAAntB,MAAAhF,KAAA6oD,GAAAkjB,GACAwC,EAAAl8C,EAAArtB,MAAAhF,KAAA6oD,GAAAkjB,EAaA,IAXA3nE,MAAAwkD,EAAAl5C,MAEAtL,EAAA6kD,OAAAmlB,EAAAljC,GACA9mC,EAAA6rD,IAAA,IAAAge,EAAAC,EAAAC,GACAD,IAAAI,GAAAH,IAAAI,IACAnqE,EAAAgpE,iBAAA,IAAAiB,EAAAtvD,GAAAuvD,GAAAD,EAAArvD,GAAAsvD,IACAlqE,EAAA6rD,IAAA,IAAAoe,EAAAC,EAAAC,IAEAnqE,EAAAgpE,iBAAA,IAAAgB,EAAAljC,GACA9mC,EAAA8oE,YAEAtkB,EAAA,MAAAxkD,GAAA,KAAAwkD,EAAA,SAhCA,GAAAroD,GAAAuxB,GACAjW,EAAAkW,GACAE,EAAAD,GACAG,EAAAD,GACAG,EAAAD,GACAhuB,EAAA,IAsDA,OAxBA4pE,GAAA/7C,OAAA,SAAAzgB,GACA,MAAApO,WAAAC,QAAA4uB,EAAA,kBAAAzgB,KAAAs7D,IAAAt7D,GAAAw8D,GAAA/7C,GAGA+7C,EAAA77C,WAAA,SAAA3gB,GACA,MAAApO,WAAAC,QAAA8uB,EAAA,kBAAA3gB,KAAAs7D,IAAAt7D,GAAAw8D,GAAA77C,GAGA67C,EAAA37C,SAAA,SAAA7gB,GACA,MAAApO,WAAAC,QAAAgvB,EAAA,kBAAA7gB,KAAAs7D,IAAAt7D,GAAAw8D,GAAA37C,GAGA27C,EAAAztE,OAAA,SAAAiR,GACA,MAAApO,WAAAC,QAAA9C,EAAAiR,EAAAw8D,GAAAztE,GAGAytE,EAAAnyD,OAAA,SAAArK,GACA,MAAApO,WAAAC,QAAAwY,EAAArK,EAAAw8D,GAAAnyD,GAGAmyD,EAAA5pE,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAAe,EAAA,MAAAoN,EAAA,KAAAA,EAAAw8D,GAAA5pE,GAGA4pE,EAOA17C,IAAAnyB,UAAAoyB,GAAApyB,WACAqC,YAAA8vB,GACAqjB,IAAA,SAAAp/B,GACA,MAPA,IAOAA,IAAAvW,OAEA0S,IAAA,SAAA6D,GACA,MAAAvW,MAVA,IAUAuW,IAEA3D,IAAA,SAAA2D,EAAAvU,GAEA,MADAhC,MAbA,IAaAuW,GAAAvU,EACAhC,MAEA6H,OAAA,SAAA0O,GACA,GAAA+W,GAjBA,IAiBA/W,CACA,OAAA+W,KAAAttB,mBAAAstB,IAEAkhD,MAAA,WACA,OAAAlhD,KAAAttB,MArBA,MAqBAstB,EAAA,UAAAttB,MAAAstB,IAEAmhD,KAAA,WACA,GAAAA,KACA,QAAAnhD,KAAAttB,MAzBA,MAyBAstB,EAAA,IAAAmhD,EAAArmE,KAAAklB,EAAA9jB,MAAA,GACA,OAAAilE,IAEA//D,OAAA,WACA,GAAAA,KACA,QAAA4e,KAAAttB,MA9BA,MA8BAstB,EAAA,IAAA5e,EAAAtG,KAAApI,KAAAstB,GACA,OAAA5e,IAEAggE,QAAA,WACA,GAAAA,KACA,QAAAphD,KAAAttB,MAnCA,MAmCAstB,EAAA,IAAAohD,EAAAtmE,MAAyEmO,IAAA+W,EAAA9jB,MAAA,GAAAxH,MAAAhC,KAAAstB,IACzE,OAAAohD,IAEAxmC,KAAA,WACA,GAAAA,GAAA,CACA,QAAA5a,KAAAttB,MAxCA,MAwCAstB,EAAA,MAAA4a,CACA,OAAAA,IAEA3kC,MAAA,WACA,OAAA+pB,KAAAttB,MAAA,GA5CA,MA4CAstB,EAAA,WACA,WAEA/b,KAAA,SAAAhF,GACA,OAAA+gB,KAAAttB,MAhDA,MAgDAstB,EAAA,IAAA/gB,EAAAvM,KAAAstB,KAAA9jB,MAAA,GAAAxJ,OA0BA,IAAA2uE,IAAA,WAOA,QAAA3pE,GAAA8F,EAAA49B,EAAAkmC,EAAAC,GACA,GAAAnmC,GAAA+lC,EAAAprE,OAEA,MADA,OAAAyrE,GAAAhkE,EAAA8tC,KAAAk2B,GACA,MAAAC,IAAAjkE,IAYA,KATA,GAGA0L,GACAxU,EAEA0M,EANAzI,GAAA,EACA+L,EAAAlH,EAAAzH,OACAkT,EAAAk4D,EAAA/lC,KAGAsmC,EAAAz8C,KAEA5sB,EAAAipE,MAEA3oE,EAAA+L,IACAtD,EAAAsgE,EAAAt8D,IAAA8D,EAAAD,EAAAvU,EAAA8I,EAAA7E,IAAA,KACAyI,EAAAtG,KAAApG,GAEAgtE,EAAAp8D,IAAA4D,GAAAxU,GAQA,OAJAgtE,GAAAz9D,KAAA,SAAA7C,EAAA6H,GACAs4D,EAAAlpE,EAAA4Q,EAAAvR,EAAA0J,EAAAg6B,EAAAkmC,EAAAC,MAGAlpE,EAGA,QAAA+oE,GAAAn8D,EAAAm2B,GACA,KAAAA,EAAA+lC,EAAAprE,OAAA,MAAAkP,EACA,IAAAzH,GAAAmkE,EAAAC,EAAAxmC,EAAA,EAGA,OAFA,OAAAqmC,GAAArmC,GAAA+lC,EAAAprE,OAAAyH,EAAAyH,EAAAm8D,WACA5jE,KAAAyH,EAAAhB,KAAA,SAAAgG,EAAA7G,GAA8C5F,EAAA1C,MAAamO,IAAA7F,EAAAhC,OAAAggE,EAAAn3D,EAAAmxB,QAC3D,MAAAumC,EAAAnkE,EAAA8tC,KAAA,SAAAlsC,EAAApK,GAAwD,MAAA2sE,GAAAviE,EAAA6J,IAAAjU,EAAAiU,OAAgCzL,EAzCxF,GAEAgkE,GACAC,EACAJ,EAJAF,KACAS,IA2CA,OAAAP,IACAn8C,OAAA,SAAA1nB,GAA6B,MAAA9F,GAAA8F,EAAA,EAAA2nB,GAAAC,KAC7BngB,IAAA,SAAAzH,GAA0B,MAAA9F,GAAA8F,EAAA,EAAA6nB,GAAAC,KAC1B87C,QAAA,SAAA5jE,GAA8B,MAAA4jE,GAAA1pE,EAAA8F,EAAA,EAAA6nB,GAAAC,IAAA,IAC9Brc,IAAA,SAAAlU,GAAoC,MAAdosE,GAAArmE,KAAA/F,GAAcssE,GACpCO,SAAA,SAAAp/D,GAAkE,MAAnCo/D,GAAAT,EAAAprE,OAAA,GAAAyM,EAAmC6+D,GAClEG,WAAA,SAAAh/D,GAAqD,MAApBg/D,GAAAh/D,EAAoB6+D,GACrDI,OAAA,SAAAxiE,GAAqC,MAAZwiE,GAAAxiE,EAAYoiE,KAsBrCQ,GAAA58C,GAAApyB,SAEA0yB,IAAA1yB,UAAA2yB,GAAA3yB,WACAqC,YAAAqwB,GACA8iB,IAAAw5B,GAAAx5B,IACA70C,IAAA,SAAAkB,GAGA,MAFAA,IAAA,GACAhC,KA3JA,IA2JAgC,KACAhC,MAEA6H,OAAAsnE,GAAAtnE,OACA2mE,MAAAW,GAAAX,MACA9/D,OAAAygE,GAAAV,KACAvmC,KAAAinC,GAAAjnC,KACA3kC,MAAA4rE,GAAA5rE,MACAgO,KAAA49D,GAAA59D,KAmBA,IAAAk9D,IAAA,SAAAl8D,GACA,GAAAk8D,KACA,QAAAl4D,KAAAhE,GAAAk8D,EAAArmE,KAAAmO,EACA,OAAAk4D,IAGA//D,GAAA,SAAA6D,GACA,GAAA7D,KACA,QAAA6H,KAAAhE,GAAA7D,EAAAtG,KAAAmK,EAAAgE,GACA,OAAA7H,IAGAggE,GAAA,SAAAn8D,GACA,GAAAm8D,KACA,QAAAn4D,KAAAhE,GAAAm8D,EAAAtmE,MAAqCmO,MAAAvU,MAAAuQ,EAAAgE,IACrC,OAAAm4D,IAgCAU,GAAA,SAAAC,GAIA,QAAA3sD,GAAAnS,EAAAhE,GACA,GAAA+iE,GAAAt8C,EAAAO,EAAAg8C,EAAAh/D,EAAA,SAAA8iB,EAAAptB,GACA,GAAAqpE,EAAA,MAAAA,GAAAj8C,EAAAptB,EAAA,EACA+sB,GAAAK,EAAAi8C,EAAA/iE,EAAA6mB,GAAAC,EAAA9mB,GAAAwmB,GAAAM,IAGA,OADAE,GAAAP,UACAO,EAGA,QAAAg8C,GAAAh/D,EAAAhE,GAUA,QAAAijE,KACA,GAAAvwB,GAAA5vB,EAAA,MAAAogD,EACA,IAAAC,EAAA,MAAAA,IAAA,EAAAC,CAGA,IAAAh9D,GAAAsC,EAAAgqC,CACA,SAAA1uC,EAAA8qC,WAAApmC,GAAA,CAEA,IADA,GAAAhP,GAAAgP,EACAhP,IAAAopB,GACA,QAAA9e,EAAA8qC,WAAAp1C,GAAA,CACA,QAAAsK,EAAA8qC,WAAAp1C,EAAA,WACAA,EAWA,MARAg5C,GAAAh5C,EAAA,EACA0M,EAAApC,EAAA8qC,WAAAp1C,EAAA,GACA,KAAA0M,GACA+8D,GAAA,EACA,KAAAn/D,EAAA8qC,WAAAp1C,EAAA,MAAAg5C,GACS,KAAAtsC,IACT+8D,GAAA,GAEAn/D,EAAA/G,MAAAyL,EAAA,EAAAhP,GAAA+7C,QAAA,WAIA,KAAA/C,EAAA5vB,GAAA,CACA,GAAA3e,GAAA,CAEA,UADAiC,EAAApC,EAAA8qC,WAAA4D,MACAywB,GAAA,MACA,SAAA/8D,EAA4B+8D,GAAA,EAAY,KAAAn/D,EAAA8qC,WAAA4D,WAAAvuC,OACxC,IAAAiC,IAAAi9D,EAAA,QACA,OAAAr/D,GAAA/G,MAAAyL,EAAAgqC,EAAAvuC,GAIA,MAAAH,GAAA/G,MAAAyL,GAGA,IAhDA,GAMAlD,GACA29D,EAPAC,KACAF,KACAl8C,KACAlE,EAAA9e,EAAAlN,OACA47C,EAAA,EACAjtC,EAAA,GA2CAD,EAAAy9D,OAAAC,GAAA,CAEA,IADA,GAAA/iE,MACAqF,IAAA49D,GAAA59D,IAAA09D,GACA/iE,EAAAtE,KAAA2J,GACAA,EAAAy9D,GAEAjjE,IAAA,OAAAG,EAAAH,EAAAG,EAAAsF,OACAuhB,EAAAnrB,KAAAsE,GAGA,MAAA6mB,GAGA,QAAAxkB,GAAAwkB,EAAAP,GAEA,MADA,OAAAA,MAAAM,GAAAC,KACAP,EAAAzgB,IAAAs9D,GAAApsD,KAAA4rD,IAAAjoE,OAAAmsB,EAAAhhB,IAAA,SAAA8gB,GACA,MAAAL,GAAAzgB,IAAA,SAAAkhB,GACA,MAAAo8C,GAAAx8C,EAAAI,MACOhQ,KAAA4rD,MACF5rD,KAAA,MAGL,QAAAqsD,GAAAv8C,GACA,MAAAA,GAAAhhB,IAAAw9D,GAAAtsD,KAAA,MAGA,QAAAssD,GAAA18C,GACA,MAAAA,GAAA9gB,IAAAs9D,GAAApsD,KAAA4rD,GAGA,QAAAQ,GAAAt/D,GACA,aAAAA,EAAA,GACAy/D,EAAA12B,KAAA/oC,GAAA,QAAAA,EAAAyxC,QAAA,gBACAzxC,EA9FA,GAAAy/D,GAAA,GAAA9tB,QAAA,KAAAmtB,EAAA,SACAO,EAAAP,EAAAh0B,WAAA,EAgGA,QACA34B,QACA6sD,YACAxgE,SACA+gE,eAIAG,GAAAb,GAAA,KAEAc,GAAAD,GAAAvtD,MACAytD,GAAAF,GAAAV,UACAa,GAAAH,GAAAlhE,OACAshE,GAAAJ,GAAAH,WAEAQ,GAAAlB,GAAA,MAEAmB,GAAAD,GAAA5tD,MACA8tD,GAAAF,GAAAf,UACAkB,GAAAH,GAAAvhE,OACA2hE,GAAAJ,GAAAR,WAEAa,GAAA,SAAAhlE,EAAAoC,GAMA,QAAA6iE,KACA,GAAA3qE,GAEAkQ,EADAnE,EAAA8iB,EAAAzxB,OAEAwtE,EAAA,EACAC,EAAA,CAEA,KAAA7qE,EAAA,EAAeA,EAAA+L,IAAO/L,EACtBkQ,EAAA2e,EAAA7uB,GAAA4qE,GAAA16D,EAAAxK,EAAAmlE,GAAA36D,EAAApI,CAGA,KAAA8iE,IAAA7+D,EAAArG,EAAAmlE,IAAA9+D,EAAAjE,EAAA9H,EAAA,EAAiDA,EAAA+L,IAAO/L,EACxDkQ,EAAA2e,EAAA7uB,GAAAkQ,EAAAxK,GAAAklE,EAAA16D,EAAApI,GAAA+iE,EAjBA,GAAAh8C,EAiCA,OA/BA,OAAAnpB,MAAA,GACA,MAAAoC,MAAA,GAkBA6iE,EAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,GAGAo/D,EAAAjlE,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAAsI,GAAA6F,EAAAo/D,GAAAjlE,GAGAilE,EAAA7iE,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA0K,GAAAyD,EAAAo/D,GAAA7iE,GAGA6iE,GAGAG,GAAA,SAAAplE,GACA,kBACA,MAAAA,KAIAqlE,GAAA,WACA,aAAAjkE,KAAAyhC,SAAA,KAGAyiC,GAAA,SAAA5uE,GACA,GAAAsJ,IAAA3L,KAAAo0B,GAAAvzB,KAAA,KAAAwB,GACA0L,GAAA/N,KAAAq0B,GAAAxzB,KAAA,KAAAwB,EACA,OAAAvB,IAAAd,KAAAy0B,MAAA9oB,EAAAoC,GAAApC,EAAAoC,EAAA1L,IAmFA6uE,GAAA,SAAAvlE,EAAAoC,GACA,GAAAsT,MAAA1V,OAAA0V,MAAAtT,MAAA,MAAA/N,KAEA,IAAAg0B,GAAAh0B,KAAA0xB,IACAuC,EAAAj0B,KAAA2xB,IACAuC,EAAAl0B,KAAA4xB,IACAuC,EAAAn0B,KAAA6xB,GAKA,IAAAxQ,MAAA2S,GACAE,GAAAF,EAAAjnB,KAAAG,MAAAvB,IAAA,EACAwoB,GAAAF,EAAAlnB,KAAAG,MAAAa,IAAA,MAIA,MAAAimB,EAAAroB,KAAAuoB,GAAAD,EAAAlmB,KAAAomB,GAiCA,MAAAn0B,KAhCA,IAEA4E,GACAqB,EAHAg2B,EAAA/H,EAAAF,EACA7d,EAAAnW,KAAAkK,KAIA,QAAAjE,GAAA8H,GAAAkmB,EAAAE,GAAA,MAAAxoB,GAAAqoB,EAAAE,GAAA,GACA,OACA,GAAAtvB,EAAA,GAAA8G,OAAA,GAAA9G,EAAAqB,GAAAkQ,IAAAvR,QACAq3B,GAAA,EAAA/H,EAAAF,EAAAiI,EAAA9H,EAAAF,EAAAgI,EAAAtwB,EAAAuoB,GAAAnmB,EAAAomB,EACA,MAEA,QACA,GAAAvvB,EAAA,GAAA8G,OAAA,GAAA9G,EAAAqB,GAAAkQ,IAAAvR,QACAq3B,GAAA,EAAAjI,EAAAE,EAAA+H,EAAA9H,EAAAF,EAAAgI,EAAAjI,EAAAroB,GAAAoC,EAAAomB,EACA,MAEA,QACA,GAAAvvB,EAAA,GAAA8G,OAAA,GAAA9G,EAAAqB,GAAAkQ,IAAAvR,QACAq3B,GAAA,EAAA/H,EAAAF,EAAAiI,EAAAhI,EAAAE,EAAA8H,EAAAtwB,EAAAuoB,GAAAD,EAAAlmB,EACA,MAEA,QACA,GAAAnJ,EAAA,GAAA8G,OAAA,GAAA9G,EAAAqB,GAAAkQ,IAAAvR,QACAq3B,GAAA,EAAAjI,EAAAE,EAAA+H,EAAAhI,EAAAE,EAAA8H,EAAAjI,EAAAroB,GAAAsoB,EAAAlmB,GAKA/N,KAAAkK,OAAAlK,KAAAkK,MAAA7G,SAAArD,KAAAkK,MAAAiM,GAUA,MAJAnW,MAAA0xB,IAAAsC,EACAh0B,KAAA2xB,IAAAsC,EACAj0B,KAAA4xB,IAAAsC,EACAl0B,KAAA6xB,IAAAsC,EACAn0B,MAGAmxE,GAAA,WACA,GAAAvhE,KAIA,OAHA5P,MAAAoxE,MAAA,SAAAj7D,GACA,IAAAA,EAAA9S,OAAA,GAAAuM,EAAAxH,KAAA+N,EAAAvG,YAA8CuG,IAAA9U,QAE9CuO,GAGAyhE,GAAA,SAAA7/D,GACA,MAAApO,WAAAC,OACArD,KAAAy0B,OAAAjjB,EAAA,OAAAA,EAAA,OAAAijB,OAAAjjB,EAAA,OAAAA,EAAA,OACA6P,MAAArhB,KAAA0xB,SAAAsD,KAAAh1B,KAAA0xB,IAAA1xB,KAAA2xB,MAAA3xB,KAAA4xB,IAAA5xB,KAAA6xB,OAGAy/C,GAAA,SAAAn7D,EAAA6d,EAAAC,EAAAC,EAAAC,GACAn0B,KAAAmW,OACAnW,KAAAg0B,KACAh0B,KAAAi0B,KACAj0B,KAAAk0B,KACAl0B,KAAAm0B,MAGAo9C,GAAA,SAAA5lE,EAAAoC,EAAAkkB,GACA,GAAAriB,GAGAskB,EACAC,EACA0U,EACAC,EAKA3lB,EACAld,EAXA+tB,EAAAh0B,KAAA0xB,IACAuC,EAAAj0B,KAAA2xB,IAKA6d,EAAAxvC,KAAA4xB,IACA6d,EAAAzvC,KAAA6xB,IACA2/C,KACAr7D,EAAAnW,KAAAkK,KAYA,KARAiM,GAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAn7D,EAAA6d,EAAAC,EAAAub,EAAAC,IACA,MAAAxd,IAAArM,KAEAoO,EAAAroB,EAAAsmB,EAAAgC,EAAAlmB,EAAAkkB,EACAud,EAAA7jC,EAAAsmB,EAAAwd,EAAA1hC,EAAAkkB,EACAA,MAGA9O,EAAAquD,EAAArmE,OAGA,OAAAgL,EAAAgN,EAAAhN,QACA+d,EAAA/Q,EAAA6Q,IAAAwb,IACArb,EAAAhR,EAAA8Q,IAAAwb,IACA5G,EAAA1lB,EAAA+Q,IAAAF,IACA8U,EAAA3lB,EAAAgR,IAAAF,GAGA,GAAA9d,EAAA9S,OAAA,CACA,GAAAswB,IAAAO,EAAA2U,GAAA,EACAjV,GAAAO,EAAA2U,GAAA,CAEA0oC,GAAAppE,KACA,GAAAkpE,IAAAn7D,EAAA,GAAAwd,EAAAC,EAAAiV,EAAAC,GACA,GAAAwoC,IAAAn7D,EAAA,GAAA+d,EAAAN,EAAAD,EAAAmV,GACA,GAAAwoC,IAAAn7D,EAAA,GAAAwd,EAAAQ,EAAA0U,EAAAjV,GACA,GAAA09C,IAAAn7D,EAAA,GAAA+d,EAAAC,EAAAR,EAAAC,KAIA3tB,GAAA8H,GAAA6lB,IAAA,EAAAjoB,GAAAgoB,KACAxQ,EAAAquD,IAAAnuE,OAAA,GACAmuE,IAAAnuE,OAAA,GAAAmuE,IAAAnuE,OAAA,EAAA4C,GACAurE,IAAAnuE,OAAA,EAAA4C,GAAAkd,OAKA,CACA,GAAAnH,GAAArQ,GAAA3L,KAAAo0B,GAAAvzB,KAAA,KAAAsV,EAAAvG,MACAqM,EAAAlO,GAAA/N,KAAAq0B,GAAAxzB,KAAA,KAAAsV,EAAAvG,MACA+4B,EAAA3sB,IAAAC,GACA,IAAA0sB,EAAA1W,EAAA,CACA,GAAA5vB,GAAA0K,KAAAiT,KAAAiS,EAAA0W,EACA3U,GAAAroB,EAAAtJ,EAAA4xB,EAAAlmB,EAAA1L,EACAmtC,EAAA7jC,EAAAtJ,EAAAotC,EAAA1hC,EAAA1L,EACAuN,EAAAuG,EAAAvG,MAKA,MAAAA,IAGA6hE,GAAA,SAAApvE,GACA,GAAAgf,MAAA1V,GAAA3L,KAAAo0B,GAAAvzB,KAAA,KAAAwB,KAAAgf,MAAAtT,GAAA/N,KAAAq0B,GAAAxzB,KAAA,KAAAwB,IAAA,MAAArC,KAEA,IAAA4E,GAEA8sE,EACA9gC,EACAvvC,EAKAsK,EACAoC,EACA4lB,EACAC,EACAxiB,EACAR,EACA3K,EACAgP,EAfAkB,EAAAnW,KAAAkK,MAIA8pB,EAAAh0B,KAAA0xB,IACAuC,EAAAj0B,KAAA2xB,IACAuC,EAAAl0B,KAAA4xB,IACAuC,EAAAn0B,KAAA6xB,GAWA,KAAA1b,EAAA,MAAAnW,KAIA,IAAAmW,EAAA9S,OAAA,QAGA,IAFA+N,EAAAzF,IAAAgoB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAmDO,EAAAP,GACnD/iB,EAAA7C,IAAA6lB,GAAAK,EAAAE,GAAA,IAAAF,EAAAL,EAAoDO,EAAAP,EACpDhvB,EAAAuR,QAAAlQ,EAAA2K,GAAA,EAAAQ,IAAA,MAAApR,KACA,KAAAmW,EAAA9S,OAAA,OACAuB,EAAAqB,EAAA,MAAArB,EAAAqB,EAAA,MAAArB,EAAAqB,EAAA,QAAAyrE,EAAA9sE,EAAAqQ,EAAAhP,GAIA,KAAAkQ,EAAAvG,OAAAvN,GAAA,GAAAuuC,EAAAz6B,QAAA9U,MAAA,MAAArB,KAIA,QAHAqB,EAAA8U,EAAA9U,aAAA8U,GAAA9U,KAGAuvC,GAAAvvC,EAAAuvC,EAAAvvC,aAAAuvC,GAAAvvC,KAAArB,MAGA4E,GAGAvD,EAAAuD,EAAAqB,GAAA5E,QAAAuD,GAAAqB,IAGAkQ,EAAAvR,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,KACAuR,KAAAvR,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,MACAuR,EAAA9S,SACAquE,IAAAz8D,GAAAkB,EACAnW,KAAAkK,MAAAiM,GAGAnW,OAbAA,KAAAkK,MAAA7I,EAAArB,OAqBA2xE,GAAA,WACA,MAAA3xE,MAAAkK,OAGA0nE,GAAA,WACA,GAAA1pC,GAAA,CAIA,OAHAloC,MAAAoxE,MAAA,SAAAj7D,GACA,IAAAA,EAAA9S,OAAA,KAAA6kC,QAAgC/xB,IAAA9U,QAEhC6mC,GAGA2pC,GAAA,SAAAh/D,GACA,GAAAsQ,GAAA2qB,EAAA9Z,EAAAC,EAAAC,EAAAC,EAAAq9C,KAAAr7D,EAAAnW,KAAAkK,KAEA,KADAiM,GAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAn7D,EAAAnW,KAAA0xB,IAAA1xB,KAAA2xB,IAAA3xB,KAAA4xB,IAAA5xB,KAAA6xB,MACA1O,EAAAquD,EAAArmE,OACA,IAAA0H,EAAAsD,EAAAgN,EAAAhN,KAAA6d,EAAA7Q,EAAA6Q,GAAAC,EAAA9Q,EAAA8Q,GAAAC,EAAA/Q,EAAA+Q,GAAAC,EAAAhR,EAAAgR,KAAAhe,EAAA9S,OAAA,CACA,GAAAswB,IAAAK,EAAAE,GAAA,EAAAN,GAAAK,EAAAE,GAAA,GACA2Z,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAAna,EAAAC,EAAAM,EAAAC,KACA2Z,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAA9Z,EAAAJ,EAAAD,EAAAQ,KACA2Z,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAAna,EAAAM,EAAAC,EAAAN,KACAka,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAA9Z,EAAAC,EAAAN,EAAAC,IAGA,MAAA5zB,OAGA8xE,GAAA,SAAAj/D,GACA,GAAAsQ,GAAAquD,KAAAnwE,IAEA,KADArB,KAAAkK,OAAAsnE,EAAAppE,KAAA,GAAAkpE,IAAAtxE,KAAAkK,MAAAlK,KAAA0xB,IAAA1xB,KAAA2xB,IAAA3xB,KAAA4xB,IAAA5xB,KAAA6xB,MACA1O,EAAAquD,EAAArmE,OAAA,CACA,GAAAgL,GAAAgN,EAAAhN,IACA,IAAAA,EAAA9S,OAAA,CACA,GAAAyqC,GAAA9Z,EAAA7Q,EAAA6Q,GAAAC,EAAA9Q,EAAA8Q,GAAAC,EAAA/Q,EAAA+Q,GAAAC,EAAAhR,EAAAgR,GAAAR,GAAAK,EAAAE,GAAA,EAAAN,GAAAK,EAAAE,GAAA,GACA2Z,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAA9Z,EAAAC,EAAAN,EAAAC,KACAka,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAAna,EAAAM,EAAAC,EAAAN,KACAka,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAA9Z,EAAAJ,EAAAD,EAAAQ,KACA2Z,EAAA33B,EAAA,KAAAq7D,EAAAppE,KAAA,GAAAkpE,IAAAxjC,EAAAna,EAAAC,EAAAM,EAAAC,IAEA9yB,EAAA+G,KAAA+a,GAEA,KAAAA,EAAA9hB,EAAA8J,OACA0H,EAAAsQ,EAAAhN,KAAAgN,EAAA6Q,GAAA7Q,EAAA8Q,GAAA9Q,EAAA+Q,GAAA/Q,EAAAgR,GAEA,OAAAn0B,OAOA+xE,GAAA,SAAAvgE,GACA,MAAApO,WAAAC,QAAArD,KAAAo0B,GAAA5iB,EAAAxR,WAAAo0B,IAOA49C,GAAA,SAAAxgE,GACA,MAAApO,WAAAC,QAAArD,KAAAq0B,GAAA7iB,EAAAxR,WAAAq0B,IAwBA49C,GAAAp9C,GAAA10B,UAAA40B,GAAA50B,SAEA8xE,IAAA1oE,KAAA,WACA,GAEAurB,GACAgZ,EAHAvkC,EAAA,GAAAwrB,IAAA/0B,KAAAo0B,GAAAp0B,KAAAq0B,GAAAr0B,KAAA0xB,IAAA1xB,KAAA2xB,IAAA3xB,KAAA4xB,IAAA5xB,KAAA6xB,KACA1b,EAAAnW,KAAAkK,KAIA,KAAAiM,EAAA,MAAA5M,EAEA,KAAA4M,EAAA9S,OAAA,MAAAkG,GAAAW,MAAA+qB,GAAA9e,GAAA5M,CAGA,KADAurB,IAAYv0B,OAAA4V,EAAA0F,OAAAtS,EAAAW,MAAA,GAAAwB,OAAA,KACZyK,EAAA2e,EAAA3pB,OACA,OAAAlF,GAAA,EAAmBA,EAAA,IAAOA,GAC1B6nC,EAAA33B,EAAA5V,OAAA0F,MACA6nC,EAAAzqC,OAAAyxB,EAAA1sB,MAAsC7H,OAAAutC,EAAAjyB,OAAA1F,EAAA0F,OAAA5V,GAAA,GAAAyF,OAAA,KACtCyK,EAAA0F,OAAA5V,GAAAgvB,GAAA6Y,GAKA,OAAAvkC,IAGA0oE,GAAAnxE,IAAAmwE,GACAgB,GAAA39C,UACA29C,GAAAx9C,MAAAy8C,GACAe,GAAAriE,KAAAuhE,GACAc,GAAAtlD,OAAA0kD,GACAY,GAAA78C,KAAAm8C,GACAU,GAAApqE,OAAA4pE,GACAQ,GAAAv9C,aACAu9C,GAAAzwE,KAAAmwE,GACAM,GAAA/pC,KAAA0pC,GACAK,GAAAb,MAAAS,GACAI,GAAAC,WAAAJ,GACAG,GAAAtmE,EAAAomE,GACAE,GAAAlkE,EAAAikE,EAUA,IA+kBAG,IA/kBAC,GAAA,SAAAngD,GAQA,QAAA2+C,KAoBA,QAAA5rE,GAAAqtE,EAAAr+C,EAAAC,EAAAC,EAAAC,GACA,GAAAvkB,GAAAyiE,EAAAziE,KAAA0iE,EAAAD,EAAAz0D,IAAA20D,EAAAD,CACA,MAAA1iE,EAiBA,MAAAokB,GAAA6hC,EAAAj4C,GAAAsW,EAAA2hC,EAAAj4C,GAAAqW,EAAAu+C,EAAA50D,GAAAuW,EAAAq+C,EAAA50D,CAhBA,IAAAhO,EAAAhI,MAAAuO,EAAAvO,MAAA,CACA,GAAA+D,GAAAkqD,EAAAjmD,EAAAjE,EAAAiE,EAAAslB,GACAnnB,EAAAykE,EAAA5iE,EAAA7B,EAAA6B,EAAAulB,GACAhX,EAAAxS,IAAAoC,GACAoQ,GAAAP,MACA,IAAAjS,MAAAqlE,KAAA7yD,GAAAxS,KACA,IAAAoC,MAAAijE,KAAA7yD,GAAApQ,KACAoQ,GAAAP,GAAAO,EAAApR,KAAAiT,KAAA7B,OAAAs0D,EACAt8D,EAAA+e,KAAAvpB,GAAAwS,IAAAP,GAAA00D,OAAAI,EAAAJ,IACAn8D,EAAAgf,KAAApnB,GAAAoQ,GAAAP,EACAhO,EAAAslB,IAAAvpB,GAAAiS,EAAA,EAAAA,GACAhO,EAAAulB,IAAApnB,EAAA6P,KAzBA,OARA3X,GACAytB,EACAvd,EACA0/C,EACA2c,EACAD,EACAG,EANA1gE,EAAA8iB,EAAAzxB,OAQAqN,EAAA,EAAmBA,EAAAiiE,IAAgBjiE,EAEnC,IADAgjB,EAAAmB,GAAAC,EAAAnpB,GAAAoC,IAAAmkE,WAAAU,GACA3sE,EAAA,EAAiBA,EAAA+L,IAAO/L,EACxBkQ,EAAA2e,EAAA7uB,GACAssE,EAAAM,EAAA18D,EAAAvO,OAAA8qE,EAAAH,IACA1c,EAAA1/C,EAAAxK,EAAAwK,EAAA+e,GACAs9C,EAAAr8D,EAAApI,EAAAoI,EAAAgf,GACAzB,EAAA09C,MAAApsE,GA2BA,QAAA4tE,GAAAP,GACA,GAAAA,EAAAziE,KAAA,MAAAyiE,GAAAz0D,EAAAi1D,EAAAR,EAAAziE,KAAAhI,MACA,QAAA3B,GAAAosE,EAAAz0D,EAAA,EAA4B3X,EAAA,IAAOA,EACnCosE,EAAApsE,IAAAosE,EAAApsE,GAAA2X,EAAAy0D,EAAAz0D,IACAy0D,EAAAz0D,EAAAy0D,EAAApsE,GAAA2X,GAKA,QAAA2P,KACA,GAAAuH,EAAA,CACA,GAAA7uB,GAAAkQ,EAAAnE,EAAA8iB,EAAAzxB,MAEA,KADAwvE,EAAA,GAAAnnE,OAAAsG,GACA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EAAAkQ,EAAA2e,EAAA7uB,GAAA4sE,EAAA18D,EAAAvO,QAAAqqB,EAAA9b,EAAAlQ,EAAA6uB,IA/DtB,GAAAA,GACA+9C,EACAJ,EAAA,EACAE,EAAA,CAgFA,OA9EA,kBAAA1gD,OAAA8+C,GAAA,MAAA9+C,EAAA,GAAAA,IA6DA2+C,EAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,EACA+b,KAGAqjD,EAAA+B,WAAA,SAAAnhE,GACA,MAAApO,WAAAC,QAAAsvE,GAAAnhE,EAAAo/D,GAAA+B,GAGA/B,EAAA6B,SAAA,SAAAjhE,GACA,MAAApO,WAAAC,QAAAovE,GAAAjhE,EAAAo/D,GAAA6B,GAGA7B,EAAA3+C,OAAA,SAAAzgB,GACA,MAAApO,WAAAC,QAAA4uB,EAAA,kBAAAzgB,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAA3+C,GAGA2+C,GAaAjoB,GAAA,SAAAmqB,GAaA,QAAAC,GAAApqB,GACA,SAAA57C,KAAAuR,IAAA9S,EAAAm9C,EAAApoD,OAAAqH,OAAA4D,EAAAm9C,EAAA9sC,OAAAjU,QAGA,QAAAgpE,GAAAv9B,GACA,OAAA3iC,GAAA,EAAAsB,EAAA8gE,EAAAzvE,OAAqCqN,EAAAiiE,IAAgBjiE,EACrD,OAAAi4C,GAAApoD,EAAAsb,EAAAlQ,EAAAoC,EAAAoQ,EAAA7b,EAAA2D,EAAA,EAAuDA,EAAA+L,IAAO/L,EAC9D0iD,EAAAmqB,EAAA7sE,GAAA1F,EAAAooD,EAAApoD,OAAAsb,EAAA8sC,EAAA9sC,OACAlQ,EAAAkQ,EAAAlQ,EAAAkQ,EAAAqZ,GAAA30B,EAAAoL,EAAApL,EAAA20B,IAAA87C,KACAjjE,EAAA8N,EAAA9N,EAAA8N,EAAAsZ,GAAA50B,EAAAwN,EAAAxN,EAAA40B,IAAA67C,KACA7yD,EAAApR,KAAAiT,KAAArU,IAAAoC,KACAoQ,KAAA60D,EAAA/sE,IAAAkY,EAAAk1B,EAAA4/B,EAAAhtE,GACA0F,GAAAwS,EAAApQ,GAAAoQ,EACAtC,EAAAqZ,IAAAvpB,GAAArJ,EAAA4wE,EAAAjtE,IACA4V,EAAAsZ,IAAApnB,EAAAzL,EACA/B,EAAA20B,IAAAvpB,GAAArJ,EAAA,EAAAA,GACA/B,EAAA40B,IAAApnB,EAAAzL,EAKA,QAAAirB,KACA,GAAAuH,EAAA,CAEA,GAAA7uB,GAIA0iD,EAHA32C,EAAA8iB,EAAAzxB,OACA6R,EAAA49D,EAAAzvE,OACAgyB,EAAA9C,GAAAuC,EAAAhZ,EAGA,KAAA7V,EAAA,EAAAuF,EAAA,GAAAE,OAAAsG,GAAqC/L,EAAAiP,IAAOjP,EAC5C0iD,EAAAmqB,EAAA7sE,GAAA0iD,EAAA/gD,MAAA3B,EACA,gBAAA0iD,GAAApoD,SAAAooD,EAAApoD,OAAA60B,GAAAC,EAAAszB,EAAApoD,SACA,gBAAAooD,GAAA9sC,SAAA8sC,EAAA9sC,OAAAuZ,GAAAC,EAAAszB,EAAA9sC,SACArQ,EAAAm9C,EAAApoD,OAAAqH,QAAA4D,EAAAm9C,EAAApoD,OAAAqH,QAAA,KACA4D,EAAAm9C,EAAA9sC,OAAAjU,QAAA4D,EAAAm9C,EAAA9sC,OAAAjU,QAAA,IAGA,KAAA3B,EAAA,EAAAitE,EAAA,GAAAxnE,OAAAwJ,GAAoCjP,EAAAiP,IAAOjP,EAC3C0iD,EAAAmqB,EAAA7sE,GAAAitE,EAAAjtE,GAAAuF,EAAAm9C,EAAApoD,OAAAqH,QAAA4D,EAAAm9C,EAAApoD,OAAAqH,OAAA4D,EAAAm9C,EAAA9sC,OAAAjU,OAGAqrE,GAAA,GAAAvnE,OAAAwJ,GAAAi+D,IACAH,EAAA,GAAAtnE,OAAAwJ,GAAAk+D,KAGA,QAAAD,KACA,GAAAr+C,EAEA,OAAA7uB,GAAA,EAAA+L,EAAA8gE,EAAAzvE,OAAqC4C,EAAA+L,IAAO/L,EAC5CgtE,EAAAhtE,IAAAwsE,EAAAK,EAAA7sE,KAAA6sE,GAIA,QAAAM,KACA,GAAAt+C,EAEA,OAAA7uB,GAAA,EAAA+L,EAAA8gE,EAAAzvE,OAAqC4C,EAAA+L,IAAO/L,EAC5C+sE,EAAA/sE,IAAAw8B,EAAAqwC,EAAA7sE,KAAA6sE,GAtEA,GAEAG,GAEAD,EACAl+C,EACAtpB,EACA0nE,EAPAp3D,EAAAlU,GACA6qE,EAAAM,EAEAtwC,EAAAsuC,GAAA,IAKA4B,EAAA,CA2FA,OAzFA,OAAAG,UAgEAlC,EAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,EACA+b,KAGAqjD,EAAAkC,MAAA,SAAAthE,GACA,MAAApO,WAAAC,QAAAyvE,EAAAthE,EAAA+b,IAAAqjD,GAAAkC,GAGAlC,EAAA90D,GAAA,SAAAtK,GACA,MAAApO,WAAAC,QAAAyY,EAAAtK,EAAAo/D,GAAA90D,GAGA80D,EAAA+B,WAAA,SAAAnhE,GACA,MAAApO,WAAAC,QAAAsvE,GAAAnhE,EAAAo/D,GAAA+B,GAGA/B,EAAA6B,SAAA,SAAAjhE,GACA,MAAApO,WAAAC,QAAAovE,EAAA,kBAAAjhE,KAAAu/D,IAAAv/D,GAAA2hE,IAAAvC,GAAA6B,GAGA7B,EAAAnuC,SAAA,SAAAjxB,GACA,MAAApO,WAAAC,QAAAo/B,EAAA,kBAAAjxB,KAAAu/D,IAAAv/D,GAAA4hE,IAAAxC,GAAAnuC,GAGAmuC,GAWAyC,GAAA,GACAC,GAAAvmE,KAAAo5D,IAAA,EAAAp5D,KAAAiT,KAAA,IAEAuzD,GAAA,SAAAz+C,GAaA,QAAAhoB,KACA+C,IACAuE,EAAAvT,KAAA,OAAA0yE,GACAlgC,EAAAmgC,IACAC,EAAA5mE,OACAuH,EAAAvT,KAAA,MAAA0yE,IAIA,QAAA1jE,KACA,GAAA5J,GAAAkQ,EAAAnE,EAAA8iB,EAAAzxB,MAQA,KANAgwC,IAAAqgC,EAAArgC,GAAAsgC,EAEAC,EAAAriE,KAAA,SAAAq/D,GACAA,EAAAv9B,KAGAptC,EAAA,EAAeA,EAAA+L,IAAO/L,EACtBkQ,EAAA2e,EAAA7uB,GACA,MAAAkQ,EAAAo4C,GAAAp4C,EAAAxK,GAAAwK,EAAA+e,IAAA2+C,GACA19D,EAAAxK,EAAAwK,EAAAo4C,GAAAp4C,EAAA+e,GAAA,GACA,MAAA/e,EAAA+1B,GAAA/1B,EAAApI,GAAAoI,EAAAgf,IAAA0+C,GACA19D,EAAApI,EAAAoI,EAAA+1B,GAAA/1B,EAAAgf,GAAA,GAIA,QAAA2+C,KACA,OAAA39D,GAAAlQ,EAAA,EAAA+L,EAAA8iB,EAAAzxB,OAA2C4C,EAAA+L,IAAO/L,EAAA,CAElD,GADAkQ,EAAA2e,EAAA7uB,GAAAkQ,EAAAvO,MAAA3B,EACAob,MAAAlL,EAAAxK,IAAA0V,MAAAlL,EAAApI,GAAA,CACA,GAAAkkB,GAAAohD,GAAAtmE,KAAAiT,KAAA/Z,GAAAi1B,EAAAj1B,EAAAqtE,EACAn9D,GAAAxK,EAAAsmB,EAAAllB,KAAAgS,IAAAmc,GACA/kB,EAAApI,EAAAkkB,EAAAllB,KAAAiS,IAAAkc,IAEA7Z,MAAAlL,EAAA+e,KAAA7T,MAAAlL,EAAAgf,OACAhf,EAAA+e,GAAA/e,EAAAgf,GAAA,IAKA,QAAA4+C,GAAAnD,GAEA,MADAA,GAAArjD,YAAAqjD,EAAArjD,WAAAuH,GACA87C,EAvDA,GAAA2C,GACAlgC,EAAA,EACAmgC,EAAA,KACAG,EAAA,EAAA5mE,KAAAM,IAAAmmE,EAAA,OACAE,EAAA,EACAG,EAAA,GACAD,EAAArhD,KACAkhD,EAAA1uD,GAAAjY,GACAsH,EAAA9I,EAAA,aAoDA,OAlDA,OAAAwpB,UAgDAg/C,IAEAP,GACA1jE,OAEAqV,QAAA,WACA,MAAAuuD,GAAAvuD,QAAApY,GAAAymE,GAGA1mE,KAAA,WACA,MAAA4mE,GAAA5mE,OAAA0mE,GAGAz+C,MAAA,SAAAtjB,GACA,MAAApO,WAAAC,QAAAyxB,EAAAtjB,EAAAsiE,IAAAF,EAAAriE,KAAAwiE,GAAAR,GAAAz+C,GAGAue,MAAA,SAAA7hC,GACA,MAAApO,WAAAC,QAAAgwC,GAAA7hC,EAAA+hE,GAAAlgC,GAGAmgC,SAAA,SAAAhiE,GACA,MAAApO,WAAAC,QAAAmwE,GAAAhiE,EAAA+hE,GAAAC,GAGAG,WAAA,SAAAniE,GACA,MAAApO,WAAAC,QAAAswE,GAAAniE,EAAA+hE,IAAAI,GAGAD,YAAA,SAAAliE,GACA,MAAApO,WAAAC,QAAAqwE,GAAAliE,EAAA+hE,GAAAG,GAGAG,cAAA,SAAAriE,GACA,MAAApO,WAAAC,QAAAwwE,EAAA,EAAAriE,EAAA+hE,GAAA,EAAAM,GAGAjD,MAAA,SAAAp+D,EAAAhB,GACA,MAAApO,WAAAC,OAAA,SAAAmO,EAAAoiE,EAAA/rE,OAAA2K,GAAAohE,EAAAhhE,IAAAJ,EAAAuhE,EAAAviE,IAAA+hE,GAAAK,EAAAlhE,IAAAF,IAGA4iB,KAAA,SAAAzpB,EAAAoC,EAAAkkB,GACA,GAEAjW,GACAC,EACA0sB,EACAxyB,EACA69D,EANA/tE,EAAA,EACA+L,EAAA8iB,EAAAzxB,MAUA,KAHA,MAAA4uB,IAAArM,IACAqM,KAEAhsB,EAAA,EAAiBA,EAAA+L,IAAO/L,EACxBkQ,EAAA2e,EAAA7uB,GACA+V,EAAArQ,EAAAwK,EAAAxK,EACAsQ,EAAAlO,EAAAoI,EAAApI,GACA46B,EAAA3sB,IAAAC,KACAgW,IAAA+hD,EAAA79D,EAAA8b,EAAA0W,EAGA,OAAAqrC,IAGAl/D,GAAA,SAAAtC,EAAAhB,GACA,MAAApO,WAAAC,OAAA,GAAA+Q,EAAAU,GAAAtC,EAAAhB,GAAA+hE,GAAAn/D,EAAAU,GAAAtC,MAKAyhE,GAAA,WAUA,QAAArD,GAAAp/D,GACA,GAAAvL,GAAA+L,EAAA8iB,EAAAzxB,OAAAqwB,EAAAmB,GAAAC,EAAAS,GAAAC,IAAA08C,WAAAgC,EACA,KAAA7gC,EAAA7hC,EAAAvL,EAAA,EAA0BA,EAAA+L,IAAO/L,EAAAkQ,EAAA2e,EAAA7uB,GAAAytB,EAAA09C,MAAApsE,GAGjC,QAAAuoB,KACA,GAAAuH,EAAA,CACA,GAAA7uB,GAAAkQ,EAAAnE,EAAA8iB,EAAAzxB,MAEA,KADA4vE,EAAA,GAAAvnE,OAAAsG,GACA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EAAAkQ,EAAA2e,EAAA7uB,GAAAgtE,EAAA98D,EAAAvO,QAAA6qE,EAAAt8D,EAAAlQ,EAAA6uB,IAGtB,QAAAo/C,GAAA7B,GACA,GAAAlvD,GAAAxQ,EAAAhH,EAAAoC,EAAA9H,EAAAwsE,EAAA,CAGA,IAAAJ,EAAAhvE,OAAA,CACA,IAAAsI,EAAAoC,EAAA9H,EAAA,EAAyBA,EAAA,IAAOA,GAChCkd,EAAAkvD,EAAApsE,MAAA0M,EAAAwQ,EAAAnhB,SACAywE,GAAA9/D,EAAAhH,GAAAgH,EAAAwQ,EAAAxX,EAAAoC,GAAA4E,EAAAwQ,EAAApV,EAGAskE,GAAA1mE,IAAA8mE,EACAJ,EAAAtkE,IAAA0kE,MAIA,CACAtvD,EAAAkvD,EACAlvD,EAAAxX,EAAAwX,EAAAvT,KAAAjE,EACAwX,EAAApV,EAAAoV,EAAAvT,KAAA7B,CACA,IAAA0kE,GAAAQ,EAAA9vD,EAAAvT,KAAAhI,aACAub,IAAA9hB,MAGAgxE,EAAArwE,MAAAywE,EAGA,QAAAztE,GAAAqtE,EAAAn+C,EAAA1iB,EAAAq3B,GACA,IAAAwpC,EAAArwE,MAAA,QAEA,IAAA2J,GAAA0mE,EAAA1mE,EAAAwK,EAAAxK,EACAoC,EAAAskE,EAAAtkE,EAAAoI,EAAApI,EACA4uB,EAAAkM,EAAA3U,EACA/V,EAAAxS,IAAAoC,GAIA,IAAA4uB,IAAAw3C,EAAAh2D,EAQA,MAPAA,GAAAi2D,IACA,IAAAzoE,MAAAqlE,KAAA7yD,GAAAxS,KACA,IAAAoC,MAAAijE,KAAA7yD,GAAApQ,KACAoQ,EAAAk2D,IAAAl2D,EAAApR,KAAAiT,KAAAq0D,EAAAl2D,IACAhI,EAAA+e,IAAAvpB,EAAA0mE,EAAArwE,MAAAqxC,EAAAl1B,EACAhI,EAAAgf,IAAApnB,EAAAskE,EAAArwE,MAAAqxC,EAAAl1B,IAEA,CAIA,MAAAk0D,EAAAhvE,QAAA8a,GAAAi2D,GAAA,EAGA/B,EAAAziE,OAAAuG,GAAAk8D,EAAAhxE,QACA,IAAAsK,MAAAqlE,KAAA7yD,GAAAxS,KACA,IAAAoC,MAAAijE,KAAA7yD,GAAApQ,KACAoQ,EAAAk2D,IAAAl2D,EAAApR,KAAAiT,KAAAq0D,EAAAl2D,IAGA,IAAAk0D,EAAAziE,OAAAuG,IACAwmB,EAAAs2C,EAAAZ,EAAAziE,KAAAhI,OAAAyrC,EAAAl1B,EACAhI,EAAA+e,IAAAvpB,EAAAgxB,EACAxmB,EAAAgf,IAAApnB,EAAA4uB,SACK01C,IAAAhxE,OAlFL,GAAAyzB,GACA3e,EACAk9B,EAEA4/B,EADAR,EAAA1B,IAAA,IAEAsD,EAAA,EACAD,EAAAxuD,IACAuuD,EAAA,GAmGA,OArBAvD,GAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,EACA+b,KAGAqjD,EAAA6B,SAAA,SAAAjhE,GACA,MAAApO,WAAAC,QAAAovE,EAAA,kBAAAjhE,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAA6B,GAGA7B,EAAA0D,YAAA,SAAA9iE,GACA,MAAApO,WAAAC,QAAAgxE,EAAA7iE,IAAAo/D,GAAA7jE,KAAAiT,KAAAq0D,IAGAzD,EAAA2D,YAAA,SAAA/iE,GACA,MAAApO,WAAAC,QAAA+wE,EAAA5iE,IAAAo/D,GAAA7jE,KAAAiT,KAAAo0D,IAGAxD,EAAA1mC,MAAA,SAAA14B,GACA,MAAApO,WAAAC,QAAA8wE,EAAA3iE,IAAAo/D,GAAA7jE,KAAAiT,KAAAm0D,IAGAvD,GAGA4D,GAAA,SAAA7oE,GAQA,QAAAilE,GAAAv9B,GACA,OAAAl9B,GAAAlQ,EAAA,EAAA+L,EAAA8iB,EAAAzxB,OAA2C4C,EAAA+L,IAAO/L,EAClDkQ,EAAA2e,EAAA7uB,GAAAkQ,EAAA+e,KAAAX,EAAAtuB,GAAAkQ,EAAAxK,GAAAsnE,EAAAhtE,GAAAotC,EAIA,QAAA9lB,KACA,GAAAuH,EAAA,CACA,GAAA7uB,GAAA+L,EAAA8iB,EAAAzxB,MAGA,KAFA4vE,EAAA,GAAAvnE,OAAAsG,GACAuiB,EAAA,GAAA7oB,OAAAsG,GACA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EACtBgtE,EAAAhtE,GAAAob,MAAAkT,EAAAtuB,IAAA0F,EAAAmpB,EAAA7uB,KAAA6uB,IAAA,GAAA29C,EAAA39C,EAAA7uB,KAAA6uB,IAnBA,GACAA,GACAm+C,EACA1+C,EAHAk+C,EAAA1B,GAAA,GAoCA,OA/BA,kBAAAplE,OAAAolE,GAAA,MAAAplE,EAAA,GAAAA,IAkBAilE,EAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,EACA+b,KAGAqjD,EAAA6B,SAAA,SAAAjhE,GACA,MAAApO,WAAAC,QAAAovE,EAAA,kBAAAjhE,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAA6B,GAGA7B,EAAAjlE,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAAsI,EAAA,kBAAA6F,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAAjlE,GAGAilE,GAGA6D,GAAA,SAAA1mE,GAQA,QAAA6iE,GAAAv9B,GACA,OAAAl9B,GAAAlQ,EAAA,EAAA+L,EAAA8iB,EAAAzxB,OAA2C4C,EAAA+L,IAAO/L,EAClDkQ,EAAA2e,EAAA7uB,GAAAkQ,EAAAgf,KAAAX,EAAAvuB,GAAAkQ,EAAApI,GAAAklE,EAAAhtE,GAAAotC,EAIA,QAAA9lB,KACA,GAAAuH,EAAA,CACA,GAAA7uB,GAAA+L,EAAA8iB,EAAAzxB,MAGA,KAFA4vE,EAAA,GAAAvnE,OAAAsG,GACAwiB,EAAA,GAAA9oB,OAAAsG,GACA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EACtBgtE,EAAAhtE,GAAAob,MAAAmT,EAAAvuB,IAAA8H,EAAA+mB,EAAA7uB,KAAA6uB,IAAA,GAAA29C,EAAA39C,EAAA7uB,KAAA6uB,IAnBA,GACAA,GACAm+C,EACAz+C,EAHAi+C,EAAA1B,GAAA,GAoCA,OA/BA,kBAAAhjE,OAAAgjE,GAAA,MAAAhjE,EAAA,GAAAA,IAkBA6iE,EAAArjD,WAAA,SAAA/b,GACAsjB,EAAAtjB,EACA+b,KAGAqjD,EAAA6B,SAAA,SAAAjhE,GACA,MAAApO,WAAAC,QAAAovE,EAAA,kBAAAjhE,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAA6B,GAGA7B,EAAA7iE,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA0K,EAAA,kBAAAyD,KAAAu/D,IAAAv/D,GAAA+b,IAAAqjD,GAAA7iE,GAGA6iE,GAMA8D,GAAA,SAAA/oE,EAAAlJ,GACA,IAAAwD,GAAA0F,EAAAlJ,EAAAkJ,EAAAgpE,cAAAlyE,EAAA,GAAAkJ,EAAAgpE,iBAAAhsE,QAAA,mBACA,IAAA1C,GAAA2uE,EAAAjpE,EAAAnC,MAAA,EAAAvD,EAIA,QACA2uE,EAAAvxE,OAAA,EAAAuxE,EAAA,GAAAA,EAAAprE,MAAA,GAAAorE,GACAjpE,EAAAnC,MAAAvD,EAAA,KAIA4uE,GAAA,SAAAlpE,GACA,MAAAA,GAAA+oE,GAAA3nE,KAAAY,IAAAhC,QAAA,GAAAkL,KAGAi+D,GAAA,SAAAC,EAAAC,GACA,gBAAAhzE,EAAAuqB,GAOA,IANA,GAAAtmB,GAAAjE,EAAAqB,OACA0O,KACAkD,EAAA,EACA4I,EAAAk3D,EAAA,GACA1xE,EAAA,EAEA4C,EAAA,GAAA4X,EAAA,IACAxa,EAAAwa,EAAA,EAAA0O,IAAA1O,EAAA9Q,KAAAC,IAAA,EAAAuf,EAAAlpB,IACA0O,EAAA3J,KAAApG,EAAAizE,UAAAhvE,GAAA4X,EAAA5X,EAAA4X,OACAxa,GAAAwa,EAAA,GAAA0O,KACA1O,EAAAk3D,EAAA9/D,KAAA,GAAA8/D,EAAA1xE,OAGA,OAAA0O,GAAA0xB,UAAAhgB,KAAAuxD,KAIAE,GAAA,SAAAC,GACA,gBAAAnzE,GACA,MAAAA,GAAAggD,QAAA,kBAAA/7C,GACA,MAAAkvE,IAAAlvE,OAKAmvE,GAAA,SAAAzpE,EAAAlJ,GACAkJ,IAAA0pE,YAAA5yE,EAEA6yE,GAAA,OAAA9hC,GAAAxhC,EAAArG,EAAAtI,OAAA4C,EAAA,EAAAstC,GAAA,EAAiDttC,EAAA+L,IAAO/L,EACxD,OAAA0F,EAAA1F,IACA,QAAAstC,EAAAC,EAAAvtC,CAA4B,MAC5B,aAAAstC,MAAAttC,GAAqCutC,EAAAvtC,CAAQ,MAC7C,cAAAqvE,EACA,SAAA/hC,EAAA,IAAAA,EAAA,GAIA,MAAAA,GAAA,EAAA5nC,EAAAnC,MAAA,EAAA+pC,GAAA5nC,EAAAnC,MAAAgqC,EAAA,GAAA7nC,GAKA4pE,GAAA,SAAA5pE,EAAAlJ,GACA,GAAAJ,GAAAqyE,GAAA/oE,EAAAlJ,EACA,KAAAJ,EAAA,MAAAsJ,GAAA,EACA,IAAAipE,GAAAvyE,EAAA,GACAg2C,EAAAh2C,EAAA,GACA4D,EAAAoyC,GAAA85B,GAAA,EAAAplE,KAAAC,KAAA,EAAAD,KAAAuR,IAAA,EAAAvR,KAAAG,MAAAmrC,EAAA,QACArmC,EAAA4iE,EAAAvxE,MACA,OAAA4C,KAAA+L,EAAA4iE,EACA3uE,EAAA+L,EAAA4iE,EAAA,GAAAlpE,OAAAzF,EAAA+L,EAAA,GAAAyR,KAAA,KACAxd,EAAA,EAAA2uE,EAAAprE,MAAA,EAAAvD,GAAA,IAAA2uE,EAAAprE,MAAAvD,GACA,QAAAyF,OAAA,EAAAzF,GAAAwd,KAAA,KAAAixD,GAAA/oE,EAAAoB,KAAAC,IAAA,EAAAvK,EAAAwD,EAAA,QAGAuvE,GAAA,SAAA7pE,EAAAlJ,GACA,GAAAJ,GAAAqyE,GAAA/oE,EAAAlJ,EACA,KAAAJ,EAAA,MAAAsJ,GAAA,EACA,IAAAipE,GAAAvyE,EAAA,GACAg2C,EAAAh2C,EAAA,EACA,OAAAg2C,GAAA,UAAA3sC,QAAA2sC,GAAA50B,KAAA,KAAAmxD,EACAA,EAAAvxE,OAAAg1C,EAAA,EAAAu8B,EAAAprE,MAAA,EAAA6uC,EAAA,OAAAu8B,EAAAprE,MAAA6uC,EAAA,GACAu8B,EAAA,GAAAlpE,OAAA2sC,EAAAu8B,EAAAvxE,OAAA,GAAAogB,KAAA,MAGA2S,IACAq/C,GAAAL,GACAt1B,IAAA,SAAAn0C,EAAAlJ,GAAuB,WAAAkJ,GAAA+pE,QAAAjzE,IACvBH,EAAA,SAAAqJ,GAAoB,MAAAoB,MAAAsB,MAAA1C,GAAAoI,SAAA,IACpBpB,EAAA,SAAAhH,GAAoB,MAAAA,GAAA,IACpBtJ,EAAA,SAAAsJ,GAAoB,MAAAoB,MAAAsB,MAAA1C,GAAAoI,SAAA,KACpB9L,EAAA,SAAA0D,EAAAlJ,GAAuB,MAAAkJ,GAAAgpE,cAAAlyE,IACvB8J,EAAA,SAAAZ,EAAAlJ,GAAuB,MAAAkJ,GAAA+pE,QAAAjzE,IACvBob,EAAA,SAAAlS,EAAAlJ,GAAuB,MAAAkJ,GAAA0pE,YAAA5yE,IACvBuS,EAAA,SAAArJ,GAAoB,MAAAoB,MAAAsB,MAAA1C,GAAAoI,SAAA,IACpBtR,EAAA,SAAAkJ,EAAAlJ,GAAuB,MAAA+yE,IAAA,IAAA7pE,EAAAlJ,IACvBmb,EAAA43D,GACAt3D,EAAAq3D,GACAtoD,EAAA,SAAAthB,GAAoB,MAAAoB,MAAAsB,MAAA1C,GAAAoI,SAAA,IAAA4hE,eACpBhqE,EAAA,SAAAA,GAAoB,MAAAoB,MAAAsB,MAAA1C,GAAAoI,SAAA,MAIpB8hB,GAAA,uEAMAJ,IAAAt1B,UAAAw1B,GAAAx1B,UAoCAw1B,GAAAx1B,UAAA4T,SAAA,WACA,MAAA/T,MAAA81B,KACA91B,KAAA+1B,MACA/1B,KAAAg2B,KACAh2B,KAAAi2B,QACAj2B,KAAA4hB,KAAA,SACA,MAAA5hB,KAAAusB,MAAA,GAAAxf,KAAAC,IAAA,IAAAhN,KAAAusB,SACAvsB,KAAAk2B,MAAA,SACA,MAAAl2B,KAAAm2B,UAAA,OAAAppB,KAAAC,IAAA,IAAAhN,KAAAm2B,YACAn2B,KAAAyS,KAGA,IA6HA6jB,IA7HAs/C,GAAA,SAAAjqE,GACA,MAAAA,IAGAkqE,IAAA,oEAEAt/C,GAAA,SAAA0kB,GAOA,QAAAC,GAAAxlB,GAgCA,QAAA3mB,GAAA/M,GACA,GAEAiE,GAAA+L,EAAAW,EAFAmjE,EAAAtf,EACAuf,EAAAC,CAGA,UAAAvjE,EACAsjE,EAAAE,EAAAj0E,GAAA+zE,EACA/zE,EAAA,OACO,CACPA,IAGA,IAAAk0E,GAAAl0E,EAAA,CAYA,IAXAA,EAAAi0E,EAAAlpE,KAAAY,IAAA3L,GAAAm0B,GAGA+/C,GAAA,IAAAl0E,IAAAk0E,GAAA,GAGAJ,GAAAI,EAAA,MAAAlgD,IAAA,UAAAA,GAAA,MAAAA,EAAA,GAAAA,GAAA8/C,EACAC,KAAA,MAAAtjE,EAAAojE,GAAA,EAAA1D,GAAA,QAAA+D,GAAA,MAAAlgD,EAAA,QAIAmgD,EAEA,IADAlwE,GAAA,EAAA+L,EAAAhQ,EAAAqB,SACA4C,EAAA+L,GACA,OAAAW,EAAA3Q,EAAAq5C,WAAAp1C,KAAA0M,EAAA,IACAojE,GAAA,KAAApjE,EAAAyjE,EAAAp0E,EAAAwH,MAAAvD,EAAA,GAAAjE,EAAAwH,MAAAvD,IAAA8vE,EACA/zE,IAAAwH,MAAA,EAAAvD,EACA,QAOAiwB,IAAAtU,IAAA5f,EAAAkS,EAAAlS,EAAA4jB,KAGA,IAAAviB,GAAAyyE,EAAAzyE,OAAArB,EAAAqB,OAAA0yE,EAAA1yE,OACAquC,EAAAruC,EAAAkpB,EAAA,GAAA7gB,OAAA6gB,EAAAlpB,EAAA,GAAAogB,KAAAqS,GAAA,EAMA,QAHAI,GAAAtU,IAAA5f,EAAAkS,EAAAw9B,EAAA1vC,EAAA0vC,EAAAruC,OAAAkpB,EAAAwpD,EAAA1yE,OAAAuiB,KAAA8rB,EAAA,IAGA3b,GACA,QAAA/zB,EAAA8zE,EAAA9zE,EAAA+zE,EAAArkC,CAAsE,MACtE,SAAA1vC,EAAA8zE,EAAApkC,EAAA1vC,EAAA+zE,CAAsE,MACtE,SAAA/zE,EAAA0vC,EAAAloC,MAAA,EAAAnG,EAAAquC,EAAAruC,QAAA,GAAAyyE,EAAA9zE,EAAA+zE,EAAArkC,EAAAloC,MAAAnG,EAAqI,MACrI,SAAArB,EAAA0vC,EAAAokC,EAAA9zE,EAAA+zE,EAGA,MAAAZ,GAAAnzE,GArFA0zB,EAAAD,GAAAC,EAEA,IAAAI,GAAAJ,EAAAI,KACAC,EAAAL,EAAAK,MACAC,EAAAN,EAAAM,KACAC,EAAAP,EAAAO,OACArU,EAAA8T,EAAA9T,KACA2K,EAAAmJ,EAAAnJ,MACA2J,EAAAR,EAAAQ,MACAC,EAAAT,EAAAS,UACA1jB,EAAAijB,EAAAjjB,KAIA+jD,EAAA,MAAAvgC,EAAAogD,EAAA,SAAApgD,GAAA,SAAAqjB,KAAA7mC,GAAA,IAAAA,EAAAmK,cAAA,GACAo5D,EAAA,MAAA//C,EAAAogD,EAAA,UAAA/8B,KAAA7mC,GAAA6jE,EAAA,GAKAL,EAAA7/C,GAAA3jB,GACA0jE,GAAA1jE,GAAA,aAAA6mC,KAAA7mC,EAuEA,OAjEA0jB,GAAA,MAAAA,EAAA1jB,EAAA,KACA,SAAA6mC,KAAA7mC,GAAA1F,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,GAAA6X,IACAppB,KAAAC,IAAA,EAAAD,KAAAuR,IAAA,GAAA6X,IA2DApnB,EAAAgF,SAAA,WACA,MAAA2hB,GAAA,IAGA3mB,EAGA,QAAAynB,GAAAd,EAAA1zB,GACA,GAAAuK,GAAA2uC,GAAAxlB,EAAAD,GAAAC,KAAAjjB,KAAA,IAAAijB,IACAztB,EAAA,EAAA8E,KAAAC,KAAA,EAAAD,KAAAuR,IAAA,EAAAvR,KAAAG,MAAA2nE,GAAA7yE,GAAA,KACA0O,EAAA3D,KAAAM,IAAA,IAAApF,GACAuuD,EAAAqf,GAAA,EAAA5tE,EAAA,EACA,iBAAAjG,GACA,MAAAuK,GAAAmE,EAAA1O,GAAAw0D,GA5GA,GAAAtiD,GAAA+mC,EAAA85B,UAAA95B,EAAA+5B,UAAAF,GAAA75B,EAAA85B,SAAA95B,EAAA+5B,WAAAY,GACAS,EAAAp7B,EAAAo7B,SACAD,EAAAn7B,EAAAm7B,QACAjB,EAAAl6B,EAAAk6B,SAAAD,GAAAj6B,EAAAk6B,UAAAS,GACAU,EAAAr7B,EAAAq7B,SAAA,GA4GA,QACAvnE,OAAAmsC,EACA1kB,gBAQAH,KACA+/C,QAAA,IACApB,UAAA,IACAD,UAAA,GACAsB,UAAA,SAUA,IAAAE,IAAA,SAAAzpE,GACA,MAAAC,MAAAC,IAAA,GAAA6nE,GAAA9nE,KAAAY,IAAAb,MAGA0pE,GAAA,SAAA1pE,EAAA9K,GACA,MAAA+K,MAAAC,IAAA,IAAAD,KAAAC,KAAA,EAAAD,KAAAuR,IAAA,EAAAvR,KAAAG,MAAA2nE,GAAA7yE,GAAA,KAAA6yE,GAAA9nE,KAAAY,IAAAb,MAGA2pE,GAAA,SAAA3pE,EAAAE,GAEA,MADAF,GAAAC,KAAAY,IAAAb,GAAAE,EAAAD,KAAAY,IAAAX,GAAAF,EACAC,KAAAC,IAAA,EAAA6nE,GAAA7nE,GAAA6nE,GAAA/nE,IAAA,GAUA8pB,GAAA,WACA,UAAAH,IAOAA,IAAAt2B,WACAqC,YAAAi0B,GACAC,MAAA,WACA12B,KAAAke,EACAle,KAAA+R,EAAA,GAEAjR,IAAA,SAAAiN,GACA4oB,GAAA+/C,GAAA3oE,EAAA/N,KAAA+R,GACA4kB,GAAA32B,KAAA02E,GAAAx4D,EAAAle,KAAAke,GACAle,KAAAke,EAAAle,KAAA+R,GAAA2kE,GAAA3kE,EACA/R,KAAAke,EAAAw4D,GAAA3kE,GAEAu1D,QAAA,WACA,MAAAtnE,MAAAke,GAIA,IAwHAqa,IACAC,GACAI,GACAC,GACAG,GA+FAkB,GACAE,GACAD,GACAE,GACAQ,GACAW,GACAC,GACAlB,GAEAN,GACA5qB,GAqKA6sB,GACAU,GACAT,GACAC,GACAC,GACAQ,GACAC,GACAC,GACAW,GACAC,GACAC,GACAP,GACAC,GACAtJ,GACAC,GACAwI,GAzZAi6C,GAAA,GAAAjgD,IASAmF,GAAA,KAEA5E,GAAAjqB,KAAAo5D,GACAjvC,GAAAF,GAAA,EACA+B,GAAA/B,GAAA,EACA8G,GAAA,EAAA9G,GAEAgE,GAAA,IAAAhE,GACA2B,GAAA3B,GAAA,IAEArpB,GAAAZ,KAAAY,IACA45B,GAAAx6B,KAAAw6B,KACAznB,GAAA/S,KAAA+S,MACAgZ,GAAA/rB,KAAAgS,IACAskB,GAAAt2B,KAAAs2B,KACA1f,GAAA5W,KAAA4W,IAEAxW,GAAAJ,KAAAI,IACAE,GAAAN,KAAAM,IACA+pB,GAAArqB,KAAAiS,IACAgX,GAAAjpB,KAAAipB,MAAA,SAAArqB,GAAqC,MAAAA,GAAA,IAAAA,EAAA,QACrCqU,GAAAjT,KAAAiT,KACA4rB,GAAA7+B,KAAA6+B,IAsBA+qC,IACAC,QAAA,SAAApkD,EAAAgF,GACAF,GAAA9E,EAAA+E,SAAAC,IAEAq/C,kBAAA,SAAArkD,EAAAgF,GAEA,IADA,GAAAs/C,GAAAtkD,EAAAskD,SAAA7wE,GAAA,EAAA+L,EAAA8kE,EAAAzzE,SACA4C,EAAA+L,GAAAslB,GAAAw/C,EAAA7wE,GAAAsxB,SAAAC,KAIAC,IACAs/C,OAAA,SAAAvkD,EAAAgF,GACAA,EAAA8T,UAEA0rC,MAAA,SAAAxkD,EAAAgF,GACAhF,IAAAmF,YACAH,EAAAlJ,MAAAkE,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAykD,WAAA,SAAAzkD,EAAAgF,GAEA,IADA,GAAAG,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAAwgB,EAAAmF,EAAA1xB,GAAAuxB,EAAAlJ,MAAAkE,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEA0kD,WAAA,SAAA1kD,EAAAgF,GACAE,GAAAlF,EAAAmF,YAAAH,EAAA,IAEA2/C,gBAAA,SAAA3kD,EAAAgF,GAEA,IADA,GAAAG,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAA0lB,GAAAC,EAAA1xB,GAAAuxB,EAAA,IAEA4/C,QAAA,SAAA5kD,EAAAgF,GACAO,GAAAvF,EAAAmF,YAAAH,IAEA6/C,aAAA,SAAA7kD,EAAAgF,GAEA,IADA,GAAAG,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAA+lB,GAAAJ,EAAA1xB,GAAAuxB,IAEA8/C,mBAAA,SAAA9kD,EAAAgF,GAEA,IADA,GAAA+/C,GAAA/kD,EAAA+kD,WAAAtxE,GAAA,EAAA+L,EAAAulE,EAAAl0E,SACA4C,EAAA+L,GAAAslB,GAAAigD,EAAAtxE,GAAAuxB,KAkBAuQ,GAAA,SAAAvV,EAAAgF,GACAhF,GAAAmkD,GAAAj0E,eAAA8vB,EAAA/f,MACAkkE,GAAAnkD,EAAA/f,MAAA+f,EAAAgF,GAEAF,GAAA9E,EAAAgF,IAIA+B,GAAA3C,KAEA4gD,GAAA5gD,KAOAuB,IACA7J,MAAA+I,GACAQ,UAAAR,GACAS,QAAAT,GACAW,aAAA,WACAuB,GAAA7C,QACAyB,GAAAN,UAAAK,GACAC,GAAAL,QAAAO,IAEAJ,WAAA,WACA,GAAAw/C,IAAAl+C,EACAi+C,IAAA12E,IAAA22E,EAAA,EAAA35C,GAAA25C,KACAz3E,KAAA63B,UAAA73B,KAAA83B,QAAA93B,KAAAsuB,MAAA+I,IAEAiU,OAAA,WACAksC,GAAA12E,IAAAg9B,MAwCA45C,GAAA,SAAAllD,GAGA,MAFAglD,IAAA9gD,QACAqR,GAAAvV,EAAA2F,IACA,EAAAq/C,IA2CAj8C,GAAA3E,KAIAwE,IACA9M,MAAA0L,GACAnC,UAAAsD,GACArD,QAAAuD,GACArD,aAAA,WACAoD,GAAA9M,MAAAgN,GACAF,GAAAvD,UAAA6D,GACAN,GAAAtD,QAAA6D,GACAJ,GAAA7E,QACAyB,GAAAH,gBAEAC,WAAA,WACAE,GAAAF,aACAmD,GAAA9M,MAAA0L,GACAoB,GAAAvD,UAAAsD,GACAC,GAAAtD,QAAAuD,GACA9B,GAAA,GAAAW,KAAAC,GAAA,KAAAC,KAAAC,GAAA,KACAkB,GAAAK,GAAAvB,GAAA,GACAkB,IAAAK,KAAAxB,IAAA,IACA/qB,GAAA,GAAA6qB,GAAA7qB,GAAA,GAAA8qB,KA2GAw9C,GAAA,SAAAC,GACA,GAAA3xE,GAAA+L,EAAAtF,EAAApK,EAAAmzD,EAAAoiB,EAAAj9C,CAOA,IALAP,GAAAF,KAAAD,GAAAE,GAAAxU,KACAqU,MACA8N,GAAA6vC,EAAAx8C,IAGAppB,EAAAioB,GAAA52B,OAAA,CAIA,IAHA42B,GAAA2e,KAAA/c,IAGA51B,EAAA,EAAAyG,EAAAutB,GAAA,GAAAw7B,GAAA/oD,GAA4CzG,EAAA+L,IAAO/L,EACnD3D,EAAA23B,GAAAh0B,GACA61B,GAAApvB,EAAApK,EAAA,KAAAw5B,GAAApvB,EAAApK,EAAA,KACA44B,GAAAxuB,EAAA,GAAApK,EAAA,IAAA44B,GAAAxuB,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAApK,EAAA,IACA44B,GAAA54B,EAAA,GAAAoK,EAAA,IAAAwuB,GAAAxuB,EAAA,GAAAA,EAAA,MAAAA,EAAA,GAAApK,EAAA,KAEAmzD,EAAArtD,KAAAsE,EAAApK,EAMA,KAAAu1E,GAAAjyD,IAAA5T,EAAAyjD,EAAApyD,OAAA,EAAA4C,EAAA,EAAAyG,EAAA+oD,EAAAzjD,GAA2E/L,GAAA+L,EAAQtF,EAAApK,IAAA2D,EACnF3D,EAAAmzD,EAAAxvD,IACA20B,EAAAM,GAAAxuB,EAAA,GAAApK,EAAA,KAAAu1E,MAAAj9C,EAAAV,GAAA53B,EAAA,GAAA63B,GAAAztB,EAAA,IAMA,MAFAutB,IAAA5qB,GAAA,KAEA6qB,KAAAtU,KAAAwU,KAAAxU,MACA/O,sBACAqjB,GAAAE,KAAAD,GAAAE,MAoBAkC,IACA+O,OAAAjU,GACA/I,MAAAyN,GACAlE,UAAAyE,GACAxE,QAAAkF,GACAhF,aAAA,WACAuE,GAAA1E,UAAAoF,GACAV,GAAAzE,QAAAqF,IAEAlF,WAAA,WACAsE,GAAA1E,UAAAyE,GACAC,GAAAzE,QAAAkF,KA8FA86C,GAAA,SAAAtlD,GACA0J,GAAAU,GACAT,GAAAC,GAAAC,GACAQ,GAAAC,GAAAC,GACAW,GAAAC,GAAAC,GAAA,EACAmK,GAAAvV,EAAA+J,GAEA,IAAA5wB,GAAA+xB,GACA3vB,EAAA4vB,GACA1B,EAAA2B,GACA1oB,EAAAvJ,IAAAoC,IAAAkuB,GAGA,OAAA/mB,GAvgBA,QAwgBAvJ,EAAAkxB,GAAA9uB,EAAA+uB,GAAAb,EAAAc,GAEAH,GAAAhB,KAAAjwB,EAAAwwB,GAAApuB,EAAAquB,GAAAH,EAAAI,KACAnnB,EAAAvJ,IAAAoC,IAAAkuB,KA3gBA,QA6gBAplB,UAGAiJ,GAAA/R,EAAApC,GAAAqvB,GAAA/D,GAAAgF,EAAAjc,GAAA9K,IAAA8lB,KAGA+8C,GAAA,SAAApsE,GACA,kBACA,MAAAA,KAIAwyB,GAAA,SAAAzxB,EAAApK,GAEA,QAAA67B,GAAAxyB,EAAAoC,GACA,MAAApC,GAAAe,EAAAf,EAAAoC,GAAAzL,EAAAqJ,EAAA,GAAAA,EAAA,IAOA,MAJAe,GAAA8xB,QAAAl8B,EAAAk8B,SAAAL,EAAAK,OAAA,SAAA7yB,EAAAoC,GACA,OAAApC,EAAArJ,EAAAk8B,OAAA7yB,EAAAoC,KAAArB,EAAA8xB,OAAA7yB,EAAA,GAAAA,EAAA,MAGAwyB,EAOAN,IAAAW,OAAAX,EAsDA,IAwgBAkE,IACAC,GACAC,GAwRAkC,GACAE,GACAD,GACAE,GA4EAwB,GACAC,GACAX,GACAC,GAp3BA9G,GAAA,SAAAlb,GAGA,QAAA0nB,GAAApT,GAEA,MADAA,GAAAtU,EAAAsU,EAAA,GAAAgB,GAAAhB,EAAA,GAAAgB,IACAhB,EAAA,IAAAqD,GAAArD,EAAA,IAAAqD,GAAArD,EAQA,MAZAtU,GAAA0a,GAAA1a,EAAA,GAAAsV,GAAAtV,EAAA,GAAAsV,GAAAtV,EAAAhgB,OAAA,EAAAggB,EAAA,GAAAsV,GAAA,GAOAoS,EAAAvM,OAAA,SAAA7G,GAEA,MADAA,GAAAtU,EAAAmb,OAAA7G,EAAA,GAAAgB,GAAAhB,EAAA,GAAAgB,IACAhB,EAAA,IAAAqD,GAAArD,EAAA,IAAAqD,GAAArD,GAGAoT,GA+BA4F,GAAA,WAQA,QAAAriB,GAAA3iB,EAAAoC,GACAwyB,EAAAn4B,KAAAuD,EAAA0X,EAAA1X,EAAAoC,IACApC,EAAA,IAAAqvB,GAAArvB,EAAA,IAAAqvB,GAGA,QAAA2V,KACA,GAAAh+B,GAAAzE,EAAAlJ,MAAAhF,KAAAoD,WACAwa,EAAAqU,EAAAjtB,MAAAhF,KAAAoD,WAAAu1B,GACAl2B,EAAA0zB,EAAAnxB,MAAAhF,KAAAoD,WAAAu1B,EAMA,OALA4H,MACAld,EAAA0a,IAAAprB,EAAA,GAAAgmB,IAAAhmB,EAAA,GAAAgmB,GAAA,GAAA6F,OACAK,GAAArH,EAAA5Z,EAAAnb,EAAA,GACAkQ,GAASF,KAAA,UAAAklB,aAAA4I,IACTA,EAAAld,EAAA,KACA1Q,EArBA,GAGA4tB,GACAld,EAJAnV,EAAA6pE,IAAA,MACA9lD,EAAA8lD,GAAA,IACA5hD,EAAA4hD,GAAA,GAGAvgD,GAAgBlJ,QA+BhB,OAZAqiB,GAAAziC,OAAA,SAAAsD,GACA,MAAApO,WAAAC,QAAA6K,EAAA,kBAAAsD,KAAAumE,KAAAvmE,EAAA,IAAAA,EAAA,KAAAm/B,GAAAziC,GAGAyiC,EAAA1e,OAAA,SAAAzgB,GACA,MAAApO,WAAAC,QAAA4uB,EAAA,kBAAAzgB,KAAAumE,IAAAvmE,GAAAm/B,GAAA1e,GAGA0e,EAAAxa,UAAA,SAAA3kB,GACA,MAAApO,WAAAC,QAAA8yB,EAAA,kBAAA3kB,KAAAumE,IAAAvmE,GAAAm/B,GAAAxa,GAGAwa,GAGAjP,GAAA,WACA,GACArxB,GADA+yB,IAEA,QACA9U,MAAA,SAAA3iB,EAAAoC,GACAsC,EAAAjI,MAAAuD,EAAAoC,KAEA8pB,UAAA,WACAuL,EAAAh7B,KAAAiI,OAEAynB,QAAAT,GACAiK,OAAA,WACA8B,EAAA//B,OAAA,GAAA+/B,EAAAh7B,KAAAg7B,EAAAj4B,MAAA/D,OAAAg8B,EAAAiP,WAEA1sC,OAAA,WACA,GAAAA,GAAAy9B,CAGA,OAFAA,MACA/yB,EAAA,KACA1K,KAKA87B,GAAA,SAAA/0B,EAAApK,EAAA0xB,EAAAC,EAAAC,EAAAC,GACA,GAQAvW,GARAuyB,EAAAzjC,EAAA,GACA0jC,EAAA1jC,EAAA,GACAohD,EAAAxrD,EAAA,GACAyrD,EAAAzrD,EAAA,GACAmd,EAAA,EACAE,EAAA,EACA3D,EAAA8xC,EAAA3d,EACAl0B,EAAA8xC,EAAA3d,CAIA,IADAxyB,EAAAoW,EAAAmc,EACAn0B,KAAA4B,EAAA,IAEA,GADAA,GAAA5B,EACAA,EAAA,GACA,GAAA4B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,OACG,IAAA5B,EAAA,GACH,GAAA4B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,GAIA,GADAA,EAAAsW,EAAAic,EACAn0B,KAAA4B,EAAA,IAEA,GADAA,GAAA5B,EACAA,EAAA,GACA,GAAA4B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,OACG,IAAA5B,EAAA,GACH,GAAA4B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,GAIA,GADAA,EAAAqW,EAAAmc,EACAn0B,KAAA2B,EAAA,IAEA,GADAA,GAAA3B,EACAA,EAAA,GACA,GAAA2B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,OACG,IAAA3B,EAAA,GACH,GAAA2B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,GAIA,GADAA,EAAAuW,EAAAic,EACAn0B,KAAA2B,EAAA,IAEA,GADAA,GAAA3B,EACAA,EAAA,GACA,GAAA2B,EAAA+B,EAAA,MACA/B,GAAA6B,MAAA7B,OACG,IAAA3B,EAAA,GACH,GAAA2B,EAAA6B,EAAA,MACA7B,GAAA+B,MAAA/B,GAKA,MAFA6B,GAAA,IAAA/S,EAAA,GAAAyjC,EAAA1wB,EAAAzD,EAAAtP,EAAA,GAAA0jC,EAAA3wB,EAAAxD,GACA0D,EAAA,IAAArd,EAAA,GAAA6tC,EAAAxwB,EAAA3D,EAAA1Z,EAAA,GAAA8tC,EAAAzwB,EAAA1D,IACA,OAGA+7D,GAAA,SAAAtrE,EAAApK,GACA,MAAAqL,IAAAjB,EAAA,GAAApK,EAAA,IAAAs5B,IAAAjuB,GAAAjB,EAAA,GAAApK,EAAA,IAAAs5B,IAeAiF,GAAA,SAAAJ,EAAAV,EAAAY,EAAAlB,EAAAjI,GACA,GAEAvxB,GACA+L,EAHA5I,KACA0+B,IAwBA,IApBArH,EAAAr/B,QAAA,SAAA4lC,GACA,MAAAh1B,EAAAg1B,EAAA3jC,OAAA,QACA,GAAA2O,GAAArG,EAAA4uB,EAAAyM,EAAA,GAAAsiB,EAAAtiB,EAAAh1B,EAKA,IAAAgmE,GAAAz9C,EAAA+uB,GAAA,CAEA,IADA9xB,EAAAK,YACA5xB,EAAA,EAAiBA,EAAA+L,IAAO/L,EAAAuxB,EAAAlJ,OAAAiM,EAAAyM,EAAA/gC,IAAA,GAAAs0B,EAAA,GAExB,YADA/C,GAAAM,UAIA1uB,EAAAhB,KAAAuD,EAAA,GAAAuzB,IAAA3E,EAAAyM,EAAA,UACAc,EAAA1/B,KAAAuD,EAAAqJ,EAAA,GAAAkqB,IAAA3E,EAAA,KAAA5uB,GAAA,IACAvC,EAAAhB,KAAAuD,EAAA,GAAAuzB,IAAAoqB,EAAAtiB,EAAA,UACAc,EAAA1/B,KAAAuD,EAAAqJ,EAAA,GAAAkqB,IAAAoqB,EAAA,KAAA39C,GAAA,OAGAvC,EAAA/F,OAAA,CAMA,IAJAykC,EAAA8Q,KAAA7Y,GACAT,GAAAl2B,GACAk2B,GAAAwI,GAEA7hC,EAAA,EAAA+L,EAAA81B,EAAAzkC,OAA8B4C,EAAA+L,IAAO/L,EACrC6hC,EAAA7hC,GAAAgC,EAAA04B,IAOA,KAJA,GACAxB,GACA7Q,EAFA1hB,EAAAxD,EAAA,KAIA,CAIA,IAFA,GAAAkuD,GAAA1qD,EACAqrE,GAAA,EACA3gB,EAAA//C,GAAA,IAAA+/C,IAAAtlD,KAAApF,EAAA,MACAuyB,GAAAm4B,EAAAr7B,EACAzE,EAAAK,WACA,IAEA,GADAy/B,EAAA//C,EAAA+/C,EAAAtiD,EAAAuC,GAAA,EACA+/C,EAAArvD,EAAA,CACA,GAAAgwE,EACA,IAAAhyE,EAAA,EAAA+L,EAAAmtB,EAAA97B,OAAwC4C,EAAA+L,IAAO/L,EAAAuxB,EAAAlJ,SAAA6Q,EAAAl5B,IAAA,GAAAqoB,EAAA,QAE/CmR,GAAA63B,EAAA3rD,EAAA2rD,EAAAtlD,EAAArG,EAAA,EAAA6rB,EAEA8/B,KAAAtlD,MACO,CACP,GAAAimE,EAEA,IADA94C,EAAAm4B,EAAA70D,EAAAw5B,EACAh2B,EAAAk5B,EAAA97B,OAAA,EAAqC4C,GAAA,IAAQA,EAAAuxB,EAAAlJ,SAAA6Q,EAAAl5B,IAAA,GAAAqoB,EAAA,QAE7CmR,GAAA63B,EAAA3rD,EAAA2rD,EAAA70D,EAAAkJ,GAAA,EAAA6rB,EAEA8/B,KAAA70D,EAEA60D,IAAAtiD,EACAmqB,EAAAm4B,EAAAr7B,EACAg8C,YACK3gB,EAAA//C,EACLigB,GAAAM,aAmBA0J,GAAA,IACAD,IAAAC,GAmKA02C,GAAA,WACA,GAIAluC,GACAC,EACAnC,EANA9T,EAAA,EACAC,EAAA,EACAC,EAAA,IACAC,EAAA,GAKA,OAAA2T,IACAtQ,OAAA,SAAAA,GACA,MAAAwS,IAAAC,IAAAzS,EAAAwS,IAAAzK,GAAAvL,EAAAC,EAAAC,EAAAC,GAAA8V,EAAAzS,IAEA7K,OAAA,SAAAnb,GACA,MAAApO,WAAAC,QAAA2wB,GAAAxiB,EAAA,MAAAyiB,GAAAziB,EAAA,MAAA0iB,GAAA1iB,EAAA,MAAA2iB,GAAA3iB,EAAA,MAAAw4B,EAAAC,EAAA,KAAAnC,KAAA9T,EAAAC,IAAAC,EAAAC,OAKAgkD,GAAAvhD,KAEAiM,GAAA,SAAAxC,EAAA/R,GACA,GAAAmK,GAAAnK,EAAA,GACAoK,EAAApK,EAAA,GACAkM,GAAApD,GAAAqB,IAAAK,GAAAL,GAAA,GACAyC,EAAA,EACAkF,EAAA,CAEA+3C,IAAAzhD,OAEA,QAAAzwB,GAAA,EAAA+L,EAAAquB,EAAAh9B,OAAqC4C,EAAA+L,IAAO/L,EAC5C,GAAAiP,GAAAqrB,EAAAF,EAAAp6B,IAAA5C,OASA,OARAk9B,GACArrB,EACAwZ,EAAA6R,EAAArrB,EAAA,GACA0jB,EAAAlK,EAAA,GACA0L,EAAA1L,EAAA,KAAAqK,GACAC,EAAA5B,GAAAgD,GACAvB,EAAAC,GAAAsB,GAEAnlB,EAAA,EAAmBA,EAAAC,IAAOD,EAAA2jB,EAAAuB,EAAAnB,EAAAo/C,EAAAv/C,EAAAwO,EAAA3Y,EAAAT,EAAA,CAC1B,GAAAA,GAAAsS,EAAAtrB,GACAklB,EAAAlM,EAAA,GACAoM,EAAApM,EAAA,KAAA8K,GACAq/C,EAAAhhD,GAAAiD,GACAgN,EAAAvO,GAAAuB,GACAO,EAAAT,EAAAvB,EACAkC,EAAAF,GAAA,OACAy9C,EAAAv9C,EAAAF,EACAK,EAAAo9C,EAAArhD,GACAtmB,EAAAsoB,EAAAo/C,CAOA,IALAD,GAAAr3E,IAAAgf,GAAApP,EAAAoqB,EAAA1D,GAAAihD,GAAAx/C,EAAAwO,EAAA32B,EAAAooB,GAAAu/C,KACAn9C,GAAAD,EAAAL,EAAAE,EAAAgD,GAAAlD,EAIAK,EAAArC,GAAAH,EAAA0B,GAAA1B,EAAA,CACA,GAAAw3B,GAAAt2B,GAAAF,GAAA/K,GAAA+K,GAAAxL,GACA8L,IAAAk2B,EACA,IAAAqoB,GAAA3+C,GAAAa,EAAAy1B,EACAl2B,IAAAu+C,EACA,IAAAC,IAAAt9C,EAAAL,GAAA,QAAA3D,GAAAqhD,EAAA,KACA5/C,EAAA6/C,GAAA7/C,IAAA6/C,IAAAtoB,EAAA,IAAAA,EAAA,OACA7vB,GAAAnF,EAAAL,GAAA,SAiBA,OAAAM,GAAAU,IAAAV,EAAAU,IAAAu8C,IAAAv8C,IAAA,EAAAwE,GAGAiC,GAAAzL,KAKAgL,IACA0J,OAAAjU,GACA/I,MAAA+I,GACAQ,UAAA8J,GACA7J,QAAAT,GACAW,aAAAX,GACAY,WAAAZ,IAgCAmhD,GAAA,SAAAhmD,GAGA,MAFA6P,IAAA3L,QACAqR,GAAAvV,EAAAoP,KACAS,IAGA1K,IAAA,WACA8gD,IAAgBhmE,KAAA,aAAAklB,gBAEhB8K,GAAA,SAAA/1B,EAAApK,GAGA,MAFAq1B,IAAA,GAAAjrB,EACAirB,GAAA,GAAAr1B,EACAk2E,GAAAC,KAGAC,IACA9B,QAAA,SAAApkD,EAAAlE,GACA,MAAAgU,IAAA9P,EAAA+E,SAAAjJ,IAEAuoD,kBAAA,SAAArkD,EAAAlE,GAEA,IADA,GAAAwoD,GAAAtkD,EAAAskD,SAAA7wE,GAAA,EAAA+L,EAAA8kE,EAAAzzE,SACA4C,EAAA+L,GAAA,GAAAswB,GAAAw0C,EAAA7wE,GAAAsxB,SAAAjJ,GAAA,QACA,YAIAiU,IACAw0C,OAAA,WACA,UAEAC,MAAA,SAAAxkD,EAAAlE,GACA,MAAAkU,IAAAhQ,EAAAmF,YAAArJ,IAEA2oD,WAAA,SAAAzkD,EAAAlE,GAEA,IADA,GAAAqJ,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAA,GAAAwwB,GAAA7K,EAAA1xB,GAAAqoB,GAAA,QACA,WAEA4oD,WAAA,SAAA1kD,EAAAlE,GACA,MAAAoU,IAAAlQ,EAAAmF,YAAArJ,IAEA6oD,gBAAA,SAAA3kD,EAAAlE,GAEA,IADA,GAAAqJ,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAA,GAAA0wB,GAAA/K,EAAA1xB,GAAAqoB,GAAA,QACA,WAEA8oD,QAAA,SAAA5kD,EAAAlE,GACA,MAAAsU,IAAApQ,EAAAmF,YAAArJ,IAEA+oD,aAAA,SAAA7kD,EAAAlE,GAEA,IADA,GAAAqJ,GAAAnF,EAAAmF,YAAA1xB,GAAA,EAAA+L,EAAA2lB,EAAAt0B,SACA4C,EAAA+L,GAAA,GAAA4wB,GAAAjL,EAAA1xB,GAAAqoB,GAAA,QACA,WAEAgpD,mBAAA,SAAA9kD,EAAAlE,GAEA,IADA,GAAAipD,GAAA/kD,EAAA+kD,WAAAtxE,GAAA,EAAA+L,EAAAulE,EAAAl0E,SACA4C,EAAA+L,GAAA,GAAAswB,GAAAi1C,EAAAtxE,GAAAqoB,GAAA,QACA,YAiCAksC,GAAA,SAAAhoC,EAAAlE,GACA,OAAAkE,GAAAkmD,GAAAh2E,eAAA8vB,EAAA/f,MACAimE,GAAAlmD,EAAA/f,MACA6vB,IAAA9P,EAAAlE,IA0GAqqD,GAAA,SAAAjsE,EAAApK,GACA,GAAA0xB,GAAAtnB,EAAA,GAAAisB,GACA1E,EAAAvnB,EAAA,GAAAisB,GACAzE,EAAA5xB,EAAA,GAAAq2B,GACAxE,EAAA7xB,EAAA,GAAAq2B,GACAsT,EAAAnT,GAAA7E,GACAiX,EAAA9T,GAAAnD,GACAyzB,EAAA5uB,GAAA3E,GACAykD,EAAAxhD,GAAAjD,GACA0kD,EAAA5sC,EAAAnT,GAAA9E,GACA8kD,EAAA7sC,EAAA7U,GAAApD,GACA+kD,EAAArxB,EAAA5uB,GAAA5E,GACA8kD,EAAAtxB,EAAAtwB,GAAAlD,GACA7xB,EAAA,EAAA40B,GAAAjX,GAAAmX,GAAAhD,EAAAF,GAAAgY,EAAAyb,EAAAvwB,GAAAjD,EAAAF,KACAtjB,EAAA0mB,GAAA/0B,GAEAo9B,EAAAp9B,EAAA,SAAA0P,GACA,GAAA28B,GAAAtX,GAAArlB,GAAA1P,GAAAqO,EACAu/B,EAAA7Y,GAAA/0B,EAAA0P,GAAArB,EACA/E,EAAAskC,EAAA4oC,EAAAnqC,EAAAqqC,EACAhrE,EAAAkiC,EAAA6oC,EAAApqC,EAAAsqC,EACA/8C,EAAAgU,EAAA/E,EAAAwD,EAAAkqC,CACA,QACA94D,GAAA/R,EAAApC,GAAAqvB,GACAlb,GAAAmc,EAAAjc,GAAArU,IAAAoC,MAAAitB,KAEG,WACH,OAAAhH,EAAAgH,GAAA/G,EAAA+G,IAKA,OAFAyE,GAAAgD,SAAApgC,EAEAo9B,GAGA6K,GAAA,SAAA3+B,GACA,MAAAA,IAGAstE,GAAAriD,KACA2N,GAAA3N,KAMAoN,IACA1V,MAAA+I,GACAQ,UAAAR,GACAS,QAAAT,GACAW,aAAA,WACAgM,GAAAnM,UAAAkM,GACAC,GAAAlM,QAAA0M,IAEAvM,WAAA,WACA+L,GAAAnM,UAAAmM,GAAAlM,QAAAkM,GAAA1V,MAAA+I,GACA4hD,GAAAn4E,IAAA6M,GAAA42B,KACAA,GAAA7N,SAEA/wB,OAAA,WACA,GAAA+xE,GAAAuB,GAAA,CAEA,OADAA,IAAAviD,QACAghD,IAsBAhzC,GAAA9e,IACA+e,GAAAD,GACAxQ,IAAAwQ,GACAvQ,GAAAD,GAEA8T,IACA1Z,MAAAmW,GACA5M,UAAAR,GACAS,QAAAT,GACAW,aAAAX,GACAY,WAAAZ,GACA1xB,OAAA,WACA,GAAAgyE,KAAAjzC,GAAAC,KAAAzQ,GAAAC,IAEA,OADAD,IAAAC,KAAAwQ,GAAAD,GAAA9e,KACA+xD,IAaA9yC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAO,GAAA,EACAC,GAAA,EACAC,GAAA,EACAQ,GAAA,EACAC,GAAA,EACAC,GAAA,EAMAjB,IACA3W,MAAAsW,GACA/M,UAAAmN,GACAlN,QAAA2N,GACAzN,aAAA,WACAiN,GAAApN,UAAA6N,GACAT,GAAAnN,QAAA8N,IAEA3N,WAAA,WACAgN,GAAA3W,MAAAsW,GACAK,GAAApN,UAAAmN,GACAC,GAAAnN,QAAA2N,IAEA9/B,OAAA,WACA,GAAAmyE,GAAA5xC,IAAAF,GAAAE,GAAAD,GAAAC,IACAV,IAAAF,GAAAE,GAAAD,GAAAC,IACAT,IAAAF,GAAAE,GAAAD,GAAAC,KACAluB,QAIA,OAHAguB,IAAAC,GAAAC,GACAO,GAAAC,GAAAC,GACAQ,GAAAC,GAAAC,GAAA,EACA4xC,GAgEA3xC,IAAAhmC,WACA+4E,QAAA,IACAC,YAAA,SAAA3nE,GACA,MAAAxR,MAAAk5E,QAAA1nE,EAAAxR,MAEAg4B,aAAA,WACAh4B,KAAAo5E,MAAA,GAEAnhD,WAAA,WACAj4B,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,IAAA93B,KAAAo5E,OAAAp5E,KAAAuE,SAAA2oE,YACAltE,KAAAq5E,OAAAxiE,KAEAyX,MAAA,SAAA3iB,EAAAoC,GACA,OAAA/N,KAAAq5E,QACA,OACAr5E,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,GACA/N,KAAAq5E,OAAA,CACA,MAEA,QACAr5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,EACA,MAEA,SACA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAA3L,KAAAk5E,QAAAnrE,GACA/N,KAAAuE,SAAA0rD,IAAAtkD,EAAAoC,EAAA/N,KAAAk5E,QAAA,EAAAp7C,MAKAn4B,OAAA0xB,GAGA,IACAiiD,IACA/yC,GACAE,GACAD,GACAE,GALAC,GAAA/P,KAOAyP,IACA/X,MAAA+I,GACAQ,UAAA,WACAwO,GAAA/X,MAAA8X,IAEAtO,QAAA,WACAwhD,IAAAhzC,GAAAC,GAAAE,IACAJ,GAAA/X,MAAA+I,IAEAW,aAAA,WACAshD,IAAA,GAEArhD,WAAA,WACAqhD,GAAA,MAEA3zE,OAAA,WACA,GAAAtC,IAAAsjC,EAEA,OADAA,IAAAjQ,QACArzB,GAmBAujC,IAAAzmC,WACA+4E,QAAA,IACAK,QAAAzyC,GAAA,KACAqyC,YAAA,SAAA3nE,GAEA,OADAA,QAAAxR,KAAAk5E,UAAAl5E,KAAAk5E,QAAA1nE,EAAAxR,KAAAu5E,QAAA,MACAv5E,MAEAg4B,aAAA,WACAh4B,KAAAo5E,MAAA,GAEAnhD,WAAA,WACAj4B,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,IAAA93B,KAAAo5E,OAAAp5E,KAAA6mC,QAAAz+B,KAAA,KACApI,KAAAq5E,OAAAxiE,KAEAyX,MAAA,SAAA3iB,EAAAoC,GACA,OAAA/N,KAAAq5E,QACA,OACAr5E,KAAA6mC,QAAAz+B,KAAA,IAAAuD,EAAA,IAAAoC,GACA/N,KAAAq5E,OAAA,CACA,MAEA,QACAr5E,KAAA6mC,QAAAz+B,KAAA,IAAAuD,EAAA,IAAAoC,EACA,MAEA,SACA,MAAA/N,KAAAu5E,UAAAv5E,KAAAu5E,QAAAzyC,GAAA9mC,KAAAk5E,UACAl5E,KAAA6mC,QAAAz+B,KAAA,IAAAuD,EAAA,IAAAoC,EAAA/N,KAAAu5E,WAKA5zE,OAAA,WACA,GAAA3F,KAAA6mC,QAAAxjC,OAAA,CACA,GAAAsC,GAAA3F,KAAA6mC,QAAApjB,KAAA,GAEA,OADAzjB,MAAA6mC,WACAlhC,EAEA,aAYA,IAAA6zE,IAAA,SAAA3xC,EAAAzjC,GAKA,QAAAsL,GAAA8iB,GAKA,MAJAA,KACA,kBAAA2mD,IAAAM,EAAAN,eAAAn0E,MAAAhF,KAAAoD,YACA2kC,GAAAvV,EAAAknD,EAAAD,KAEAA,EAAA9zE,SATA,GACA+zE,GACAD,EAFAN,EAAA,GAiDA,OArCAzpE,GAAAgoE,KAAA,SAAAllD,GAEA,MADAuV,IAAAvV,EAAAknD,EAAA11C,KACAA,GAAAr+B,UAGA+J,EAAAiqE,QAAA,SAAAnnD,GAEA,MADAuV,IAAAvV,EAAAknD,EAAArzC,KACAA,GAAA1gC,UAGA+J,EAAAioE,OAAA,SAAAnlD,GAEA,MADAuV,IAAAvV,EAAAknD,EAAA1xC,KACAA,GAAAriC,UAGA+J,EAAAooE,SAAA,SAAAtlD,GAEA,MADAuV,IAAAvV,EAAAknD,EAAAz0C,KACAA,GAAAt/B,UAGA+J,EAAAm4B,WAAA,SAAAr2B,GACA,MAAApO,WAAAC,QAAAq2E,EAAA,MAAAloE,GAAAq2B,EAAA,KAAAyC,KAAAzC,EAAAr2B,GAAAgmB,OAAA9nB,GAAAm4B,GAGAn4B,EAAAtL,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QACAo2E,EAAA,MAAAjoE,GAAApN,EAAA,QAAAwiC,KAAA,GAAAT,IAAA/hC,EAAAoN,GACA,kBAAA2nE,IAAAM,EAAAN,eACAzpE,GAHAtL,GAMAsL,EAAAypE,YAAA,SAAA3nE,GACA,MAAApO,WAAAC,QACA81E,EAAA,kBAAA3nE,MAAAioE,EAAAN,aAAA3nE,OACA9B,GAFAypE,GAKAzpE,EAAAm4B,cAAAzjC,YAGA0jC,GAAA,SAAA8xC,EAAAn4C,EAAAhC,EAAA7yB,GACA,gBAAAyW,EAAA1iB,GAgDA,QAAA2tB,GAAAmK,EAAAC,GACA,GAAApK,GAAAjL,EAAAoV,EAAAC,EACAkhD,GAAAnhD,EAAAnK,EAAA,GAAAoK,EAAApK,EAAA,KAAA3tB,EAAA2tB,MAAAmK,EAAAC,GAGA,QAAAmhD,GAAAphD,EAAAC,GACA,GAAApK,GAAAjL,EAAAoV,EAAAC,EACAroB,GAAAie,QAAA,GAAAA,EAAA,IAGA,QAAAuJ,KACAiQ,EAAAxZ,MAAAurD,EACAxpE,EAAAwnB,YAGA,QAAAC,KACAgQ,EAAAxZ,QACAje,EAAAynB,UAGA,QAAAgiD,GAAArhD,EAAAC,GACA6H,EAAAn4B,MAAAqwB,EAAAC,GACA,IAAApK,GAAAjL,EAAAoV,EAAAC,EACAqhD,GAAAzrD,QAAA,GAAAA,EAAA,IAGA,QAAA+a,KACA0wC,EAAAliD,YACA0I,KAGA,QAAAgJ,KACAuwC,EAAAv5C,EAAA,MAAAA,EAAA,OACAw5C,EAAAjiD,SAEA,IAEA7xB,GAAAiP,EACA8xB,EACA1Y,EAJAoS,EAAAq5C,EAAAr5C,QACAs5C,EAAAC,EAAAt0E,SACAqM,EAAAgoE,EAAA32E,MAQA,IAJAk9B,EAAAp1B,MACAk1B,EAAAj4B,KAAAm4B,GACAA,EAAA,KAEAvuB,EAGA,KAAA0uB,GAEA,GADAsG,EAAAgzC,EAAA,IACA9kE,EAAA8xB,EAAA3jC,OAAA,MAGA,IAFA62E,IAAAv5E,EAAAq3B,eAAAkiD,GAAA,GACAv5E,EAAAk3B,YACA5xB,EAAA,EAAqBA,EAAAiP,IAAOjP,EAAAtF,EAAA2tB,SAAA0Y,EAAA/gC,IAAA,GAAAqoB,EAAA,GAC5B3tB,GAAAm3B,eAOA9lB,GAAA,KAAA0uB,GAAAs5C,EAAA5xE,KAAA4xE,EAAA7uE,MAAA/D,OAAA4yE,EAAA3nC,UAEA5R,EAAAr4B,KAAA4xE,EAAA1oE,OAAAy1B,KA9GA,GAKA1G,GACAI,EACAF,EAPAlwB,EAAAoxB,EAAA9gC,GACAw5E,EAAA92D,EAAAmb,OAAA5xB,EAAA,GAAAA,EAAA,IACAqtE,EAAAv4C,KACAq4C,EAAAt4C,EAAAw4C,GACAC,GAAA,EAKApyC,GACAxZ,QACAuJ,YACAC,UACAE,aAAA,WACA8P,EAAAxZ,MAAAwrD,EACAhyC,EAAAjQ,UAAAwR,EACAvB,EAAAhQ,QAAAyR,EACA9I,KACAJ,MAEApI,WAAA,WACA6P,EAAAxZ,QACAwZ,EAAAjQ,YACAiQ,EAAAhQ,UACA2I,EAAAjwB,GAAAiwB,EACA,IAAAE,GAAAkC,GAAAxC,EAAA85C,EACA15C,GAAAp9B,QACA62E,IAAAv5E,EAAAq3B,eAAAkiD,GAAA,GACAr5C,GAAAJ,EAAAV,GAAAY,EAAAlB,EAAA9+B,IACSggC,IACTu5C,IAAAv5E,EAAAq3B,eAAAkiD,GAAA,GACAv5E,EAAAk3B,YACA4H,EAAA,YAAA9+B,GACAA,EAAAm3B,WAEAoiD,IAAAv5E,EAAAs3B,aAAAiiD,GAAA,GACAz5C,EAAAJ,EAAA,MAEAiL,OAAA,WACA3qC,EAAAq3B,eACAr3B,EAAAk3B,YACA4H,EAAA,YAAA9+B,GACAA,EAAAm3B,UACAn3B,EAAAs3B,cAsEA,OAAA6P,KAeAsC,GAAAtC,GACA,WAAc,UACdb,GACAO,KACAxQ,IAAAE,KAsFAyT,GAAA,SAAA1Y,EAAA2I,GAKA,QAAA6E,GAAAC,EAAAC,EAAAb,EAAAtH,GACAqH,GAAArH,EAAAvF,EAAA2I,EAAAkE,EAAAY,EAAAC,GAGA,QAAAH,GAAA/G,EAAAC,GACA,MAAAI,IAAAL,GAAAK,GAAAJ,GAAA0hD,EAOA,QAAA34C,GAAAjK,GACA,GAAA9I,GACA8Z,EACA3nB,EACA+uC,EACAlvB,CACA,QACA7I,UAAA,WACA+3B,EAAA/uC,GAAA,EACA6f,EAAA,GAEApS,MAAA,SAAAmK,EAAAC,GACA,GACA2hD,GADApsD,GAAAwK,EAAAC,GAEAnhB,EAAAioB,EAAA/G,EAAAC,GACA/lB,EAAA2nE,EACA/iE,EAAA,EAAAgjE,EAAA9hD,EAAAC,GACAnhB,EAAAgjE,EAAA9hD,KAAA,EAAAzB,QAAA0B,GAAA,CAYA,KAXAhK,IAAAkhC,EAAA/uC,EAAAtJ,IAAAigB,EAAAK,YAGAtgB,IAAAsJ,MACAw5D,EAAA9zB,EAAA73B,EAAAT,KACA+pD,GAAAtpD,EAAA2rD,IAAArC,GAAA/pD,EAAAosD,MACApsD,EAAA,IAAA2N,GACA3N,EAAA,IAAA2N,GACArkB,EAAAioB,EAAAvR,EAAA,GAAAA,EAAA,KAGA1W,IAAAsJ,EACA6f,EAAA,EACAnpB,GAEAigB,EAAAK,YACAwiD,EAAA9zB,EAAAt4B,EAAAS,GACA8I,EAAAlJ,MAAA+rD,EAAA,GAAAA,EAAA,MAGAA,EAAA9zB,EAAA73B,EAAAT,GACAuJ,EAAAlJ,MAAA+rD,EAAA,GAAAA,EAAA,IACA7iD,EAAAM,WAEApJ,EAAA2rD,MACS,IAAAG,GAAA9rD,GAAA4rD,EAAA/iE,EAAA,CACT,GAAAxF,EAGAY,GAAA61B,KAAAz2B,EAAAw0C,EAAAt4B,EAAAS,GAAA,MACAgS,EAAA,EACA45C,GACA9iD,EAAAK,YACAL,EAAAlJ,MAAAvc,EAAA,MAAAA,EAAA,OACAylB,EAAAlJ,MAAAvc,EAAA,MAAAA,EAAA,OACAylB,EAAAM,YAEAN,EAAAlJ,MAAAvc,EAAA,MAAAA,EAAA,OACAylB,EAAAM,UACAN,EAAAK,YACAL,EAAAlJ,MAAAvc,EAAA,MAAAA,EAAA,UAIAwF,GAAAmX,GAAAspD,GAAAtpD,EAAAT,IACAuJ,EAAAlJ,MAAAL,EAAA,GAAAA,EAAA,IAEAS,EAAAT,EAAApN,EAAAtJ,EAAAixB,EAAA71B,GAEAmlB,QAAA,WACAjX,GAAA2W,EAAAM,UACApJ,EAAA,MAIAgS,MAAA,WACA,MAAAA,IAAAkvB,GAAA/uC,IAAA,IAMA,QAAA0lC,GAAA75C,EAAApK,EAAAm4E,GACA,GAAAC,GAAAjhD,GAAA/sB,GACAiuE,EAAAlhD,GAAAn3B,GAIAmtB,GAAA,OACAmrD,EAAAjhD,GAAA+gD,EAAAC,GACAE,EAAAnhD,GAAAkhD,KACAE,EAAAF,EAAA,GACAG,EAAAF,EAAAC,GAGA,KAAAC,EAAA,OAAAN,GAAA/tE,CAEA,IAAA+7B,GAAA2xC,EAAAS,EAAAE,EACAlrC,GAAAuqC,EAAAU,EAAAC,EACAC,EAAArhD,GAAAlK,EAAAmrD,GACA3qC,EAAApW,GAAApK,EAAAgZ,EAEA7O,IAAAqW,EADApW,GAAA+gD,EAAA/qC,GAIA,IAAAvW,GAAA0hD,EACAr+C,EAAAjD,GAAAuW,EAAA3W,GACA2hD,EAAAvhD,GAAAJ,KACA9Z,EAAAmd,IAAAs+C,GAAAvhD,GAAAuW,KAAA,EAEA,MAAAzwB,EAAA,IAEA,GAAAzN,GAAAiO,GAAAR,GACA2D,EAAA0W,GAAAP,IAAAqD,EAAA5qB,GAAAkpE,EAIA,IAHArhD,GAAAzW,EAAA8sB,GACA9sB,EAAAqW,GAAArW,IAEAs3D,EAAA,MAAAt3D,EAGA,IAIA8Y,GAJArD,EAAAlsB,EAAA,GACAytB,EAAA73B,EAAA,GACA83B,EAAA1tB,EAAA,GACA2tB,EAAA/3B,EAAA,EAGA63B,GAAAvB,IAAAqD,EAAArD,IAAAuB,IAAA8B,EAEA,IAAArB,GAAAT,EAAAvB,EACAsiD,EAAAvtE,GAAAitB,EAAA5D,IAAA4E,GACAu/C,EAAAD,GAAAtgD,EAAAgB,EAKA,KAHAs/C,GAAA7gD,EAAAD,IAAA6B,EAAA7B,IAAAC,IAAA4B,GAGAk/C,EACAD,EACA9gD,EAAAC,EAAA,EAAAlX,EAAA,IAAAxV,GAAAwV,EAAA,GAAAyV,GAAAgD,GAAAxB,EAAAC,GACAD,GAAAjX,EAAA,IAAAA,EAAA,IAAAkX,EACAO,EAAA5D,IAAA4B,GAAAzV,EAAA,IAAAA,EAAA,IAAAgX,GAAA,CACA,GAAAihD,GAAAvhD,GAAAP,IAAAqD,EAAA5qB,GAAAkpE,EAEA,OADArhD,IAAAwhD,EAAAnrC,IACA9sB,EAAAqW,GAAA4hD,MAMA,QAAAb,GAAA9hD,EAAAC,GACA,GAAA9a,GAAA08D,EAAAroD,EAAA+E,GAAA/E,EACAsoD,EAAA,CAKA,OAJA9hD,IAAA7a,EAAA28D,GAAA,EACA9hD,EAAA7a,IAAA28D,GAAA,GACA7hD,GAAA9a,EAAA28D,GAAA,EACA7hD,EAAA9a,IAAA28D,GAAA,GACAA,EAzKA,GAAAH,GAAAthD,GAAA7G,GACAqoD,EAAAF,EAAA,EACAI,EAAA7sE,GAAAysE,GAAAx+C,EA0KA,OAAAkM,IAAAtI,EAAAiC,EAAAhC,EAAA66C,GAAA,GAAAroD,KAAA+E,GAAA/E,EAAA+E,MAGAhmB,GAAA,SAAA02B,GACA,OACAlQ,OAAAiQ,GAAAC,IAeAC,IAAAxnC,WACAqC,YAAAmlC,GACArZ,MAAA,SAAA3iB,EAAAoC,GAAyB/N,KAAAw3B,OAAAlJ,MAAA3iB,EAAAoC,IACzBu9B,OAAA,WAAsBtrC,KAAAw3B,OAAA8T,UACtBzT,UAAA,WAAyB73B,KAAAw3B,OAAAK,aACzBC,QAAA,WAAuB93B,KAAAw3B,OAAAM,WACvBE,aAAA,WAA4Bh4B,KAAAw3B,OAAAQ,gBAC5BC,WAAA,WAA0Bj4B,KAAAw3B,OAAAS,cAgC1B,IAAAmR,IAAA,GACAF,GAAApQ,GAAA,GAAAH,IAEA6R,GAAA,SAAApC,EAAAE,GACA,OAAAA,EAAAD,GAAAD,EAAAE,GAAAH,GAAAC,IA+FAqC,GAAAhD,IACAnZ,MAAA,SAAA3iB,EAAAoC,GACA/N,KAAAw3B,OAAAlJ,MAAA3iB,EAAAgtB,GAAA5qB,EAAA4qB,OA8IA0iD,GAAA,WACA,MAAAzwC,IAAAI,IACA/8B,MAAA,SACAC,QAAA,aAGAotE,GAAA,WACA,MAAAD,MACAxwC,WAAA,YACA58B,MAAA,MACA6U,WAAA,UACAO,QAAA,OACAnV,SAAA,WAsBAqtE,GAAA,WAQA,QAAAA,GAAA5jD,GACA,GAAAhsB,GAAAgsB,EAAA,GAAA5pB,EAAA4pB,EAAA,EACA,OAAArJ,GAAA,KACAktD,EAAAltD,MAAA3iB,EAAAoC,GAAAugB,IACAmtD,EAAAntD,MAAA3iB,EAAAoC,GAAAugB,KACAotD,EAAAptD,MAAA3iB,EAAAoC,GAAAugB,GA2DA,QAAAoI,KAEA,MADAsT,GAAAC,EAAA,KACAsxC,EAzEA,GAAAvxC,GACAC,EACAuxC,EACAC,EACAC,EACAptD,EAHAqtD,EAAAL,KACAM,EAAAP,KAAAh4D,QAAA,QAAAnV,SAAA,SAAA28B,WAAA,QACAgxC,EAAAR,KAAAh4D,QAAA,QAAAnV,SAAA,SAAA28B,WAAA,OACAixC,GAA4BxtD,MAAA,SAAA3iB,EAAAoC,GAAuBugB,GAAA3iB,EAAAoC,IAuEnD,OA7DAwtE,GAAA/8C,OAAA,SAAA7G,GACA,GAAAjnB,GAAAirE,EAAA1tE,QACA8D,EAAA4pE,EAAA74D,YACAnX,GAAAgsB,EAAA,GAAA5lB,EAAA,IAAArB,EACA3C,GAAA4pB,EAAA,GAAA5lB,EAAA,IAAArB,CACA,QAAA3C,GAAA,KAAAA,EAAA,MAAApC,IAAA,MAAAA,GAAA,KAAAiwE,EACA7tE,GAAA,MAAAA,EAAA,MAAApC,IAAA,MAAAA,GAAA,KAAAkwE,EACAF,GAAAn9C,OAAA7G,IAGA4jD,EAAA/jD,OAAA,SAAAA,GACA,MAAAwS,IAAAC,IAAAzS,EAAAwS,IAAAoB,IAAAuwC,EAAAnkD,OAAAyS,EAAAzS,GAAAokD,EAAApkD,UAAAqkD,EAAArkD,aAGA+jD,EAAAplD,UAAA,SAAA3kB,GACA,MAAApO,WAAAC,QACAs4E,EAAAxlD,UAAA3kB,GAAAoqE,EAAAzlD,UAAA3kB,GAAAqqE,EAAA1lD,UAAA3kB,GACAklB,KAFAilD,EAAAxlD,aAKAolD,EAAAttE,MAAA,SAAAuD,GACA,MAAApO,WAAAC,QACAs4E,EAAA1tE,MAAAuD,GAAAoqE,EAAA3tE,MAAA,IAAAuD,GAAAqqE,EAAA5tE,MAAAuD,GACA+pE,EAAAz4D,UAAA64D,EAAA74D,cAFA64D,EAAA1tE,SAKAstE,EAAAz4D,UAAA,SAAAtR,GACA,IAAApO,UAAAC,OAAA,MAAAs4E,GAAA74D,WACA,IAAApS,GAAAirE,EAAA1tE,QAAAtC,GAAA6F,EAAA,GAAAzD,GAAAyD,EAAA,EAiBA,OAfAgqE,GAAAG,EACA74D,UAAAtR,GACA+tB,aAAA5zB,EAAA,KAAA+E,EAAA3C,EAAA,KAAA2C,IAAA/E,EAAA,KAAA+E,EAAA3C,EAAA,KAAA2C,KACA8mB,OAAAskD,GAEAL,EAAAG,EACA94D,WAAAnX,EAAA,KAAA+E,EAAA3C,EAAA,KAAA2C,IACA6uB,aAAA5zB,EAAA,KAAA+E,EAAAkrB,GAAA7tB,EAAA,IAAA2C,EAAAkrB,KAAAjwB,EAAA,KAAA+E,EAAAkrB,GAAA7tB,EAAA,KAAA2C,EAAAkrB,MACApE,OAAAskD,GAEAJ,EAAAG,EACA/4D,WAAAnX,EAAA,KAAA+E,EAAA3C,EAAA,KAAA2C,IACA6uB,aAAA5zB,EAAA,KAAA+E,EAAAkrB,GAAA7tB,EAAA,KAAA2C,EAAAkrB,KAAAjwB,EAAA,KAAA+E,EAAAkrB,GAAA7tB,EAAA,KAAA2C,EAAAkrB,MACApE,OAAAskD,GAEAplD,KAGA6kD,EAAA3zC,UAAA,SAAAjb,EAAA6F,GACA,MAAAoV,IAAA2zC,EAAA5uD,EAAA6F,IAGA+oD,EAAAtzC,QAAA,SAAAC,EAAA1V,GACA,MAAAyV,IAAAszC,EAAArzC,EAAA1V,IAQA+oD,EAAAttE,MAAA,OA4BA8tE,GAAAxwC,GAAA,SAAAywC,GACA,MAAAh8D,IAAA,KAAAg8D,KAGAD,IAAAv9C,OAAAgN,GAAA,SAAAvP,GACA,SAAAhF,GAAAgF,EAAA,IAGA,IAAAggD,IAAA,WACA,MAAAp0C,IAAAk0C,IACA9tE,MAAA,QACAy8B,UAAA,UAGAwxC,GAAA3wC,GAAA,SAAA54B,GACA,OAAAA,EAAAokB,GAAApkB,OAAAykB,GAAAzkB,IAGAupE,IAAA19C,OAAAgN,GAAA,SAAAvP,GACA,MAAAA,IAGA,IAAAkgD,IAAA,WACA,MAAAt0C,IAAAq0C,IACAjuE,MAAA,SACAy8B,UAAA,SAOAiB,IAAAnN,OAAA,SAAA7yB,EAAAoC,GACA,OAAApC,EAAA,EAAA47B,GAAA5jB,GAAA5V,IAAAmpB,IAGA,IAAAklD,IAAA,WACA,MAAAvwC,IAAAF,IACA19B,MAAA,IAAA6vB,KAiEAu+C,GAAA,WACA,MAAAzxC,IAAAoB,IACA/9B,MAAA,OACA48B,WAAA,QAOAsB,IAAA3N,OAAA2N,EAEA,IAAAmwC,IAAA,WACA,MAAAz0C,IAAAsE,IACAl+B,MAAA,SAuBAsuE,GAAA,WACA,MAAA3xC,IAAAwB,IACAn+B,MAAA,SACAC,QAAA,YAQAq+B,IAAA/N,OAAAgN,GAAAjE,GAEA,IAAAi1C,IAAA,WACA,MAAA30C,IAAA0E,IACAt+B,MAAA,SACAy8B,UAAA,KAWA+xC,GAAA,WAOA,QAAA/lD,KAEA,MADAsT,GAAAC,EAAA,KACApC,EARA,GACA5T,GAAAC,EAAAC,EACA6V,EACAC,EACApC,EAJAn3B,EAAA,EAAAi8B,EAAA,EAAAC,EAAA,EAAAikC,EAAA,EAAAC,EAAA,EAAA4L,EAAApyC,GACAtW,EAAA,KAAA8T,EAAAwC,EAUA,OAAAzC,IACArQ,OAAA,SAAAA,GACA,MAAAwS,IAAAC,IAAAzS,EAAAwS,IAAA0yC,EAAA50C,EAAAmC,EAAAzS,KAEA+H,WAAA,SAAA/tB,GACA,MAAApO,WAAAC,QAAAykC,EAAA,MAAAt2B,GAAAwiB,EAAAC,EAAAC,EAAAC,EAAA,KAAAmW,IAAA/K,GAAAvL,GAAAxiB,EAAA,MAAAyiB,GAAAziB,EAAA,MAAA0iB,GAAA1iB,EAAA,MAAA2iB,GAAA3iB,EAAA,OAAAklB,KAAA,MAAA1C,EAAA,OAAAA,EAAAC,IAAAC,EAAAC,KAEAlmB,MAAA,SAAAuD,GACA,MAAApO,WAAAC,QAAAq5E,EAAAlwC,IAAA97B,GAAAc,GAAAq/D,EAAAngE,EAAAogE,EAAAnkC,EAAAC,GAAAlW,KAAAhmB,GAEAoS,UAAA,SAAAtR,GACA,MAAApO,WAAAC,QAAAq5E,EAAAlwC,GAAA97B,EAAAmgE,EAAAngE,EAAAogE,EAAAnkC,GAAAn7B,EAAA,GAAAo7B,GAAAp7B,EAAA,IAAAklB,MAAAiW,EAAAC,IAEA+vC,SAAA,SAAAnrE,GACA,MAAApO,WAAAC,QAAAq5E,EAAAlwC,GAAA97B,GAAAmgE,EAAAr/D,GAAA,KAAAd,EAAAogE,EAAAnkC,EAAAC,GAAAlW,KAAAm6C,EAAA,GAEA+L,SAAA,SAAAprE,GACA,MAAApO,WAAAC,QAAAq5E,EAAAlwC,GAAA97B,EAAAmgE,EAAAngE,GAAAogE,EAAAt/D,GAAA,KAAAm7B,EAAAC,GAAAlW,KAAAo6C,EAAA,GAEAlpC,UAAA,SAAAjb,EAAA6F,GACA,MAAAoV,IAAAC,EAAAlb,EAAA6F,IAEAyV,QAAA,SAAAC,EAAA1V,GACA,MAAAyV,IAAAJ,EAAAK,EAAA1V,KASAqa,IAAArO,OAAAgN,GAAAvU,GAEA,IAAA4lD,IAAA,WACA,MAAAh1C,IAAAgF,IACA5+B,MAAA,OACAy8B,UAAA,GAAA9O,IAQAkR,IAAAtO,OAAAgN,GAAA,SAAAvP,GACA,SAAAsL,GAAAtL,IAGA,IAAA6gD,IAAA,WACA,MAAAj1C,IAAAiF,IACA7+B,MAAA,KACAy8B,UAAA,KAOAqC,IAAAvO,OAAA,SAAA7yB,EAAAoC,GACA,QAAAA,EAAA,EAAAw5B,GAAA5jB,GAAAhY,IAAAurB,IAGA,IAAA6lD,IAAA,WACA,GAAA7nE,GAAA22B,GAAAkB,IACA7+B,EAAAgH,EAAAhH,OACAmV,EAAAnO,EAAAmO,MAUA,OARAnO,GAAAhH,OAAA,SAAAsD,GACA,MAAApO,WAAAC,OAAA6K,IAAAsD,EAAA,GAAAA,EAAA,MAAAA,EAAAtD,KAAAsD,EAAA,IAAAA,EAAA,MAGA0D,EAAAmO,OAAA,SAAA7R,GACA,MAAApO,WAAAC,OAAAggB,GAAA7R,EAAA,GAAAA,EAAA,GAAAA,EAAAnO,OAAA,EAAAmO,EAAA,YAAAA,EAAA6R,KAAA7R,EAAA,GAAAA,EAAA,GAAAA,EAAA,SAGA6R,GAAA,SACApV,MAAA,UAmCA+uE,GAAA,WAMA,QAAAA,GAAAx7E,GACA,GAAAy7E,GACAtxE,EAAA,CAGAnK,GAAA07E,UAAA,SAAA/mE,GACA,GAAA+2B,GAAA/2B,EAAA+2B,QACAA,IACA/2B,EAAAxK,EAAAshC,GAAAC,GACA/2B,EAAApI,EAAAq/B,GAAAF,KAEA/2B,EAAAxK,EAAAsxE,EAAAtxE,GAAAwxE,EAAAhnE,EAAA8mE,GAAA,EACA9mE,EAAApI,EAAA,EACAkvE,EAAA9mE,IAIA,IAAAhF,GAAAm8B,GAAA9rC,GACA4P,EAAAm8B,GAAA/rC,GACAwyB,EAAA7iB,EAAAxF,EAAAwxE,EAAAhsE,EAAAC,GAAA,EACA8iB,EAAA9iB,EAAAzF,EAAAwxE,EAAA/rE,EAAAD,GAAA,CAGA,OAAA3P,GAAA07E,UAAAE,EAAA,SAAAjnE,GACAA,EAAAxK,GAAAwK,EAAAxK,EAAAnK,EAAAmK,GAAAqQ,EACA7F,EAAApI,GAAAvM,EAAAuM,EAAAoI,EAAApI,GAAAkO,GACK,SAAA9F,GACLA,EAAAxK,GAAAwK,EAAAxK,EAAAqoB,IAAAE,EAAAF,GAAAhY,EACA7F,EAAApI,GAAA,GAAAvM,EAAAuM,EAAAoI,EAAApI,EAAAvM,EAAAuM,EAAA,IAAAkO,IAjCA,GAAAkhE,GAAAnwC,GACAhxB,EAAA,EACAC,EAAA,EACAmhE,GAAA,CA8CA,OAZAJ,GAAAG,WAAA,SAAAxxE,GACA,MAAAvI,WAAAC,QAAA85E,EAAAxxE,EAAAqxE,GAAAG,GAGAH,EAAA90C,KAAA,SAAAv8B,GACA,MAAAvI,WAAAC,QAAA+5E,GAAA,EAAAphE,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAAqxE,GAAAI,EAAA,MAAAphE,EAAAC,IAGA+gE,EAAAI,SAAA,SAAAzxE,GACA,MAAAvI,WAAAC,QAAA+5E,GAAA,EAAAphE,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAAqxE,GAAAI,GAAAphE,EAAAC,GAAA,MAGA+gE,GAYAK,GAAA,WACA,MAAAr9E,MAAAk9E,UAAA1xE,KAGA8xE,GAAA,SAAAzqE,GACA,GAAAykD,GAAApqB,EAAAjnC,EAAA+L,EAAAmE,EAAAnW,KAAAqB,GAAA8U,EACA,IAEA,IADAmhD,EAAAj2D,EAAAoiC,UAAApiC,KACA8U,EAAAmhD,EAAAnsD,OAEA,GADA0H,EAAAsD,GAAA+2B,EAAA/2B,EAAA+2B,SACA,IAAAjnC,EAAA,EAAA+L,EAAAk7B,EAAA7pC,OAAoD4C,EAAA+L,IAAO/L,EAC3D5E,EAAA+G,KAAA8kC,EAAAjnC,UAGG5E,EAAAgC,OACH,OAAArD,OAGAu9E,GAAA,SAAA1qE,GAEA,IADA,GAAAq6B,GAAAjnC,EAAAkQ,EAAAnW,KAAA80B,GAAA3e,GACAA,EAAA2e,EAAA3pB,OAEA,GADA0H,EAAAsD,GAAA+2B,EAAA/2B,EAAA+2B,SACA,IAAAjnC,EAAAinC,EAAA7pC,OAAA,EAA+C4C,GAAA,IAAQA,EACvD6uB,EAAA1sB,KAAA8kC,EAAAjnC,GAGA,OAAAjG,OAGAw9E,GAAA,SAAA3qE,GAEA,IADA,GAAAq6B,GAAAjnC,EAAA+L,EAAAmE,EAAAnW,KAAA80B,GAAA3e,GAAA9U,KACA8U,EAAA2e,EAAA3pB,OAEA,GADA9J,EAAA+G,KAAA+N,GAAA+2B,EAAA/2B,EAAA+2B,SACA,IAAAjnC,EAAA,EAAA+L,EAAAk7B,EAAA7pC,OAAkD4C,EAAA+L,IAAO/L,EACzD6uB,EAAA1sB,KAAA8kC,EAAAjnC,GAGA,MAAAkQ,EAAA9U,EAAA8J,OACA0H,EAAAsD,EAEA,OAAAnW,OAGAy9E,GAAA,SAAAz7E,GACA,MAAAhC,MAAAk9E,UAAA,SAAA/mE,GAIA,IAHA,GAAAq3B,IAAAxrC,EAAAmU,EAAAvG,OAAA,EACAs9B,EAAA/2B,EAAA+2B,SACAjnC,EAAAinC,KAAA7pC,SACA4C,GAAA,GAAAunC,GAAAN,EAAAjnC,GAAAjE,KACAmU,GAAAnU,MAAAwrC,KAIAkwC,GAAA,SAAAlsD,GACA,MAAAxxB,MAAAmuC,WAAA,SAAAh4B,GACAA,EAAA+2B,UACA/2B,EAAA+2B,SAAA0L,KAAApnB,MAKAmsD,GAAA,SAAA35D,GAIA,IAHA,GAAApX,GAAA5M,KACA0yC,EAAAjF,GAAA7gC,EAAAoX,GACA8Q,GAAAloB,GACAA,IAAA8lC,GACA9lC,IAAAhI,OACAkwB,EAAA1sB,KAAAwE,EAGA,KADA,GAAA8D,GAAAokB,EAAAzxB,OACA2gB,IAAA0uB,GACA5d,EAAAlsB,OAAA8H,EAAA,EAAAsT,GACAA,IAAApf,MAEA,OAAAkwB,IAkBA8oD,GAAA,WAEA,IADA,GAAAznE,GAAAnW,KAAA80B,GAAA3e,GACAA,IAAAvR,QACAkwB,EAAA1sB,KAAA+N,EAEA,OAAA2e,IAGA+oD,GAAA,WACA,GAAA/oD,KAIA,OAHA90B,MAAAuR,KAAA,SAAA4E,GACA2e,EAAA1sB,KAAA+N,KAEA2e,GAGAgpD,GAAA,WACA,GAAAC,KAMA,OALA/9E,MAAAmuC,WAAA,SAAAh4B,GACAA,EAAA+2B,UACA6wC,EAAA31E,KAAA+N,KAGA4nE,GAGAC,GAAA,WACA,GAAAx8E,GAAAxB,KAAA8yE,IAMA,OALAtxE,GAAA+P,KAAA,SAAA4E,GACAA,IAAA3U,GACAsxE,EAAA1qE,MAAkB7H,OAAA4V,EAAAvR,OAAAiX,OAAA1F,MAGlB28D,EAuDA9kC,IAAA7tC,UAAA0tC,GAAA1tC,WACAqC,YAAAwrC,GACAxiC,MAAA6xE,GACA9rE,KAAA+rE,GACAJ,UAAAM,GACArvC,WAAAovC,GACA/vC,IAAAiwC,GACA7kC,KAAA8kC,GACAhuE,KAAAiuE,GACAhwC,UAAAiwC,GACAK,YAAAJ,GACAE,OAAAD,GACAhL,MAAAkL,GACAz0E,KAAA8kC,GAGA,IAAA6vC,IAAAxyE,MAAAvL,UAAAqJ,MAiBA2nC,GAAA,SAAAL,GAGA,IAFA,GAAAruC,GAAAwF,EAAAhC,EAAA,EAAA+L,GAAA8+B,EAAAvC,GAAA2vC,GAAAr9E,KAAAiwC,KAAAztC,OAAAqrC,KAEAzoC,EAAA+L,GACAvP,EAAAquC,EAAA7qC,GACAgC,GAAA+mC,GAAA/mC,EAAAxF,KAAAwD,GACAgC,EAAAgnC,GAAAP,EAAAD,GAAAC,EAAAjsC,IAAAwD,EAAA,EAGA,OAAAgC,IAyNAk2E,GAAA,SAAArtC,GAEA,MADAD,IAAAC,GACAA,GAgBAstC,GAAA,SAAAzyE,GACA,kBACA,MAAAA,KAQA0yE,GAAA,WAMA,QAAAntC,GAAA1vC,GAYA,MAXAA,GAAAmK,EAAAqQ,EAAA,EAAAxa,EAAAuM,EAAAkO,EAAA,EACAgW,EACAzwB,EAAA2sC,WAAAqD,GAAAvf,IACAirD,UAAAzrC,GAAAC,EAAA,KACAvD,WAAAwD,GAAA,IAEAnwC,EAAA2sC,WAAAqD,GAAAD,KACA2rC,UAAAzrC,GAAAH,GAAA,IACA4rC,UAAAzrC,GAAAC,EAAAlwC,EAAAoc,EAAA7Q,KAAAuR,IAAAtC,EAAAC,KACAkyB,WAAAwD,GAAA5kC,KAAAuR,IAAAtC,EAAAC,IAAA,EAAAza,EAAAoc,KAEApc,EAjBA,GAAAywB,GAAA,KACAjW,EAAA,EACAC,EAAA,EACAy1B,EAAAJ,EA6BA,OAZAJ,GAAAjf,OAAA,SAAAtmB,GACA,MAAAvI,WAAAC,QAAA4uB,EAAAmf,GAAAzlC,GAAAulC,GAAAjf,GAGAif,EAAAhJ,KAAA,SAAAv8B,GACA,MAAAvI,WAAAC,QAAA2Y,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAAulC,IAAAl1B,EAAAC,IAGAi1B,EAAAQ,QAAA,SAAA/lC,GACA,MAAAvI,WAAAC,QAAAquC,EAAA,kBAAA/lC,KAAAyyE,IAAAzyE,GAAAulC,GAAAQ,GAGAR,GAuCAotC,GAAA,SAAAnoE,GACAA,EAAA6d,GAAAjnB,KAAAsB,MAAA8H,EAAA6d,IACA7d,EAAA8d,GAAAlnB,KAAAsB,MAAA8H,EAAA8d,IACA9d,EAAA+d,GAAAnnB,KAAAsB,MAAA8H,EAAA+d,IACA/d,EAAAge,GAAApnB,KAAAsB,MAAA8H,EAAAge,KAGAuf,GAAA,SAAA9uC,EAAAovB,EAAAC,EAAAC,EAAAC,GAOA,IANA,GACAhe,GADA2e,EAAAlwB,EAAAsoC,SAEAjnC,GAAA,EACA+L,EAAA8iB,EAAAzxB,OACAqN,EAAA9L,EAAA5C,QAAAkyB,EAAAF,GAAApvB,EAAA5C,QAEAiE,EAAA+L,GACAmE,EAAA2e,EAAA7uB,GAAAkQ,EAAA8d,KAAA9d,EAAAge,KACAhe,EAAA6d,KAAA7d,EAAA+d,GAAAF,GAAA7d,EAAAnU,MAAA0O,GAIA6tE,GAAA,WAMA,QAAAA,GAAA/8E,GACA,GAAAwQ,GAAAxQ,EAAAgrB,OAAA,CAOA,OANAhrB,GAAAwyB,GACAxyB,EAAAyyB,GAAAyd,EACAlwC,EAAA0yB,GAAAlY,EACAxa,EAAA2yB,GAAAlY,EAAAjK,EACAxQ,EAAA2sC,WAAAqwC,EAAAviE,EAAAjK,IACA3D,GAAA7M,EAAA2sC,WAAAmwC,IACA98E,EAGA,QAAAg9E,GAAAviE,EAAAjK,GACA,gBAAAmE,GACAA,EAAA+2B,UACAwG,GAAAv9B,IAAA6d,GAAA/X,GAAA9F,EAAAuyB,MAAA,GAAA12B,EAAAmE,EAAA+d,GAAAjY,GAAA9F,EAAAuyB,MAAA,GAAA12B,EAEA,IAAAgiB,GAAA7d,EAAA6d,GACAC,EAAA9d,EAAA8d,GACAC,EAAA/d,EAAA+d,GAAAwd,EACAvd,EAAAhe,EAAAge,GAAAud,CACAxd,GAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAC,EAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAhe,EAAA6d,KACA7d,EAAA8d,KACA9d,EAAA+d,KACA/d,EAAAge,MA9BA,GAAAnY,GAAA,EACAC,EAAA,EACAy1B,EAAA,EACArjC,GAAA,CA2CA,OAZAkwE,GAAAlwE,MAAA,SAAA1C,GACA,MAAAvI,WAAAC,QAAAgL,IAAA1C,EAAA4yE,GAAAlwE,GAGAkwE,EAAAr2C,KAAA,SAAAv8B,GACA,MAAAvI,WAAAC,QAAA2Y,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAA4yE,IAAAviE,EAAAC,IAGAsiE,EAAA7sC,QAAA,SAAA/lC,GACA,MAAAvI,WAAAC,QAAAquC,GAAA/lC,EAAA4yE,GAAA7sC,GAGA6sC,GAGAE,GAAA,IACAC,IAAeh2C,OAAA,GACfi2C,MAUAC,GAAA,WAIA,QAAAA,GAAAhvE,GACA,GAAAvN,GACA4D,EAEAzE,EACAoD,EACAuR,EAEAmf,EACAupD,EANA7sE,EAAApC,EAAAvM,OAIAyxB,EAAA,GAAAppB,OAAAsG,GAGA8sE,IAEA,KAAA74E,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB5D,EAAAuN,EAAA3J,GAAAkQ,EAAA2e,EAAA7uB,GAAA,GAAA+nC,IAAA3rC,GACA,OAAAizB,EAAAxZ,EAAAzZ,EAAA4D,EAAA2J,MAAA0lB,GAAA,MACAupD,EAAAJ,IAAAtoE,EAAA2F,GAAAwZ,GACAwpD,EAAAD,OAAAC,GAAAH,GAAAxoE,EAIA,KAAAlQ,EAAA,EAAeA,EAAA+L,IAAO/L,EAEtB,GADAkQ,EAAA2e,EAAA7uB,GACA,OADAqvB,EAAAwc,EAAAliC,EAAA3J,KAAA2J,MACA0lB,GAAA,IAGO,CAEP,KADA1wB,EAAAk6E,EAAAL,GAAAnpD,IACA,SAAA1zB,OAAA,YAAA0zB,EACA,IAAA1wB,IAAA+5E,GAAA,SAAA/8E,OAAA,cAAA0zB,EACA1wB,GAAAsoC,SAAAtoC,EAAAsoC,SAAA9kC,KAAA+N,GACAvR,EAAAsoC,UAAA/2B,GACAA,EAAAvR,aATA,CACA,GAAApD,EAAA,SAAAI,OAAA,iBACAJ,GAAA2U,EAWA,IAAA3U,EAAA,SAAAI,OAAA,UAIA,IAHAJ,EAAAoD,OAAA85E,GACAl9E,EAAA2sC,WAAA,SAAAh4B,GAAoCA,EAAAuyB,MAAAvyB,EAAAvR,OAAA8jC,MAAA,IAAoC12B,IAAOm8B,WAAAC,IAC/E5sC,EAAAoD,OAAA,KACAoN,EAAA,WAAApQ,OAAA,QAEA,OAAAJ,GA5CA,GAAAsa,GAAA81B,GACAE,EAAAD,EAsDA,OARA+sC,GAAA9iE,GAAA,SAAAnQ,GACA,MAAAvI,WAAAC,QAAAyY,EAAAu1B,GAAA1lC,GAAAizE,GAAA9iE,GAGA8iE,EAAA9sC,SAAA,SAAAnmC,GACA,MAAAvI,WAAAC,QAAAyuC,EAAAT,GAAA1lC,GAAAizE,GAAA9sC,GAGA8sC,EA0EAjsC,IAAAxyC,UAAAwC,OAAAR,OAAA6rC,GAAA7tC,UA0BA,IAAAuzB,IAAA,WAMA,QAAAA,GAAAlyB,GACA,GAAAuQ,GAAA6gC,GAAApxC,EAOA,IAJAuQ,EAAAmrE,UAAA6B,GAAAhtE,EAAAnN,OAAAsQ,GAAAnD,EAAAkqB,EACAlqB,EAAAo8B,WAAA6wC,GAGA5B,EAAA57E,EAAA2sC,WAAA8wC,OAIA,CACA,GAAA9tE,GAAA3P,EACA4P,EAAA5P,EACAoP,EAAApP,CACAA,GAAA2sC,WAAA,SAAAh4B,GACAA,EAAAxK,EAAAwF,EAAAxF,IAAAwF,EAAAgF,GACAA,EAAAxK,EAAAyF,EAAAzF,IAAAyF,EAAA+E,GACAA,EAAAuyB,MAAA93B,EAAA83B,QAAA93B,EAAAuF,IAEA,IAAA+H,GAAA/M,IAAAC,EAAA,EAAA+rE,EAAAhsE,EAAAC,GAAA,EACAu7B,EAAAzuB,EAAA/M,EAAAxF,EACA8gC,EAAAzwB,GAAA5K,EAAAzF,EAAAuS,EAAAyuB,GACAD,EAAAzwB,GAAArL,EAAA83B,OAAA,EACAlnC,GAAA2sC,WAAA,SAAAh4B,GACAA,EAAAxK,GAAAwK,EAAAxK,EAAAghC,GAAAF,EACAt2B,EAAApI,EAAAoI,EAAAuyB,MAAAgE,IAIA,MAAAlrC,GAOA,QAAAu9E,GAAAxnE,GACA,GAAA21B,GAAA31B,EAAA21B,SACAixC,EAAA5mE,EAAA3S,OAAAsoC,SACAvQ,EAAAplB,EAAAtR,EAAAk4E,EAAA5mE,EAAAtR,EAAA,OACA,IAAAinC,EAAA,CACAqF,GAAAh7B,EACA,IAAA2nE,IAAAhyC,EAAA,GAAAjR,EAAAiR,IAAA7pC,OAAA,GAAA44B,GAAA,CACAU,IACAplB,EAAA0kB,EAAAU,EAAAV,EAAAkhD,EAAA5lE,EAAA/F,EAAAmrB,EAAAnrB,GACA+F,EAAArC,EAAAqC,EAAA0kB,EAAAijD,GAEA3nE,EAAA0kB,EAAAijD,MAEKviD,KACLplB,EAAA0kB,EAAAU,EAAAV,EAAAkhD,EAAA5lE,EAAA/F,EAAAmrB,EAAAnrB,GAEA+F,GAAA3S,OAAAqrC,EAAAkvC,EAAA5nE,EAAAolB,EAAAplB,EAAA3S,OAAAqrC,GAAAkuC,EAAA,IAIA,QAAAa,GAAAznE,GACAA,EAAA/F,EAAA7F,EAAA4L,EAAA0kB,EAAA1kB,EAAA3S,OAAAsQ,EACAqC,EAAArC,GAAAqC,EAAA3S,OAAAsQ,EAcA,QAAAiqE,GAAA5nE,EAAAolB,EAAA+V,GACA,GAAA/V,EAAA,CAUA,IATA,GAQA0V,GARA+sC,EAAA7nE,EACA8nE,EAAA9nE,EACAk7B,EAAA9V,EACA2iD,EAAAF,EAAAx6E,OAAAsoC,SAAA,GACAqyC,EAAAH,EAAAlqE,EACAsqE,EAAAH,EAAAnqE,EACAuqE,EAAAhtC,EAAAv9B,EACAwqE,EAAAJ,EAAApqE,EAEAu9B,EAAAR,GAAAQ,GAAA2sC,EAAAptC,GAAAotC,GAAA3sC,GAAA2sC,GACAE,EAAAttC,GAAAstC,GACAD,EAAAptC,GAAAotC,GACAA,EAAA3yE,EAAA6K,EACA86B,EAAAI,EAAAxW,EAAAwjD,EAAAL,EAAAnjD,EAAAsjD,EAAApC,EAAA1qC,EAAAjhC,EAAA4tE,EAAA5tE,GACA6gC,EAAA,IACAH,GAAAM,GAAAC,EAAAl7B,EAAAm7B,GAAAn7B,EAAA86B,GACAktC,GAAAltC,EACAmtC,GAAAntC,GAEAotC,GAAAhtC,EAAAv9B,EACAqqE,GAAAH,EAAAlqE,EACAwqE,GAAAJ,EAAApqE,EACAsqE,GAAAH,EAAAnqE,CAEAu9B,KAAAR,GAAAotC,KACAA,EAAAttE,EAAA0gC,EACA4sC,EAAAnqE,GAAAuqE,EAAAD,GAEAJ,IAAAptC,GAAAstC,KACAA,EAAAvtE,EAAAqtE,EACAE,EAAApqE,GAAAqqE,EAAAG,EACAhtC,EAAAn7B,GAGA,MAAAm7B,GAGA,QAAAusC,GAAA9oE,GACAA,EAAAxK,GAAAqQ,EACA7F,EAAApI,EAAAoI,EAAAuyB,MAAAzsB,EAxHA,GAAAkhE,GAAAprC,GACA/1B,EAAA,EACAC,EAAA,EACAmhE,EAAA,IAoIA,OAZA1pD,GAAAypD,WAAA,SAAAxxE,GACA,MAAAvI,WAAAC,QAAA85E,EAAAxxE,EAAA+nB,GAAAypD,GAGAzpD,EAAAwU,KAAA,SAAAv8B,GACA,MAAAvI,WAAAC,QAAA+5E,GAAA,EAAAphE,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAA+nB,GAAA0pD,EAAA,MAAAphE,EAAAC,IAGAyX,EAAA0pD,SAAA,SAAAzxE,GACA,MAAAvI,WAAAC,QAAA+5E,GAAA,EAAAphE,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAA+nB,GAAA0pD,GAAAphE,EAAAC,GAAA,MAGAyX,GAGAigB,GAAA,SAAA/uC,EAAAovB,EAAAC,EAAAC,EAAAC,GAOA,IANA,GACAhe,GADA2e,EAAAlwB,EAAAsoC,SAEAjnC,GAAA,EACA+L,EAAA8iB,EAAAzxB,OACAqN,EAAA9L,EAAA5C,QAAAmyB,EAAAF,GAAArvB,EAAA5C,QAEAiE,EAAA+L,GACAmE,EAAA2e,EAAA7uB,GAAAkQ,EAAA6d,KAAA7d,EAAA+d,KACA/d,EAAA8d,KAAA9d,EAAAge,GAAAF,GAAA9d,EAAAnU,MAAA0O,GAIAgoB,IAAA,EAAA3rB,KAAAiT,KAAA,MAmDA2/D,GAAA,QAAAlV,GAAA33B,GAEA,QAAA6sC,GAAA/6E,EAAAovB,EAAAC,EAAAC,EAAAC,GACA0e,GAAAC,EAAAluC,EAAAovB,EAAAC,EAAAC,EAAAC,GAOA,MAJAwrD,GAAA7sC,MAAA,SAAAnnC,GACA,MAAA8+D,IAAA9+D,MAAA,EAAAA,EAAA,IAGAg0E,GACCjnD,IAEDknD,GAAA,WAYA,QAAAC,GAAAr+E,GAQA,MAPAA,GAAAwyB,GACAxyB,EAAAyyB,GAAA,EACAzyB,EAAA0yB,GAAAlY,EACAxa,EAAA2yB,GAAAlY,EACAza,EAAA2sC,WAAAqwC,GACAsB,GAAA,GACAzxE,GAAA7M,EAAA2sC,WAAAmwC,IACA98E,EAGA,QAAAg9E,GAAAroE,GACA,GAAA1T,GAAAq9E,EAAA3pE,EAAAuyB,OACA1U,EAAA7d,EAAA6d,GAAAvxB,EACAwxB,EAAA9d,EAAA8d,GAAAxxB,EACAyxB,EAAA/d,EAAA+d,GAAAzxB,EACA0xB,EAAAhe,EAAAge,GAAA1xB,CACAyxB,GAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAC,EAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAhe,EAAA6d,KACA7d,EAAA8d,KACA9d,EAAA+d,KACA/d,EAAAge,KACAhe,EAAA+2B,WACAzqC,EAAAq9E,EAAA3pE,EAAAuyB,MAAA,GAAAoN,EAAA3/B,GAAA,EACA6d,GAAA+rD,EAAA5pE,GAAA1T,EACAwxB,GAAA+rD,EAAA7pE,GAAA1T,EACAyxB,GAAA+rD,EAAA9pE,GAAA1T,EACA0xB,GAAA+rD,EAAA/pE,GAAA1T,EACAyxB,EAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAC,EAAAF,MAAAE,GAAAF,EAAAE,GAAA,GACAgsD,EAAAhqE,EAAA6d,EAAAC,EAAAC,EAAAC,IA1CA,GAAAgsD,GAAAR,GACAtxE,GAAA,EACA2N,EAAA,EACAC,EAAA,EACA6jE,GAAA,GACAhqC,EAAAxE,GACA0uC,EAAA1uC,GACA2uC,EAAA3uC,GACA4uC,EAAA5uC,GACAyuC,EAAAzuC,EA6EA,OAxCAuuC,GAAAxxE,MAAA,SAAA1C,GACA,MAAAvI,WAAAC,QAAAgL,IAAA1C,EAAAk0E,GAAAxxE,GAGAwxE,EAAA33C,KAAA,SAAAv8B,GACA,MAAAvI,WAAAC,QAAA2Y,GAAArQ,EAAA,GAAAsQ,GAAAtQ,EAAA,GAAAk0E,IAAA7jE,EAAAC,IAGA4jE,EAAAM,KAAA,SAAAx0E,GACA,MAAAvI,WAAAC,QAAA88E,EAAA9uC,GAAA1lC,GAAAk0E,GAAAM,GAGAN,EAAAnuC,QAAA,SAAA/lC,GACA,MAAAvI,WAAAC,OAAAw8E,EAAA/pC,aAAAnqC,GAAAoqC,aAAApqC,GAAAk0E,EAAA/pC,gBAGA+pC,EAAA/pC,aAAA,SAAAnqC,GACA,MAAAvI,WAAAC,QAAAyyC,EAAA,kBAAAnqC,KAAAyyE,IAAAzyE,GAAAk0E,GAAA/pC,GAGA+pC,EAAA9pC,aAAA,SAAApqC,GACA,MAAAvI,WAAAC,OAAAw8E,EAAAG,WAAAr0E,GAAAs0E,aAAAt0E,GAAAu0E,cAAAv0E,GAAAo0E,YAAAp0E,GAAAk0E,EAAAG,cAGAH,EAAAG,WAAA,SAAAr0E,GACA,MAAAvI,WAAAC,QAAA28E,EAAA,kBAAAr0E,KAAAyyE,IAAAzyE,GAAAk0E,GAAAG,GAGAH,EAAAI,aAAA,SAAAt0E,GACA,MAAAvI,WAAAC,QAAA48E,EAAA,kBAAAt0E,KAAAyyE,IAAAzyE,GAAAk0E,GAAAI,GAGAJ,EAAAK,cAAA,SAAAv0E,GACA,MAAAvI,WAAAC,QAAA68E,EAAA,kBAAAv0E,KAAAyyE,IAAAzyE,GAAAk0E,GAAAK,GAGAL,EAAAE,YAAA,SAAAp0E,GACA,MAAAvI,WAAAC,QAAA08E,EAAA,kBAAAp0E,KAAAyyE,IAAAzyE,GAAAk0E,GAAAE,GAGAF,GAGAO,GAAA,SAAAx7E,EAAAovB,EAAAC,EAAAC,EAAAC,GAWA,QAAAoqD,GAAAt4E,EAAAgP,EAAAjT,EAAAgyB,EAAAC,EAAAC,EAAAC,GACA,GAAAluB,GAAAgP,EAAA,GACA,GAAAkB,GAAA2e,EAAA7uB,EAGA,OAFAkQ,GAAA6d,KAAA7d,EAAA8d,KACA9d,EAAA+d,KAAA/d,EAAAge,SACA,GAQA,IALA,GAAAksD,GAAAC,EAAAr6E,GACAs6E,EAAAv+E,EAAA,EAAAq+E,EACA3vE,EAAAzK,EAAA,EACA6tD,EAAA7+C,EAAA,EAEAvE,EAAAojD,GAAA,CACA,GAAAC,GAAArjD,EAAAojD,IAAA,CACAwsB,GAAAvsB,GAAAwsB,EAAA7vE,EAAAqjD,EAAA,EACAD,EAAAC,EAGAwsB,EAAAD,EAAA5vE,EAAA,GAAA4vE,EAAA5vE,GAAA6vE,GAAAt6E,EAAA,EAAAyK,MAEA,IAAA8vE,GAAAF,EAAA5vE,GAAA2vE,EACAI,EAAAz+E,EAAAw+E,CAEA,IAAAtsD,EAAAF,EAAAG,EAAAF,EAAA,CACA,GAAAysD,IAAA1sD,EAAAysD,EAAAvsD,EAAAssD,GAAAx+E,CACAu8E,GAAAt4E,EAAAyK,EAAA8vE,EAAAxsD,EAAAC,EAAAysD,EAAAvsD,GACAoqD,EAAA7tE,EAAAuE,EAAAwrE,EAAAC,EAAAzsD,EAAAC,EAAAC,OACK,CACL,GAAAwsD,IAAA1sD,EAAAwsD,EAAAtsD,EAAAqsD,GAAAx+E,CACAu8E,GAAAt4E,EAAAyK,EAAA8vE,EAAAxsD,EAAAC,EAAAC,EAAAysD,GACApC,EAAA7tE,EAAAuE,EAAAwrE,EAAAzsD,EAAA2sD,EAAAzsD,EAAAC,IAzCA,GACAluB,GACAunC,EAFA1Y,EAAAlwB,EAAAsoC,SACAl7B,EAAA8iB,EAAAzxB,OACAi9E,EAAA,GAAA50E,OAAAsG,EAAA,EAEA,KAAAsuE,EAAA,GAAA9yC,EAAAvnC,EAAA,EAA6BA,EAAA+L,IAAO/L,EACpCq6E,EAAAr6E,EAAA,GAAAunC,GAAA1Y,EAAA7uB,GAAAjE,KAGAu8E,GAAA,EAAAvsE,EAAApN,EAAA5C,MAAAgyB,EAAAC,EAAAC,EAAAC,IAsCAysD,GAAA,SAAAh8E,EAAAovB,EAAAC,EAAAC,EAAAC,IACA,EAAAvvB,EAAA8jC,MAAAiL,GAAAD,IAAA9uC,EAAAovB,EAAAC,EAAAC,EAAAC,IAGA0sD,GAAA,QAAApW,GAAA33B,GAEA,QAAA+tC,GAAAj8E,EAAAovB,EAAAC,EAAAC,EAAAC,GACA,IAAAZ,EAAA3uB,EAAAk8E,YAAAvtD,EAAAuf,UAUA,IATA,GAAAvf,GACAF,EACAyB,EACA7uB,EAEA+L,EADAiD,GAAA,EAEAC,EAAAqe,EAAAlwB,OACArB,EAAA4C,EAAA5C,QAEAiT,EAAAC,GAAA,CAEA,IADAme,EAAAE,EAAAte,GAAA6f,EAAAzB,EAAA6Z,SACAjnC,EAAAotB,EAAArxB,MAAA,EAAAgQ,EAAA8iB,EAAAzxB,OAAiD4C,EAAA+L,IAAO/L,EAAAotB,EAAArxB,OAAA8yB,EAAA7uB,GAAAjE,KACxDqxB,GAAAogB,KAAAC,GAAArgB,EAAAW,EAAAC,EAAAC,EAAAD,IAAAE,EAAAF,GAAAZ,EAAArxB,SACA2xC,GAAAtgB,EAAAW,EAAAC,EAAAD,IAAAE,EAAAF,GAAAX,EAAArxB,QAAAmyB,GACAnyB,GAAAqxB,EAAArxB,UAGA4C,GAAAk8E,UAAAvtD,EAAAsf,GAAAC,EAAAluC,EAAAovB,EAAAC,EAAAC,EAAAC,GACAZ,EAAAuf,QAQA,MAJA+tC,GAAA/tC,MAAA,SAAAnnC,GACA,MAAA8+D,IAAA9+D,MAAA,EAAAA,EAAA,IAGAk1E,GACCnoD,IAEDqoD,GAAA,SAAA1gD,GAOA,IANA,GAEA3zB,GAFAzG,GAAA,EACA+L,EAAAquB,EAAAh9B,OAEAf,EAAA+9B,EAAAruB,EAAA,GACA0lE,EAAA,IAEAzxE,EAAA+L,GACAtF,EAAApK,EACAA,EAAA+9B,EAAAp6B,GACAyxE,GAAAhrE,EAAA,GAAApK,EAAA,GAAAoK,EAAA,GAAApK,EAAA,EAGA,OAAAo1E,GAAA,GAGAsJ,GAAA,SAAA3gD,GAUA,IATA,GAIA3zB,GAEAiG,EANA1M,GAAA,EACA+L,EAAAquB,EAAAh9B,OACAsI,EAAA,EACAoC,EAAA,EAEAzL,EAAA+9B,EAAAruB,EAAA,GAEAtB,EAAA,IAEAzK,EAAA+L,GACAtF,EAAApK,EACAA,EAAA+9B,EAAAp6B,GACAyK,GAAAiC,EAAAjG,EAAA,GAAApK,EAAA,GAAAA,EAAA,GAAAoK,EAAA,GACAf,IAAAe,EAAA,GAAApK,EAAA,IAAAqQ,EACA5E,IAAArB,EAAA,GAAApK,EAAA,IAAAqQ,CAGA,OAAAjC,IAAA,GAAA/E,EAAA+E,EAAA3C,EAAA2C,IAOAqjC,GAAA,SAAArnC,EAAApK,EAAAqQ,GACA,OAAArQ,EAAA,GAAAoK,EAAA,KAAAiG,EAAA,GAAAjG,EAAA,KAAApK,EAAA,GAAAoK,EAAA,KAAAiG,EAAA,GAAAjG,EAAA,KAuBAu0E,GAAA,SAAA9hD,GACA,IAAAntB,EAAAmtB,EAAA97B,QAAA,aAEA,IAAA4C,GACA+L,EACAkvE,EAAA,GAAAx1E,OAAAsG,GACAmvE,EAAA,GAAAz1E,OAAAsG,EAEA,KAAA/L,EAAA,EAAaA,EAAA+L,IAAO/L,EAAAi7E,EAAAj7E,KAAAk5B,EAAAl5B,GAAA,IAAAk5B,EAAAl5B,GAAA,GAAAA,EAEpB,KADAi7E,EAAAtoC,KAAAhF,IACA3tC,EAAA,EAAaA,EAAA+L,IAAO/L,EAAAk7E,EAAAl7E,IAAAi7E,EAAAj7E,GAAA,IAAAi7E,EAAAj7E,GAAA,GAEpB,IAAAm7E,GAAAvtC,GAAAqtC,GACAG,EAAAxtC,GAAAstC,GAGAG,EAAAD,EAAA,KAAAD,EAAA,GACAG,EAAAF,IAAAh+E,OAAA,KAAA+9E,IAAA/9E,OAAA,GACA49E,IAIA,KAAAh7E,EAAAm7E,EAAA/9E,OAAA,EAAmC4C,GAAA,IAAQA,EAAAg7E,EAAA74E,KAAA+2B,EAAA+hD,EAAAE,EAAAn7E,IAAA,IAC3C,KAAAA,GAAAq7E,EAAqBr7E,EAAAo7E,EAAAh+E,OAAAk+E,IAAqCt7E,EAAAg7E,EAAA74E,KAAA+2B,EAAA+hD,EAAAG,EAAAp7E,IAAA,IAE1D,OAAAg7E,IAGAO,GAAA,SAAAnhD,EAAA/R,GAQA,OAHA4F,GAAAC,EAJAniB,EAAAquB,EAAAh9B,OACAZ,EAAA49B,EAAAruB,EAAA,GACArG,EAAA2iB,EAAA,GAAAvgB,EAAAugB,EAAA,GACA0F,EAAAvxB,EAAA,GAAAwxB,EAAAxxB,EAAA,GAEAg/E,GAAA,EAEAx7E,EAAA,EAAiBA,EAAA+L,IAAO/L,EACxBxD,EAAA49B,EAAAp6B,GAAAiuB,EAAAzxB,EAAA,GAAA0xB,EAAA1xB,EAAA,GACA0xB,EAAApmB,GAAAkmB,EAAAlmB,GAAApC,GAAAqoB,EAAAE,IAAAnmB,EAAAomB,IAAAF,EAAAE,GAAAD,IAAAutD,MACAztD,EAAAE,EAAAD,EAAAE,CAGA,OAAAstD,IAGAC,GAAA,SAAArhD,GAUA,IATA,GAGAtd,GACAC,EAJA/c,GAAA,EACA+L,EAAAquB,EAAAh9B,OACAf,EAAA+9B,EAAAruB,EAAA,GAGAiR,EAAA3gB,EAAA,GACA4gB,EAAA5gB,EAAA,GACAq/E,EAAA,IAEA17E,EAAA+L,GACA+Q,EAAAE,EACAD,EAAAE,EACA5gB,EAAA+9B,EAAAp6B,GACAgd,EAAA3gB,EAAA,GACA4gB,EAAA5gB,EAAA,GACAygB,GAAAE,EACAD,GAAAE,EACAy+D,GAAA50E,KAAAiT,KAAA+C,IAAAC,IAGA,OAAA2+D,IAGAC,MAAAp4E,MAEAmrC,KAcAX,IAAA7zC,UAAA00C,GAAA10C,WACAqC,YAAAwxC,GACA6tC,MAAA,SAAAhvE,GACA,qBAAAA,GAAA,SAAAjR,OAAA,mBACA,IAAA5B,KAAA6kB,MAAA,SAAAjjB,OAAA,oBACA,UAAA5B,KAAA2D,OAAA,MAAA3D,KACA,IAAA+R,GAAA6vE,GAAA/gF,KAAAuC,UAAA,EAIA,OAHA2O,GAAA3J,KAAAyK,KACA7S,KAAAo0C,SAAAp0C,KAAAk0C,OAAA9rC,KAAA2J,GACAyiC,GAAAx0C,MACAA,MAEA00C,MAAA,WAEA,MADA,OAAA10C,KAAA2D,QAAA+wC,GAAA10C,KAAA,GAAA4B,OAAA,UACA5B,MAEA8hF,MAAA,SAAAjvE,GACA,qBAAAA,GAAA,SAAAjR,OAAA,mBACA,IAAA5B,KAAA6kB,MAAA,SAAAjjB,OAAA,iBAGA,OAFA5B,MAAA6kB,MAAA,SAAApkB,EAAAshF,GAA2ClvE,EAAA7N,MAAA,MAAAvE,GAAA2G,OAAA26E,KAC3CntC,GAAA50C,MACAA,MAEAgiF,SAAA,SAAAnvE,GACA,qBAAAA,GAAA,SAAAjR,OAAA,mBACA,IAAA5B,KAAA6kB,MAAA,SAAAjjB,OAAA,iBAGA,OAFA5B,MAAA6kB,MAAAhS,EACA+hC,GAAA50C,MACAA,MA8EA,IAAAiiF,IAAA,WACA,MAAAl1E,MAAAyhC,UAGA0zC,GAAA,QAAAC,GAAA5hF,GACA,QAAA6hF,GAAA9jE,EAAAtR,GAKA,MAJAsR,GAAA,MAAAA,EAAA,GAAAA,EACAtR,EAAA,MAAAA,EAAA,GAAAA,EACA,IAAA5J,UAAAC,QAAA2J,EAAAsR,IAAA,GACAtR,GAAAsR,EACA,WACA,MAAA/d,KAAAyM,EAAAsR,GAMA,MAFA8jE,GAAA7hF,OAAA4hF,EAEAC,GACCH,IAEDznD,GAAA,QAAA6nD,GAAA9hF,GACA,QAAA+hF,GAAAC,EAAAC,GACA,GAAA72E,GAAAiS,CAGA,OAFA2kE,GAAA,MAAAA,EAAA,GAAAA,EACAC,EAAA,MAAAA,EAAA,GAAAA,EACA,WACA,GAAAz0E,EAGA,UAAApC,EAAAoC,EAAApC,IAAA,SAGA,IACAA,EAAA,EAAApL,IAAA,EACAwN,EAAA,EAAAxN,IAAA,EACAqd,EAAAjS,IAAAoC,WACO6P,KAAA,EAEP,OAAA2kE,GAAAC,EAAAz0E,EAAAhB,KAAAiT,MAAA,EAAAjT,KAAAI,IAAAyQ,OAMA,MAFA0kE,GAAA/hF,OAAA8hF,EAEAC,GACCL,IAEDQ,GAAA,QAAAC,GAAAniF,GACA,QAAAoiF,KACA,GAAAL,GAAA9nD,GAAAj6B,UAAAyE,MAAAhF,KAAAoD,UACA,mBACA,MAAA2J,MAAA4W,IAAA2+D,MAMA,MAFAK,GAAApiF,OAAAmiF,EAEAC,GACCV,IAEDW,GAAA,QAAAC,GAAAtiF,GACA,QAAAuiF,GAAA9wE,GACA,kBACA,OAAAw7B,GAAA,EAAAvnC,EAAA,EAA8BA,EAAA+L,IAAO/L,EAAAunC,GAAAjtC,GACrC,OAAAitC,IAMA,MAFAs1C,GAAAviF,OAAAsiF,EAEAC,GACCb,IAEDc,GAAA,QAAAC,GAAAziF,GACA,QAAA0iF,GAAAjxE,GACA,GAAA8wE,GAAAF,GAAAriF,UAAAyR,EACA,mBACA,MAAA8wE,KAAA9wE,GAMA,MAFAixE,GAAA1iF,OAAAyiF,EAEAC,GACChB,IAEDiB,GAAA,QAAAC,GAAA5iF,GACA,QAAA6iF,GAAA3qD,GACA,kBACA,OAAA1rB,KAAAI,IAAA,EAAA5M,KAAAk4B,GAMA,MAFA2qD,GAAA7iF,OAAA4iF,EAEAC,GACCnB,IAEDoB,GAAA,SAAAC,EAAAzwE,GAqBA,QAAA0wE,GAAAvuE,GACA,GAAArP,GAAA69E,EAAAxuC,EAAAwuC,MACA,KAAAA,GAAAvuC,GAAAD,IACAwuC,GAAA,KAAAA,EAAA,KACA,MAAAA,EAAA,CACA,GAAAruC,EACA,IACAxvC,EAAAwvC,EAAAt0C,KAAAwiF,EAAAruC,GACS,MAAA/sC,GAET,WADAmM,GAAAvT,KAAA,QAAAwiF,EAAAp7E,OAIAtC,GAAAqvC,CAEA5gC,GAAAvT,KAAA,OAAAwiF,EAAA19E,OAEAyO,GAAAvT,KAAA,QAAAwiF,EAAAruE,GArCA,GAAAquE,GAEAI,EAKAtuC,EACAD,EAPA9gC,EAAA9I,EAAA,wCAEAo4E,EAAAnxD,KACAyiB,EAAA,GAAA2uC,gBACAC,EAAA,KACAC,EAAA,KAGAr+D,EAAA,CAsHA,IAnHA,mBAAAs+D,iBACA,mBAAA9uC,KACA,oBAAAsE,KAAAgqC,KAAAtuC,EAAA,GAAA8uC,iBAEA,UAAA9uC,GACAA,EAAA+uC,OAAA/uC,EAAAgvC,QAAAhvC,EAAAivC,UAAAV,EACAvuC,EAAAkvC,mBAAA,SAAAlvE,GAA8CggC,EAAAmvC,WAAA,GAAAZ,EAAAvuE,IAuB9CggC,EAAAovC,WAAA,SAAAn8E,GACAmM,EAAAvT,KAAA,WAAAwiF,EAAAp7E,IAGAo7E,GACAgB,OAAA,SAAA7xE,EAAAxQ,GAEA,MADAwQ,MAAA,IAAAoK,cACAxZ,UAAAC,OAAA,EAAAqgF,EAAAhxE,IAAAF,IACA,MAAAxQ,EAAA0hF,EAAA77E,OAAA2K,GACAkxE,EAAA9wE,IAAAJ,EAAAxQ,EAAA,IACAqhF,IAIAI,SAAA,SAAAzhF,GACA,MAAAoB,WAAAC,QACAogF,EAAA,MAAAzhF,EAAA,KAAAA,EAAA,GACAqhF,GAFAI,GAOAvuC,aAAA,SAAAlzC,GACA,MAAAoB,WAAAC,QACA6xC,EAAAlzC,EACAqhF,GAFAnuC,GAKA1vB,QAAA,SAAAxjB,GACA,MAAAoB,WAAAC,QACAmiB,GAAAxjB,EACAqhF,GAFA79D,GAKAo+D,KAAA,SAAA5hF,GACA,MAAAoB,WAAAC,OAAA,EAAAugF,KAAA,MAAA5hF,EAAA,KAAAA,EAAA,GAAAqhF,IAGAQ,SAAA,SAAA7hF,GACA,MAAAoB,WAAAC,OAAA,EAAAwgF,KAAA,MAAA7hF,EAAA,KAAAA,EAAA,GAAAqhF,IAKAluC,SAAA,SAAAnzC,GAEA,MADAmzC,GAAAnzC,EACAqhF,GAIA3wE,IAAA,SAAA9C,EAAAiD,GACA,MAAAwwE,GAAAiB,KAAA,MAAA10E,EAAAiD,IAIA0xE,KAAA,SAAA30E,EAAAiD,GACA,MAAAwwE,GAAAiB,KAAA,OAAA10E,EAAAiD,IAIAyxE,KAAA,SAAAE,EAAA50E,EAAAiD,GAYA,MAXAmiC,GAAAyvC,KAAAD,EAAAlB,GAAA,EAAAM,EAAAC,GACA,MAAAJ,GAAAC,EAAA/tC,IAAA,WAAA+tC,EAAA9wE,IAAA,SAAA6wE,EAAA,QACAzuC,EAAA0vC,kBAAAhB,EAAAnyE,KAAA,SAAAvP,EAAAwQ,GAAoEwiC,EAAA0vC,iBAAAlyE,EAAAxQ,KACpE,MAAAyhF,GAAAzuC,EAAA2vC,kBAAA3vC,EAAA2vC,iBAAAlB,GACA,MAAAvuC,IAAAF,EAAAE,gBACA1vB,EAAA,IAAAwvB,EAAAxvB,WACA,MAAA3S,GAAA,kBAAAjD,KAAAiD,EAAAjD,IAAA,MACA,MAAAiD,GAAA,IAAAA,EAAAxP,SAAAwP,EAAAkiC,GAAAliC,IACA,MAAAA,GAAAwwE,EAAAvuE,GAAA,QAAAjC,GAAAiC,GAAA,gBAAAkgC,GAAoFniC,EAAA,KAAAmiC,KACpF5gC,EAAAvT,KAAA,aAAAwiF,EAAAruC,GACAA,EAAAsvC,KAAA,MAAA10E,EAAA,KAAAA,GACAyzE,GAGA3uC,MAAA,WAEA,MADAM,GAAAN,QACA2uC,GAGAvuE,GAAA,WACA,GAAA9S,GAAAoS,EAAAU,GAAA9P,MAAAoP,EAAAhR,UACA,OAAApB,KAAAoS,EAAAivE,EAAArhF,IAIA,MAAA6Q,EAAA,CACA,qBAAAA,GAAA,SAAAjR,OAAA,qBAAAiR,EACA,OAAAwwE,GAAA3wE,IAAAG,GAGA,MAAAwwE,IAgBAuB,GAAA,SAAAC,EAAA1vC,GACA,gBAAAmuC,EAAAzwE,GACA,GAAA+K,GAAAylE,GAAAC,GAAAG,SAAAoB,GAAA1vC,WACA,UAAAtiC,EAAA,CACA,qBAAAA,GAAA,SAAAjR,OAAA,qBAAAiR,EACA,OAAA+K,GAAAlL,IAAAG,GAEA,MAAA+K,KAIAw9C,GAAAwpB,GAAA,qBAAA5vC,GACA,MAAAhiC,UAAA8xE,cAAAC,yBAAA/vC,EAAAI,gBAGA4vC,GAAAJ,GAAA,4BAAA5vC,GACA,MAAA9hB,MAAAxQ,MAAAsyB,EAAAI,gBAGA7kC,GAAAq0E,GAAA,sBAAA5vC,GACA,MAAAA,GAAAI,eAGAihB,GAAAuuB,GAAA,2BAAA5vC,GACA,GAAAqhB,GAAArhB,EAAAiwC,WACA,KAAA5uB,EAAA,SAAAz0D,OAAA,cACA,OAAAy0D,KAGA6uB,GAAA,SAAAL,EAAAniE,GACA,gBAAA4gE,EAAAjwD,EAAAxgB,GACAzP,UAAAC,OAAA,IAAAwP,EAAAwgB,IAAA,KACA,IAAAzV,GAAAylE,GAAAC,GAAAG,SAAAoB,EAGA,OAFAjnE,GAAAyV,IAAA,SAAA7hB,GAAyB,MAAApO,WAAAC,OAAAua,EAAAu3B,SAAAE,GAAA3yB,EAAA2Q,EAAA7hB,IAAA6hB,GACzBzV,EAAAyV,OACAxgB,EAAA+K,EAAAlL,IAAAG,GAAA+K,IAUAunE,GAAAD,GAAA,WAAAhV,IAEAkV,GAAAF,GAAA,4BAAA3U,IAEA8U,GAAA35E,MAAAvL,UAEA+2C,GAAAmuC,GAAA9yE,IACAmjC,GAAA2vC,GAAA77E,MAEAisC,IAAgBjjC,KAAA,YA+IhB6jC,GAAA,SAAA1qC,GACA,kBACA,MAAAA,KAIAwrC,GAAA,SAAAxrC,GACA,OAAAA,GAGAsrC,IAAA,KA4GAjoC,GAAA,SAAAF,EAAAtD,EAAAkqB,GACA,GAGAS,GAHAvpB,EAAAkC,EAAA,GACAjC,EAAAiC,IAAAzL,OAAA,GACAyJ,EAAAW,EAAAb,EAAAC,EAAA,MAAArB,EAAA,GAAAA,EAGA,QADAkqB,EAAAD,GAAA,MAAAC,EAAA,KAAAA,GACAA,EAAAjjB,MACA,QACA,GAAAzQ,GAAA+K,KAAAC,IAAAD,KAAAY,IAAAf,GAAAG,KAAAY,IAAAd,GAEA,OADA,OAAA6oB,EAAAS,WAAA9U,MAAA8U,EAAAqgD,GAAA1pE,EAAA9K,MAAA0zB,EAAAS,aACA12B,EAAA+2B,aAAAd,EAAA1zB,EAEA,QACA,QACA,QACA,QACA,QACA,MAAA0zB,EAAAS,WAAA9U,MAAA8U,EAAAsgD,GAAA3pE,EAAAC,KAAAC,IAAAD,KAAAY,IAAAf,GAAAG,KAAAY,IAAAd,QAAA6oB,EAAAS,aAAA,MAAAT,EAAAjjB,MACA,MAEA,SACA,QACA,MAAAijB,EAAAS,WAAA9U,MAAA8U,EAAAogD,GAAAzpE,MAAA4oB,EAAAS,YAAA,SAAAT,EAAAjjB,OAIA,MAAAhT,GAAAsP,OAAA2mB,IAwFA4hB,GAAA,SAAAxoC,EAAAkX,GACAlX,IAAAtF,OAEA,IAIAuI,GAJAwhC,EAAA,EACAC,EAAA1kC,EAAAzL,OAAA,EACA2wB,EAAAllB,EAAAykC,GACArf,EAAAplB,EAAA0kC,EAUA,OAPAtf,GAAAF,IACAjiB,EAAAwhC,IAAAC,IAAAzhC,EACAA,EAAAiiB,IAAAE,IAAAniB,GAGAjD,EAAAykC,GAAAvtB,EAAA9Y,MAAA8mB,GACAllB,EAAA0kC,GAAAxtB,EAAAqd,KAAAnP,GACAplB,GA4RA0qC,GAAA,GAAAH,MACAI,GAAA,GAAAJ,MAmEAisC,GAAAtsC,GAAA,aAEC,SAAAI,EAAAtsC,GACDssC,EAAAG,SAAAH,EAAAtsC,IACC,SAAAF,EAAAoX,GACD,MAAAA,GAAApX,GAIA04E,IAAAt8D,MAAA,SAAAtY,GAEA,MADAA,GAAA3D,KAAAG,MAAAwD,GACAK,SAAAL,MAAA,EACAA,EAAA,EACAsoC,GAAA,SAAAI,GACAA,EAAAG,QAAAxsC,KAAAG,MAAAksC,EAAA1oC,OACG,SAAA0oC,EAAAtsC,GACHssC,EAAAG,SAAAH,EAAAtsC,EAAA4D,IACG,SAAA9D,EAAAoX,GACH,OAAAA,EAAApX,GAAA8D,IANA40E,GADA,KAWA,IAAAC,IAAAD,GAAAj2E,MAGA2qC,GAAA,IAGAC,GAAA,OAEAurC,GAAAxsC,GAAA,SAAAI,GACAA,EAAAG,QAPA,IAOAxsC,KAAAG,MAAAksC,EAPA,OAQC,SAAAA,EAAAtsC,GACDssC,EAAAG,SAAAH,EATA,IASAtsC,IACC,SAAAF,EAAAoX,GACD,OAAAA,EAAApX,GAXA,KAYC,SAAAwsC,GACD,MAAAA,GAAA6J,kBAGAwiC,GAAAD,GAAAn2E,MAEAq2E,GAAA1sC,GAAA,SAAAI,GACAA,EAAAG,QAAAxsC,KAAAG,MAAAksC,EAAAY,SACC,SAAAZ,EAAAtsC,GACDssC,EAAAG,SAAAH,EAAAtsC,EAAAktC,KACC,SAAAptC,EAAAoX,GACD,OAAAA,EAAApX,GAAAotC,IACC,SAAAZ,GACD,MAAAA,GAAAoJ,eAGAmjC,GAAAD,GAAAr2E,MAEAu2E,GAAA5sC,GAAA,SAAAI,GACA,GAAAjrC,GAAAirC,EAAAW,oBAAAC,GA7BA,IA8BA7rC,GAAA,IAAAA,GA9BA,MA+BAirC,EAAAG,QA/BA,KA+BAxsC,KAAAG,QAAAksC,EAAAjrC,GA/BA,MA+BAA,IACC,SAAAirC,EAAAtsC,GACDssC,EAAAG,SAAAH,EAjCA,KAiCAtsC,IACC,SAAAF,EAAAoX,GACD,OAAAA,EAAApX,GAnCA,MAoCC,SAAAwsC,GACD,MAAAA,GAAA2E,aAGA8nC,GAAAD,GAAAv2E,MAEAgzC,GAAArJ,GAAA,SAAAI,GACAA,EAAAU,SAAA,UACC,SAAAV,EAAAtsC,GACDssC,EAAAO,QAAAP,EAAAQ,UAAA9sC,IACC,SAAAF,EAAAoX,GACD,OAAAA,EAAApX,GAAAoX,EAAA+1B,oBAAAntC,EAAAmtC,qBAAAC,IA9CA,OA+CC,SAAAZ,GACD,MAAAA,GAAAQ,UAAA,IAGA6E,GAAA4D,GAAAhzC,MAaAqzC,GAAAhJ,GAAA,GACAiJ,GAAAjJ,GAAA,GACAosC,GAAApsC,GAAA,GACAqsC,GAAArsC,GAAA,GACAssC,GAAAtsC,GAAA,GACAusC,GAAAvsC,GAAA,GACAwsC,GAAAxsC,GAAA,GAEAysC,GAAAzjC,GAAArzC,MACA+2E,GAAAzjC,GAAAtzC,MACAg3E,GAAAP,GAAAz2E,MACAi3E,GAAAP,GAAA12E,MACAk3E,GAAAP,GAAA32E,MACAm3E,GAAAP,GAAA52E,MACAo3E,GAAAP,GAAA72E,MAEAq3E,GAAA1tC,GAAA,SAAAI,GACAA,EAAAO,QAAA,GACAP,EAAAU,SAAA,UACC,SAAAV,EAAAtsC,GACDssC,EAAAutC,SAAAvtC,EAAAsE,WAAA5wC,IACC,SAAAF,EAAAoX,GACD,MAAAA,GAAA05B,WAAA9wC,EAAA8wC,WAAA,IAAA15B,EAAA4+B,cAAAh2C,EAAAg2C,gBACC,SAAAxJ,GACD,MAAAA,GAAAsE,aAGAiB,GAAA+nC,GAAAr3E,MAEAizC,GAAAtJ,GAAA,SAAAI,GACAA,EAAAutC,SAAA,KACAvtC,EAAAU,SAAA,UACC,SAAAV,EAAAtsC,GACDssC,EAAAuB,YAAAvB,EAAAwJ,cAAA91C,IACC,SAAAF,EAAAoX,GACD,MAAAA,GAAA4+B,cAAAh2C,EAAAg2C,eACC,SAAAxJ,GACD,MAAAA,GAAAwJ,eAIAN,IAAAt5B,MAAA,SAAAtY,GACA,MAAAK,UAAAL,EAAA3D,KAAAG,MAAAwD,OAAA,EAAAsoC,GAAA,SAAAI,GACAA,EAAAuB,YAAA5tC,KAAAG,MAAAksC,EAAAwJ,cAAAlyC,MACA0oC,EAAAutC,SAAA,KACAvtC,EAAAU,SAAA,UACG,SAAAV,EAAAtsC,GACHssC,EAAAuB,YAAAvB,EAAAwJ,cAAA91C,EAAA4D,KALA,KASA,IAAAk2E,IAAAtkC,GAAAjzC,MAEAw3E,GAAA7tC,GAAA,SAAAI,GACAA,EAAA0tC,cAAA,MACC,SAAA1tC,EAAAtsC,GACDssC,EAAAG,SAAAH,EAAAtsC,EAAAktC,KACC,SAAAptC,EAAAoX,GACD,OAAAA,EAAApX,GAAAotC,IACC,SAAAZ,GACD,MAAAA,GAAA4J,kBAGA+jC,GAAAF,GAAAx3E,MAEA23E,GAAAhuC,GAAA,SAAAI,GACAA,EAAA6tC,cAAA,QACC,SAAA7tC,EAAAtsC,GACDssC,EAAAG,SAAAH,EArIA,KAqIAtsC,IACC,SAAAF,EAAAoX,GACD,OAAAA,EAAApX,GAvIA,MAwIC,SAAAwsC,GACD,MAAAA,GAAAkF,gBAGA4oC,GAAAF,GAAA33E,MAEAwzC,GAAA7J,GAAA,SAAAI,GACAA,EAAAkB,YAAA,UACC,SAAAlB,EAAAtsC,GACDssC,EAAAe,WAAAf,EAAAgB,aAAAttC,IACC,SAAAF,EAAAoX,GACD,OAAAA,EAAApX,GAlJA,OAmJC,SAAAwsC,GACD,MAAAA,GAAAgB,aAAA,IAGA+sC,GAAAtkC,GAAAxzC,MAaA6zC,GAAAhJ,GAAA,GACAiJ,GAAAjJ,GAAA,GACAktC,GAAAltC,GAAA,GACAmtC,GAAAntC,GAAA,GACAotC,GAAAptC,GAAA,GACAqtC,GAAArtC,GAAA,GACAstC,GAAAttC,GAAA,GAEAutC,GAAAvkC,GAAA7zC,MACAq4E,GAAAvkC,GAAA9zC,MACAs4E,GAAAP,GAAA/3E,MACAu4E,GAAAP,GAAAh4E,MACAw4E,GAAAP,GAAAj4E,MACAy4E,GAAAP,GAAAl4E,MACA04E,GAAAP,GAAAn4E,MAEA24E,GAAAhvC,GAAA,SAAAI,GACAA,EAAAe,WAAA,GACAf,EAAAkB,YAAA,UACC,SAAAlB,EAAAtsC,GACDssC,EAAA6uC,YAAA7uC,EAAA+E,cAAArxC,IACC,SAAAF,EAAAoX,GACD,MAAAA,GAAAm6B,cAAAvxC,EAAAuxC,cAAA,IAAAn6B,EAAAo/B,iBAAAx2C,EAAAw2C,mBACC,SAAAhK,GACD,MAAAA,GAAA+E,gBAGA+pC,GAAAF,GAAA34E,MAEAyzC,GAAA9J,GAAA,SAAAI,GACAA,EAAA6uC,YAAA,KACA7uC,EAAAkB,YAAA,UACC,SAAAlB,EAAAtsC,GACDssC,EAAA0B,eAAA1B,EAAAgK,iBAAAt2C,IACC,SAAAF,EAAAoX,GACD,MAAAA,GAAAo/B,iBAAAx2C,EAAAw2C,kBACC,SAAAhK,GACD,MAAAA,GAAAgK,kBAIAN,IAAA95B,MAAA,SAAAtY,GACA,MAAAK,UAAAL,EAAA3D,KAAAG,MAAAwD,OAAA,EAAAsoC,GAAA,SAAAI,GACAA,EAAA0B,eAAA/tC,KAAAG,MAAAksC,EAAAgK,iBAAA1yC,MACA0oC,EAAA6uC,YAAA,KACA7uC,EAAAkB,YAAA,UACG,SAAAlB,EAAAtsC,GACHssC,EAAA0B,eAAA1B,EAAAgK,iBAAAt2C,EAAA4D,KALA,KASA,IAkhBA4yC,IAlhBA6kC,GAAArlC,GAAAzzC,MA2TAisC,IAAY8sC,IAAA,GAAA52E,EAAA,IAAA62E,EAAA,KACZlmC,GAAA,UACAC,GAAA,KACAH,GAAA,iCA0NAoB,KACA9E,SAAA,SACAnF,KAAA,aACAn0B,KAAA,eACAu5B,SAAA,WACAC,MAAA,wEACAC,WAAA,2CACAC,QAAA,+GACAC,aAAA,0EAYA,IAMA0pC,IAAAjvC,KAAAl5C,UAAAujD,YACAD,GACAhkD,EAAAoiD,UARA,yBAeA0mC,IAAA,GAAAlvC,MAAA,4BACAsK,GACAlkD,EAAAqiD,SAjBA,yBAmBAoD,GAAA,IACAC,GAAA,GAAAD,GACAE,GAAA,GAAAD,GACAE,GAAA,GAAAD,GACAE,GAAA,EAAAD,GACAE,GAAA,GAAAF,GACAJ,GAAA,IAAAI,GAsHApgC,GAAA,WACA,MAAA6+B,IAAAxB,GAAAokC,GAAAhkC,GAAAL,GAAAujC,GAAAF,GAAAF,GAAAF,GAAA7lF,EAAA8jD,YAAAz0C,QAAA,GAAAuqC,MAAA,YAAAA,MAAA,YAGAmvC,GAAA,WACA,MAAA1kC,IAAAhB,GAAAklC,GAAA9kC,GAAAL,GAAAmkC,GAAAH,GAAArB,GAAAF,GAAA7lF,EAAAoiD,WAAA/yC,QAAAuqC,KAAAwB,IAAA,SAAAxB,KAAAwB,IAAA,YAGAn5B,GAAA,SAAAxD,GACA,MAAAA,GAAA0X,MAAA,SAAsBrjB,IAAA,SAAA5G,GACtB,UAAAA,KAIA88E,GAAA/mE,GAAA,gEAEAgnE,GAAAhnE,GAAA,4HAEAinE,GAAAjnE,GAAA,4HAEAknE,GAAAlnE,GAAA,4HAEAmnE,GAAAtgB,GAAA5nD,GAAA,UAAAA,IAAA,WAEAmoE,GAAAvgB,GAAA5nD,IAAA,aAAAA,GAAA,YAEAooE,GAAAxgB,GAAA5nD,GAAA,aAAAA,GAAA,YAEAqoE,GAAAroE,KAEAsoE,GAAA,SAAAl3E,IACAA,EAAA,GAAAA,EAAA,KAAAA,GAAAhF,KAAAG,MAAA6E,GACA,IAAAm3E,GAAAn8E,KAAAY,IAAAoE,EAAA,GAIA,OAHAi3E,IAAA/qE,EAAA,IAAAlM,EAAA,IACAi3E,GAAA9qE,EAAA,QAAAgrE,EACAF,GAAA7qE,EAAA,MAAA+qE,EACAF,GAAA,IAUAG,GAAA3jC,GAAA9jC,GAAA,qgDAEA0nE,GAAA5jC,GAAA9jC,GAAA,qgDAEA2nE,GAAA7jC,GAAA9jC,GAAA,qgDAEA4nE,GAAA9jC,GAAA9jC,GAAA,qgDA+BAqnC,GAAA,SAAAp9C,GACA,kBACA,MAAAA,KAIA49E,GAAAx8E,KAAAY,IACA67E,GAAAz8E,KAAA+S,MACA2pE,GAAA18E,KAAAgS,IACAwoC,GAAAx6C,KAAAC,IACA08E,GAAA38E,KAAAuR,IACAqrE,GAAA58E,KAAAiS,IACAkoC,GAAAn6C,KAAAiT,KAEA6qC,GAAA,MACAjF,GAAA74C,KAAAo5D,GACArgB,GAAAF,GAAA,EACAgkC,GAAA,EAAAhkC,GAgFAqK,GAAA,WAUA,QAAAA,KACA,GAAArH,GACAhrC,EACAqtB,GAAA+a,EAAAhhD,MAAAhF,KAAAoD,WACA+rC,GAAA+W,EAAAlhD,MAAAhF,KAAAoD,WACAk9B,EAAAnO,EAAAntB,MAAAhF,KAAAoD,WAAA0iD,GACAlmB,EAAAvN,EAAArtB,MAAAhF,KAAAoD,WAAA0iD,GACAzV,EAAAk5C,GAAA3pD,EAAAU,GACAwmB,EAAAlnB,EAAAU,CAQA,IANAl8B,MAAAwkD,EAAAl5C,MAGAy/B,EAAAlE,IAAArtB,EAAAuxB,IAAAlE,IAAArtB,GAGAuxB,EAAA0b,GAGA,GAAAxa,EAAAu5C,GAAA/+B,GACAzmD,EAAA6kD,OAAA9Z,EAAAs6C,GAAAnpD,GAAA6O,EAAAw6C,GAAArpD,IACAl8B,EAAA6rD,IAAA,IAAA9gB,EAAA7O,EAAAV,GAAAknB,GACA7b,EAAA4f,KACAzmD,EAAA6kD,OAAAhe,EAAAw+C,GAAA7pD,GAAAqL,EAAA0+C,GAAA/pD,IACAx7B,EAAA6rD,IAAA,IAAAhlB,EAAArL,EAAAU,EAAAwmB,QAKA,CACA,GAWArnC,GACAE,EAZAkqE,EAAAvpD,EACAwpD,EAAAlqD,EACA4J,EAAAlJ,EACAypD,EAAAnqD,EACAoqD,EAAA35C,EACA45C,EAAA55C,EACA65C,EAAA5jC,EAAAthD,MAAAhF,KAAAoD,WAAA,EACA+mF,EAAAD,EAAAr/B,KAAAu/B,KAAAplF,MAAAhF,KAAAoD,WAAA8jD,GAAAjc,IAAAkE,MACA0X,EAAA6iC,GAAAH,GAAAp6C,EAAAlE,GAAA,GAAAo/C,EAAArlF,MAAAhF,KAAAoD,YACAknF,EAAAzjC,EACA0jC,EAAA1jC,CAKA,IAAAsjC,EAAAt/B,GAAA,CACA,GAAAtwB,GAAAsrB,GAAAskC,EAAAl/C,EAAA0+C,GAAAO,IACA5gC,EAAAzD,GAAAskC,EAAAh7C,EAAAw6C,GAAAO,KACAF,GAAA,EAAAzvD,GAAAswB,IAAAtwB,GAAAusB,EAAA,KAAAtd,GAAAjP,EAAAwvD,GAAAxvD,IACAyvD,EAAA,EAAAxgD,EAAAugD,GAAAzpD,EAAAV,GAAA,IACAqqD,GAAA,EAAA3gC,GAAAuB,IAAAvB,GAAAxC,EAAA,KAAA+iC,GAAAvgC,EAAAwgC,GAAAxgC,IACA2gC,EAAA,EAAAJ,EAAAC,GAAAxpD,EAAAV,GAAA,GAGA,GAAAmnB,GAAA5X,EAAAs6C,GAAAI,GACA7iC,EAAA7X,EAAAw6C,GAAAE,GACArjC,EAAAvb,EAAAw+C,GAAAM,GACAtjC,EAAAxb,EAAA0+C,GAAAI,EAGA,IAAAljC,EAAAgE,GAAA,CACA,GAAAxD,GAAAlY,EAAAs6C,GAAAK,GACAxiC,EAAAnY,EAAAw6C,GAAAG,GACA3lD,EAAA8G,EAAAw+C,GAAAjgD,GACAnF,EAAA4G,EAAA0+C,GAAAngD,EAGA,IAAA6G,EAAAuV,GAAA,CACA,GAAA4kC,GAAAR,EAAAn/B,GAAAtE,GAAAQ,EAAAC,EAAA7iB,EAAAE,EAAAgjB,EAAAC,EAAAd,EAAAC,IAAAD,EAAAC,GACAtW,EAAA4W,EAAAyjC,EAAA,GACAp6C,EAAA4W,EAAAwjC,EAAA,GACA18B,EAAAzG,EAAAmjC,EAAA,GACAz8B,EAAAzG,EAAAkjC,EAAA,GACAC,EAAA,EAAAd,GAAAhkC,IAAAxV,EAAA2d,EAAA1d,EAAA2d,IAAA7G,GAAA/W,IAAAC,KAAA8W,GAAA4G,IAAAC,OAAA,GACA28B,EAAAxjC,GAAAsjC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAF,GAAAZ,GAAA7iC,GAAA5b,EAAAy/C,IAAAD,EAAA,IACAF,EAAAb,GAAA7iC,GAAA1X,EAAAu7C,IAAAD,EAAA,KAKAR,EAAAp/B,GAGA0/B,EAAA1/B,IACAprC,EAAAmnC,GAAAziB,EAAAE,EAAA0iB,EAAAC,EAAA7X,EAAAo7C,EAAAzjC,GACAnnC,EAAAinC,GAAAS,EAAAC,EAAAd,EAAAC,EAAAtX,EAAAo7C,EAAAzjC,GAEA1iD,EAAA6kD,OAAAxpC,EAAA8d,GAAA9d,EAAAsnC,IAAAtnC,EAAA+d,GAAA/d,EAAAunC,KAGAujC,EAAA1jC,EAAAziD,EAAA6rD,IAAAxwC,EAAA8d,GAAA9d,EAAA+d,GAAA+sD,EAAAf,GAAA/pE,EAAAunC,IAAAvnC,EAAAsnC,KAAAyiC,GAAA7pE,EAAAqnC,IAAArnC,EAAAonC,MAAAD,IAIA1iD,EAAA6rD,IAAAxwC,EAAA8d,GAAA9d,EAAA+d,GAAA+sD,EAAAf,GAAA/pE,EAAAunC,IAAAvnC,EAAAsnC,KAAAyiC,GAAA/pE,EAAA6nC,IAAA7nC,EAAA4nC,MAAAP,GACA1iD,EAAA6rD,IAAA,IAAA9gB,EAAAq6C,GAAA/pE,EAAA+d,GAAA/d,EAAA6nC,IAAA7nC,EAAA8d,GAAA9d,EAAA4nC,KAAAmiC,GAAA7pE,EAAA6d,GAAA7d,EAAA2nC,IAAA3nC,EAAA4d,GAAA5d,EAAA0nC,MAAAP,GACA1iD,EAAA6rD,IAAAtwC,EAAA4d,GAAA5d,EAAA6d,GAAA+sD,EAAAf,GAAA7pE,EAAA2nC,IAAA3nC,EAAA0nC,KAAAmiC,GAAA7pE,EAAAqnC,IAAArnC,EAAAonC,MAAAD,MAKA1iD,EAAA6kD,OAAAlC,EAAAC,GAAA5iD,EAAA6rD,IAAA,IAAA9gB,EAAA06C,EAAAC,GAAAhjC,IArBA1iD,EAAA6kD,OAAAlC,EAAAC,GAyBA/b,EAAA4f,IAAAm/B,EAAAn/B,GAGAy/B,EAAAz/B,IACAprC,EAAAmnC,GAAAJ,EAAAC,EAAAY,EAAAC,EAAArc,GAAAq/C,EAAAxjC,GACAnnC,EAAAinC,GAAAG,EAAAC,EAAA7iB,EAAAE,EAAA4G,GAAAq/C,EAAAxjC,GAEA1iD,EAAA+oE,OAAA1tD,EAAA8d,GAAA9d,EAAAsnC,IAAAtnC,EAAA+d,GAAA/d,EAAAunC,KAGAsjC,EAAAzjC,EAAAziD,EAAA6rD,IAAAxwC,EAAA8d,GAAA9d,EAAA+d,GAAA8sD,EAAAd,GAAA/pE,EAAAunC,IAAAvnC,EAAAsnC,KAAAyiC,GAAA7pE,EAAAqnC,IAAArnC,EAAAonC,MAAAD,IAIA1iD,EAAA6rD,IAAAxwC,EAAA8d,GAAA9d,EAAA+d,GAAA8sD,EAAAd,GAAA/pE,EAAAunC,IAAAvnC,EAAAsnC,KAAAyiC,GAAA/pE,EAAA6nC,IAAA7nC,EAAA4nC,MAAAP,GACA1iD,EAAA6rD,IAAA,IAAAhlB,EAAAu+C,GAAA/pE,EAAA+d,GAAA/d,EAAA6nC,IAAA7nC,EAAA8d,GAAA9d,EAAA4nC,KAAAmiC,GAAA7pE,EAAA6d,GAAA7d,EAAA2nC,IAAA3nC,EAAA4d,GAAA5d,EAAA0nC,KAAAP,GACA1iD,EAAA6rD,IAAAtwC,EAAA4d,GAAA5d,EAAA6d,GAAA8sD,EAAAd,GAAA7pE,EAAA2nC,IAAA3nC,EAAA0nC,KAAAmiC,GAAA7pE,EAAAqnC,IAAArnC,EAAAonC,MAAAD,KAKA1iD,EAAA6rD,IAAA,IAAAhlB,EAAA8+C,EAAAvgD,EAAAsd,GArBA1iD,EAAA+oE,OAAA3mB,EAAAC,OA1FAriD,GAAA6kD,OAAA,IAoHA,IAFA7kD,EAAA8oE,YAEAtkB,EAAA,MAAAxkD,GAAA,KAAAwkD,EAAA,SA7IA,GAAA5C,GAAAD,GACAG,EAAAD,GACAokC,EAAAthC,GAAA,GACAqhC,EAAA,KACAj4D,EAAAg0B,GACA9zB,EAAA+zB,GACAE,EAAAD,GACAjiD,EAAA,IA+KA,OAtCA6rD,GAAA6nB,SAAA,WACA,GAAAl6D,KAAAooC,EAAAhhD,MAAAhF,KAAAoD,aAAA8iD,EAAAlhD,MAAAhF,KAAAoD,YAAA,EACAsJ,IAAAylB,EAAAntB,MAAAhF,KAAAoD,aAAAivB,EAAArtB,MAAAhF,KAAAoD,YAAA,EAAAwiD,GAAA,CACA,QAAA6jC,GAAA/8E,GAAAkR,EAAA+rE,GAAAj9E,GAAAkR,IAGAqyC,EAAAjK,YAAA,SAAAx0C,GACA,MAAApO,WAAAC,QAAA2iD,EAAA,kBAAAx0C,KAAAu3C,IAAAv3C,GAAAy+C,GAAAjK,GAGAiK,EAAA/J,YAAA,SAAA10C,GACA,MAAApO,WAAAC,QAAA6iD,EAAA,kBAAA10C,KAAAu3C,IAAAv3C,GAAAy+C,GAAA/J,GAGA+J,EAAAo6B,aAAA,SAAA74E,GACA,MAAApO,WAAAC,QAAAgnF,EAAA,kBAAA74E,KAAAu3C,IAAAv3C,GAAAy+C,GAAAo6B,GAGAp6B,EAAAm6B,UAAA,SAAA54E,GACA,MAAApO,WAAAC,QAAA+mF,EAAA,MAAA54E,EAAA,uBAAAA,KAAAu3C,IAAAv3C,GAAAy+C,GAAAm6B,GAGAn6B,EAAA99B,WAAA,SAAA3gB,GACA,MAAApO,WAAAC,QAAA8uB,EAAA,kBAAA3gB,KAAAu3C,IAAAv3C,GAAAy+C,GAAA99B,GAGA89B,EAAA59B,SAAA,SAAA7gB,GACA,MAAApO,WAAAC,QAAAgvB,EAAA,kBAAA7gB,KAAAu3C,IAAAv3C,GAAAy+C,GAAA59B,GAGA49B,EAAA3J,SAAA,SAAA90C,GACA,MAAApO,WAAAC,QAAAijD,EAAA,kBAAA90C,KAAAu3C,IAAAv3C,GAAAy+C,GAAA3J,GAGA2J,EAAA7rD,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAAe,EAAA,MAAAoN,EAAA,KAAAA,EAAAy+C,GAAA7rD,GAGA6rD,EAOAlI,IAAA5nD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAAq5E,OAAA,GAEAvhD,QAAA,YACA93B,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,CACA,SAAAr5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,KAKA,IAAA88E,IAAA,SAAAzmF,GACA,UAAA2jD,IAAA3jD,IAWAiM,GAAA,WAQA,QAAAA,GAAAT,GACA,GAAA3J,GAEA5D,EAEAumD,EAHA52C,EAAApC,EAAAvM,OAEAynF,GAAA,CAKA,KAFA,MAAA1mF,IAAA0oB,EAAAq7B,EAAAS,EAAAl5C,OAEAzJ,EAAA,EAAeA,GAAA+L,IAAQ/L,IACvBA,EAAA+L,GAAA+4E,EAAA1oF,EAAAuN,EAAA3J,KAAA2J,MAAAk7E,KACAA,MAAAh+D,EAAA+K,YACA/K,EAAAgL,WAEAgzD,GAAAh+D,EAAAwB,OAAA3iB,EAAAtJ,EAAA4D,EAAA2J,IAAA7B,EAAA1L,EAAA4D,EAAA2J,GAGA,IAAAg5C,EAAA,MAAA97B,GAAA,KAAA87B,EAAA,SAxBA,GAAAj9C,GAAAq8C,GACAj6C,EAAAk6C,GACA8iC,EAAAhiC,IAAA,GACA3kD,EAAA,KACA+jD,EAAA0iC,GACA/9D,EAAA,IA0CA,OApBAzc,GAAA1E,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAAsI,EAAA,kBAAA6F,KAAAu3C,IAAAv3C,GAAAnB,GAAA1E,GAGA0E,EAAAtC,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA0K,EAAA,kBAAAyD,KAAAu3C,IAAAv3C,GAAAnB,GAAAtC,GAGAsC,EAAA06E,QAAA,SAAAv5E,GACA,MAAApO,WAAAC,QAAA0nF,EAAA,kBAAAv5E,KAAAu3C,KAAAv3C,GAAAnB,GAAA06E,GAGA16E,EAAA83C,MAAA,SAAA32C,GACA,MAAApO,WAAAC,QAAA8kD,EAAA32C,EAAA,MAAApN,IAAA0oB,EAAAq7B,EAAA/jD,IAAAiM,GAAA83C,GAGA93C,EAAAjM,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAA,MAAAmO,EAAApN,EAAA0oB,EAAA,KAAAA,EAAAq7B,EAAA/jD,EAAAoN,GAAAnB,GAAAjM,GAGAiM,GAGA26E,GAAA,WAUA,QAAAtT,GAAA9nE,GACA,GAAA3J,GACAgP,EACAvE,EAEArO,EAEAumD,EAHA52C,EAAApC,EAAAvM,OAEAynF,GAAA,EAEAG,EAAA,GAAAv/E,OAAAsG,GACAk5E,EAAA,GAAAx/E,OAAAsG,EAIA,KAFA,MAAA5N,IAAA0oB,EAAAq7B,EAAAS,EAAAl5C,OAEAzJ,EAAA,EAAeA,GAAA+L,IAAQ/L,EAAA,CACvB,KAAAA,EAAA+L,GAAA+4E,EAAA1oF,EAAAuN,EAAA3J,KAAA2J,MAAAk7E,EACA,GAAAA,KACA71E,EAAAhP,EACA6mB,EAAA69D,YACA79D,EAAA+K,gBACS,CAGT,IAFA/K,EAAAgL,UACAhL,EAAA+K,YACAnnB,EAAAzK,EAAA,EAAyByK,GAAAuE,IAAQvE,EACjCoc,EAAAwB,MAAA28D,EAAAv6E,GAAAw6E,EAAAx6E,GAEAoc,GAAAgL,UACAhL,EAAA89D,UAGAE,IACAG,EAAAhlF,IAAA+tB,EAAA3xB,EAAA4D,EAAA2J,GAAAs7E,EAAAjlF,IAAAguB,EAAA5xB,EAAA4D,EAAA2J,GACAkd,EAAAwB,MAAA4F,KAAA7xB,EAAA4D,EAAA2J,GAAAq7E,EAAAhlF,GAAAkuB,KAAA9xB,EAAA4D,EAAA2J,GAAAs7E,EAAAjlF,KAIA,GAAA2iD,EAAA,MAAA97B,GAAA,KAAA87B,EAAA,SAGA,QAAAuiC,KACA,MAAA96E,MAAA06E,WAAA5iC,SAAA/jD,WAhDA,GAAA4vB,GAAAg0B,GACA9zB,EAAA,KACAD,EAAA80B,GAAA,GACA50B,EAAA8zB,GACA8iC,EAAAhiC,IAAA,GACA3kD,EAAA,KACA+jD,EAAA0iC,GACA/9D,EAAA,IA6FA,OAjDA4qD,GAAA/rE,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAA2wB,EAAA,kBAAAxiB,KAAAu3C,IAAAv3C,GAAA0iB,EAAA,KAAAwjD,GAAA1jD,GAGA0jD,EAAA1jD,GAAA,SAAAxiB,GACA,MAAApO,WAAAC,QAAA2wB,EAAA,kBAAAxiB,KAAAu3C,IAAAv3C,GAAAkmE,GAAA1jD,GAGA0jD,EAAAxjD,GAAA,SAAA1iB,GACA,MAAApO,WAAAC,QAAA6wB,EAAA,MAAA1iB,EAAA,uBAAAA,KAAAu3C,IAAAv3C,GAAAkmE,GAAAxjD,GAGAwjD,EAAA3pE,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA4wB,EAAA,kBAAAziB,KAAAu3C,IAAAv3C,GAAA2iB,EAAA,KAAAujD,GAAAzjD,GAGAyjD,EAAAzjD,GAAA,SAAAziB,GACA,MAAApO,WAAAC,QAAA4wB,EAAA,kBAAAziB,KAAAu3C,IAAAv3C,GAAAkmE,GAAAzjD,GAGAyjD,EAAAvjD,GAAA,SAAA3iB,GACA,MAAApO,WAAAC,QAAA8wB,EAAA,MAAA3iB,EAAA,uBAAAA,KAAAu3C,IAAAv3C,GAAAkmE,GAAAvjD,GAGAujD,EAAA0T,OACA1T,EAAA2T,OAAA,WACA,MAAAF,KAAAx/E,EAAAqoB,GAAAjmB,EAAAkmB,IAGAyjD,EAAA4T,OAAA,WACA,MAAAH,KAAAx/E,EAAAqoB,GAAAjmB,EAAAomB,IAGAujD,EAAA6T,OAAA,WACA,MAAAJ,KAAAx/E,EAAAuoB,GAAAnmB,EAAAkmB,IAGAyjD,EAAAqT,QAAA,SAAAv5E,GACA,MAAApO,WAAAC,QAAA0nF,EAAA,kBAAAv5E,KAAAu3C,KAAAv3C,GAAAkmE,GAAAqT,GAGArT,EAAAvvB,MAAA,SAAA32C,GACA,MAAApO,WAAAC,QAAA8kD,EAAA32C,EAAA,MAAApN,IAAA0oB,EAAAq7B,EAAA/jD,IAAAszE,GAAAvvB,GAGAuvB,EAAAtzE,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAA,MAAAmO,EAAApN,EAAA0oB,EAAA,KAAAA,EAAAq7B,EAAA/jD,EAAAoN,GAAAkmE,GAAAtzE,GAGAszE,GAGA8T,GAAA,SAAA9+E,EAAApK,GACA,MAAAA,GAAAoK,GAAA,EAAApK,EAAAoK,EAAA,EAAApK,GAAAoK,EAAA,EAAAmK,KAGA40E,GAAA,SAAAppF,GACA,MAAAA,IAGAqpF,GAAA,WAQA,QAAAA,GAAA97E,GACA,GAAA3J,GAEAgP,EACAvE,EAMAkvB,EAGAroB,EAXAvF,EAAApC,EAAAvM,OAGAmqC,EAAA,EACA5lC,EAAA,GAAA8D,OAAAsG,GACA25E,EAAA,GAAAjgF,OAAAsG,GACAsuB,GAAAnO,EAAAntB,MAAAhF,KAAAoD,WACAitC,EAAAtjC,KAAAuR,IAAAsrE,GAAA78E,KAAAC,KAAA48E,GAAAv3D,EAAArtB,MAAAhF,KAAAoD,WAAAk9B,IAEA79B,EAAAsK,KAAAuR,IAAAvR,KAAAY,IAAA0iC,GAAAr+B,EAAAs0C,EAAAthD,MAAAhF,KAAAoD,YACAs3E,EAAAj4E,GAAA4tC,EAAA,OAGA,KAAApqC,EAAA,EAAeA,EAAA+L,IAAO/L,GACtBsR,EAAAo0E,EAAA/jF,EAAA3B,OAAAjE,EAAA4N,EAAA3J,KAAA2J,IAAA,IACA49B,GAAAj2B,EASA,KAJA,MAAAu3D,EAAAlnE,EAAAgxC,KAAA,SAAA3yC,EAAAgP,GAAuD,MAAA65D,GAAA6c,EAAA1lF,GAAA0lF,EAAA12E,MACvD,MAAA2jC,GAAAhxC,EAAAgxC,KAAA,SAAA3yC,EAAAgP,GAAsD,MAAA2jC,GAAAhpC,EAAA3J,GAAA2J,EAAAqF,MAGtDhP,EAAA,EAAAyK,EAAA88B,GAAA6C,EAAAr+B,EAAA0oE,GAAAltC,EAAA,EAAkDvnC,EAAA+L,IAAO/L,EAAAq6B,EAAAV,EACzD3qB,EAAArN,EAAA3B,GAAAsR,EAAAo0E,EAAA12E,GAAA2qB,EAAAU,GAAA/oB,EAAA,EAAAA,EAAA7G,EAAA,GAAAgqE,EAAAiR,EAAA12E,IACArF,OAAAqF,GACArN,MAAA3B,EACAjE,MAAAuV,EACA4a,WAAAmO,EACAjO,SAAAuN,EACA0mB,SAAA7jD,EAIA,OAAAkpF,GA5CA,GAAA3pF,GAAAypF,GACA3c,EAAA0c,GACA5yC,EAAA,KACAzmB,EAAA42B,GAAA,GACA12B,EAAA02B,GAAA6gC,IACAtjC,EAAAyC,GAAA,EAkEA,OAxBA2iC,GAAA1pF,MAAA,SAAAwP,GACA,MAAApO,WAAAC,QAAArB,EAAA,kBAAAwP,KAAAu3C,IAAAv3C,GAAAk6E,GAAA1pF,GAGA0pF,EAAA5c,WAAA,SAAAt9D,GACA,MAAApO,WAAAC,QAAAyrE,EAAAt9D,EAAAonC,EAAA,KAAA8yC,GAAA5c,GAGA4c,EAAA9yC,KAAA,SAAApnC,GACA,MAAApO,WAAAC,QAAAu1C,EAAApnC,EAAAs9D,EAAA,KAAA4c,GAAA9yC,GAGA8yC,EAAAv5D,WAAA,SAAA3gB,GACA,MAAApO,WAAAC,QAAA8uB,EAAA,kBAAA3gB,KAAAu3C,IAAAv3C,GAAAk6E,GAAAv5D,GAGAu5D,EAAAr5D,SAAA,SAAA7gB,GACA,MAAApO,WAAAC,QAAAgvB,EAAA,kBAAA7gB,KAAAu3C,IAAAv3C,GAAAk6E,GAAAr5D,GAGAq5D,EAAAplC,SAAA,SAAA90C,GACA,MAAApO,WAAAC,QAAAijD,EAAA,kBAAA90C,KAAAu3C,IAAAv3C,GAAAk6E,GAAAplC,GAGAolC,GAGAE,GAAAvjC,GAAAwiC,GAMA3iC,IAAA/nD,WACAwqF,UAAA,WACA3qF,KAAAooD,OAAAuiC,aAEAC,QAAA,WACA5qF,KAAAooD,OAAAwiC,WAEA/yD,UAAA,WACA73B,KAAAooD,OAAAvwB,aAEAC,QAAA,WACA93B,KAAAooD,OAAAtwB,WAEAxJ,MAAA,SAAA5hB,EAAAkR,GACA5d,KAAAooD,OAAA95B,MAAA1Q,EAAA7Q,KAAAiS,IAAAtS,GAAAkR,GAAA7Q,KAAAgS,IAAArS,KA4BA,IAAAm/E,IAAA,WACA,MAAAtjC,IAAAl4C,KAAA83C,MAAAyjC,MAGAE,GAAA,WACA,GAAAp/E,GAAAs+E,KAAA7iC,MAAAyjC,IACAj5E,EAAAjG,EAAAy7C,MACAn0B,EAAAtnB,EAAA0+E,OACAl3D,EAAAxnB,EAAA6+E,OACAt3D,EAAAvnB,EAAA2+E,OACAl3D,EAAAznB,EAAA4+E,MAiBA,OAfA5+E,GAAAwuB,MAAAxuB,EAAAf,QAAAe,GAAAf,EACAe,EAAAylB,WAAAzlB,EAAAsnB,SAAAtnB,GAAAsnB,GACAtnB,EAAA2lB,SAAA3lB,EAAAwnB,SAAAxnB,GAAAwnB,GACAxnB,EAAAulB,OAAAvlB,EAAAqB,QAAArB,GAAAqB,EACArB,EAAAs5C,YAAAt5C,EAAAunB,SAAAvnB,GAAAunB,GACAvnB,EAAAw5C,YAAAx5C,EAAAynB,SAAAznB,GAAAynB,GACAznB,EAAAq/E,eAAA,WAAiC,MAAAxjC,IAAAv0B,YAA2BtnB,GAAA0+E,OAC5D1+E,EAAAs/E,aAAA,WAA+B,MAAAzjC,IAAAr0B,YAA2BxnB,GAAA6+E,OAC1D7+E,EAAAu/E,gBAAA,WAAkC,MAAA1jC,IAAAt0B,YAA2BvnB,GAAA2+E,OAC7D3+E,EAAAw/E,gBAAA,WAAkC,MAAA3jC,IAAAp0B,YAA2BznB,GAAA4+E,OAE7D5+E,EAAAy7C,MAAA,SAAA32C,GACA,MAAApO,WAAAC,OAAAsP,EAAA01C,GAAA72C,IAAAmB,IAAAy1C,QAGA17C,GAGA28C,GAAA,SAAA19C,EAAAoC,GACA,QAAAA,MAAAhB,KAAAgS,IAAApT,GAAAoB,KAAAo5D,GAAA,GAAAp4D,EAAAhB,KAAAiS,IAAArT,KAGAm9C,GAAAp9C,MAAAvL,UAAAqJ,MAiFA2iF,IACAC,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAtqB,GAAA7Q,KAAAiT,KAAAkoB,EAAA0d,GACAxhD,GAAA6kD,OAAArrC,EAAA,GACAxZ,EAAA6rD,IAAA,IAAAryC,EAAA,EAAAgsE,MAIAyC,IACAD,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAtqB,GAAA7Q,KAAAiT,KAAAkoB,EAAA,IACA9jC,GAAA6kD,QAAA,EAAArrC,MACAxZ,EAAA+oE,QAAAvvD,MACAxZ,EAAA+oE,QAAAvvD,GAAA,EAAAA,GACAxZ,EAAA+oE,OAAAvvD,GAAA,EAAAA,GACAxZ,EAAA+oE,OAAAvvD,MACAxZ,EAAA+oE,OAAA,EAAAvvD,MACAxZ,EAAA+oE,OAAA,EAAAvvD,KACAxZ,EAAA+oE,OAAAvvD,KACAxZ,EAAA+oE,OAAAvvD,EAAA,EAAAA,GACAxZ,EAAA+oE,QAAAvvD,EAAA,EAAAA,GACAxZ,EAAA+oE,QAAAvvD,KACAxZ,EAAA+oE,QAAA,EAAAvvD,KACAxZ,EAAA8oE,cAIAof,GAAAv/E,KAAAiT,KAAA,KACAusE,GAAA,EAAAD,GAEAE,IACAJ,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAn6B,GAAAhB,KAAAiT,KAAAkoB,EAAAqkD,IACA5gF,EAAAoC,EAAAu+E,EACAloF,GAAA6kD,OAAA,GAAAl7C,GACA3J,EAAA+oE,OAAAxhE,EAAA,GACAvH,EAAA+oE,OAAA,EAAAp/D,GACA3J,EAAA+oE,QAAAxhE,EAAA,GACAvH,EAAA8oE,cAKAuf,GAAA1/E,KAAAiS,IAAA4mC,GAAA,IAAA74C,KAAAiS,IAAA,EAAA4mC,GAAA,IACAnZ,GAAA1/B,KAAAiS,IAAA4qE,GAAA,IAAA6C,GACA//C,IAAA3/B,KAAAgS,IAAA6qE,GAAA,IAAA6C,GAEAC,IACAN,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAtqB,GAAA7Q,KAAAiT,KAPA,kBAOAkoB,GACAv8B,EAAA8gC,GAAA7uB,EACA7P,EAAA2+B,GAAA9uB,CACAxZ,GAAA6kD,OAAA,GAAArrC,GACAxZ,EAAA+oE,OAAAxhE,EAAAoC,EACA,QAAA9H,GAAA,EAAmBA,EAAA,IAAOA,EAAA,CAC1B,GAAAyG,GAAAk9E,GAAA3jF,EAAA,EACA0M,EAAA5F,KAAAgS,IAAArS,GACAwR,EAAAnR,KAAAiS,IAAAtS,EACAtI,GAAA+oE,OAAAjvD,EAAAN,GAAAjL,EAAAiL,GACAxZ,EAAA+oE,OAAAx6D,EAAAhH,EAAAuS,EAAAnQ,EAAAmQ,EAAAvS,EAAAgH,EAAA5E,GAEA3J,EAAA8oE,cAIAyf,IACAP,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAvL,GAAA5vB,KAAAiT,KAAAkoB,GACAv8B,GAAAgxB,EAAA,CACAv4B,GAAAyzD,KAAAlsD,IAAAgxB,OAIAiwD,GAAA7/E,KAAAiT,KAAA,GAEA6sE,IACAT,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAn6B,IAAAhB,KAAAiT,KAAAkoB,GAAA,EAAA0kD,IACAxoF,GAAA6kD,OAAA,IAAAl7C,GACA3J,EAAA+oE,QAAAyf,GAAA7+E,MACA3J,EAAA+oE,OAAAyf,GAAA7+E,MACA3J,EAAA8oE,cAIAv6D,IAAA,GACAuL,GAAAnR,KAAAiT,KAAA,KACAtP,GAAA,EAAA3D,KAAAiT,KAAA,IACAtT,GAAA,GAAAgE,GAAA,KAEAo8E,IACAV,KAAA,SAAAhoF,EAAA8jC,GACA,GAAAtqB,GAAA7Q,KAAAiT,KAAAkoB,EAAAx7B,IACAsnB,EAAApW,EAAA,EACAqW,EAAArW,EAAAlN,GACAwjB,EAAAF,EACAG,EAAAvW,EAAAlN,GAAAkN,EACAirB,GAAA3U,EACA4U,EAAA3U,CACA/vB,GAAA6kD,OAAAj1B,EAAAC,GACA7vB,EAAA+oE,OAAAj5C,EAAAC,GACA/vB,EAAA+oE,OAAAtkC,EAAAC,GACA1kC,EAAA+oE,OAAAx6D,GAAAqhB,EAAA9V,GAAA+V,EAAA/V,GAAA8V,EAAArhB,GAAAshB,GACA7vB,EAAA+oE,OAAAx6D,GAAAuhB,EAAAhW,GAAAiW,EAAAjW,GAAAgW,EAAAvhB,GAAAwhB,GACA/vB,EAAA+oE,OAAAx6D,GAAAk2B,EAAA3qB,GAAA4qB,EAAA5qB,GAAA2qB,EAAAl2B,GAAAm2B,GACA1kC,EAAA+oE,OAAAx6D,GAAAqhB,EAAA9V,GAAA+V,EAAAthB,GAAAshB,EAAA/V,GAAA8V,GACA5vB,EAAA+oE,OAAAx6D,GAAAuhB,EAAAhW,GAAAiW,EAAAxhB,GAAAwhB,EAAAjW,GAAAgW,GACA9vB,EAAA+oE,OAAAx6D,GAAAk2B,EAAA3qB,GAAA4qB,EAAAn2B,GAAAm2B,EAAA5qB,GAAA2qB,GACAzkC,EAAA8oE,cAIA6f,IACAZ,GACAE,GACAG,GACAG,GACAD,GACAG,GACAC,IAGA72D,GAAA,WAKA,QAAAA,KACA,GAAA2yB,EAGA,IAFAxkD,MAAAwkD,EAAAl5C,MACA+C,EAAAzN,MAAAhF,KAAAoD,WAAAgpF,KAAAhoF,GAAA8jC,EAAAljC,MAAAhF,KAAAoD,YACAwlD,EAAA,MAAAxkD,GAAA,KAAAwkD,EAAA,SARA,GAAAn2C,GAAAs2C,GAAAojC,IACAjkD,EAAA6gB,GAAA,IACA3kD,EAAA,IAqBA,OAZA6xB,GAAAxjB,KAAA,SAAAjB,GACA,MAAApO,WAAAC,QAAAoP,EAAA,kBAAAjB,KAAAu3C,GAAAv3C,GAAAykB,GAAAxjB,GAGAwjB,EAAAiS,KAAA,SAAA12B,GACA,MAAApO,WAAAC,QAAA6kC,EAAA,kBAAA12B,KAAAu3C,IAAAv3C,GAAAykB,GAAAiS,GAGAjS,EAAA7xB,QAAA,SAAAoN,GACA,MAAApO,WAAAC,QAAAe,EAAA,MAAAoN,EAAA,KAAAA,EAAAykB,GAAA7xB,GAGA6xB,GAGA+2D,GAAA,YAiBAnjC,IAAA1pD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IACA5xB,KAAA2xB,IAAA3xB,KAAA6xB,IAAAhb,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OAAAzvB,GAAA5pD,UAAA4xB,IAAA5xB,KAAA6xB,IACA,QAAA7xB,KAAAuE,SAAA4oE,OAAAntE,KAAA4xB,IAAA5xB,KAAA6xB,MAEA7xB,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAuE,SAAA4oE,QAAA,EAAAntE,KAAA0xB,IAAA1xB,KAAA4xB,KAAA,KAAA5xB,KAAA2xB,IAAA3xB,KAAA6xB,KAAA,EAC9B,SAAA+3B,GAAA5pD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAAjmB,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA9jB,GAIA,IAAAk/E,IAAA,SAAA7oF,GACA,UAAAylD,IAAAzlD,GAOA0lD,IAAA3pD,WACAwqF,UAAAqC,GACApC,QAAAoC,GACAn1D,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAktF,IAAAltF,KAAAmtF,IACAntF,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAotF,IAAAptF,KAAAqtF,IAAAx2E,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OACAr5E,KAAAuE,SAAA0kD,OAAAjpD,KAAAqqD,IAAArqD,KAAAsqD,KACAtqD,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAuE,SAAA0kD,QAAAjpD,KAAAqqD,IAAA,EAAArqD,KAAAktF,KAAA,GAAAltF,KAAAsqD,IAAA,EAAAtqD,KAAAotF,KAAA,GACAptF,KAAAuE,SAAA4oE,QAAAntE,KAAAktF,IAAA,EAAAltF,KAAAqqD,KAAA,GAAArqD,KAAAotF,IAAA,EAAAptF,KAAAsqD,KAAA,GACAtqD,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAsuB,MAAAtuB,KAAAqqD,IAAArqD,KAAAsqD,KACAtqD,KAAAsuB,MAAAtuB,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAsuB,MAAAtuB,KAAAmtF,IAAAntF,KAAAqtF,OAKA/+D,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAqqD,IAAA1+C,EAAA3L,KAAAsqD,IAAAv8C,CAA4B,MAC1D,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAAktF,IAAAvhF,EAAA3L,KAAAotF,IAAAr/E,CAA4B,MAC1D,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAAmtF,IAAAxhF,EAAA3L,KAAAqtF,IAAAt/E,EAA4B/N,KAAAuE,SAAA0kD,QAAAjpD,KAAA0xB,IAAA,EAAA1xB,KAAA4xB,IAAAjmB,GAAA,GAAA3L,KAAA2xB,IAAA,EAAA3xB,KAAA6xB,IAAA9jB,GAAA,EAA4F,MACtJ,SAAA67C,GAAA5pD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAAjmB,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA9jB,GAIA,IAAAu/E,IAAA,SAAAlpF,GACA,UAAA0lD,IAAA1lD,GAOA2lD,IAAA5pD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IACA5xB,KAAA2xB,IAAA3xB,KAAA6xB,IAAAhb,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,YACA93B,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,CAA8B,IAAArlD,IAAAh0B,KAAA0xB,IAAA,EAAA1xB,KAAA4xB,IAAAjmB,GAAA,EAAAsoB,GAAAj0B,KAAA2xB,IAAA,EAAA3xB,KAAA6xB,IAAA9jB,GAAA,CAAoF/N,MAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAn5C,EAAAC,GAAAj0B,KAAAuE,SAAA0kD,OAAAj1B,EAAAC,EAA0E,MAC5L,QAAAj0B,KAAAq5E,OAAA,CACA,SAAAzvB,GAAA5pD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAAjmB,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA9jB,GAIA,IAAAw/E,IAAA,SAAAnpF,GACA,UAAA2lD,IAAA3lD,GAQA4lD,IAAA7pD,WACA03B,UAAA,WACA73B,KAAAo0B,MACAp0B,KAAAq0B,MACAr0B,KAAAiqD,OAAApyB,aAEAC,QAAA,WACA,GAAAnsB,GAAA3L,KAAAo0B,GACArmB,EAAA/N,KAAAq0B,GACApf,EAAAtJ,EAAAtI,OAAA,CAEA,IAAA4R,EAAA,EAQA,IAPA,GAKAlD,GALAiiB,EAAAroB,EAAA,GACAsoB,EAAAlmB,EAAA,GACAiO,EAAArQ,EAAAsJ,GAAA+e,EACA/X,EAAAlO,EAAAkH,GAAAgf,EACAhuB,GAAA,IAGAA,GAAAgP,GACAlD,EAAA9L,EAAAgP,EACAjV,KAAAiqD,OAAA37B,MACAtuB,KAAAkqD,MAAAv+C,EAAA1F,IAAA,EAAAjG,KAAAkqD,QAAAl2B,EAAAjiB,EAAAiK,GACAhc,KAAAkqD,MAAAn8C,EAAA9H,IAAA,EAAAjG,KAAAkqD,QAAAj2B,EAAAliB,EAAAkK,GAKAjc,MAAAo0B,GAAAp0B,KAAAq0B,GAAA,KACAr0B,KAAAiqD,OAAAnyB,WAEAxJ,MAAA,SAAA3iB,EAAAoC,GACA/N,KAAAo0B,GAAAhsB,MAAAuD,GACA3L,KAAAq0B,GAAAjsB,MAAA2F,IAIA,IAAAy/E,IAAA,QAAA/iB,GAAAn3B,GAEA,QAAAk6C,GAAAppF,GACA,WAAAkvC,EAAA,GAAAuW,IAAAzlD,GAAA,GAAA4lD,IAAA5lD,EAAAkvC,GAOA,MAJAk6C,GAAAl6C,KAAA,SAAAA,GACA,MAAAm3B,IAAAn3B,IAGAk6C,GACC,IAkBDjjC,IAAApqD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IACArqD,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAzzC,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OAAAr5E,KAAAuE,SAAA4oE,OAAAntE,KAAAqqD,IAAArqD,KAAAsqD,IAAuD,MACvD,QAAAH,GAAAnqD,UAAA4xB,IAAA5xB,KAAA6xB,MAEA7xB,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAA4xB,IAAAjmB,EAAA3L,KAAA6xB,IAAA9jB,CAA4B,MAC1D,QAAA/N,KAAAq5E,OAAA,CACA,SAAAlvB,GAAAnqD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAA0/E,IAAA,QAAAhjB,GAAAjgB,GAEA,QAAAijC,GAAArpF,GACA,UAAAmmD,IAAAnmD,EAAAomD,GAOA,MAJAijC,GAAAjjC,QAAA,SAAAA,GACA,MAAAigB,IAAAjgB,IAGAijC,GACC,EAODhjC,IAAAtqD,WACAwqF,UAAAqC,GACApC,QAAAoC,GACAn1D,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAktF,IAAAltF,KAAAmtF,IAAAntF,KAAA0tF,IACA1tF,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAotF,IAAAptF,KAAAqtF,IAAArtF,KAAA2tF,IAAA92E,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OACAr5E,KAAAuE,SAAA0kD,OAAAjpD,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAuE,SAAA4oE,OAAAntE,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAsuB,MAAAtuB,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAsuB,MAAAtuB,KAAAmtF,IAAAntF,KAAAqtF,KACArtF,KAAAsuB,MAAAtuB,KAAA0tF,IAAA1tF,KAAA2tF,OAKAr/D,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAktF,IAAAvhF,EAAA3L,KAAAotF,IAAAr/E,CAA4B,MAC1D,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAAuE,SAAA0kD,OAAAjpD,KAAAmtF,IAAAxhF,EAAA3L,KAAAqtF,IAAAt/E,EAAkD,MAChF,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAA0tF,IAAA/hF,EAAA3L,KAAA2tF,IAAA5/E,CAA4B,MAC1D,SAAAo8C,GAAAnqD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAA6/E,IAAA,QAAAnjB,GAAAjgB,GAEA,QAAAqjC,GAAAzpF,GACA,UAAAqmD,IAAArmD,EAAAomD,GAOA,MAJAqjC,GAAArjC,QAAA,SAAAA,GACA,MAAAigB,IAAAjgB,IAGAqjC,GACC,EAODnjC,IAAAvqD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IACArqD,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAzzC,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,YACA93B,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAntE,KAAAqqD,IAAArqD,KAAAsqD,KAAAtqD,KAAAuE,SAAA0kD,OAAAjpD,KAAAqqD,IAAArqD,KAAAsqD,IAAkG,MAChI,QAAAtqD,KAAAq5E,OAAA,CACA,SAAAlvB,GAAAnqD,KAAA2L,EAAAoC,GAEA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAA+/E,IAAA,QAAArjB,GAAAjgB,GAEA,QAAAqjC,GAAAzpF,GACA,UAAAsmD,IAAAtmD,EAAAomD,GAOA,MAJAqjC,GAAArjC,QAAA,SAAAA,GACA,MAAAigB,IAAAjgB,IAGAqjC,GACC,EA8BD1iC,IAAAhrD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IACArqD,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAzzC,IACA7W,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OAAAr5E,KAAAuE,SAAA4oE,OAAAntE,KAAAqqD,IAAArqD,KAAAsqD,IAAuD,MACvD,QAAAtqD,KAAAsuB,MAAAtuB,KAAAqqD,IAAArqD,KAAAsqD,MAEAtqD,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAGA,GAFApC,KAAAoC,KAEA/N,KAAAq5E,OAAA,CACA,GAAA0U,GAAA/tF,KAAAqqD,IAAA1+C,EACAqiF,EAAAhuF,KAAAsqD,IAAAv8C,CACA/N,MAAAirD,OAAAl+C,KAAAiT,KAAAhgB,KAAAkrD,QAAAn+C,KAAAM,IAAA0gF,IAAAC,IAAAhuF,KAAAorD,SAGA,OAAAprD,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,CACA,SAAA1uB,GAAA3qD,KAAA2L,EAAAoC,GAGA/N,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAAkgF,IAAA,QAAAxjB,GAAAp3B,GAEA,QAAA46C,GAAA7pF,GACA,MAAAivC,GAAA,GAAA8X,IAAA/mD,EAAAivC,GAAA,GAAAkX,IAAAnmD,EAAA,GAOA,MAJA6pF,GAAA56C,MAAA,SAAAA,GACA,MAAAo3B,IAAAp3B,IAGA46C,GACC,GAOD5iC,IAAAlrD,WACAwqF,UAAAqC,GACApC,QAAAoC,GACAn1D,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAktF,IAAAltF,KAAAmtF,IAAAntF,KAAA0tF,IACA1tF,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAotF,IAAAptF,KAAAqtF,IAAArtF,KAAA2tF,IAAA92E,IACA7W,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OACAr5E,KAAAuE,SAAA0kD,OAAAjpD,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAuE,SAAA4oE,OAAAntE,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAuE,SAAA2oE,WACA,MAEA,QACAltE,KAAAsuB,MAAAtuB,KAAAktF,IAAAltF,KAAAotF,KACAptF,KAAAsuB,MAAAtuB,KAAAmtF,IAAAntF,KAAAqtF,KACArtF,KAAAsuB,MAAAtuB,KAAA0tF,IAAA1tF,KAAA2tF,OAKAr/D,MAAA,SAAA3iB,EAAAoC,GAGA,GAFApC,KAAAoC,KAEA/N,KAAAq5E,OAAA,CACA,GAAA0U,GAAA/tF,KAAAqqD,IAAA1+C,EACAqiF,EAAAhuF,KAAAsqD,IAAAv8C,CACA/N,MAAAirD,OAAAl+C,KAAAiT,KAAAhgB,KAAAkrD,QAAAn+C,KAAAM,IAAA0gF,IAAAC,IAAAhuF,KAAAorD,SAGA,OAAAprD,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAktF,IAAAvhF,EAAA3L,KAAAotF,IAAAr/E,CAA4B,MAC1D,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAAuE,SAAA0kD,OAAAjpD,KAAAmtF,IAAAxhF,EAAA3L,KAAAqtF,IAAAt/E,EAAkD,MAChF,QAAA/N,KAAAq5E,OAAA,EAA8Br5E,KAAA0tF,IAAA/hF,EAAA3L,KAAA2tF,IAAA5/E,CAA4B,MAC1D,SAAA48C,GAAA3qD,KAAA2L,EAAAoC,GAGA/N,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAAmgF,IAAA,QAAAzjB,GAAAp3B,GAEA,QAAA86C,GAAA/pF,GACA,MAAAivC,GAAA,GAAAgY,IAAAjnD,EAAAivC,GAAA,GAAAoX,IAAArmD,EAAA,GAOA,MAJA+pF,GAAA96C,MAAA,SAAAA,GACA,MAAAo3B,IAAAp3B,IAGA86C,GACC,GAOD7iC,IAAAnrD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAAqqD,IACArqD,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAzzC,IACA7W,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAAq5E,OAAA,GAEAvhD,QAAA,YACA93B,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GAGA,GAFApC,KAAAoC,KAEA/N,KAAAq5E,OAAA,CACA,GAAA0U,GAAA/tF,KAAAqqD,IAAA1+C,EACAqiF,EAAAhuF,KAAAsqD,IAAAv8C,CACA/N,MAAAirD,OAAAl+C,KAAAiT,KAAAhgB,KAAAkrD,QAAAn+C,KAAAM,IAAA0gF,IAAAC,IAAAhuF,KAAAorD,SAGA,OAAAprD,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAntE,KAAAqqD,IAAArqD,KAAAsqD,KAAAtqD,KAAAuE,SAAA0kD,OAAAjpD,KAAAqqD,IAAArqD,KAAAsqD,IAAkG,MAChI,QAAAtqD,KAAAq5E,OAAA,CACA,SAAA1uB,GAAA3qD,KAAA2L,EAAAoC,GAGA/N,KAAA4qD,OAAA5qD,KAAA+qD,OAAA/qD,KAAA+qD,OAAA/qD,KAAAirD,OACAjrD,KAAA8qD,QAAA9qD,KAAAgrD,QAAAhrD,KAAAgrD,QAAAhrD,KAAAkrD,QACAlrD,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAA5xB,KAAAqqD,IAAArqD,KAAAqqD,IAAA1+C,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA7xB,KAAAsqD,IAAAtqD,KAAAsqD,IAAAv8C,GAIA,IAAAqgF,IAAA,QAAA3jB,GAAAp3B,GAEA,QAAA86C,GAAA/pF,GACA,MAAAivC,GAAA,GAAAiY,IAAAlnD,EAAAivC,GAAA,GAAAqX,IAAAtmD,EAAA,GAOA,MAJA+pF,GAAA96C,MAAA,SAAAA,GACA,MAAAo3B,IAAAp3B,IAGA86C,GACC,GAMD5iC,IAAAprD,WACAwqF,UAAAqC,GACApC,QAAAoC,GACAn1D,UAAA,WACA73B,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA93B,KAAAq5E,QAAAr5E,KAAAuE,SAAA2oE,aAEA5+C,MAAA,SAAA3iB,EAAAoC,GACApC,KAAAoC,KACA/N,KAAAq5E,OAAAr5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,IACA/N,KAAAq5E,OAAA,EAAAr5E,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,KAIA,IAAAsgF,IAAA,SAAAjqF,GACA,UAAAmnD,IAAAnnD,GA0CA0nD,IAAA3rD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAA0xB,IAAA1xB,KAAA4xB,IACA5xB,KAAA2xB,IAAA3xB,KAAA6xB,IACA7xB,KAAAsuF,IAAAz3E,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,OAAA93B,KAAAq5E,QACA,OAAAr5E,KAAAuE,SAAA4oE,OAAAntE,KAAA4xB,IAAA5xB,KAAA6xB,IAAuD,MACvD,QAAAg6B,GAAA7rD,UAAAsuF,IAAA1iC,GAAA5rD,UAAAsuF,OAEAtuF,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,OAEA9qD,MAAA,SAAA3iB,EAAAoC,GACA,GAAA4R,GAAA9I,GAGA,IADAlL,KAAAoC,KACApC,IAAA3L,KAAA4xB,KAAA7jB,IAAA/N,KAAA6xB,IAAA,CACA,OAAA7xB,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,CAA8B,MAC9B,QAAAr5E,KAAAq5E,OAAA,EAA8BxtB,GAAA7rD,KAAA4rD,GAAA5rD,KAAA2f,EAAA8rC,GAAAzrD,KAAA2L,EAAAoC,IAAA4R,EAA0D,MACxF,SAAAksC,GAAA7rD,UAAAsuF,IAAA3uE,EAAA8rC,GAAAzrD,KAAA2L,EAAAoC,IAGA/N,KAAA0xB,IAAA1xB,KAAA4xB,IAAA5xB,KAAA4xB,IAAAjmB,EACA3L,KAAA2xB,IAAA3xB,KAAA6xB,IAAA7xB,KAAA6xB,IAAA9jB,EACA/N,KAAAsuF,IAAA3uE,MAQAosC,GAAA5rD,UAAAwC,OAAAR,OAAA2pD,GAAA3rD,YAAAmuB,MAAA,SAAA3iB,EAAAoC,GACA+9C,GAAA3rD,UAAAmuB,MAAAztB,KAAAb,KAAA+N,EAAApC,IAOAqgD,GAAA7rD,WACA8oD,OAAA,SAAAt9C,EAAAoC,GAA0B/N,KAAAuE,SAAA0kD,OAAAl7C,EAAApC,IAC1BuhE,UAAA,WAAyBltE,KAAAuE,SAAA2oE,aACzBC,OAAA,SAAAxhE,EAAAoC,GAA0B/N,KAAAuE,SAAA4oE,OAAAp/D,EAAApC,IAC1Bu9C,cAAA,SAAAh1B,EAAAC,EAAA0U,EAAAC,EAAAn9B,EAAAoC,GAAiD/N,KAAAuE,SAAA2kD,cAAA/0B,EAAAD,EAAA4U,EAAAD,EAAA96B,EAAApC,KAejDwgD,GAAAhsD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAAo0B,MACAp0B,KAAAq0B,OAEAyD,QAAA,WACA,GAAAnsB,GAAA3L,KAAAo0B,GACArmB,EAAA/N,KAAAq0B,GACAriB,EAAArG,EAAAtI,MAEA,IAAA2O,EAEA,GADAhS,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAA,GAAAoC,EAAA,IAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAA,GAAAoC,EAAA,IACA,IAAAiE,EACAhS,KAAAuE,SAAA4oE,OAAAxhE,EAAA,GAAAoC,EAAA,QAIA,QAFAwgF,GAAAniC,GAAAzgD,GACA6iF,EAAApiC,GAAAr+C,GACAwlC,EAAA,EAAAC,EAAA,EAAgCA,EAAAxhC,IAAQuhC,IAAAC,EACxCxzC,KAAAuE,SAAA2kD,cAAAqlC,EAAA,GAAAh7C,GAAAi7C,EAAA,GAAAj7C,GAAAg7C,EAAA,GAAAh7C,GAAAi7C,EAAA,GAAAj7C,GAAA5nC,EAAA6nC,GAAAzlC,EAAAylC,KAKAxzC,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAApnE,IAAAhS,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,MACAp5E,KAAAo0B,GAAAp0B,KAAAq0B,GAAA,MAEA/F,MAAA,SAAA3iB,EAAAoC,GACA/N,KAAAo0B,GAAAhsB,MAAAuD,GACA3L,KAAAq0B,GAAAjsB,MAAA2F,IAuBA,IAAA0gF,IAAA,SAAArqF,GACA,UAAA+nD,IAAA/nD,GAQAioD,IAAAlsD,WACAwqF,UAAA,WACA3qF,KAAAo5E,MAAA,GAEAwR,QAAA,WACA5qF,KAAAo5E,MAAAviE,KAEAghB,UAAA,WACA73B,KAAAo0B,GAAAp0B,KAAAq0B,GAAAxd,IACA7W,KAAAq5E,OAAA,GAEAvhD,QAAA,WACA,EAAA93B,KAAAssD,IAAAtsD,KAAAssD,GAAA,OAAAtsD,KAAAq5E,QAAAr5E,KAAAuE,SAAA4oE,OAAAntE,KAAAo0B,GAAAp0B,KAAAq0B,KACAr0B,KAAAo5E,OAAA,IAAAp5E,KAAAo5E,OAAA,IAAAp5E,KAAAq5E,SAAAr5E,KAAAuE,SAAA2oE,YACAltE,KAAAo5E,OAAA,IAAAp5E,KAAAssD,GAAA,EAAAtsD,KAAAssD,GAAAtsD,KAAAo5E,MAAA,EAAAp5E,KAAAo5E,QAEA9qD,MAAA,SAAA3iB,EAAAoC,GAEA,OADApC,KAAAoC,KACA/N,KAAAq5E,QACA,OAAAr5E,KAAAq5E,OAAA,EAA8Br5E,KAAAo5E,MAAAp5E,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,GAAA/N,KAAAuE,SAAA0kD,OAAAt9C,EAAAoC,EAAsE,MACpG,QAAA/N,KAAAq5E,OAAA,CACA,SACA,GAAAr5E,KAAAssD,IAAA,EACAtsD,KAAAuE,SAAA4oE,OAAAntE,KAAAo0B,GAAArmB,GACA/N,KAAAuE,SAAA4oE,OAAAxhE,EAAAoC,OACS,CACT,GAAAmmB,GAAAl0B,KAAAo0B,IAAA,EAAAp0B,KAAAssD,IAAA3gD,EAAA3L,KAAAssD,EACAtsD,MAAAuE,SAAA4oE,OAAAj5C,EAAAl0B,KAAAq0B,IACAr0B,KAAAuE,SAAA4oE,OAAAj5C,EAAAnmB,IAKA/N,KAAAo0B,GAAAzoB,EAAA3L,KAAAq0B,GAAAtmB,GAIA,IAAAjB,IAAA,SAAA1I,GACA,UAAAioD,IAAAjoD,EAAA,KAWAsqF,GAAA,SAAA/hC,EAAA78C,GACA,IAAAkC,EAAA26C,EAAAtpD,QAAA,EACA,OAAA4R,GAAAua,EAAAxd,EAAA/L,EAAA,EAAAypB,EAAAi9B,EAAA78C,EAAA,IAAAoF,EAAAwa,EAAArsB,OAAiE4C,EAAA+L,IAAO/L,EAExE,IADAupB,EAAAE,IAAAi9B,EAAA78C,EAAA7J,IACAgP,EAAA,EAAeA,EAAAC,IAAOD,EACtBya,EAAAza,GAAA,IAAAya,EAAAza,GAAA,GAAAoM,MAAAmO,EAAAva,GAAA,IAAAua,EAAAva,GAAA,GAAAua,EAAAva,GAAA,IAKA05E,GAAA,SAAAhiC,GAEA,IADA,GAAA36C,GAAA26C,EAAAtpD,OAAA2R,EAAA,GAAAtJ,OAAAsG,KACAA,GAAA,GAAAgD,EAAAhD,IACA,OAAAgD,IAOA45E,GAAA,WAMA,QAAAA,GAAAh/E,GACA,GACA3J,GAIA4oF,EALAC,EAAArgB,EAAAzpE,MAAAhF,KAAAoD,WAEA8R,EAAAtF,EAAAvM,OACA2O,EAAA88E,EAAAzrF,OACA0rF,EAAA,GAAArjF,OAAAsG,EAGA,KAAA/L,EAAA,EAAeA,EAAA+L,IAAO/L,EAAA,CACtB,OAAA+oF,GAAAC,EAAAH,EAAA7oF,GAAAipF,EAAAH,EAAA9oF,GAAA,GAAAyF,OAAAwJ,GAAAD,EAAA,EAAiEA,EAAAC,IAAOD,EACxEi6E,EAAAj6E,GAAA+5E,GAAA,GAAAhtF,EAAA4N,EAAAqF,GAAAg6E,EAAAh6E,EAAArF,IACAo/E,EAAAp/E,OAAAqF,EAEAi6E,GAAA34E,IAAA04E,EAGA,IAAAhpF,EAAA,EAAA4oF,EAAA/+E,EAAAi/E,GAA+B9oF,EAAA+L,IAAO/L,EACtC8oF,EAAAF,EAAA5oF,IAAA2B,MAAA3B,CAIA,OADAkI,GAAA4gF,EAAAF,GACAE,EA1BA,GAAAtgB,GAAA1lB,OACAj5C,EAAA6+E,GACAxgF,EAAAugF,GACA1sF,EAAAyqD,EA0CA,OAhBAmiC,GAAAngB,KAAA,SAAAj9D,GACA,MAAApO,WAAAC,QAAAorE,EAAA,kBAAAj9D,KAAAu3C,GAAAD,GAAAjoD,KAAA2Q,IAAAo9E,GAAAngB,GAGAmgB,EAAA5sF,MAAA,SAAAwP,GACA,MAAApO,WAAAC,QAAArB,EAAA,kBAAAwP,KAAAu3C,IAAAv3C,GAAAo9E,GAAA5sF,GAGA4sF,EAAA9+E,MAAA,SAAA0B,GACA,MAAApO,WAAAC,QAAAyM,EAAA,MAAA0B,EAAAm9E,GAAA,kBAAAn9E,KAAAu3C,GAAAD,GAAAjoD,KAAA2Q,IAAAo9E,GAAA9+E,GAGA8+E,EAAAzgF,OAAA,SAAAqD,GACA,MAAApO,WAAAC,QAAA8K,EAAA,MAAAqD,EAAAk9E,GAAAl9E,EAAAo9E,GAAAzgF,GAGAygF,GAGAO,GAAA,SAAAxiC,EAAA78C,GACA,IAAAkC,EAAA26C,EAAAtpD,QAAA,GACA,OAAA4C,GAAA+L,EAAAjE,EAAAkH,EAAA,EAAAC,EAAAy3C,EAAA,GAAAtpD,OAAgD4R,EAAAC,IAAOD,EAAA,CACvD,IAAAlH,EAAA9H,EAAA,EAAmBA,EAAA+L,IAAO/L,EAAA8H,GAAA4+C,EAAA1mD,GAAAgP,GAAA,KAC1B,IAAAlH,EAAA,IAAA9H,EAAA,EAAsBA,EAAA+L,IAAO/L,EAAA0mD,EAAA1mD,GAAAgP,GAAA,IAAAlH,EAE7B2gF,GAAA/hC,EAAA78C,KAGAs/E,GAAA,SAAAziC,EAAA78C,GACA,IAAAkC,EAAA26C,EAAAtpD,QAAA,EACA,OAAA4C,GAAA5D,EAAA4Z,EAAA6X,EAAAu7D,EAAAr9E,EAAAiD,EAAA,EAAAC,EAAAy3C,EAAA78C,EAAA,IAAAzM,OAAmE4R,EAAAC,IAAOD,EAC1E,IAAA6e,EAAAu7D,EAAA,EAAAppF,EAAA,EAA4BA,EAAA+L,IAAO/L,GACnCgW,GAAA5Z,EAAAsqD,EAAA78C,EAAA7J,IAAAgP,IAAA,GAAA5S,EAAA,QACAA,EAAA,GAAAyxB,EAAAzxB,EAAA,GAAAyxB,GAAA7X,GACOA,EAAA,GACP5Z,EAAA,GAAAgtF,EAAAhtF,EAAA,GAAAgtF,GAAApzE,GAEA5Z,EAAA,GAAAyxB,GAMAw7D,GAAA,SAAA3iC,EAAA78C,GACA,IAAAkC,EAAA26C,EAAAtpD,QAAA,GACA,OAAA2O,GAAAiD,EAAA,EAAAua,EAAAm9B,EAAA78C,EAAA,IAAAoF,EAAAsa,EAAAnsB,OAA0D4R,EAAAC,IAAOD,EAAA,CACjE,OAAAhP,GAAA,EAAA8H,EAAA,EAA0B9H,EAAA+L,IAAO/L,EAAA8H,GAAA4+C,EAAA1mD,GAAAgP,GAAA,KACjCua,GAAAva,GAAA,IAAAua,EAAAva,GAAA,IAAAlH,EAAA,EAEA2gF,GAAA/hC,EAAA78C,KAGAy/E,GAAA,SAAA5iC,EAAA78C,GACA,IAAAkC,EAAA26C,EAAAtpD,QAAA,IAAA6R,GAAAsa,EAAAm9B,EAAA78C,EAAA,KAAAzM,QAAA,GACA,OAAAmsB,GAAAta,EAAAlD,EAAAjE,EAAA,EAAAkH,EAAA,EAAkCA,EAAAC,IAAOD,EAAA,CACzC,OAAAhP,GAAA,EAAAypB,EAAA,EAAA8/D,EAAA,EAAmCvpF,EAAA+L,IAAO/L,EAAA,CAK1C,OAJAipF,GAAAviC,EAAA78C,EAAA7J,IACAwpF,EAAAP,EAAAj6E,GAAA,MACAy6E,EAAAR,EAAAj6E,EAAA,SACA06E,GAAAF,EAAAC,GAAA,EACAh/E,EAAA,EAAqBA,EAAAzK,IAAOyK,EAAA,CAC5B,GAAAugC,GAAA0b,EAAA78C,EAAAY,GAGAi/E,KAFA1+C,EAAAh8B,GAAA,QACAg8B,EAAAh8B,EAAA,UAGAya,GAAA+/D,EAAAD,GAAAG,EAAAF,EAEAjgE,EAAAva,EAAA,OAAAua,EAAAva,EAAA,MAAAlH,EACA2hB,IAAA3hB,GAAAyhF,EAAA9/D,GAEAF,EAAAva,EAAA,OAAAua,EAAAva,EAAA,MAAAlH,EACA2gF,GAAA/hC,EAAA78C,KAGA8/E,GAAA,SAAAjjC,GACA,GAAA2zB,GAAA3zB,EAAAp6C,IAAAm6C,GACA,OAAAiiC,IAAAhiC,GAAA/T,KAAA,SAAAlsC,EAAApK,GAA6C,MAAAg+E,GAAA5zE,GAAA4zE,EAAAh+E,MAS7CutF,GAAA,SAAAljC,GACA,MAAAijC,IAAAjjC,GAAAlpB,WAGAqsD,GAAA,SAAAnjC,GACA,GACA1mD,GACAgP,EAFAjD,EAAA26C,EAAAtpD,OAGAi9E,EAAA3zB,EAAAp6C,IAAAm6C,IACA58C,EAAA6+E,GAAAhiC,GAAA/T,KAAA,SAAAlsC,EAAApK,GAAkD,MAAAg+E,GAAAh+E,GAAAg+E,EAAA5zE,KAClDiE,EAAA,EACAC,EAAA,EACAm/E,KACAC,IAEA,KAAA/pF,EAAA,EAAaA,EAAA+L,IAAO/L,EACpBgP,EAAAnF,EAAA7J,GACA0K,EAAAC,GACAD,GAAA2vE,EAAArrE,GACA86E,EAAA3nF,KAAA6M,KAEArE,GAAA0vE,EAAArrE,GACA+6E,EAAA5nF,KAAA6M,GAIA,OAAA+6E,GAAAvsD,UAAAr8B,OAAA2oF,IAGAtsD,GAAA,SAAAkpB,GACA,MAAAgiC,IAAAhiC,GAAAlpB,WAGAwsD,GAAA,SAAAtkF,GACA,kBACA,MAAAA,IAyBAmhD,IAAA3sD,WACAqC,YAAAsqD,GAEAr8C,OAAA,SAAAy/E,EAAA/5E,GACA,GAAAvR,GAAAurF,EAAAC,CAEA,IAAAF,EAAA,CAKA,GAJA/5E,EAAA82C,EAAAijC,EACA/5E,EAAAkZ,EAAA6gE,EAAA7gE,EACA6gE,EAAA7gE,IAAA6gE,EAAA7gE,EAAA49B,EAAA92C,GACA+5E,EAAA7gE,EAAAlZ,EACA+5E,EAAAljC,EAAA,CAEA,IADAkjC,IAAAljC,EACAkjC,EAAAx1C,GAAAw1C,IAAAx1C,CACAw1C,GAAAx1C,EAAAvkC,MAEA+5E,GAAAljC,EAAA72C,CAEAvR,GAAAsrF,MACKlwF,MAAAwR,GACL0+E,EAAA9iC,GAAAptD,KAAAwR,GACA2E,EAAA82C,EAAA,KACA92C,EAAAkZ,EAAA6gE,EACAA,EAAAjjC,EAAAijC,EAAAx1C,EAAAvkC,EACAvR,EAAAsrF,IAEA/5E,EAAA82C,EAAA92C,EAAAkZ,EAAA,KACArvB,KAAAwR,EAAA2E,EACAvR,EAAA,KAOA,KALAuR,EAAAukC,EAAAvkC,EAAA62C,EAAA,KACA72C,EAAAylC,EAAAh3C,EACAuR,EAAAsK,GAAA,EAEAyvE,EAAA/5E,EACAvR,KAAA6b,GACA0vE,EAAAvrF,EAAAg3C,EACAh3C,IAAAurF,EAAAz1C,GACA01C,EAAAD,EAAAnjC,EACAojC,KAAA3vE,GACA7b,EAAA6b,EAAA2vE,EAAA3vE,GAAA,EACA0vE,EAAA1vE,GAAA,EACAyvE,EAAAC,IAEAD,IAAAtrF,EAAAooD,IACAE,GAAAltD,KAAA4E,GACAsrF,EAAAtrF,EACAA,EAAAsrF,EAAAt0C,GAEAh3C,EAAA6b,GAAA,EACA0vE,EAAA1vE,GAAA,EACA0sC,GAAAntD,KAAAmwF,MAGAC,EAAAD,EAAAz1C,EACA01C,KAAA3vE,GACA7b,EAAA6b,EAAA2vE,EAAA3vE,GAAA,EACA0vE,EAAA1vE,GAAA,EACAyvE,EAAAC,IAEAD,IAAAtrF,EAAA81C,IACAyS,GAAAntD,KAAA4E,GACAsrF,EAAAtrF,EACAA,EAAAsrF,EAAAt0C,GAEAh3C,EAAA6b,GAAA,EACA0vE,EAAA1vE,GAAA,EACAysC,GAAAltD,KAAAmwF,KAGAvrF,EAAAsrF,EAAAt0C,CAEA57C,MAAAwR,EAAAiP,GAAA,GAGA5Y,OAAA,SAAAsO,GACAA,EAAAkZ,IAAAlZ,EAAAkZ,EAAA49B,EAAA92C,EAAA82C,GACA92C,EAAA82C,IAAA92C,EAAA82C,EAAA59B,EAAAlZ,EAAAkZ,GACAlZ,EAAAkZ,EAAAlZ,EAAA82C,EAAA,IAEA,IACAojC,GAGAhvF,EACAgjE,EALAz/D,EAAAuR,EAAAylC,EAEAzqC,EAAAgF,EAAAukC,EACAtpC,EAAA+E,EAAA62C,CAsCA,IAhCA3rD,EAFA8P,EACAC,EACAg8C,GAAAh8C,GADAD,EADAC,EAIAxM,EACAA,EAAA81C,IAAAvkC,EAAAvR,EAAA81C,EAAAr5C,EACAuD,EAAAooD,EAAA3rD,EAEArB,KAAAwR,EAAAnQ,EAGA8P,GAAAC,GACAizD,EAAAhjE,EAAAof,EACApf,EAAAof,EAAAtK,EAAAsK,EACApf,EAAAq5C,EAAAvpC,EACAA,EAAAyqC,EAAAv6C,EACAA,IAAA+P,GACAxM,EAAAvD,EAAAu6C,EACAv6C,EAAAu6C,EAAAzlC,EAAAylC,EACAzlC,EAAA9U,EAAA2rD,EACApoD,EAAA81C,EAAAvkC,EACA9U,EAAA2rD,EAAA57C,EACAA,EAAAwqC,EAAAv6C,IAEAA,EAAAu6C,EAAAh3C,EACAA,EAAAvD,EACA8U,EAAA9U,EAAA2rD,KAGAqX,EAAAluD,EAAAsK,EACAtK,EAAA9U,GAGA8U,MAAAylC,EAAAh3C,IACAy/D,EAAA,CACA,GAAAluD,KAAAsK,EAAyC,YAAhBtK,EAAAsK,GAAA,EAEzB,IACA,GAAAtK,IAAAnW,KAAAwR,EAAA,KACA,IAAA2E,IAAAvR,EAAA81C,GAQA,GAPA21C,EAAAzrF,EAAAooD,EACAqjC,EAAA5vE,IACA4vE,EAAA5vE,GAAA,EACA7b,EAAA6b,GAAA,EACAysC,GAAAltD,KAAA4E,GACAyrF,EAAAzrF,EAAAooD,GAEAqjC,EAAA31C,GAAA21C,EAAA31C,EAAAj6B,GACA4vE,EAAArjC,GAAAqjC,EAAArjC,EAAAvsC,EAAA,CACA4vE,EAAArjC,GAAAqjC,EAAArjC,EAAAvsC,IACA4vE,EAAA31C,EAAAj6B,GAAA,EACA4vE,EAAA5vE,GAAA,EACA0sC,GAAAntD,KAAAqwF,GACAA,EAAAzrF,EAAAooD,GAEAqjC,EAAA5vE,EAAA7b,EAAA6b,EACA7b,EAAA6b,EAAA4vE,EAAArjC,EAAAvsC,GAAA,EACAysC,GAAAltD,KAAA4E,GACAuR,EAAAnW,KAAAwR,CACA,YAUA,IAPA6+E,EAAAzrF,EAAA81C,EACA21C,EAAA5vE,IACA4vE,EAAA5vE,GAAA,EACA7b,EAAA6b,GAAA,EACA0sC,GAAAntD,KAAA4E,GACAyrF,EAAAzrF,EAAA81C,GAEA21C,EAAA31C,GAAA21C,EAAA31C,EAAAj6B,GACA4vE,EAAArjC,GAAAqjC,EAAArjC,EAAAvsC,EAAA,CACA4vE,EAAA31C,GAAA21C,EAAA31C,EAAAj6B,IACA4vE,EAAArjC,EAAAvsC,GAAA,EACA4vE,EAAA5vE,GAAA,EACAysC,GAAAltD,KAAAqwF,GACAA,EAAAzrF,EAAA81C,GAEA21C,EAAA5vE,EAAA7b,EAAA6b,EACA7b,EAAA6b,EAAA4vE,EAAA31C,EAAAj6B,GAAA,EACA0sC,GAAAntD,KAAA4E,GACAuR,EAAAnW,KAAAwR,CACA,OAGA6+E,EAAA5vE,GAAA,EACAtK,EAAAvR,EACAA,IAAAg3C,SACKzlC,EAAAsK,EAELtK,OAAAsK,GAAA,KAkVA,IAEAowC,IAwQAO,GACA3D,GACA3c,GACAyc,GA7QAoD,MA4EAO,MA4LAzC,GAAA,KACA+B,GAAA,KA6DAoC,IAAAzyD,WACAqC,YAAAowD,GAEA09B,SAAA,WACA,GAAA/iC,GAAAvtD,KAAAutD,KAEA,OAAAvtD,MAAAytD,MAAAl7C,IAAA,SAAAs8C,GACA,GAAAxuB,GAAAwuB,EAAAnB,UAAAn7C,IAAA,SAAAtM,GAAoD,MAAA+oD,IAAAH,EAAAtB,EAAAtnD,KAEpD,OADAo6B,GAAAzwB,KAAAi/C,EAAAF,KAAA/+C,KACAywB,KAIAkwD,UAAA,WACA,GAAAA,MACAhjC,EAAAvtD,KAAAutD,KAsBA,OApBAvtD,MAAAytD,MAAArsD,QAAA,SAAAytD,EAAA5oD,GACA,GAAAiP,GAAAw4C,EAAAmB,EAAAnB,WAAArqD,OASA,IARA,GACAqqD,GAEAx4C,EACAsa,EAJAm/B,EAAAE,EAAAF,KAEA15C,GAAA,EAGAka,EAAAo+B,EAAAG,EAAAx4C,EAAA,IACAwa,EAAAP,EAAAhe,OAAAw9C,EAAAx/B,EAAA/d,MAAA+d,EAAAhe,OAEA8D,EAAAC,GACAsa,EAAAE,EACAP,EAAAo+B,EAAAG,EAAAz4C,IACAya,EAAAP,EAAAhe,OAAAw9C,EAAAx/B,EAAA/d,MAAA+d,EAAAhe,KACAqe,GAAAE,GAAAzpB,EAAAupB,EAAA5nB,OAAA3B,EAAAypB,EAAA9nB,OAAA8qD,GAAA/D,EAAAn/B,EAAAE,GAAA,GACA6gE,EAAAnoF,MAAAumD,EAAA/+C,KAAA4f,EAAA5f,KAAA8f,EAAA9f,SAKA2gF,GAGAzd,MAAA,WACA,MAAA9yE,MAAAutD,MAAAj8C,OAAA,SAAAg8C,GACA,MAAAA,GAAAl8C,QACKmB,IAAA,SAAA+6C,GACL,OACA/sD,OAAA+sD,EAAAn8C,KAAAvB,KACAiM,OAAAyxC,EAAAl8C,MAAAxB,SAKAwlB,KAAA,SAAAzpB,EAAAoC,EAAAkkB,GAIA,IAHA,GAAAshB,GAAAsb,EAAAn5C,EAAA1V,KAAAwzC,EAAA99B,EAAA86E,QAAA,EAAAx+E,EAAA0D,EAAA+3C,MAAApqD,SAGAwrD,EAAAn5C,EAAA+3C,MAAAja,KAAA,KAAAA,GAAAxhC,EAAA,WACA,IAAAgK,GAAArQ,EAAAkjD,EAAAF,KAAA,GAAA1yC,EAAAlO,EAAA8gD,EAAAF,KAAA,GAAAhmB,EAAA3sB,IAAAC,GAGA,IACA4yC,EAAAn5C,EAAA+3C,MAAAla,EAAAC,KAAA,KACAqb,EAAAnB,UAAAtsD,QAAA,SAAA6G,GACA,GAAAqlD,GAAA53C,EAAA63C,MAAAtlD,GAAAsP,EAAA+1C,EAAAn8C,IACA,IAAAoG,IAAAs3C,EAAAF,MAAAp3C,MAAA+1C,EAAAl8C,OAAA,CACA,GAAA8jB,GAAAvpB,EAAA4L,EAAA,GAAA4d,EAAApnB,EAAAwJ,EAAA,GAAAwJ,EAAAmU,IAAAC,GACApU,GAAA4nB,MAAA5nB,EAAAyyB,EAAAj8B,EAAA3P,gBAEK,OAAA4rC,EAIL,OAFA99B,GAAA86E,OAAAj9C,EAEA,MAAAthB,GAAA0W,GAAA1W,IAAA48B,EAAAF,KAAA,MAIA,IAAA8hC,IAAA,WAKA,QAAAA,GAAA7gF,GACA,UAAAgjD,IAAAhjD,EAAA2C,IAAA,SAAAlQ,EAAA4D,GACA,GAAAiY,IAAAnR,KAAAsB,MAAA1C,EAAAtJ,EAAA4D,EAAA2J,GAAA6+C,OAAA1hD,KAAAsB,MAAAN,EAAA1L,EAAA4D,EAAA2J,GAAA6+C,OAGA,OAFAvwC,GAAAtW,MAAA3B,EACAiY,EAAAtO,KAAAvN,EACA6b,IACKyO,GAVL,GAAAhhB,GAAAihD,GACA7+C,EAAA8+C,GACAlgC,EAAA,IAuCA,OA5BA8jE,GAAAH,SAAA,SAAA1gF,GACA,MAAA6gF,GAAA7gF,GAAA0gF,YAGAG,EAAA3d,MAAA,SAAAljE,GACA,MAAA6gF,GAAA7gF,GAAAkjE,SAGA2d,EAAAF,UAAA,SAAA3gF,GACA,MAAA6gF,GAAA7gF,GAAA2gF,aAGAE,EAAA9kF,EAAA,SAAA6F,GACA,MAAApO,WAAAC,QAAAsI,EAAA,kBAAA6F,KAAAy+E,IAAAz+E,GAAAi/E,GAAA9kF,GAGA8kF,EAAA1iF,EAAA,SAAAyD,GACA,MAAApO,WAAAC,QAAA0K,EAAA,kBAAAyD,KAAAy+E,IAAAz+E,GAAAi/E,GAAA1iF,GAGA0iF,EAAA9jE,OAAA,SAAAnb,GACA,MAAApO,WAAAC,QAAAspB,EAAA,MAAAnb,EAAA,QAAAA,EAAA,OAAAA,EAAA,SAAAA,EAAA,OAAAA,EAAA,QAAAi/E,GAAA9jE,OAAA,MAAAA,EAAA,QAAAA,EAAA,MAAAA,EAAA,SAGA8jE,EAAAvoD,KAAA,SAAA12B,GACA,MAAApO,WAAAC,QAAAspB,EAAA,MAAAnb,EAAA,cAAAA,EAAA,IAAAA,EAAA,KAAAi/E,GAAA9jE,MAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,QAGA8jE,GAGAC,GAAA,SAAA/kF,GACA,kBACA,MAAAA,IAgBAonD,IAAA5yD,WACAqC,YAAAuwD,GACA9kD,MAAA,SAAAyC,GACA,WAAAA,EAAA1Q,KAAA,GAAA+yD,IAAA/yD,KAAA0Q,IAAA1Q,KAAA2L,EAAA3L,KAAA+N,IAEA+U,UAAA,SAAAnX,EAAAoC,GACA,WAAApC,EAAA,IAAAoC,EAAA/N,KAAA,GAAA+yD,IAAA/yD,KAAA0Q,EAAA1Q,KAAA2L,EAAA3L,KAAA0Q,EAAA/E,EAAA3L,KAAA+N,EAAA/N,KAAA0Q,EAAA3C,IAEA/I,MAAA,SAAAspB,GACA,OAAAA,EAAA,GAAAtuB,KAAA0Q,EAAA1Q,KAAA2L,EAAA2iB,EAAA,GAAAtuB,KAAA0Q,EAAA1Q,KAAA+N,IAEA4iF,OAAA,SAAAhlF,GACA,MAAAA,GAAA3L,KAAA0Q,EAAA1Q,KAAA2L,GAEAilF,OAAA,SAAA7iF,GACA,MAAAA,GAAA/N,KAAA0Q,EAAA1Q,KAAA+N,GAEAywB,OAAA,SAAAqyD,GACA,QAAAA,EAAA,GAAA7wF,KAAA2L,GAAA3L,KAAA0Q,GAAAmgF,EAAA,GAAA7wF,KAAA+N,GAAA/N,KAAA0Q,IAEAogF,QAAA,SAAAnlF,GACA,OAAAA,EAAA3L,KAAA2L,GAAA3L,KAAA0Q,GAEAqgF,QAAA,SAAAhjF,GACA,OAAAA,EAAA/N,KAAA+N,GAAA/N,KAAA0Q,GAEAsgF,SAAA,SAAArlF,GACA,MAAAA,GAAApC,OAAAuF,OAAAnD,EAAA0D,QAAAkD,IAAAvS,KAAA8wF,QAAA9wF,MAAAuS,IAAA5G,EAAA6yB,OAAA7yB,KAEAslF,SAAA,SAAAljF,GACA,MAAAA,GAAAxE,OAAAuF,OAAAf,EAAAsB,QAAAkD,IAAAvS,KAAA+wF,QAAA/wF,MAAAuS,IAAAxE,EAAAywB,OAAAzwB,KAEAgG,SAAA,WACA,mBAAA/T,KAAA2L,EAAA,IAAA3L,KAAA+N,EAAA,WAAA/N,KAAA0Q,EAAA,KAIA,IAAAwiD,IAAA,GAAAH,IAAA,MAEAC,IAAA7yD,UAAA4yD,GAAA5yD,SAUA,IAAA+wF,IAAA,WACAzxF,EAAA2U,MAAAknD,iBACA77D,EAAA2U,MAAAgH,4BAiCA+1E,GAAA,WAoBA,QAAAA,GAAA31E,GACAA,EACA8R,SAAA,SAAAmmC,IACA3+C,GAAA,aAAAs8E,GACAt8E,GAAA,iBAAA2mD,GACA3mD,GAAA,gBAAAu8E,GACA//E,OAAAuiD,IACA/+C,GAAA,kBAAA4mD,GACA5mD,GAAA,iBAAA6mD,GACA7mD,GAAA,iCAAA8mD,GACAlkD,MAAA,uBACAA,MAAA,+CA0DA,QAAAzJ,GAAAyuE,EAAAhsE,GAEA,MADAA,GAAA3D,KAAAC,IAAAskF,EAAAvkF,KAAAuR,IAAAizE,EAAA7gF,IACAA,IAAAgsE,EAAAhsE,EAAAgsE,EAAA,GAAA3pB,IAAAriD,EAAAgsE,EAAA/wE,EAAA+wE,EAAA3uE,GAGA,QAAA+U,GAAA45D,EAAAniD,EAAA+uB,GACA,GAAA39C,GAAA4uB,EAAA,GAAA+uB,EAAA,GAAAozB,EAAAhsE,EAAA3C,EAAAwsB,EAAA,GAAA+uB,EAAA,GAAAozB,EAAAhsE,CACA,OAAA/E,KAAA+wE,EAAA/wE,GAAAoC,IAAA2uE,EAAA3uE,EAAA2uE,EAAA,GAAA3pB,IAAA2pB,EAAAhsE,EAAA/E,EAAAoC,GAGA,QAAAyjF,GAAA9U,EAAA/vD,GACA,GAAAg7B,GAAA+0B,EAAAoU,QAAAnkE,EAAA,OAAAqH,EACA6zB,EAAA60B,EAAAoU,QAAAnkE,EAAA,OAAAuH,EACA0zB,EAAA80B,EAAAqU,QAAApkE,EAAA,OAAAsH,EACA6zB,EAAA40B,EAAAqU,QAAApkE,EAAA,OAAAwH,CACA,OAAAuoD,GAAA55D,UACA+kC,EAAAF,KAAAE,GAAA,EAAA96C,KAAAuR,IAAA,EAAAqpC,IAAA56C,KAAAC,IAAA,EAAA66C,GACAC,EAAAF,KAAAE,GAAA,EAAA/6C,KAAAuR,IAAA,EAAAspC,IAAA76C,KAAAC,IAAA,EAAA86C,IAIA,QAAAgwB,GAAAnrD,GACA,SAAAA,EAAA,QAAAA,EAAA,WAAAA,EAAA,QAAAA,EAAA,UAGA,QAAAlhB,GAAAg+D,EAAAiT,EAAAxuE,GACAu7D,EACA30D,GAAA,wBAAsC+mD,EAAA77D,KAAAoD,WAAAwJ,UACtCkI,GAAA,qCAAmD+mD,EAAA77D,KAAAoD,WAAA4gB,QACnDgD,MAAA,kBACA,GAAAtR,GAAA1V,KACA2V,EAAAvS,UACAya,EAAAg+C,EAAAnmD,EAAAC,GACA1N,EAAA0kB,EAAA3nB,MAAA0Q,EAAAC,GACAlT,EAAAyL,GAAA4pE,EAAA7vE,GACA00B,EAAA5vB,KAAAC,IAAA/E,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,OACAyE,EAAAgJ,EAAAu9C,OACA3wD,EAAA,kBAAAo6E,KAAA13E,MAAA0Q,EAAAC,GAAA+mE,EACAz2E,EAAAw5B,EAAA/yB,EAAA8xB,OAAA/7B,GAAA2E,OAAAu1B,EAAAjwB,EAAAgE,GAAApO,EAAAk8B,OAAA/7B,GAAA2E,OAAAu1B,EAAAr6B,EAAAoO,GACA,iBAAAqB,GACA,OAAAA,IAAAzP,MACA,CAAkB,GAAA6b,GAAAlY,EAAA8L,GAAArB,EAAAisB,EAAAxe,EAAA,EAA4BpM,GAAA,GAAAghD,IAAAriD,EAAAjO,EAAA,GAAA0b,EAAA,GAAAzN,EAAAjO,EAAA,GAAA0b,EAAA,GAAAzN,GAC9CmN,EAAAszE,KAAA,KAAAp/E,MAKA,QAAA8pD,GAAAnmD,EAAAC,GACA,OAAAkI,GAAA5X,EAAA,EAAA+L,EAAAqqD,EAAAh5D,OAA2C4C,EAAA+L,IAAO/L,EAClD,IAAA4X,EAAAw+C,EAAAp2D,IAAAyP,SACA,MAAAmI,EAGA,WAAA4zE,GAAA/7E,EAAAC,GAGA,QAAA87E,GAAA/7E,EAAAC,GACA3V,KAAA0V,OACA1V,KAAA2V,OACA3V,KAAA4H,OAAA,EACA5H,KAAA+b,OAAA,EACA/b,KAAA2sB,SAAA3nB,MAAA0Q,EAAAC,GAgCA,QAAAy7E,KA8BA,QAAAM,KACA7zE,EAAA8zE,MAAA,KACA9zE,EAAAmG,MA/BA,GAAA1S,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAAAya,GAAAg+C,EAAA77D,KAAAoD,WACA2O,EAAA/R,KAAAizD,OACAviD,EAAA3D,KAAAC,IAAAskF,EAAAvkF,KAAAuR,IAAAizE,EAAAx/E,EAAArB,EAAA3D,KAAAM,IAAA,EAAAukF,EAAA5sF,MAAAhF,KAAAoD,cACAX,EAAAyrB,GAAAluB,KAIA,IAAA6d,EAAA8zE,MACA9zE,EAAAqQ,MAAA,QAAAzrB,EAAA,IAAAob,EAAAqQ,MAAA,QAAAzrB,EAAA,KACAob,EAAAqQ,MAAA,GAAAnc,EAAAysB,OAAA3gB,EAAAqQ,MAAA,GAAAzrB,IAEAsjB,aAAAlI,EAAA8zE,WAIA,IAAA5/E,EAAArB,MAAA,MAIAmN,GAAAqQ,OAAAzrB,EAAAsP,EAAAysB,OAAA/7B,IACAquB,GAAA9wB,MACA6d,EAAAjR,QAGAskF,KACArzE,EAAA8zE,MAAArrF,WAAAorF,EAAAG,GACAh0E,EAAAszE,KAAA,QAAAK,EAAA1uE,EAAA7U,EAAA8D,EAAArB,GAAAmN,EAAAqQ,MAAA,GAAArQ,EAAAqQ,MAAA,IAAArQ,EAAA8O,UAQA,QAAA8uC,KAcA,QAAAM,KAEA,GADAm1B,MACArzE,EAAAmQ,MAAA,CACA,GAAAhS,GAAAvc,EAAA2U,MAAAojD,QAAAxjC,EAAA/X,EAAAxc,EAAA2U,MAAAqjD,QAAAxjC,CACApW,GAAAmQ,MAAAhS,IAAAC,IAAAmgD,EAEAv+C,EAAAszE,KAAA,QAAAK,EAAA1uE,EAAAjF,EAAAnI,KAAAu9C,OAAAp1C,EAAAqQ,MAAA,GAAAA,GAAArQ,EAAAnI,MAAAmI,EAAAqQ,MAAA,IAAArQ,EAAA8O,SAGA,QAAAqvC,KACAzkD,EAAAzC,GAAA,oCACAuG,GAAA5b,EAAA2U,MAAAkH,KAAAuC,EAAAmQ,OACAkjE,KACArzE,EAAAmG,MA1BA,IAAAkM,GAAA5e,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAAAya,GAAAg+C,EAAA77D,KAAAoD,WACAmU,EAAAjH,GAAA7Q,EAAA2U,MAAAkH,MAAAxG,GAAA,iBAAAinD,GAAA,GAAAjnD,GAAA,eAAAknD,GAAA,GACAv5D,EAAAyrB,GAAAluB,MACAg0B,EAAAv0B,EAAA2U,MAAAojD,QACAvjC,EAAAx0B,EAAA2U,MAAAqjD,OAEA5mC,IAAApxB,EAAA2U,MAAAkH,MACA63C,KACAt1C,EAAAqQ,OAAAzrB,EAAAzC,KAAAizD,OAAAz0B,OAAA/7B,IACAquB,GAAA9wB,MACA6d,EAAAjR,SAmBA,QAAAykF,KACA,GAAA//E,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAAAqc,GAAAzf,KAAAizD,OACA14B,EAAArM,GAAAluB,MACAspD,EAAA7pC,EAAA+e,OAAAjE,GACAg3D,EAAA9xE,EAAA/O,GAAAjR,EAAA2U,MAAAuc,SAAA,MACAhR,EAAA6xE,EAAA1uE,EAAA7U,EAAAwR,EAAA8xE,GAAAh3D,EAAA+uB,GAAA38B,EAAA3nB,MAAAhF,KAAAoD,WAEA8tF,MACAjqE,EAAA,EAAA3W,GAAAtQ,MAAA6Q,aAAAoW,YAAApmB,KAAA4K,EAAAkU,EAAA4a,GACAjqB,GAAAtQ,MAAAa,KAAAswF,EAAAngF,UAAA2O,IAGA,QAAA+7C,KACA,GAAApqD,EAAAtM,MAAAhF,KAAAoD,WAAA,CACA,GAEAwqB,GACA3nB,EAAA8L,EAAAtP,EAHAob,EAAAg+C,EAAA77D,KAAAoD,WACAk5D,EAAA78D,EAAA2U,MAAAmc,eAEAve,EAAAsqD,EAAAj5D,MAGA,KADA8vD,KACAltD,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB8L,EAAAuqD,EAAAr2D,GAAAxD,EAAA44D,GAAAr7D,KAAAs8D,EAAAvqD,EAAAmK,YACAzZ,KAAAzC,KAAAizD,OAAAz0B,OAAA/7B,GAAAsP,EAAAmK,YACA2B,EAAAi0E,OACAj0E,EAAAk0E,SAAAl0E,EAAAk0E,OAAAtvF,IADAob,EAAAi0E,OAAArvF,EAAAmrB,GAAA,EAKA,IAAAokE,IACAA,EAAAjsE,aAAAisE,IACAn0E,EAAAk0E,QAIA,MAHAl0E,GAAAmG,YACAvhB,EAAA6N,GAAAtQ,MAAA8U,GAAA,mBACArS,EAAAuC,MAAAhF,KAAAoD,WAKAwqB,KACAokE,EAAA1rF,WAAA,WAA6C0rF,EAAA,MAAwBC,GACrEnhE,GAAA9wB,MACA6d,EAAAjR,UAIA,QAAA+uD,KACA,GAEA11D,GAAA8L,EAAAtP,EAAA0b,EAFAN,EAAAg+C,EAAA77D,KAAAoD,WACAk5D,EAAA78D,EAAA2U,MAAAmc,eACAve,EAAAsqD,EAAAj5D,MAIA,KAFA6tF,KACAc,MAAAjsE,aAAAisE,IACA/rF,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB8L,EAAAuqD,EAAAr2D,GAAAxD,EAAA44D,GAAAr7D,KAAAs8D,EAAAvqD,EAAAmK,YACA2B,EAAAi0E,QAAAj0E,EAAAi0E,OAAA,KAAA//E,EAAAmK,WAAA2B,EAAAi0E,OAAA,GAAArvF,EACAob,EAAAk0E,QAAAl0E,EAAAk0E,OAAA,KAAAhgF,EAAAmK,aAAA2B,EAAAk0E,OAAA,GAAAtvF,EAGA,IADAsP,EAAA8L,EAAAnI,KAAAu9C,OACAp1C,EAAAk0E,OAAA,CACA,GAAAx3D,GAAA1c,EAAAi0E,OAAA,GAAAI,EAAAr0E,EAAAi0E,OAAA,GACAxoC,EAAAzrC,EAAAk0E,OAAA,GAAAI,EAAAt0E,EAAAk0E,OAAA,GACAK,KAAA9oC,EAAA,GAAA/uB,EAAA,IAAA63D,KAAA9oC,EAAA,GAAA/uB,EAAA,IAAA63D,EACAC,KAAAF,EAAA,GAAAD,EAAA,IAAAG,KAAAF,EAAA,GAAAD,EAAA,IAAAG,CACAtgF,GAAA9D,EAAA8D,EAAAhF,KAAAiT,KAAAoyE,EAAAC,IACA5vF,IAAA83B,EAAA,GAAA+uB,EAAA,OAAA/uB,EAAA,GAAA+uB,EAAA,OACAnrC,IAAA+zE,EAAA,GAAAC,EAAA,OAAAD,EAAA,GAAAC,EAAA,WAEA,KAAAt0E,EAAAi0E,OACA,MADArvF,GAAAob,EAAAi0E,OAAA,GAAA3zE,EAAAN,EAAAi0E,OAAA,GAEAj0E,EAAAszE,KAAA,QAAAK,EAAA1uE,EAAA/Q,EAAAtP,EAAA0b,GAAAN,EAAA8O,SAGA,QAAAivC,KACA,GAEA31D,GAAA8L,EAFA8L,EAAAg+C,EAAA77D,KAAAoD,WACAk5D,EAAA78D,EAAA2U,MAAAmc,eACAve,EAAAsqD,EAAAj5D,MAKA,KAHA8vD,KACAjjC,GAAAnK,aAAAmK,GACAA,EAAA5pB,WAAA,WAAyC4pB,EAAA,MAAsB+hE,GAC/DhsF,EAAA,EAAeA,EAAA+L,IAAO/L,EACtB8L,EAAAuqD,EAAAr2D,GACA4X,EAAAi0E,QAAAj0E,EAAAi0E,OAAA,KAAA//E,EAAAmK,iBAAA2B,GAAAi0E,OACAj0E,EAAAk0E,QAAAl0E,EAAAk0E,OAAA,KAAAhgF,EAAAmK,kBAAA2B,GAAAk0E,MAEAl0E,GAAAk0E,SAAAl0E,EAAAi0E,SAAAj0E,EAAAi0E,OAAAj0E,EAAAk0E,aAAAl0E,GAAAk0E,QACAl0E,EAAAi0E,OAAAj0E,EAAAi0E,OAAA,GAAA9xF,KAAAizD,OAAAz0B,OAAA3gB,EAAAi0E,OAAA,IACAj0E,EAAAmG,MAhVA,GAaAguE,GACA9hE,EAdA5e,EAAA8hD,GACAzmC,EAAA0mC,GACAu+B,EAAAl+B,GACA49B,EAAA,EACAC,EAAA3rE,IACAoO,GAAAu9D,EACAr9D,EAAAq9D,EACAt9D,EAAAD,EACAG,EAAAD,EACAjN,EAAA,IACAwY,EAAAmoC,GACAvL,KACAtrC,EAAAzlB,EAAA,sBAGA2mF,EAAA,IACAJ,EAAA,IACAz1B,EAAA,CAuWA,OAvVA+0B,GAAAngF,UAAA,SAAAshF,EAAA5V,GACA,GAAAlhE,GAAA82E,EAAA7iF,UAAA6iF,EAAA7iF,YAAA6iF,CACA92E,GAAA8R,SAAA,SAAAmmC,IACA6+B,IAAA92E,EACA/P,EAAA6mF,EAAA5V,GAEAlhE,EAAAsV,YAAAvf,KAAA,WACAsqD,EAAA77D,KAAAoD,WACAwJ,QACAukF,KAAA,uBAAAzU,KAAA13E,MAAAhF,KAAAoD,WAAAs5E,GACA14D,SAKAmtE,EAAAoB,QAAA,SAAA/2E,EAAA9K,GACAygF,EAAAqB,QAAAh3E,EAAA,WAGA,MAFAxb,MAAAizD,OAAAviD,GACA,kBAAAA,KAAA1L,MAAAhF,KAAAoD,WAAAsN,MAKAygF,EAAAqB,QAAA,SAAAh3E,EAAA9K,GACAygF,EAAAngF,UAAAwK,EAAA,WACA,GAAAvT,GAAA0kB,EAAA3nB,MAAAhF,KAAAoD,WACAqc,EAAAzf,KAAAizD,OACA14B,EAAAu9C,EAAA7vE,GACAqhD,EAAA7pC,EAAA+e,OAAAjE,EAEA,OAAAi3D,GAAA1uE,EAAA7U,EAAAwR,EADA,kBAAA/O,KAAA1L,MAAAhF,KAAAoD,WAAAsN,GACA6pB,EAAA+uB,GAAArhD,MAIAkpF,EAAAsB,YAAA,SAAAj3E,EAAA7P,EAAAoC,GACAojF,EAAAngF,UAAAwK,EAAA,WACA,MAAAg2E,GAAAxxF,KAAAizD,OAAAnwC,UACA,kBAAAnX,KAAA3G,MAAAhF,KAAAoD,WAAAuI,EACA,kBAAAoC,KAAA/I,MAAAhF,KAAAoD,WAAA2K,GACA4e,EAAA3nB,MAAAhF,KAAAoD,eAIA+tF,EAAAuB,YAAA,SAAAl3E,EAAA7P,EAAAoC,GACAojF,EAAAngF,UAAAwK,EAAA,WACA,GAAAvT,GAAA0kB,EAAA3nB,MAAAhF,KAAAoD,WACA2O,EAAA/R,KAAAizD,OACAxwD,EAAAq1E,EAAA7vE,EACA,OAAAupF,GAAAt+B,GAAApwC,UAAArgB,EAAA,GAAAA,EAAA,IAAAwL,MAAA8D,EAAArB,GAAAoS,UACA,kBAAAnX,MAAA3G,MAAAhF,KAAAoD,YAAAuI,EACA,kBAAAoC,MAAA/I,MAAAhF,KAAAoD,YAAA2K,GACA9F,MAoEAwpF,EAAAtxF,WACAyM,MAAA,WAKA,MAJA,MAAA5M,KAAA+b,SACA/b,KAAA4H,MAAAy0D,EAAAj0D,KAAApI,MAAA,EACAA,KAAA+vB,KAAA,UAEA/vB,MAEAmxF,KAAA,SAAA56E,EAAAmmE,GAMA,MALA18E,MAAAkuB,OAAA,UAAA3X,IAAAvW,KAAAkuB,MAAA,GAAAwuD,EAAAl+C,OAAAx+B,KAAAkuB,MAAA,KACAluB,KAAA8xF,QAAA,UAAAv7E,IAAAvW,KAAA8xF,OAAA,GAAApV,EAAAl+C,OAAAx+B,KAAA8xF,OAAA,KACA9xF,KAAA+xF,QAAA,UAAAx7E,IAAAvW,KAAA+xF,OAAA,GAAArV,EAAAl+C,OAAAx+B,KAAA+xF,OAAA,KACA/xF,KAAA0V,KAAAu9C,OAAAypB,EACA18E,KAAA+vB,KAAA,QACA/vB,MAEAgkB,IAAA,WAMA,MALA,MAAAhkB,KAAA+b,SACAsgD,EAAAzzD,OAAA5I,KAAA4H,MAAA,GACA5H,KAAA4H,OAAA,EACA5H,KAAA+vB,KAAA,QAEA/vB,MAEA+vB,KAAA,SAAAtd,GACAgD,EAAA,GAAAq9C,IAAAq+B,EAAA1+E,EAAAzS,KAAA0V,KAAAu9C,QAAAliC,EAAA/rB,MAAA+rB,GAAAte,EAAAzS,KAAA0V,KAAA1V,KAAA2V,SAkKAw7E,EAAAS,WAAA,SAAApgF,GACA,MAAApO,WAAAC,QAAAuuF,EAAA,kBAAApgF,KAAAk/E,IAAAl/E,GAAA2/E,GAAAS,GAGAT,EAAA7/E,OAAA,SAAAE,GACA,MAAApO,WAAAC,QAAAiO,EAAA,kBAAAE,KAAAk/E,KAAAl/E,GAAA2/E,GAAA7/E,GAGA6/E,EAAAxkE,OAAA,SAAAnb,GACA,MAAApO,WAAAC,QAAAspB,EAAA,kBAAAnb,KAAAk/E,MAAAl/E,EAAA,OAAAA,EAAA,SAAAA,EAAA,OAAAA,EAAA,SAAA2/E,GAAAxkE,GAGAwkE,EAAAwB,YAAA,SAAAnhF,GACA,MAAApO,WAAAC,QAAAiuF,GAAA9/E,EAAA,GAAA+/E,GAAA//E,EAAA,GAAA2/E,IAAAG,EAAAC,IAGAJ,EAAAyB,gBAAA,SAAAphF,GACA,MAAApO,WAAAC,QAAA2wB,GAAAxiB,EAAA,MAAA0iB,GAAA1iB,EAAA,MAAAyiB,GAAAziB,EAAA,MAAA2iB,GAAA3iB,EAAA,MAAA2/E,KAAAn9D,EAAAC,IAAAC,EAAAC,KAGAg9D,EAAAlqE,SAAA,SAAAzV,GACA,MAAApO,WAAAC,QAAA4jB,GAAAzV,EAAA2/E,GAAAlqE,GAGAkqE,EAAA1xD,YAAA,SAAAjuB,GACA,MAAApO,WAAAC,QAAAo8B,EAAAjuB,EAAA2/E,GAAA1xD,GAGA0xD,EAAAr8E,GAAA,WACA,GAAA9S,GAAA+uB,EAAAjc,GAAA9P,MAAA+rB,EAAA3tB,UACA,OAAApB,KAAA+uB,EAAAogE,EAAAnvF,GAGAmvF,EAAA30B,cAAA,SAAAhrD,GACA,MAAApO,WAAAC,QAAA+4D,GAAA5qD,QAAA2/E,GAAApkF,KAAAiT,KAAAo8C,IAGA+0B,EAGA1xF,GAAAozF,QA/ngBA,SAgogBApzF,EAAAqzF,OAAAj8C,GACAp3C,EAAAo3C,eACAp3C,EAAAw0D,cACAx0D,EAAA+M,aACA/M,EAAAslD,YACAtlD,EAAA00D,SACA10D,EAAA60D,cACA70D,EAAAk1D,aACAl1D,EAAAktB,UACAltB,EAAAu1D,aACAv1D,EAAAszF,0BAAA39B,GACA31D,EAAAuzF,eAAA39B,GACA51D,EAAAwzF,iBAAAn+B,GACAr1D,EAAAuN,OACAvN,EAAAi1D,QACAj1D,EAAA61D,UACA71D,EAAA+Q,SACA/Q,EAAA6e,OACA7e,EAAAy0D,SACAz0D,EAAAi2D,WACAj2D,EAAA+4C,SAAAE,GACAj5C,EAAA4P,MAAA4zB,GACAxjC,EAAAm2D,QACAn2D,EAAAs2D,WACAt2D,EAAA+tC,OACA/tC,EAAAmP,SACAnP,EAAAkN,gBACAlN,EAAAgO,WACAhO,EAAAu2D,aACAv2D,EAAA+0D,YACA/0D,EAAAw2D,OACAx2D,EAAAkS,UACAlS,EAAAmS,YACAnS,EAAAoS,aACApS,EAAAqS,WACArS,EAAA2tB,SACA3tB,EAAAstB,UACAttB,EAAAytB,UACAztB,EAAAmtB,kBACAntB,EAAAysE,SACAzsE,EAAAuuE,UACAvuE,EAAAkvE,QACAlvE,EAAAmT,IAAAkgB,GACArzB,EAAA8S,IAAAggB,GACA9yB,EAAAgvE,QACAhvE,EAAAiP,UACAjP,EAAAivE,WACAjvE,EAAAkd,SACAld,EAAAse,OACAte,EAAA8e,OACA9e,EAAA6f,OACA7f,EAAAwgB,OACAxgB,EAAAkhB,aACAlhB,EAAA6L,WACA7L,EAAA+7D,QACA/7D,EAAAoxB,eACApxB,EAAAyzF,WAAA73E,GACA5b,EAAA0zF,UAAA/jB,GACA3vE,EAAAywE,YACAzwE,EAAA0wE,gBACA1wE,EAAA2wE,aACA3wE,EAAA4wE,iBACA5wE,EAAA8wE,YACA9wE,EAAA+wE,gBACA/wE,EAAAgxE,aACAhxE,EAAAixE,iBACAjxE,EAAA2zF,WAAAppE,GACAvqB,EAAA4zF,SAAAlpE,GACA1qB,EAAA6zF,WAAArpE,GACAxqB,EAAA8zF,YAAArpE,GACAzqB,EAAA+zF,cAAArpE,GACA1qB,EAAAg0F,UAAAnpE,GACA7qB,EAAAi0F,YAAAtpE,GACA3qB,EAAAk0F,aAAAtpE,GACA5qB,EAAAm0F,eAAAtpE,GACA7qB,EAAAo0F,SAAAlpB,GACAlrE,EAAAq0F,WAAAtpB,GACA/qE,EAAAs0F,YAAArpB,GACAjrE,EAAAu0F,cAAArpB,GACAlrE,EAAAw0F,QAAAvpE,GACAjrB,EAAAy0F,UAAA3pE,GACA9qB,EAAA00F,WAAA1pE,GACAhrB,EAAA20F,aAAA1pE,GACAjrB,EAAA40F,QAAAvpE,GACArrB,EAAA60F,UAAA1pE,GACAnrB,EAAA80F,WAAA1pE,GACAprB,EAAA+0F,aAAA1pE,GACArrB,EAAAg1F,WAAAxpE,GACAxrB,EAAAi1F,aAAA3pE,GACAtrB,EAAAk1F,cAAA3pE,GACAvrB,EAAAm1F,gBAAA3pE,GACAxrB,EAAAo1F,WAAA1pE,GACA1rB,EAAAq1F,aAAA5pE,GACAzrB,EAAAs1F,cAAA5pE,GACA1rB,EAAAu1F,gBAAAlpE,GACArsB,EAAAw1F,SAAAlqB,GACAtrE,EAAAy1F,WAAAtqB,GACAnrE,EAAA01F,YAAArqB,GACArrE,EAAA21F,cAAArqB,GACAtrE,EAAA41F,YAAAjqB,GACA3rE,EAAA61F,cAAArqB,GACAxrE,EAAA81F,eAAAnqB,GACA3rE,EAAA+1F,iBAAAnqB,GACA5rE,EAAAg2F,YAAA9kB,GACAlxE,EAAAi2F,aAAAtjB,GACA3yE,EAAAk2F,UAAAhtC,GACAlpD,EAAAm2F,cAAA3hB,GACAx0E,EAAAo2F,gBAAAtiB,GACA9zE,EAAAq2F,OAAAthB,GACA/0E,EAAAs2F,OAAAthB,GACAh1E,EAAAu2F,oBAAA3/D,GACA52B,EAAA82B,gBACA92B,EAAAg2B,mBACAh2B,EAAA82E,kBACA92E,EAAA+2E,mBACA/2E,EAAAg3E,kBACAh3E,EAAAw2F,QAAAve,GACAj4E,EAAAy2F,UAAAve,GACAl4E,EAAA02F,YAAAre,GACAr4E,EAAA22F,UAAAzlD,GACAlxC,EAAA42F,cAAAne,GACAz4E,EAAA62F,YAAA97B,GACA/6D,EAAA82F,YAAA9zD,GACAhjC,EAAA+2F,aAAArzD,GACA1jC,EAAAg3F,eAAA3yD,GACArkC,EAAAi3F,eAAA/d,GACAl5E,EAAAk3F,UAAAne,GACA/4E,EAAAm3F,QAAApd,GACA/5E,EAAAo3F,UAAAvb,GACA77E,EAAAq3F,aAAAvb,GACA97E,EAAAs3F,sBAAA9a,GACAx8E,EAAAu3F,yBAAAjb,GACAt8E,EAAAw3F,wBAAA9a,GACA18E,EAAAy3F,2BAAAhb,GACAz8E,EAAA03F,kBAAA9a,GACA58E,EAAA23F,qBAAAprD,GACAvsC,EAAA43F,kBAAAhc,GACA57E,EAAA63F,qBAAAtsD,GACAvrC,EAAA83F,oBAAAhb,GACA98E,EAAA+3F,uBAAAprD,GACA3sC,EAAAg4F,mBAAAnb,GACA78E,EAAAi4F,sBAAAvrD,GACA1sC,EAAAk4F,YAAAnb,GACA/8E,EAAAm4F,eAAArrD,GACA9sC,EAAAo4F,YAAApb,GACAh9E,EAAAq4F,cAAAjwD,GACApoC,EAAAs4F,qBAAApuD,GACAlqC,EAAAu4F,YAAA5b,GACA38E,EAAAw4F,eAAAtsD,GACAlsC,EAAAy4F,gBAAArb,GACAp9E,EAAA04F,mBAAAtrD,GACAptC,EAAA24F,iBAAAtb,GACAr9E,EAAA44F,oBAAAvrD,GACArtC,EAAA64F,sBAAAvb,GACAt9E,EAAA84F,yBAAAxrD,GACAttC,EAAA+4F,YAAAj6D,GACA9+B,EAAAsoC,aACAtoC,EAAAg5F,aAAAznF,GACAvR,EAAAu9E,WACAv9E,EAAAouC,aACApuC,EAAAyxC,KAAAmtC,GACA5+E,EAAAi5F,aAAAva,GACA1+E,EAAAoxC,YAAAM,GACA1xC,EAAA8+E,aACA9+E,EAAAm/E,YACAn/E,EAAAi0B,QACAj0B,EAAAogF,QAAAD,GACAngF,EAAAk5F,cAAAvY,GACA3gF,EAAAi0C,eACAj0C,EAAAk0C,gBACAl0C,EAAAm5F,iBAAAhY,GACAnhF,EAAAo5F,gBAAAlZ,GACAlgF,EAAAq5F,kBAAAjY,GACAphF,EAAAggC,YAAAtO,GACA1xB,EAAAs5F,iBAAApyB,GACAlnE,EAAAu5F,iBAAA5yB,GACA3mE,EAAAw5F,uBAAA5yB,GACA5mE,EAAAy5F,gBAAA9/C,GACA35C,EAAA05F,kBAAA/1E,GACA3jB,EAAA25F,kBAAA5mE,GACA/yB,EAAA23C,oBACA33C,EAAAunE,qBACAvnE,EAAA+nE,2BACA/nE,EAAAgoE,2BACAhoE,EAAAmoE,mBACAnoE,EAAA6mE,kBACA7mE,EAAA45F,oBAAA5yB,GACAhnE,EAAA65F,0BAAA5yB,GACAjnE,EAAA85F,eAAArxB,GACAzoE,EAAA+5F,mBAAArxB,GACA1oE,EAAAg6F,eAAAx1E,GACAxkB,EAAAi6F,eAAAtxB,GACA3oE,EAAAk6F,mBAAAtxB,GACA5oE,EAAAm6F,qBAAAtxB,GACA7oE,EAAAo6F,yBAAAtxB,GACA9oE,EAAA+oE,YACA/oE,EAAAiQ,QACAjQ,EAAAq6F,YAAA/Y,GACAthF,EAAAs6F,gBAAA/Y,EACAvhF,GAAAu6F,YAAA/Y,GACAxhF,EAAAojC,gBAAA2+C,GACA/hF,EAAAw6F,cAAAvY,GACAjiF,EAAAo1B,YACAp1B,EAAAo1C,SACAp1C,EAAA2iF,cAAAF,GACAziF,EAAA6iF,aAAA9nD,GACA/6B,EAAAkjF,gBAAAF,GACAhjF,EAAAwjF,YAAAF,GACAtjF,EAAAqjF,gBAAAF,GACAnjF,EAAA2jF,kBAAAF,GACAzjF,EAAA4jF,WACA5jF,EAAA27D,QACA37D,EAAAulF,QACAvlF,EAAA8Q,QACA9Q,EAAA42D,OACA52D,EAAAwwE,IAAAkV,GACA1lF,EAAA6wE,IAAA8U,GACA3lF,EAAAy6F,UAAAtkD,GACAn2C,EAAA06F,WAAAhkD,GACA12C,EAAA26F,cAAA5iD,GACA/3C,EAAA46F,YAAA9iD,GACA93C,EAAA66F,SAAAriD,GACAx4C,EAAA86F,aAAAhlD,GACA91C,EAAA+6F,cAAA/kD,GACAh2C,EAAAg7F,SAAAniD,GACA74C,EAAAi7F,UAAAniD,GACA94C,EAAAk7F,cAAAniD,GACA/4C,EAAAm7F,cAAA9hD,GACAr5C,EAAAo7F,eAAA9hD,GACAt5C,EAAAq7F,UAAA71E,GACAxlB,EAAAs7F,SAAAvS,GACA/oF,EAAAu7F,iBAAAvS,GACAhpF,EAAAw7F,kBAAAvS,GACAjpF,EAAAy7F,kBAAAvS,GACAlpF,EAAA07F,iBAAAvS,GACAnpF,EAAA27F,4BAAAvS,GACAppF,EAAA47F,mBAAApS,GACAxpF,EAAA67F,gBAAAxS,GACArpF,EAAA87F,gBAAAxS,GACAtpF,EAAA+7F,mBAAArS,GACA1pF,EAAAg8F,iBAAArS,GACA3pF,EAAAi8F,mBAAArS,GACA5pF,EAAAk8F,kBAAArS,GACA7pF,EAAAm8F,gBAAAn2C,GACAhmD,EAAAg3D,WACAh3D,EAAAkU,MAAAC,EACAnU,EAAAi3D,QAAAQ,GACAz3D,EAAAyuB,SACAzuB,EAAA82D,aACA92D,EAAA02D,cACA12D,EAAA6Q,UACA7Q,EAAAkQ,aACAlQ,EAAAgQ,aACAhQ,EAAAsM,YACAtM,EAAA64D,eACA74D,EAAAiY,MAAAM,EACAvY,EAAA47D,SACA57D,EAAAwwB,WACAxwB,EAAAoK,OAAAqO,GACAzY,EAAAgW,cACAhW,EAAAwwD,OACAxwD,EAAAi4E,KAAAsT,GACAvrF,EAAA4Q,QACA5Q,EAAAisF,OACAjsF,EAAAqsF,cACArsF,EAAAo8F,WAAA/P,GACArsF,EAAA8oD,WAAAsjC,GACApsF,EAAAq8F,WAAAjQ,GACApsF,EAAA4pD,eACA5pD,EAAAgqD,kBACAhqD,EAAAiqD,gBACAjqD,EAAAkqD,cACAlqD,EAAAw2B,UACAx2B,EAAAstF,WACAttF,EAAAs8F,aAAA5P,GACA1sF,EAAAu8F,YAAA3P,GACA5sF,EAAAw8F,cAAAzP,GACA/sF,EAAAy8F,aAAAvP,GACAltF,EAAA08F,WAAAzP,GACAjtF,EAAA28F,eAAAvP,GACAptF,EAAA48F,UAAAvP,GACArtF,EAAA68F,iBAAAhP,GACA7tF,EAAA88F,eAAAhP,GACA9tF,EAAA+8F,WAAAvP,GACAxtF,EAAAg9F,YAAAjP,GACA/tF,EAAAi9F,oBAAA9O,GACAnuF,EAAAk9F,kBAAA7O,GACAruF,EAAAm9F,cAAAnP,GACAhuF,EAAAo9F,sBAAA3O,GACAzuF,EAAAq9F,oBAAA1O,GACA3uF,EAAAs9F,gBAAA9O,GACAxuF,EAAAu9F,kBAAA3O,GACA5uF,EAAAorF,eACAprF,EAAAw9F,eAAAhxC,GACAxsD,EAAAy9F,eAAAhxC,GACAzsD,EAAA09F,aAAA1O,GACAhvF,EAAA29F,UAAAtwF,GACArN,EAAA49F,eAAA7wC,GACA/sD,EAAA69F,gBAAA/wC,GACA9sD,EAAAmvF,SACAnvF,EAAA89F,kBAAApO,GACA1vF,EAAA+9F,qBAAApO,GACA3vF,EAAAg+F,gBAAA/O,GACAjvF,EAAAi+F,sBAAApO,GACA7vF,EAAAk+F,kBAAApO,GACA9vF,EAAAm+F,oBAAAhO,GACAnwF,EAAAo+F,qBAAAhO,GACApwF,EAAAq+F,oBAAAhO,GACArwF,EAAAs+F,eAAApP,GACAlvF,EAAAu+F,kBAAAv6D,GACAhkC,EAAAw+F,aAAAjlD,GACAv5C,EAAAy+F,gBAAA5Y,GACA7lF,EAAA0+F,iBAAA5Y,GACA9lF,EAAA2+F,eAAA9Y,GACA7lF,EAAA4+F,gBAAA9Y,GACA9lF,EAAA6+F,WAAA9Y,GACA/lF,EAAA8+F,YAAA9Y,GACAhmF,EAAA++F,UAAAhZ,GACA/lF,EAAAg/F,WAAAhZ,GACAhmF,EAAAi/F,WAAAhZ,GACAjmF,EAAAk/F,YAAAhZ,GACAlmF,EAAAm/F,SAAAhZ,GACAnmF,EAAAo/F,UAAAhZ,GACApmF,EAAAq/F,QAAAz8C,GACA5iD,EAAAs/F,SAAAtgD,GACAh/C,EAAAu/F,SAAAt8C,GACAjjD,EAAAw/F,UAAA9Y,GACA1mF,EAAAy/F,WAAAx8C,GACAjjD,EAAA0/F,YAAAhZ,GACA1mF,EAAA2/F,WAAAz8C,GACAljD,EAAA4/F,YAAAjZ,GACA3mF,EAAA6/F,YAAAxZ,GACArmF,EAAA8/F,aAAAlZ,GACA5mF,EAAA+/F,cAAAzZ,GACAtmF,EAAAggG,eAAAnZ,GACA7mF,EAAAigG,aAAA1Z,GACAvmF,EAAAkgG,cAAApZ,GACA9mF,EAAAmgG,WAAA3Z,GACAxmF,EAAAogG,YAAArZ,GACA/mF,EAAAqgG,aAAA5Z,GACAzmF,EAAAsgG,cAAAtZ,GACAhnF,EAAAugG,UAAAtZ,GACAjnF,EAAAwgG,WAAAthD,GACAl/C,EAAAygG,SAAA59C,GACA7iD,EAAA0gG,UAAAvZ,GACAnnF,EAAAonF,aACApnF,EAAAsnF,cACAtnF,EAAAunF,WACAvnF,EAAAynF,YACAznF,EAAAojD,UACApjD,EAAA0nF,WACA1nF,EAAA2gG,QAAAl9C,GACAzjD,EAAA4gG,SAAA5Y,GACAhoF,EAAAyjD,aACAzjD,EAAAgoF,cACAhoF,EAAA0jD,aACA1jD,EAAAioF,cACAjoF,EAAA2nF,cACA3nF,EAAAkoF,eACAloF,EAAA4nF,gBACA5nF,EAAAmoF,iBACAnoF,EAAA6nF,eACA7nF,EAAAooF,gBACApoF,EAAA8nF,aACA9nF,EAAAqoF,cACAroF,EAAA+nF,eACA/nF,EAAAsoF,gBACAtoF,EAAAuoF,YACAvoF,EAAAyoF,aACAzoF,EAAAqjD,WACArjD,EAAA0oF,YACA1oF,EAAA6gG,wBAAAj9C,GACA5jD,EAAA8gG,iBAAAvlD,GACAv7C,EAAA+gG,UAAAlY,GACA7oF,EAAAghG,SAAAlY,GACA9oF,EAAA6kB,OACA7kB,EAAAslB,SACAtlB,EAAA0lB,cACA1lB,EAAA+lB,QAAAqB,GACApnB,EAAAumB,SAAA4iD,GACAnpE,EAAAoR,cACApR,EAAAsc,UACAtc,EAAAqxB,aACArxB,EAAAgxF,WACAhxF,EAAA0xF,QACA1xF,EAAAihG,cAAA1tC,GACAvzD,EAAAkhG,aAAAztC,GAEAvwD,OAAAi+F,eAAAnhG,EAAA,cAA8CuC,OAAA,OhBy6CxC,SAAUxC,EAAQC,EAASC,GAEjC,YiBr7jBA,IAAAoG,GAAApG,EAAA,GAeAmhG,EAAA,WACA,QAAAA,GAAAC,EAAA9+F,EAAAvB,GACAT,KAAA8gG,OACA9gG,KAAAgC,QACAhC,KAAAS,QACAT,KAAA+gG,SAAA,MAAAD,EAsGA,MA/FAD,GAAA1gG,UAAA6gG,QAAA,SAAAC,GACA,OAAAjhG,KAAA8gG,MACA,QACA,MAAAG,GAAA5/F,MAAA4/F,EAAA5/F,KAAArB,KAAAgC,MACA,SACA,MAAAi/F,GAAAxgG,OAAAwgG,EAAAxgG,MAAAT,KAAAS,MACA,SACA,MAAAwgG,GAAAvgG,UAAAugG,EAAAvgG,aAWAmgG,EAAA1gG,UAAA+gG,GAAA,SAAA7/F,EAAAZ,EAAAC,GAEA,OADAV,KAAA8gG,MAEA,QACA,MAAAz/F,MAAArB,KAAAgC,MACA,SACA,MAAAvB,MAAAT,KAAAS,MACA,SACA,MAAAC,UAYAmgG,EAAA1gG,UAAAghG,OAAA,SAAAC,EAAA3gG,EAAAC,GACA,MAAA0gG,IAAA,kBAAAA,GAAA//F,KACArB,KAAAghG,QAAAI,GAGAphG,KAAAkhG,GAAAE,EAAA3gG,EAAAC,IAQAmgG,EAAA1gG,UAAAkhG,aAAA,WAEA,OADArhG,KAAA8gG,MAEA,QACA,MAAAh7F,GAAAhG,WAAAkL,GAAAhL,KAAAgC,MACA,SACA,MAAA8D,GAAAhG,WAAAwhG,MAAAthG,KAAAS,MACA,SACA,MAAAqF,GAAAhG,WAAAyD,QAEA,SAAA3B,OAAA,uCASAi/F,EAAAU,WAAA,SAAAv/F,GACA,gBAAAA,EACA,GAAA6+F,GAAA,IAAA7+F,GAEA6+F,EAAAW,4BASAX,EAAAY,YAAA,SAAAtgG,GACA,UAAA0/F,GAAA,QAAA7rE,GAAA7zB,IAMA0/F,EAAAa,eAAA,WACA,MAAAb,GAAAc,sBAEAd,EAAAc,qBAAA,GAAAd,GAAA,KACAA,EAAAW,2BAAA,GAAAX,GAAA,QAAA7rE,IACA6rE,IAEAphG,GAAAohG,gBjB47jBM,SAAUrhG,EAAQC,EAASC,GAEjC,YkB1jkBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA5C,EAAAD,EAAA,GACAkiG,EAAAliG,EAAA,KAMA+K,EAAA,SAAAxH,GAEA,QAAAwH,GAAAM,EAAA82F,GACA5+F,EAAApC,KAAAb,KAAA+K,EAAA82F,GACA7hG,KAAA+K,YACA/K,KAAA6hG,OACA7hG,KAAA8hG,SAAA,EAuHA,MA5HA1/F,GAAAqI,EAAAxH,GAOAwH,EAAAtK,UAAAsL,SAAA,SAAAF,EAAAyZ,GAEA,OADA,KAAAA,IAA+BA,EAAA,GAC/BhlB,KAAA6D,OACA,MAAA7D,KAGAA,MAAAuL,QAGAvL,KAAA8hG,SAAA,CACA,IAAAhmF,GAAA9b,KAAA8b,GACA/Q,EAAA/K,KAAA+K,SA4BA,OANA,OAAA+Q,IACA9b,KAAA8b,GAAA9b,KAAA+hG,eAAAh3F,EAAA+Q,EAAAkJ,IAEAhlB,KAAAglB,QAEAhlB,KAAA8b,GAAA9b,KAAA8b,IAAA9b,KAAAgiG,eAAAj3F,EAAA/K,KAAA8b,GAAAkJ,GACAhlB,MAEAyK,EAAAtK,UAAA6hG,eAAA,SAAAj3F,EAAA+Q,EAAAkJ,GAEA,WADA,KAAAA,IAA+BA,EAAA,GAC/BrlB,EAAA6B,KAAA0kB,YAAAnb,EAAAk3F,MAAA39F,KAAAyG,EAAA/K,MAAAglB,IAEAva,EAAAtK,UAAA4hG,eAAA,SAAAh3F,EAAA+Q,EAAAkJ,GAGA,WAFA,KAAAA,IAA+BA,EAAA,GAE/B,OAAAA,GAAAhlB,KAAAglB,YAAA,IAAAhlB,KAAA8hG,QACAhmF,EAIAnc,EAAA6B,KAAAykB,cAAAnK,QAAAkZ,YAMAvqB,EAAAtK,UAAA+hG,QAAA,SAAA32F,EAAAyZ,GACA,GAAAhlB,KAAA6D,OACA,UAAAjC,OAAA,+BAEA5B,MAAA8hG,SAAA,CACA,IAAArhG,GAAAT,KAAAmiG,SAAA52F,EAAAyZ,EACA,IAAAvkB,EACA,MAAAA,IAEA,IAAAT,KAAA8hG,SAAA,MAAA9hG,KAAA8b,KAcA9b,KAAA8b,GAAA9b,KAAA+hG,eAAA/hG,KAAA+K,UAAA/K,KAAA8b,GAAA,QAGArR,EAAAtK,UAAAgiG,SAAA,SAAA52F,EAAAyZ,GACA,GAAAo9E,IAAA,EACAC,MAAArtE,EACA,KACAh1B,KAAA6hG,KAAAt2F,GAEA,MAAAtD,GACAm6F,GAAA,EACAC,IAAAp6F,MAAA,GAAArG,OAAAqG,GAEA,GAAAm6F,EAEA,MADApiG,MAAAiC,cACAogG,GAGA53F,EAAAtK,UAAA0E,aAAA,WACA,GAAAiX,GAAA9b,KAAA8b,GACA/Q,EAAA/K,KAAA+K,UACAu3F,EAAAv3F,EAAAu3F,QACA16F,EAAA06F,EAAA35F,QAAA3I,KACAA,MAAA6hG,KAAA,KACA7hG,KAAAuL,MAAA,KACAvL,KAAA8hG,SAAA,EACA9hG,KAAA+K,UAAA,MACA,IAAAnD,GACA06F,EAAA15F,OAAAhB,EAAA,GAEA,MAAAkU,IACA9b,KAAA8b,GAAA9b,KAAA+hG,eAAAh3F,EAAA+Q,EAAA,OAEA9b,KAAAglB,MAAA,MAEAva,GACCm3F,EAAAW,OACD9iG,GAAAgL,elBikkBM,SAAUjL,EAAQC,EAASC,GAEjC,YmB9skBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAigG,EAAA9iG,EAAA,IACA8K,EAAA,SAAAvH,GAEA,QAAAuH,KACAvH,EAAA+B,MAAAhF,KAAAoD,WACApD,KAAAsiG,WAMAtiG,KAAA+b,QAAA,EAOA/b,KAAAyiG,cAAAztE,GAuBA,MAvCA5yB,GAAAoI,EAAAvH,GAkBAuH,EAAArK,UAAA8hG,MAAA,SAAAS,GACA,GAAAJ,GAAAtiG,KAAAsiG,OACA,IAAAtiG,KAAA+b,OAEA,WADAumF,GAAAl6F,KAAAs6F,EAGA,IAAAjiG,EACAT,MAAA+b,QAAA,CACA,IACA,GAAAtb,EAAAiiG,EAAAR,QAAAQ,EAAAn3F,MAAAm3F,EAAA19E,OACA,YAES09E,EAAAJ,EAAAjwD,QAET,IADAryC,KAAA+b,QAAA,EACAtb,EAAA,CACA,KAAAiiG,EAAAJ,EAAAjwD,SACAqwD,EAAAzgG,aAEA,MAAAxB,KAGA+J,GACCg4F,EAAAG,UACDljG,GAAA+K,kBnBqtkBM,SAAUhL,EAAQC,EAASC,GAEjC,YoBtwkBA,SAAAkjG,GAAAphG,GACA,GAAAqhG,GAAArhG,EAAAqhG,MACA,sBAAAA,GAIA,MAHAA,GAAAr8F,WACAq8F,EAAAr8F,SAAAq8F,EAAA,sBAEAA,EAAAr8F,QAIA,IAAAs8F,GAAAthG,EAAAqxB,GACA,IAAAiwE,GAAA,sBAAAA,IAAA,cACA,kBAEA,IAAAC,GAAAvhG,EAAA8wB,GAEA,IAAAywE,EAEA,OADAt0B,GAAA9rE,OAAAqgG,oBAAAD,EAAA5iG,WACA8F,EAAA,EAA2BA,EAAAwoE,EAAAprE,SAAiB4C,EAAA,CAC5C,GAAAsQ,GAAAk4D,EAAAxoE,EAEA,gBAAAsQ,GAAA,SAAAA,GAAAwsF,EAAA5iG,UAAAoW,KAAAwsF,EAAA5iG,UAAA,QACA,MAAAoW,GAIA,mBA3BA,GAAA5W,GAAAD,EAAA,EA8BAD,GAAAmjG,yBACAnjG,EAAA+G,SAAAo8F,EAAAjjG,EAAA6B,MAIA/B,EAAAwjG,WAAAxjG,EAAA+G,UpB8wkBM,SAAUhH,EAAQC,EAASC,GAEjC,YqBnzkBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAYA2gG,EAAA,SAAAjgG,GAEA,QAAAigG,KACA,GAAA/hG,GAAA8B,EAAApC,KAAAb,KAAA,wBACAA,MAAAwS,KAAArR,EAAAqR,KAAA,0BACAxS,KAAA4uF,MAAAztF,EAAAytF,MACA5uF,KAAAmjG,QAAAhiG,EAAAgiG,QAEA,MAPA/gG,GAAA8gG,EAAAjgG,GAOAigG,GACCthG,MACDnC,GAAAyjG,2BrB0zkBM,SAAU1jG,EAAQC,GsB/0kBxBD,EAAAC,QAAA,SACA2jG,EACAC,EACAC,EACAC,EACAC,GAEA,GAAAC,GACAC,EAAAN,QAGA3wF,QAAA2wF,GAAAO,OACA,YAAAlxF,GAAA,aAAAA,IACAgxF,EAAAL,EACAM,EAAAN,EAAAO,QAIA,IAAAC,GAAA,kBAAAF,GACAA,EAAAE,QACAF,CAGAL,KACAO,EAAAC,OAAAR,EAAAQ,OACAD,EAAAE,gBAAAT,EAAAS,iBAIAP,IACAK,EAAAG,SAAAR,EAGA,IAAAS,EA4BA,IA3BAR,GACAQ,EAAA,SAAA5/F,GAEAA,EACAA,GACApE,KAAAikG,QAAAjkG,KAAAikG,OAAAC,YACAlkG,KAAA4E,QAAA5E,KAAA4E,OAAAq/F,QAAAjkG,KAAA4E,OAAAq/F,OAAAC,WAEA9/F,GAAA,mBAAA+/F,uBACA//F,EAAA+/F,qBAGAb,GACAA,EAAAziG,KAAAb,KAAAoE,GAGAA,KAAAggG,uBACAhgG,EAAAggG,sBAAAtjG,IAAA0iG,IAKAI,EAAAS,aAAAL,GACGV,IACHU,EAAAV,GAGAU,EAAA,CACA,GAAAM,GAAAV,EAAAU,WACAC,EAAAD,EACAV,EAAAC,OACAD,EAAAY,YACAF,GAOAV,EAAAC,OAAA,SAAA5lF,EAAA7Z,GAEA,MADA4/F,GAAAnjG,KAAAuD,GACAmgG,EAAAtmF,EAAA7Z,IAPAw/F,EAAAY,aAAAD,KACAn9F,OAAAm9F,EAAAP,IACAA,GAUA,OACAP,WACAhkG,QAAAikG,EACAE,atB61kBM,SAAUpkG,EAAQC,EAASC,GAEjC,YuBt7kBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAmD,EAAAnD,EAAA,GAIAglG,EAAA,SAAAzhG,GAEA,QAAAyhG,KACAzhG,EAAA+B,MAAAhF,KAAAoD,WACApD,KAAAgC,MAAA,KACAhC,KAAA2kG,SAAA,EACA3kG,KAAA4kG,cAAA,EAgCA,MArCAxiG,GAAAsiG,EAAAzhG,GAOAyhG,EAAAvkG,UAAAD,WAAA,SAAAgC,GACA,MAAAlC,MAAAkJ,UACAhH,EAAAzB,MAAAT,KAAAmJ,aACAtG,EAAAqB,aAAAoE,OAEAtI,KAAA4kG,cAAA5kG,KAAA2kG,SACAziG,EAAAb,KAAArB,KAAAgC,OACAE,EAAAxB,WACAmC,EAAAqB,aAAAoE,OAEArF,EAAA9C,UAAAD,WAAAW,KAAAb,KAAAkC,IAEAwiG,EAAAvkG,UAAAkB,KAAA,SAAAW,GACAhC,KAAA4kG,eACA5kG,KAAAgC,QACAhC,KAAA2kG,SAAA,IAGAD,EAAAvkG,UAAAM,MAAA,SAAAA,GACAT,KAAA4kG,cACA3hG,EAAA9C,UAAAM,MAAAI,KAAAb,KAAAS,IAGAikG,EAAAvkG,UAAAO,SAAA,WACAV,KAAA4kG,cAAA,EACA5kG,KAAA2kG,SACA1hG,EAAA9C,UAAAkB,KAAAR,KAAAb,UAAAgC,OAEAiB,EAAA9C,UAAAO,SAAAG,KAAAb,OAEA0kG,GACCD,EAAAz7F,QACDvJ,GAAAilG,gBvB67kBM,SAAUllG,EAAQC,EAASC,GAEjC,YwBj/kBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAmlG,EAAAnlG,EAAA,IACAmD,EAAAnD,EAAA,GACAolG,EAAAplG,EAAA,IACAmJ,EAAAnJ,EAAA,IACAoJ,EAAApJ,EAAA,IAIAqlG,EAAA,SAAA9hG,GAEA,QAAA8hG,GAAAC,EAAAC,EAAAl6F,OACA,KAAAi6F,IAAoCA,EAAAE,OAAAC,uBACpC,KAAAF,IAAoCA,EAAAC,OAAAC,mBACpCliG,EAAApC,KAAAb,MACAA,KAAA+K,YACA/K,KAAAolG,WACAplG,KAAAqlG,YAAAL,EAAA,IAAAA,EACAhlG,KAAAslG,YAAAL,EAAA,IAAAA,EAmEA,MA3EA7iG,GAAA2iG,EAAA9hG,GAUA8hG,EAAA5kG,UAAAkB,KAAA,SAAAW,GACA,GAAAsiB,GAAAtkB,KAAAulG,SACAvlG,MAAAolG,QAAAh9F,KAAA,GAAAo9F,GAAAlhF,EAAAtiB,IACAhC,KAAAylG,2BACAxiG,EAAA9C,UAAAkB,KAAAR,KAAAb,KAAAgC,IAEA+iG,EAAA5kG,UAAAD,WAAA,SAAAgC,GACA,GAEAH,GAFAqjG,EAAAplG,KAAAylG,2BACA16F,EAAA/K,KAAA+K,SAEA,IAAA/K,KAAA6D,OACA,SAAAgF,GAAAS,uBAEAtJ,MAAAkJ,SACAnH,EAAAc,EAAAqB,aAAAoE,MAEAtI,KAAAmD,UACApB,EAAAc,EAAAqB,aAAAoE,OAGAtI,KAAAiJ,UAAAb,KAAAlG,GACAH,EAAA,GAAA+G,GAAAW,oBAAAzJ,KAAAkC,IAEA6I,GACA7I,EAAApB,IAAAoB,EAAA,GAAA4iG,GAAAY,oBAAAxjG,EAAA6I,GAGA,QADA7E,GAAAk/F,EAAA/hG,OACA4C,EAAA,EAAuBA,EAAAC,IAAAhE,EAAA2B,OAA+BoC,IACtD/D,EAAAb,KAAA+jG,EAAAn/F,GAAAjE,MAQA,OANAhC,MAAAkJ,SACAhH,EAAAzB,MAAAT,KAAAmJ,aAEAnJ,KAAAmD,WACAjB,EAAAxB,WAEAqB,GAEAgjG,EAAA5kG,UAAAolG,QAAA,WACA,OAAAvlG,KAAA+K,WAAA85F,EAAAhwD,OAAAvwB,OAEAygF,EAAA5kG,UAAAslG,yBAAA,WAUA,IATA,GAAAnhF,GAAAtkB,KAAAulG,UACAF,EAAArlG,KAAAqlG,YACAC,EAAAtlG,KAAAslG,YACAF,EAAAplG,KAAAolG,QACAO,EAAAP,EAAA/hG,OACAuiG,EAAA,EAIAA,EAAAD,KACArhF,EAAA8gF,EAAAQ,GAAA3gF,KAAAqgF,IAGAM,GAQA,OANAD,GAAAN,IACAO,EAAA74F,KAAAC,IAAA44F,EAAAD,EAAAN,IAEAO,EAAA,GACAR,EAAAx8F,OAAA,EAAAg9F,GAEAR,GAEAL,GACCN,EAAAz7F,QACDvJ,GAAAslG,eACA,IAAAS,GAAA,WACA,QAAAA,GAAAvgF,EAAAjjB,GACAhC,KAAAilB,OACAjlB,KAAAgC,QAEA,MAAAwjG,OxBy/kBM,SAAUhmG,EAAQC,EAASC,GAEjC,YyB1ilBA,SAAAmmG,GAAAC,GAEA,WADA,KAAAA,IAAgCA,EAAAZ,OAAAC,mBAChCnlG,KAAAI,KAAA,GAAA2lG,GAAAD,IArDA,GAAA1jG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAiDAD,GAAAomG,UACA,IAAAE,GAAA,WACA,QAAAA,GAAAD,GACA9lG,KAAA8lG,aAKA,MAHAC,GAAA5lG,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAmmG,GAAAjF,EAAAjhG,KAAA8lG,cAEAC,IAEAtmG,GAAAsmG,kBAMA,IAAAG,GAAA,SAAAjjG,GAEA,QAAAijG,GAAA5iG,EAAAwiG,GACA7iG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA8lG,aACA9lG,KAAA4kG,cAAA,EACA5kG,KAAA4oD,UACA5oD,KAAA+b,OAAA,EA4BA,MAlCA3Z,GAAA8jG,EAAAjjG,GAQAijG,EAAA/lG,UAAAuD,MAAA,SAAApD,GACAN,KAAA+b,OAAA/b,KAAA8lG,YACA9lG,KAAA+b,SACA/b,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAM,KAGAN,KAAA4oD,OAAAxgD,KAAA9H,IAGA4lG,EAAA/lG,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA,IAAA5kG,KAAA+b,QAAA,IAAA/b,KAAA4oD,OAAAvlD,QACArD,KAAAsD,YAAA5C,YAGAwlG,EAAA/lG,UAAAqF,eAAA,SAAAF,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA6H,OAAAvC,GACAtF,KAAA+b,SACA6sC,EAAAvlD,OAAA,EACArD,KAAA0D,MAAAklD,EAAAvW,SAEA,IAAAryC,KAAA+b,QAAA/b,KAAA4kG,cACA5kG,KAAAsD,YAAA5C,YAGAwlG,GACCF,EAAAjhG,gBACDtF,GAAAymG,sBzBomlBM,SAAU1mG,EAAQC,EAASC,GAEjC,Y0BjtlBA,SAAAymG,GAAA/hG,GACA,GAAAgiG,GACAvD,EAAAz+F,EAAAy+F,MAaA,OAZA,kBAAAA,GACAA,EAAAviG,WACA8lG,EAAAvD,EAAAviG,YAGA8lG,EAAAvD,EAAA,cACAA,EAAAviG,WAAA8lG,GAIAA,EAAA,eAEAA,EAhBA,GAAAzmG,GAAAD,EAAA,EAkBAD,GAAA0mG,sBACA1mG,EAAAa,WAAA6lG,EAAAxmG,EAAA6B,MAIA/B,EAAA2mG,aAAA3mG,EAAAa,Y1BytlBM,SAAUd,EAAQC,EAASC,GAEjC,Y2BlvlBA,IAAAC,GAAAD,EAAA,GACAmjG,EAAAljG,EAAA6B,KAAAqhG,MACApjG,GAAAgE,aAAA,kBAAAo/F,IAAA,kBAAAA,GAAAwD,IACAxD,EAAAwD,IAAA,iCAIA5mG,EAAA6mG,eAAA7mG,EAAAgE,c3ByvlBM,SAAUjE,EAAQC,EAASC,GAEjC,Y4BlwlBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAYAgkG,EAAA,SAAAtjG,GAEA,QAAAsjG,KACA,GAAAplG,GAAA8B,EAAApC,KAAAb,KAAA,0BACAA,MAAAwS,KAAArR,EAAAqR,KAAA,aACAxS,KAAA4uF,MAAAztF,EAAAytF,MACA5uF,KAAAmjG,QAAAhiG,EAAAgiG,QAEA,MAPA/gG,GAAAmkG,EAAAtjG,GAOAsjG,GACC3kG,MACDnC,GAAA8mG,c5BywlBM,SAAU/mG,EAAQC,EAASC,GAEjC,Y6BpylBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAWA+G,EAAA,SAAArG,GAEA,QAAAqG,KACA,GAAAnI,GAAA8B,EAAApC,KAAAb,KAAA,sBACAA,MAAAwS,KAAArR,EAAAqR,KAAA,0BACAxS,KAAA4uF,MAAAztF,EAAAytF,MACA5uF,KAAAmjG,QAAAhiG,EAAAgiG,QAEA,MAPA/gG,GAAAkH,EAAArG,GAOAqG,GACC1H,MACDnC,GAAA6J,2B7B2ylBM,SAAU9J,EAAQC,EAASC,GAEjC,Y8Br0lBA,SAAA8mG,GAAAxkG,GACA,MAAAA,aAAAq3C,QAAAh4B,OAAArf,GAEAvC,EAAA+mG,U9B40lBM,SAAUhnG,EAAQC,EAASC,GAEjC,Y+Bj1lBA,SAAA2E,GAAAsH,GACA,wBAAAA,GAEAlM,EAAA4E,c/Bw1lBM,SAAU7E,EAAQC,EAASC,GAEjC,YgC51lBA,SAAA+mG,GAAAC,GAKA,OAAAn/F,EAAAW,QAAAw+F,MAAAC,WAAAD,GAAA,KANA,GAAAn/F,GAAA7H,EAAA,GAQAD,GAAAgnG,ahCq2lBM,SAAUjnG,EAAQC,EAASC,GAEjC,YiC/2lBA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GAMA0L,EAAA,SAAAnI,GAEA,QAAAmI,GAAApJ,EAAA+I,GACA9H,EAAApC,KAAAb,MACAA,KAAAgC,QACAhC,KAAA+K,YACA/K,KAAAC,WAAA,EACA8K,IACA/K,KAAAC,WAAA,GAkCA,MAzCAmC,GAAAgJ,EAAAnI,GAUAmI,EAAAjJ,OAAA,SAAAH,EAAA+I,GACA,UAAAK,GAAApJ,EAAA+I,IAEAK,EAAAE,SAAA,SAAAC,GACA,GAAA7E,GAAA6E,EAAA7E,KAAA1E,EAAAuJ,EAAAvJ,MAAAE,EAAAqJ,EAAArJ,UACA,IAAAwE,EAEA,WADAxE,GAAAxB,UAGAwB,GAAAb,KAAAW,GACAE,EAAA2B,SAGA0H,EAAA7E,MAAA,EACA1G,KAAAyL,SAAAF,KAEAH,EAAAjL,UAAAD,WAAA,SAAAgC,GACA,GAAAF,GAAAhC,KAAAgC,MACA+I,EAAA/K,KAAA+K,SACA,IAAAA,EACA,MAAAA,GAAAU,SAAAL,EAAAE,SAAA,GACA5E,MAAA,EAAA1E,QAAAE,cAIAA,GAAAb,KAAAW,GACAE,EAAA2B,QACA3B,EAAAxB,YAIA0K,GACCtF,EAAAhG,WACDL,GAAA2L,oBjCs3lBM,SAAU5L,EAAQC,EAASC,GAEjC,YkCz3lBA,SAAAknG,KAEA,OADAC,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,IAAAm9B,GAAA,IAUA,OATA,kBAAAy+D,KAAAxjG,OAAA,KACA+kC,EAAAy+D,EAAA17F,OAIA,IAAA07F,EAAAxjG,QAAAkE,EAAAW,QAAA2+F,EAAA,MACAA,IAAA,GAAAr9F,SAEAq9F,EAAAt1C,QAAAvxD,MACAA,KAAAI,KAAAS,KAAA,GAAAimG,GAAAj8F,gBAAAg8F,GAAA,GAAAE,GAAA3+D,IArEA,GAAAhmC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAukG,EAAApnG,EAAA,IACA6H,EAAA7H,EAAA,IACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,GACAmW,IA8DApW,GAAAmnG,eACA,IAAAG,GAAA,WACA,QAAAA,GAAA3+D,GACApoC,KAAAooC,UAKA,MAHA2+D,GAAA5mG,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAinG,GAAA9kG,EAAAlC,KAAAooC,WAEA2+D,IAEAtnG,GAAAsnG,uBAMA,IAAAC,GAAA,SAAA/jG,GAEA,QAAA+jG,GAAA1jG,EAAA8kC,GACAnlC,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAA+b,OAAA,EACA/b,KAAA0O,UACA1O,KAAA6mG,eAqDA,MA3DAzkG,GAAA4kG,EAAA/jG,GAQA+jG,EAAA7mG,UAAAuD,MAAA,SAAApD,GACAN,KAAA0O,OAAAtG,KAAAyN,GACA7V,KAAA6mG,YAAAz+F,KAAA9H,IAEA0mG,EAAA7mG,UAAAyD,UAAA,WACA,GAAAijG,GAAA7mG,KAAA6mG,YACA3gG,EAAA2gG,EAAAxjG,MACA,QAAA6C,EACAlG,KAAAsD,YAAA5C,eAEA,CACAV,KAAA+b,OAAA7V,EACAlG,KAAAinG,UAAA/gG,CACA,QAAAD,GAAA,EAA2BA,EAAAC,EAASD,IAAA,CACpC,GAAA3F,GAAAumG,EAAA5gG,EACAjG,MAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAM,IAAA2F,OAIA+gG,EAAA7mG,UAAAqF,eAAA,SAAA0hG,GACA,IAAAlnG,KAAA+b,QAAA,IACA/b,KAAAsD,YAAA5C,YAGAsmG,EAAA7mG,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAoJ,GAAA1O,KAAA0O,OACAy4F,EAAAz4F,EAAAtJ,GACA6hG,EAAAjnG,KAAAinG,UAEAE,IAAAtxF,IAAA7V,KAAAinG,UAAAjnG,KAAAinG,UADA,CAEAv4F,GAAAtJ,GAAAD,EACA,IAAA8hG,IACAjnG,KAAAooC,QACApoC,KAAAonG,YAAA14F,GAGA1O,KAAAsD,YAAAjC,KAAAqN,EAAAlF,WAIAw9F,EAAA7mG,UAAAinG,YAAA,SAAA14F,GACA,GAAA/I,EACA,KACAA,EAAA3F,KAAAooC,QAAApjC,MAAAhF,KAAA0O,GAEA,MAAAvN,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEAqhG,GACChB,EAAAjhG,gBACDtF,GAAAunG,2BlCs7lBM,SAAUxnG,EAAQC,EAASC,GAEjC,YmCvhmBA,SAAA0H,KAEA,OADAy/F,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,OAAAjL,MAAAI,KAAAS,KAAAwmG,EAAAriG,UAAA,IAAAhF,MAAAoH,OAAAy/F,KAiGA,QAAAQ,KAEA,OADAR,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,IAAAF,GAAA,KACA4K,EAAAkxF,CAIA,OAHAj8F,GAAAM,YAAAyK,EAAAkxF,EAAAxjG,OAAA,MACA0H,EAAA4K,EAAAxK,OAEA,OAAAJ,GAAA,IAAA87F,EAAAxjG,QAAAwjG,EAAA,YAAA/gG,GAAAhG,WACA+mG,EAAA,GAEA,GAAAC,GAAAj8F,gBAAAg8F,EAAA97F,GAAA3K,KAAA,GAAAknG,GAAAvB,iBAAA,IAzKA,GAAAjgG,GAAApG,EAAA,GACAkL,EAAAlL,EAAA,IACAonG,EAAApnG,EAAA,IACA4nG,EAAA5nG,EAAA,GA0DAD,GAAA2H,SA8GA3H,EAAA4nG,gBnColmBM,SAAU7nG,EAAQC,EAASC,GAEjC,YoC1tmBA,SAAA6S,GAAA61B,EAAAm/D,GACA,qBAAAn/D,GACA,SAAAxhC,WAAA,6DAEA,OAAA5G,MAAAI,KAAA,GAAAonG,GAAAp/D,EAAAm/D,IA3CA,GAAAnlG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAwCAD,GAAA8S,KACA,IAAAi1F,GAAA,WACA,QAAAA,GAAAp/D,EAAAm/D,GACAvnG,KAAAooC,UACApoC,KAAAunG,UAKA,MAHAC,GAAArnG,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA0nG,GAAAvlG,EAAAlC,KAAAooC,QAAApoC,KAAAunG,WAEAC,IAEA/nG,GAAA+nG,aAMA,IAAAC,GAAA,SAAAxkG,GAEA,QAAAwkG,GAAAnkG,EAAA8kC,EAAAm/D,GACAtkG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAAwL,MAAA,EACAxL,KAAAunG,WAAAvnG,KAeA,MApBAoC,GAAAqlG,EAAAxkG,GASAwkG,EAAAtnG,UAAAuD,MAAA,SAAA1B,GACA,GAAA2D,EACA,KACAA,EAAA3F,KAAAooC,QAAAvnC,KAAAb,KAAAunG,QAAAvlG,EAAAhC,KAAAwL,SAEA,MAAArK,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEA8hG,GACC3iG,EAAA9B,apCwwmBK,SAAUxD,EAAQC,EAASC,GAEjC,YqCzymBA,SAAAgoG,GAAA38F,EAAAia,GAEA,WADA,KAAAA,IAA2BA,EAAA,GAC3BhlB,KAAAI,KAAA,GAAAunG,GAAA58F,EAAAia,IAvDA,GAAA5iB,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkoG,EAAAloG,EAAA,GAmDAD,GAAAioG,WACA,IAAAC,GAAA,WACA,QAAAA,GAAA58F,EAAAia,OACA,KAAAA,IAA+BA,EAAA,GAC/BhlB,KAAA+K,YACA/K,KAAAglB,QAKA,MAHA2iF,GAAAxnG,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA2lG,GAAAxjG,EAAAlC,KAAA+K,UAAA/K,KAAAglB,SAEA2iF,IAEAloG,GAAAkoG,mBAMA,IAAAjC,GAAA,SAAAziG,GAEA,QAAAyiG,GAAApiG,EAAAyH,EAAAia,OACA,KAAAA,IAA+BA,EAAA,GAC/B/hB,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+K,YACA/K,KAAAglB,QAmBA,MAxBA5iB,GAAAsjG,EAAAziG,GAOAyiG,EAAAp6F,SAAA,SAAAM,GACA,GAAAi8F,GAAAj8F,EAAAi8F,aAAAvkG,EAAAsI,EAAAtI,WACAukG,GAAA7G,QAAA19F,GACAtD,KAAAiC,eAEAyjG,EAAAvlG,UAAA2nG,gBAAA,SAAAD,GACA7nG,KAAAc,IAAAd,KAAA+K,UAAAU,SAAAi6F,EAAAp6F,SAAAtL,KAAAglB,MAAA,GAAA+iF,GAAAF,EAAA7nG,KAAAsD,gBAEAoiG,EAAAvlG,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA8nG,gBAAAF,EAAA/G,aAAAU,WAAAv/F,KAEA0jG,EAAAvlG,UAAAwD,OAAA,SAAAxC,GACAnB,KAAA8nG,gBAAAF,EAAA/G,aAAAY,YAAAtgG,KAEAukG,EAAAvlG,UAAAyD,UAAA,WACA5D,KAAA8nG,gBAAAF,EAAA/G,aAAAa,mBAEAgE,GACC5gG,EAAA9B,WACDvD,GAAAimG,qBACA,IAAAqC,GAAA,WACA,QAAAA,GAAAF,EAAAvkG,GACAtD,KAAA6nG,eACA7nG,KAAAsD,cAEA,MAAAykG,KAEAtoG,GAAAsoG,oBrCq2mBM,SAAUvoG,EAAQC,EAASC,GAEjC,YsCl6mBA,SAAAwH,GAAA8gG,EAAAC,GACA,GAAAC,IAAA,CASA,OAHA9kG,WAAAC,QAAA,IACA6kG,GAAA,GAEAloG,KAAAI,KAAA,GAAA+nG,GAAAH,EAAAC,EAAAC,IA7DA,GAAA9lG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EA0DAD,GAAAyH,QACA,IAAAihG,GAAA,WACA,QAAAA,GAAAH,EAAAC,EAAAC,OACA,KAAAA,IAAiCA,GAAA,GACjCloG,KAAAgoG,cACAhoG,KAAAioG,OACAjoG,KAAAkoG,UAKA,MAHAC,GAAAhoG,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAqoG,GAAAlmG,EAAAlC,KAAAgoG,YAAAhoG,KAAAioG,KAAAjoG,KAAAkoG,WAEAC,IAEA1oG,GAAA0oG,gBAMA,IAAAC,GAAA,SAAAnlG,GAEA,QAAAmlG,GAAA9kG,EAAA0kG,EAAAC,EAAAC,GACAjlG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAgoG,cACAhoG,KAAAkoG,UACAloG,KAAA4H,MAAA,EACA5H,KAAA+gG,UAAA,EACA/gG,KAAAqoG,IAAAJ,EACAjoG,KAAAkoG,SACAloG,KAAA4H,QA6BA,MAtCAxF,GAAAgmG,EAAAnlG,GAYAmlG,EAAAjoG,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA+gG,WAAA/gG,KAAA+gG,SAAA/gG,KAAAkoG,SACAloG,KAAAsoG,WAAAtmG,IAGAhC,KAAAqoG,IAAArmG,EACAhC,KAAA+gG,UAAA,IAGAqH,EAAAjoG,UAAAmoG,WAAA,SAAAtmG,GACA,GAAA2D,EACA,KACAA,EAAA3F,KAAAgoG,YAAAhoG,KAAAqoG,IAAArmG,EAAAhC,KAAA4H,SAEA,MAAAzG,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAqoG,IAAA1iG,GAEAyiG,EAAAjoG,UAAAyD,UAAA,YACA5D,KAAA+gG,UAAA/gG,KAAAkoG,UACAloG,KAAAsD,YAAAjC,KAAArB,KAAAqoG,KAEAroG,KAAAsD,YAAA5C,YAEA0nG,GACCtjG,EAAA9B,WACDvD,GAAA2oG,oBtC49mBM,SAAU5oG,EAAQC,EAASC,GAEjC,YuCvknBA,SAAA6oG,KAEA,OADA1B,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,OAAAjL,MAAAI,KAAAS,KAAA2nG,EAAAxjG,UAAA,IAAAhF,MAAAoH,OAAAy/F,KAmCA,QAAA2B,KAEA,OADA3B,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,IAAAm9B,GAAAy+D,IAAAxjG,OAAA,EAIA,OAHA,kBAAA+kC,IACAy+D,EAAA17F,MAEA,GAAA27F,GAAAj8F,gBAAAg8F,GAAAzmG,KAAA,GAAAqoG,GAAArgE,IAnEA,GAAAhmC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAukG,EAAApnG,EAAA,IACA6H,EAAA7H,EAAA,IACAoF,EAAApF,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,GACA6G,EAAA7G,EAAA,GAeAD,GAAA8oG,WA4CA9oG,EAAA+oG,WACA,IAAAC,GAAA,WACA,QAAAA,GAAArgE,GACApoC,KAAAooC,UAKA,MAHAqgE,GAAAtoG,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA2oG,GAAAxmG,EAAAlC,KAAAooC,WAEAqgE,IAEAhpG,GAAAgpG,aAMA,IAAAC,GAAA,SAAAzlG,GAEA,QAAAylG,GAAAplG,EAAA8kC,EAAA15B,OACA,KAAAA,IAAgCA,EAAA/L,OAAAR,OAAA,OAChCc,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA2oG,aACA3oG,KAAA+b,OAAA,EACA/b,KAAAooC,QAAA,kBAAAA,KAAA,KACApoC,KAAA0O,SAsFA,MA7FAtM,GAAAsmG,EAAAzlG,GASAylG,EAAAvoG,UAAAuD,MAAA,SAAA1B,GACA,GAAA2mG,GAAA3oG,KAAA2oG,SACAphG,GAAAW,QAAAlG,GACA2mG,EAAAvgG,KAAA,GAAAwgG,GAAA5mG,IAEA,kBAAAA,GAAAuE,EAAAC,UACAmiG,EAAAvgG,KAAA,GAAAygG,GAAA7mG,EAAAuE,EAAAC,cAGAmiG,EAAAvgG,KAAA,GAAA0gG,GAAA9oG,KAAAsD,YAAAtD,KAAAgC,KAGA0mG,EAAAvoG,UAAAyD,UAAA,WACA,GAAA+kG,GAAA3oG,KAAA2oG,UACAziG,EAAAyiG,EAAAtlG,MACA,QAAA6C,EAEA,WADAlG,MAAAsD,YAAA5C,UAGAV,MAAA+b,OAAA7V,CACA,QAAAD,GAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAO,GAAAmiG,EAAA1iG,EACAO,GAAAuiG,kBACA/oG,KAAAc,IAAA0F,EAAAzG,UAAAyG,EAAAP,IAGAjG,KAAA+b,WAIA2sF,EAAAvoG,UAAA6oG,eAAA,WAEA,MADAhpG,KAAA+b,QAEA/b,KAAAsD,YAAA5C,YAGAgoG,EAAAvoG,UAAA8oG,eAAA,WAKA,OAJAN,GAAA3oG,KAAA2oG,UACAziG,EAAAyiG,EAAAtlG,OACAC,EAAAtD,KAAAsD,YAEA2C,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAO,GAAAmiG,EAAA1iG,EACA,sBAAAO,GAAAu6F,WAAAv6F,EAAAu6F,WACA,OAKA,OAFAmI,IAAA,EACAvzF,KACA1P,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAO,GAAAmiG,EAAA1iG,GACAN,EAAAa,EAAAnF,MAMA,IAHAmF,EAAAo+F,iBACAsE,GAAA,GAEAvjG,EAAAe,KAEA,WADApD,GAAA5C,UAGAiV,GAAAvN,KAAAzC,EAAA3D,OAEAhC,KAAAooC,QACApoC,KAAAonG,YAAAzxF,GAGArS,EAAAjC,KAAAsU,GAEAuzF,GACA5lG,EAAA5C,YAGAgoG,EAAAvoG,UAAAinG,YAAA,SAAAzxF,GACA,GAAAhQ,EACA,KACAA,EAAA3F,KAAAooC,QAAApjC,MAAAhF,KAAA2V,GAEA,MAAAxU,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEA+iG,GACC5jG,EAAA9B,WACDvD,GAAAipG,eACA,IAAAG,GAAA,WACA,QAAAA,GAAAriG,GACAxG,KAAAwG,WACAxG,KAAAmpG,WAAA3iG,EAAAnF,OAcA,MAZAwnG,GAAA1oG,UAAA4gG,SAAA,WACA,UAEA8H,EAAA1oG,UAAAkB,KAAA,WACA,GAAAsE,GAAA3F,KAAAmpG,UAEA,OADAnpG,MAAAmpG,WAAAnpG,KAAAwG,SAAAnF,OACAsE,GAEAkjG,EAAA1oG,UAAAykG,aAAA,WACA,GAAAuE,GAAAnpG,KAAAmpG,UACA,OAAAA,MAAAziG,MAEAmiG,KAEAD,EAAA,WACA,QAAAA,GAAA99F,GACA9K,KAAA8K,QACA9K,KAAA4H,MAAA,EACA5H,KAAAqD,OAAA,EACArD,KAAAqD,OAAAyH,EAAAzH,OAgBA,MAdAulG,GAAAzoG,UAAAoG,EAAAC,UAAA,WACA,MAAAxG,OAEA4oG,EAAAzoG,UAAAkB,KAAA,SAAAW,GACA,GAAAiE,GAAAjG,KAAA4H,QACAkD,EAAA9K,KAAA8K,KACA,OAAA7E,GAAAjG,KAAAqD,QAAkCrB,MAAA8I,EAAA7E,GAAAS,MAAA,IAAmC1E,MAAA,KAAA0E,MAAA,IAErEkiG,EAAAzoG,UAAA4gG,SAAA,WACA,MAAA/gG,MAAA8K,MAAAzH,OAAArD,KAAA4H,OAEAghG,EAAAzoG,UAAAykG,aAAA,WACA,MAAA5kG,MAAA8K,MAAAzH,SAAArD,KAAA4H,OAEAghG,KAOAE,EAAA,SAAA7lG,GAEA,QAAA6lG,GAAAxlG,EAAAsB,EAAAtE,GACA2C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4E,SACA5E,KAAAM,aACAN,KAAA+oG,mBAAA,EACA/oG,KAAA4oD,UACA5oD,KAAAopG,YAAA,EAsCA,MA7CAhnG,GAAA0mG,EAAA7lG,GASA6lG,EAAA3oG,UAAAoG,EAAAC,UAAA,WACA,MAAAxG,OAIA8oG,EAAA3oG,UAAAkB,KAAA,WACA,GAAAunD,GAAA5oD,KAAA4oD,MACA,YAAAA,EAAAvlD,QAAArD,KAAAopG,YACoBpnG,MAAA,KAAA0E,MAAA,IAGA1E,MAAA4mD,EAAAvW,QAAA3rC,MAAA,IAGpBoiG,EAAA3oG,UAAA4gG,SAAA,WACA,MAAA/gG,MAAA4oD,OAAAvlD,OAAA,GAEAylG,EAAA3oG,UAAAykG,aAAA,WACA,WAAA5kG,KAAA4oD,OAAAvlD,QAAArD,KAAAopG,YAEAN,EAAA3oG,UAAAqF,eAAA,WACAxF,KAAA4oD,OAAAvlD,OAAA,GACArD,KAAAopG,YAAA,EACAppG,KAAA4E,OAAAokG,kBAGAhpG,KAAAsD,YAAA5C,YAGAooG,EAAA3oG,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA4oD,OAAAxgD,KAAAjD,GACAnF,KAAA4E,OAAAqkG,kBAEAH,EAAA3oG,UAAAJ,UAAA,SAAAiC,EAAA4F,GACA,MAAAq+F,GAAAxgG,kBAAAzF,UAAAM,WAAAN,KAAA4H,IAEAkhG,GACC9C,EAAAjhG,kBvCgmnBK,SAAUvF,EAAQC,GwCr3nBxB,GAAAoe,EAGAA,GAAA,WACA,MAAA7d,QAGA,KAEA6d,KAAAoV,SAAA,qBAAAo2E,MAAA,QACC,MAAAphG,GAED,gBAAA4B,UACAgU,EAAAhU,QAOArK,EAAAC,QAAAoe,GxC43nBM,SAAUre,EAAQC,EAASC,GAEjC,YyC74nBA,IAAA+kG,GAAA/kG,EAAA,EACAD,GAAAuJ,QAAAy7F,EAAAz7F,QACAvJ,EAAA4J,iBAAAo7F,EAAAp7F,gBAEA,IAAAvD,GAAApG,EAAA,EACAD,GAAAK,WAAAgG,EAAAhG,WAGAJ,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KAEAA,EAAA,IACAA,EAAA,IAEAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,IAEA,IAAAmD,GAAAnD,EAAA,EACAD,GAAAyE,aAAArB,EAAAqB,YACA,IAAAY,GAAApF,EAAA,EACAD,GAAAuD,WAAA8B,EAAA9B,UACA,IAAAsmG,GAAA5pG,EAAA,GACAD,GAAAilG,aAAA4E,EAAA5E,YACA,IAAA6E,GAAA7pG,EAAA,GACAD,GAAAslG,cAAAwE,EAAAxE,aACA,IAAAyE,GAAA9pG,EAAA,GACAD,GAAAgqG,gBAAAD,EAAAC,eACA,IAAAt9F,GAAAzM,EAAA,GACAD,GAAAiqG,sBAAAv9F,EAAAu9F,qBACA,IAAA9B,GAAAloG,EAAA,GACAD,GAAAohG,aAAA+G,EAAA/G,YACA,IAAA8I,GAAAjqG,EAAA,GACAD,GAAA8mG,WAAAoD,EAAApD,UACA,IAAAqD,GAAAlqG,EAAA,GACAD,GAAAyjG,wBAAA0G,EAAA1G,uBACA,IAAAr6F,GAAAnJ,EAAA,GACAD,GAAA6J,wBAAAT,EAAAS,uBACA,IAAAugG,GAAAnqG,EAAA,GACAD,GAAAqqG,aAAAD,EAAAC,YACA,IAAAziG,GAAA3H,EAAA,GACAD,GAAA6H,oBAAAD,EAAAC,mBACA,IAAAyiG,GAAArqG,EAAA,GACAD,GAAAuqG,aAAAD,EAAAC,YACA,IAAAC,GAAAvqG,EAAA,GACAD,GAAAyqG,UAAAD,EAAAC,SACA,IAAAC,GAAAzqG,EAAA,IACAD,GAAA2qG,cAAAD,EAAAC,aACA,IAAAC,GAAA3qG,EAAA,GACAD,GAAA6qG,qBAAAD,EAAAC,oBACA,IAAAC,GAAA7qG,EAAA,GACAD,GAAA+qG,aAAAD,EAAAC,aACA/qG,EAAAgrG,UAAAF,EAAAE,UACAhrG,EAAAirG,iBAAAH,EAAAG,gBACA,IAAAC,GAAAjrG,EAAA,IACAkrG,EAAAlrG,EAAA,GACAmlG,EAAAnlG,EAAA,IACAmrG,EAAAnrG,EAAA,KACAqD,EAAArD,EAAA,IACA6G,EAAA7G,EAAA,IACAG,EAAAH,EAAA,IAeAijG,GACAmI,KAAAH,EAAAG,KACAj2D,MAAAgwD,EAAAhwD,MACAk2D,eAAAF,EAAAE,eACAxgG,MAAAqgG,EAAArgG,MAEA9K,GAAAkjG,WAcA,IAAAE,IACAp/F,aAAAV,EAAAU,aACAnD,WAAAT,EAAAS,WACAkG,SAAAD,EAAAC,SAEA/G,GAAAojG,UzCw5nBM,SAAUrjG,EAAQwrG,EAAqBtrG,GAE7C,c0C7noBA,SAAAiK;;;;;AASA,QAAAshG,GAAA1zF,GACA,WAAAyd,KAAAzd,GAAA,OAAAA,EAGA,QAAA2zF,GAAA3zF,GACA,WAAAyd,KAAAzd,GAAA,OAAAA,EAGA,QAAA4zF,GAAA5zF,GACA,WAAAA,EAGA,QAAA6zF,GAAA7zF,GACA,WAAAA,EAMA,QAAA8zF,GAAArpG,GACA,MACA,gBAAAA,IACA,gBAAAA,IACA,iBAAAA,GASA,QAAA8E,GAAAwkG,GACA,cAAAA,GAAA,gBAAAA,GASA,QAAAC,GAAAD,GACA,0BAAAE,GAAA3qG,KAAAyqG,GAGA,QAAAG,GAAAl0F,GACA,0BAAAi0F,GAAA3qG,KAAA0W,GAMA,QAAAm0F,GAAAhF,GACA,GAAA10F,GAAA20F,WAAAD,EACA,OAAA10F,IAAA,GAAAjF,KAAAG,MAAA8E,QAAAjB,SAAA21F,GAMA,QAAA3yF,GAAA2yF,GACA,aAAAA,EACA,GACA,gBAAAA,GACAxzE,KAAAC,UAAAuzE,EAAA,QACAiF,OAAAjF,GAOA,QAAAkF,GAAAlF,GACA,GAAA10F,GAAA20F,WAAAD,EACA,OAAArlF,OAAArP,GAAA00F,EAAA10F,EAOA,QAAA65F,GACAC,EACAC,GAIA,OAFAx5F,GAAA5P,OAAAR,OAAA,MACA4W,EAAA+yF,EAAAx5F,MAAA,KACArM,EAAA,EAAiBA,EAAA8S,EAAA1V,OAAiB4C,IAClCsM,EAAAwG,EAAA9S,KAAA,CAEA,OAAA8lG,GACA,SAAArF,GAAsB,MAAAn0F,GAAAm0F,EAAA9pF,gBACtB,SAAA8pF,GAAsB,MAAAn0F,GAAAm0F,IAgBtB,QAAA7+F,GAAAmkG,EAAAvlG,GACA,GAAAulG,EAAA3oG,OAAA,CACA,GAAAuE,GAAAokG,EAAArjG,QAAAlC,EACA,IAAAmB,GAAA,EACA,MAAAokG,GAAApjG,OAAAhB,EAAA,IASA,QAAAqkG,GAAAX,EAAA/0F,GACA,MAAA7T,IAAA7B,KAAAyqG,EAAA/0F,GAMA,QAAA21F,GAAAvnG,GACA,GAAAqlC,GAAArnC,OAAAR,OAAA,KACA,iBAAA2pG,GAEA,MADA9hE,GAAA8hE,KACA9hE,EAAA8hE,GAAAnnG,EAAAmnG,KAiCA,QAAAxnG,GAAAK,EAAAwnG,GACA,QAAAC,GAAA1/F,GACA,GAAAyR,GAAA/a,UAAAC,MACA,OAAA8a,GACAA,EAAA,EACAxZ,EAAAK,MAAAmnG,EAAA/oG,WACAuB,EAAA9D,KAAAsrG,EAAAz/F,GACA/H,EAAA9D,KAAAsrG,GAIA,MADAC,GAAAC,QAAA1nG,EAAAtB,OACA+oG,EAMA,QAAAE,GAAAvzF,EAAAnM,GACAA,KAAA,CAGA,KAFA,GAAA3G,GAAA8S,EAAA1V,OAAAuJ,EACA2/F,EAAA,GAAA7gG,OAAAzF,GACAA,KACAsmG,EAAAtmG,GAAA8S,EAAA9S,EAAA2G,EAEA,OAAA2/F,GAMA,QAAA/vF,GAAAmjB,EAAA6sE,GACA,OAAAj2F,KAAAi2F,GACA7sE,EAAAppB,GAAAi2F,EAAAj2F,EAEA,OAAAopB,GAMA,QAAA8sE,GAAAT,GAEA,OADAU,MACAzmG,EAAA,EAAiBA,EAAA+lG,EAAA3oG,OAAgB4C,IACjC+lG,EAAA/lG,IACAuW,EAAAkwF,EAAAV,EAAA/lG,GAGA,OAAAymG,GAQA,QAAA55F,GAAApG,EAAApK,EAAAqQ,IAyBA,QAAAg6F,GAAAjgG,EAAApK,GACA,GAAAoK,IAAApK,EAAgB,QAChB,IAAAsqG,GAAA9lG,EAAA4F,GACAmgG,EAAA/lG,EAAAxE,EACA,KAAAsqG,IAAAC,EAsBG,OAAAD,IAAAC,GACHlB,OAAAj/F,KAAAi/F,OAAArpG,EAtBA,KACA,GAAAwqG,GAAAphG,MAAAxD,QAAAwE,GACAqgG,EAAArhG,MAAAxD,QAAA5F,EACA,IAAAwqG,GAAAC,EACA,MAAArgG,GAAArJ,SAAAf,EAAAe,QAAAqJ,EAAAsc,MAAA,SAAA/gB,EAAAhC,GACA,MAAA0mG,GAAA1kG,EAAA3F,EAAA2D,KAEO,IAAA6mG,GAAAC,EAQP,QAPA,IAAAC,GAAArqG,OAAA8rE,KAAA/hE,GACAugG,EAAAtqG,OAAA8rE,KAAAnsE,EACA,OAAA0qG,GAAA3pG,SAAA4pG,EAAA5pG,QAAA2pG,EAAAhkF,MAAA,SAAAzS,GACA,MAAAo2F,GAAAjgG,EAAA6J,GAAAjU,EAAAiU,MAMK,MAAAtO,GAEL,UASA,QAAAilG,GAAAlB,EAAAtF,GACA,OAAAzgG,GAAA,EAAiBA,EAAA+lG,EAAA3oG,OAAgB4C,IACjC,GAAA0mG,EAAAX,EAAA/lG,GAAAygG,GAAkC,MAAAzgG,EAElC,UAMA,QAAAknG,GAAAxoG,GACA,GAAAyoG,IAAA,CACA,mBACAA,IACAA,GAAA,EACAzoG,EAAAK,MAAAhF,KAAAoD,aAyHA,QAAAiqG,GAAAvB,GACA,GAAAn5F,IAAAm5F,EAAA,IAAAzwD,WAAA,EACA,aAAA1oC,GAAA,KAAAA,EAMA,QAAA26F,GAAAhC,EAAA/0F,EAAAmwF,EAAA6G,GACA5qG,OAAAi+F,eAAA0K,EAAA/0F,GACAvU,MAAA0kG,EACA6G,eACAC,UAAA,EACAC,cAAA,IAQA,QAAAC,GAAAh+F,GACA,IAAAi+F,GAAAr0D,KAAA5pC,GAAA,CAGA,GAAA+wB,GAAA/wB,EAAA4C,MAAA,IACA,iBAAAg5F,GACA,OAAArlG,GAAA,EAAmBA,EAAAw6B,EAAAp9B,OAAqB4C,IAAA,CACxC,IAAAqlG,EAAiB,MACjBA,KAAA7qE,EAAAx6B,IAEA,MAAAqlG,KAqGA,QAAAsC,GAAAzsG,EAAA0sG,EAAAC,GACA,GAAApsG,GAAAqsG,aACArsG,GAAAqsG,aAAAltG,KAAA,KAAAM,EAAA0sG,EAAAC,OACG,CAKH,IAAAE,IAAA,mBAAAC,SAGA,KAAA9sG,EAFA8sG,SAAAxtG,MAAAU,IA6DA,QAAA+sG,GAAAC,GACA,wBAAAA,IAAA,cAAA70D,KAAA60D,EAAAp6F,YAgKA,QAAAq6F,GAAAC,GACAC,GAAAzyF,QAAmB0yF,GAAAnmG,KAAAkmG,GAAAzyF,QACnByyF,GAAAzyF,OAAAwyF,EAGA,QAAAG,KACAF,GAAAzyF,OAAA0yF,GAAApjG,MA2GA,QAAAsjG,GAAA5yF,EAAA6yF,EAAAjgC,GAEA5yD,EAAA8yF,UAAAD,EASA,QAAAE,GAAA/yF,EAAA6yF,EAAAjgC,GACA,OAAAxoE,GAAA,EAAAkY,EAAAswD,EAAAprE,OAAkC4C,EAAAkY,EAAOlY,IAAA,CACzC,GAAAsQ,GAAAk4D,EAAAxoE,EACAqnG,GAAAzxF,EAAAtF,EAAAm4F,EAAAn4F,KASA,QAAAyqF,GAAAh/F,EAAA6sG,GACA,GAAA/nG,EAAA9E,GAAA,CAGA,GAAA8sG,EAeA,OAdA7C,GAAAjqG,EAAA,WAAAA,EAAA+sG,iBAAAC,IACAF,EAAA9sG,EAAA+sG,OAEAE,GAAAC,gBACAC,OACAzjG,MAAAxD,QAAAlG,IAAAupG,EAAAvpG,KACAW,OAAAysG,aAAAptG,KACAA,EAAAqtG,SAEAP,EAAA,GAAAE,IAAAhtG,IAEA6sG,GAAAC,GACAA,EAAAQ,UAEAR,GAMA,QAAAS,GACAjE,EACA/0F,EACAmwF,EACA8I,EACAC,GAEA,GAAAC,GAAA,GAAApB,IAEAhhF,EAAA3qB,OAAAgtG,yBAAArE,EAAA/0F,EACA,KAAA+W,IAAA,IAAAA,EAAAmgF,aAAA,CAKA,GAAAmC,GAAAtiF,KAAA5a,IACAm9F,EAAAviF,KAAA1a,IAEAk9F,GAAAL,GAAAzO,EAAA0F,EACA/jG,QAAAi+F,eAAA0K,EAAA/0F,GACAg3F,YAAA,EACAE,cAAA,EACA/6F,IAAA,WACA,GAAA1Q,GAAA4tG,IAAA/uG,KAAAyqG,GAAA5E,CAUA,OATA4H,IAAAzyF,SACA6zF,EAAAK,SACAD,GACAA,EAAAJ,IAAAK,SAEArkG,MAAAxD,QAAAlG,IACAguG,EAAAhuG,IAGAA,GAEA4Q,IAAA,SAAAq9F,GACA,GAAAjuG,GAAA4tG,IAAA/uG,KAAAyqG,GAAA5E,CAEAuJ,KAAAjuG,GAAAiuG,OAAAjuG,QAOA6tG,EACAA,EAAAhvG,KAAAyqG,EAAA2E,GAEAvJ,EAAAuJ,EAEAH,GAAAL,GAAAzO,EAAAiP,GACAP,EAAAQ,cAUA,QAAAt9F,GAAAiJ,EAAAtF,EAAAmwF,GACA,GAAAh7F,MAAAxD,QAAA2T,IAAA6vF,EAAAn1F,GAGA,MAFAsF,GAAAxY,OAAA0J,KAAAC,IAAA6O,EAAAxY,OAAAkT,GACAsF,EAAAjT,OAAA2N,EAAA,EAAAmwF,GACAA,CAEA,IAAAuF,EAAApwF,EAAAtF,GAEA,MADAsF,GAAAtF,GAAAmwF,EACAA,CAEA,IAAAoI,GAAA,EAAAC,MACA,OAAAlzF,GAAAwzF,QAAAP,KAAAQ,QAKA5I,EAEAoI,GAIAS,EAAAT,EAAA9sG,MAAAuU,EAAAmwF,GACAoI,EAAAY,IAAAQ,SACAxJ,IALA7qF,EAAAtF,GAAAmwF,EACAA,GAUA,QAAAyJ,GAAAt0F,EAAAtF,GACA,GAAA7K,MAAAxD,QAAA2T,IAAA6vF,EAAAn1F,GAEA,WADAsF,GAAAjT,OAAA2N,EAAA,EAGA,IAAAu4F,GAAA,EAAAC,MACAlzF,GAAAwzF,QAAAP,KAAAQ,SAOArD,EAAApwF,EAAAtF,WAGAsF,GAAAtF,GACAu4F,GAGAA,EAAAY,IAAAQ,UAOA,QAAAF,GAAAhuG,GACA,OAAAiG,OAAA,GAAAhC,EAAA,EAAAkY,EAAAnc,EAAAqB,OAAiD4C,EAAAkY,EAAOlY,IACxDgC,EAAAjG,EAAAiE,GACAgC,KAAA8mG,QAAA9mG,EAAA8mG,OAAAW,IAAAK,SACArkG,MAAAxD,QAAAD,IACA+nG,EAAA/nG,GAgCA,QAAAmoG,GAAAzwE,EAAAD,GACA,IAAAA,EAAc,MAAAC,EAGd,QAFAppB,GAAA85F,EAAAC,EACA7hC,EAAA9rE,OAAA8rE,KAAA/uC,GACAz5B,EAAA,EAAiBA,EAAAwoE,EAAAprE,OAAiB4C,IAClCsQ,EAAAk4D,EAAAxoE,GACAoqG,EAAA1wE,EAAAppB,GACA+5F,EAAA5wE,EAAAnpB,GACA01F,EAAAtsE,EAAAppB,GAEKg1F,EAAA8E,IAAA9E,EAAA+E,IACLF,EAAAC,EAAAC,GAFA19F,EAAA+sB,EAAAppB,EAAA+5F,EAKA,OAAA3wE,GAMA,QAAA4wE,GACAC,EACAC,EACA5C,GAEA,MAAAA,GAmBG2C,GAAAC,EACH,WAEA,GAAAC,GAAA,kBAAAD,GACAA,EAAA5vG,KAAAgtG,GACA4C,EACAE,EAAA,kBAAAH,GACAA,EAAA3vG,KAAAgtG,OACA74E,EACA,OAAA07E,GACAN,EAAAM,EAAAC,GAEAA,OAZG,GAjBHF,EAGAD,EAQA,WACA,MAAAJ,GACA,kBAAAK,KAAA5vG,KAAAb,MAAAywG,EACA,kBAAAD,KAAA3vG,KAAAb,MAAAwwG,IAVAC,EAHAD,EA2DA,QAAAI,GACAJ,EACAC,GAEA,MAAAA,GACAD,EACAA,EAAAppG,OAAAqpG,GACA/kG,MAAAxD,QAAAuoG,GACAA,GACAA,GACAD,EAcA,QAAAK,GAAAL,EAAAC,GACA,GAAA/D,GAAA/pG,OAAAR,OAAAquG,GAAA,KACA,OAAAC,GACAj0F,EAAAkwF,EAAA+D,GACA/D,EA8EA,QAAAoE,GAAAlN,GACA,GAAAmN,GAAAnN,EAAAmN,KACA,IAAAA,EAAA,CACA,GACA9qG,GAAAygG,EAAAl0F,EADAk6F,IAEA,IAAAhhG,MAAAxD,QAAA6oG,GAEA,IADA9qG,EAAA8qG,EAAA1tG,OACA4C,KAEA,iBADAygG,EAAAqK,EAAA9qG,MAEAuM,EAAAw+F,GAAAtK,GACAgG,EAAAl6F,IAAqBC,KAAA,WAKlB,IAAA84F,EAAAwF,GACH,OAAAx6F,KAAAw6F,GACArK,EAAAqK,EAAAx6F,GACA/D,EAAAw+F,GAAAz6F,GACAm2F,EAAAl6F,GAAA+4F,EAAA7E,GACAA,GACWj0F,KAAAi0F,EAGX9C,GAAAmN,MAAArE,GAMA,QAAAuE,GAAArN,GACA,GAAAsN,GAAAtN,EAAAsN,MACA,IAAAxlG,MAAAxD,QAAAgpG,GAEA,OADAC,GAAAvN,EAAAsN,UACAjrG,EAAA,EAAmBA,EAAAirG,EAAA7tG,OAAmB4C,IACtCkrG,EAAAD,EAAAjrG,IAAAirG,EAAAjrG,GAQA,QAAAmrG,GAAAxN,GACA,GAAAyN,GAAAzN,EAAA0N,UACA,IAAAD,EACA,OAAA96F,KAAA86F,GAAA,CACA,GAAA/D,GAAA+D,EAAA96F,EACA,mBAAA+2F,KACA+D,EAAA96F,IAAqBjS,KAAAgpG,EAAAp3F,OAAAo3F,KAUrB,QAAAiE,GACA3sG,EACAkpC,EACA+/D,GAgCA,QAAA2D,GAAAj7F,GACA,GAAAk7F,GAAAC,GAAAn7F,IAAAo7F,EACA/N,GAAArtF,GAAAk7F,EAAA7sG,EAAA2R,GAAAu3B,EAAAv3B,GAAAs3F,EAAAt3F,GA5BA,kBAAAu3B,KACAA,IAAA81D,SAGAkN,EAAAhjE,GACAmjE,EAAAnjE,GACAsjE,EAAAtjE,EACA,IAAA8jE,GAAA9jE,EAAA+jE,OAIA,IAHAD,IACAhtG,EAAA2sG,EAAA3sG,EAAAgtG,EAAA/D,IAEA//D,EAAAgkE,OACA,OAAA7rG,GAAA,EAAAkY,EAAA2vB,EAAAgkE,OAAAzuG,OAA4C4C,EAAAkY,EAAOlY,IACnDrB,EAAA2sG,EAAA3sG,EAAAkpC,EAAAgkE,OAAA7rG,GAAA4nG,EAGA,IACAt3F,GADAqtF,IAEA,KAAArtF,IAAA3R,GACA4sG,EAAAj7F,EAEA,KAAAA,IAAAu3B,GACAm+D,EAAArnG,EAAA2R,IACAi7F,EAAAj7F,EAOA,OAAAqtF,GAQA,QAAAmO,GACAnO,EACAnxF,EACAqJ,EACAk2F,GAGA,mBAAAl2F,GAAA,CAGA,GAAAm2F,GAAArO,EAAAnxF,EAEA,IAAAw5F,EAAAgG,EAAAn2F,GAA2B,MAAAm2F,GAAAn2F,EAC3B,IAAAo2F,GAAAlB,GAAAl1F,EACA,IAAAmwF,EAAAgG,EAAAC,GAAoC,MAAAD,GAAAC,EACpC,IAAAC,GAAAC,GAAAF,EACA,IAAAjG,EAAAgG,EAAAE,GAAqC,MAAAF,GAAAE,EASrC,OAPAF,GAAAn2F,IAAAm2F,EAAAC,IAAAD,EAAAE,IAYA,QAAAE,GACA97F,EACA+7F,EACAC,EACA1E,GAEA,GAAA2E,GAAAF,EAAA/7F,GACAk8F,GAAAxG,EAAAsG,EAAAh8F,GACAvU,EAAAuwG,EAAAh8F,EAUA,IARAm8F,EAAAC,QAAAH,EAAA//F,QACAggG,IAAAxG,EAAAuG,EAAA,WACAxwG,GAAA,EACK0wG,EAAA/G,OAAA6G,EAAA//F,OAAA,KAAAzQ,OAAA4wG,GAAAr8F,KACLvU,GAAA,QAIAgzB,KAAAhzB,EAAA,CACAA,EAAA6wG,EAAAhF,EAAA2E,EAAAj8F,EAGA,IAAAu8F,GAAA7D,GAAAC,aACAD,IAAAC,eAAA,EACAlO,EAAAh/F,GACAitG,GAAAC,cAAA4D,EAKA,MAAA9wG,GAMA,QAAA6wG,GAAAhF,EAAA2E,EAAAj8F,GAEA,GAAA01F,EAAAuG,EAAA,YAGA,GAAAlF,GAAAkF,EAAA7O,OAYA,OAAAkK,MAAAkF,SAAAR,eACAv9E,KAAA64E,EAAAkF,SAAAR,UAAAh8F,QACAye,KAAA64E,EAAAmF,OAAAz8F,GAEAs3F,EAAAmF,OAAAz8F,GAIA,kBAAA+2F,IAAA,aAAA2F,EAAAT,EAAA//F,MACA66F,EAAAzsG,KAAAgtG,GACAP,GAiFA,QAAA2F,GAAAtuG,GACA,GAAAixB,GAAAjxB,KAAAoP,WAAA6hB,MAAA,qBACA,OAAAA,KAAA,MAGA,QAAA88E,GAAAjgG,EAAA9N,GACA,IAAA+G,MAAAxD,QAAAvD,GACA,MAAAsuG,GAAAtuG,KAAAsuG,EAAAxgG,EAEA,QAAAxM,GAAA,EAAAC,EAAAvB,EAAAtB,OAAkC4C,EAAAC,EAASD,IAC3C,GAAAgtG,EAAAtuG,EAAAsB,MAAAgtG,EAAAxgG,GACA,QAIA,UA4JA,QAAAygG,GAAAxM,GACA,UAAAyM,QAAAn+E,iBAAA22E,OAAAjF,IAOA,QAAA0M,GAAAC,GACA,GAAAC,GAAA,GAAAH,IACAE,EAAAE,IACAF,EAAAzjG,KACAyjG,EAAAnmE,SACAmmE,EAAA9iG,KACA8iG,EAAAG,IACAH,EAAAjvG,QACAivG,EAAAI,iBACAJ,EAAAK,aAOA,OALAJ,GAAAK,GAAAN,EAAAM,GACAL,EAAAM,SAAAP,EAAAO,SACAN,EAAA/8F,IAAA88F,EAAA98F,IACA+8F,EAAAO,UAAAR,EAAAQ,UACAP,EAAAQ,UAAA,EACAR,EAGA,QAAAS,IAAAC,GAGA,OAFA9tG,GAAA8tG,EAAA3wG,OACAqpG,EAAA,GAAAhhG,OAAAxF,GACAD,EAAA,EAAiBA,EAAAC,EAASD,IAC1BymG,EAAAzmG,GAAAmtG,EAAAY,EAAA/tG,GAEA,OAAAymG,GAoBA,QAAAuH,IAAAC,GACA,QAAAC,KACA,GAAAC,GAAAhxG,UAEA8wG,EAAAC,EAAAD,GACA,KAAAxoG,MAAAxD,QAAAgsG,GAOA,MAAAA,GAAAlvG,MAAA,KAAA5B,UALA,QADAkwG,GAAAY,EAAA1qG,QACAvD,EAAA,EAAqBA,EAAAqtG,EAAAjwG,OAAmB4C,IACxCqtG,EAAArtG,GAAAjB,MAAA,KAAAovG,GAQA,MADAD,GAAAD,MACAC,EAGA,QAAAE,IACAv/F,EACAw/F,EACAxzG,EACAyzG,EACA1G,GAEA,GAAAr7F,GAAAgiG,EAAAC,EAAArgG,CACA,KAAA5B,IAAAsC,GACA0/F,EAAA1/F,EAAAtC,GACAiiG,EAAAH,EAAA9hG,GACA4B,EAAAsgG,GAAAliG,GACAy4F,EAAAuJ,KAKKvJ,EAAAwJ,IACLxJ,EAAAuJ,EAAAN,OACAM,EAAA1/F,EAAAtC,GAAAyhG,GAAAO,IAEA1zG,EAAAsT,EAAA5B,KAAAgiG,EAAApgG,EAAA+4F,KAAA/4F,EAAAgB,QAAAhB,EAAAugG,UACKH,IAAAC,IACLA,EAAAP,IAAAM,EACA1/F,EAAAtC,GAAAiiG,GAGA,KAAAjiG,IAAA8hG,GACArJ,EAAAn2F,EAAAtC,MACA4B,EAAAsgG,GAAAliG,GACA+hG,EAAAngG,EAAA5B,KAAA8hG,EAAA9hG,GAAA4B,EAAAgB,UAOA,QAAAw/F,IAAAtH,EAAAuH,EAAA7Q,GAIA,QAAA8Q,KACA9Q,EAAAh/F,MAAAhF,KAAAoD,WAGAyE,EAAAssG,EAAAD,IAAAY,GAPA,GAAAX,GACAY,EAAAzH,EAAAuH,EASA5J,GAAA8J,GAEAZ,EAAAF,IAAAa,IAGA5J,EAAA6J,EAAAb,MAAA/I,EAAA4J,EAAAt/C,SAEA0+C,EAAAY,EACAZ,EAAAD,IAAA9rG,KAAA0sG,IAGAX,EAAAF,IAAAc,EAAAD,IAIAX,EAAA1+C,QAAA,EACA63C,EAAAuH,GAAAV,EAKA,QAAAa,IACAplG,EACAu+F,EACAoF,GAKA,GAAAjB,GAAAnE,EAAAvK,QAAAmN,KACA,KAAA9F,EAAAqH,GAAA,CAGA,GAAA5F,MACAuI,EAAArlG,EAAAqlG,MACAlE,EAAAnhG,EAAAmhG,KACA,IAAA7F,EAAA+J,IAAA/J,EAAA6F,GACA,OAAAx6F,KAAA+7F,GAAA,CACA,GAAAhiF,GAAAsiF,GAAAr8F,EAiBA2+F,IAAAxI,EAAAqE,EAAAx6F,EAAA+Z,GAAA,IACA4kF,GAAAxI,EAAAuI,EAAA1+F,EAAA+Z,GAAA,GAGA,MAAAo8E,IAGA,QAAAwI,IACAxI,EACAyI,EACA5+F,EACA+Z,EACA8kF,GAEA,GAAAlK,EAAAiK,GAAA,CACA,GAAAlJ,EAAAkJ,EAAA5+F,GAKA,MAJAm2F,GAAAn2F,GAAA4+F,EAAA5+F,GACA6+F,SACAD,GAAA5+F,IAEA,CACK,IAAA01F,EAAAkJ,EAAA7kF,GAKL,MAJAo8E,GAAAn2F,GAAA4+F,EAAA7kF,GACA8kF,SACAD,GAAA7kF,IAEA,EAGA,SAiBA,QAAA+kF,IAAAnoE,GACA,OAAAjnC,GAAA,EAAiBA,EAAAinC,EAAA7pC,OAAqB4C,IACtC,GAAAyF,MAAAxD,QAAAglC,EAAAjnC,IACA,MAAAyF,OAAAvL,UAAAiH,OAAApC,SAAAkoC,EAGA,OAAAA,GAOA,QAAAooE,IAAApoE,GACA,MAAAm+D,GAAAn+D,IACAgmE,EAAAhmE,IACAxhC,MAAAxD,QAAAglC,GACAqoE,GAAAroE,OACAlY,GAGA,QAAAwgF,IAAAr/F,GACA,MAAA+0F,GAAA/0F,IAAA+0F,EAAA/0F,EAAA5F,OAAA66F,EAAAj1F,EAAA09F,WAGA,QAAA0B,IAAAroE,EAAAuoE,GACA,GACAxvG,GAAA0M,EAAA+iG,EADAhJ,IAEA,KAAAzmG,EAAA,EAAaA,EAAAinC,EAAA7pC,OAAqB4C,IAClC0M,EAAAu6B,EAAAjnC,GACAglG,EAAAt4F,IAAA,iBAAAA,KACA+iG,EAAAhJ,IAAArpG,OAAA,GAEAqI,MAAAxD,QAAAyK,GACA+5F,EAAAtkG,KAAApD,MAAA0nG,EAAA6I,GAAA5iG,GAAA8iG,GAAA,QAAAxvG,IACKolG,EAAA14F,GACL6iG,GAAAE,GAIA,EAAAnlG,MAAAo7F,OAAAh5F,GACO,KAAAA,GAEP+5F,EAAAtkG,KAAA8qG,EAAAvgG,IAGA6iG,GAAA7iG,IAAA6iG,GAAAE,GAEAhJ,IAAArpG,OAAA,GAAA6vG,EAAAwC,EAAAnlG,KAAAoC,EAAApC,OAGA46F,EAAAj+D,EAAAyoE,WACAzK,EAAAv4F,EAAA4gG,MACAtI,EAAAt4F,EAAA4D,MACA20F,EAAAuK,KACA9iG,EAAA4D,IAAA,UAAAk/F,EAAA,IAAAxvG,EAAA,MAEAymG,EAAAtkG,KAAAuK,IAIA,OAAA+5F,GAKA,QAAAkJ,IAAAC,EAAAj+D,GAIA,MAHAi+D,GAAAC,YAAAD,EAAAlS,UACAkS,IAAAlS,SAEA78F,EAAA+uG,GACAj+D,EAAAp7B,OAAAq5F,GACAA,EAGA,QAAAE,IACA1pG,EACAuD,EACAxL,EACA8oC,EACAqmE,GAEA,GAAAp9F,GAAA6/F,IAGA,OAFA7/F,GAAAu9F,aAAArnG,EACA8J,EAAA8/F,WAAoBrmG,OAAAxL,UAAA8oC,WAAAqmE,OACpBp9F,EAGA,QAAA+/F,IACA7pG,EACA8pG,EACA/xG,GAEA,GAAA+mG,EAAA9+F,EAAA5L,QAAAyqG,EAAA7+F,EAAA+pG,WACA,MAAA/pG,GAAA+pG,SAGA,IAAAlL,EAAA7+F,EAAAgqG,UACA,MAAAhqG,GAAAgqG,QAGA,IAAAlL,EAAA9+F,EAAAiqG,UAAApL,EAAA7+F,EAAAkqG,aACA,MAAAlqG,GAAAkqG,WAGA,KAAArL,EAAA7+F,EAAAmqG,UAGG,CACH,GAAAA,GAAAnqG,EAAAmqG,UAAApyG,GACAqyG,GAAA,EAEAC,EAAA,WACA,OAAAzwG,GAAA,EAAAkY,EAAAq4F,EAAAnzG,OAA0C4C,EAAAkY,EAAOlY,IACjDuwG,EAAAvwG,GAAA0wG,gBAIA90G,EAAAsrG,EAAA,SAAAT,GAEArgG,EAAAgqG,SAAAT,GAAAlJ,EAAAyJ,GAGAM,GACAC,MAIA50G,EAAAqrG,EAAA,SAAAyJ,GAKA1L,EAAA7+F,EAAA+pG,aACA/pG,EAAA5L,OAAA,EACAi2G,OAIAhK,EAAArgG,EAAAxK,EAAAC,EA6CA,OA3CAgF,GAAA4lG,KACA,kBAAAA,GAAArmG,KAEA4kG,EAAA5+F,EAAAgqG,WACA3J,EAAArmG,KAAAxE,EAAAC,GAEOopG,EAAAwB,EAAAmK,YAAA,kBAAAnK,GAAAmK,UAAAxwG,OACPqmG,EAAAmK,UAAAxwG,KAAAxE,EAAAC,GAEAopG,EAAAwB,EAAAjsG,SACA4L,EAAA+pG,UAAAR,GAAAlJ,EAAAjsG,MAAA01G,IAGAjL,EAAAwB,EAAA4J,WACAjqG,EAAAkqG,YAAAX,GAAAlJ,EAAA4J,QAAAH,GACA,IAAAzJ,EAAA1nF,MACA3Y,EAAAiqG,SAAA,EAEAhwG,WAAA,WACA2kG,EAAA5+F,EAAAgqG,WAAApL,EAAA5+F,EAAA5L,SACA4L,EAAAiqG,SAAA,EACAI,MAEahK,EAAA1nF,OAAA,MAIbkmF,EAAAwB,EAAAlnF,UACAlf,WAAA,WACA2kG,EAAA5+F,EAAAgqG,WACAv0G,EAGA,OAGW4qG,EAAAlnF,WAKXixF,GAAA,EAEApqG,EAAAiqG,QACAjqG,EAAAkqG,YACAlqG,EAAAgqG,SA/EAhqG,EAAAmqG,SAAApuG,KAAAhE,GAqFA,QAAA0yG,IAAA5pE,GACA,GAAAxhC,MAAAxD,QAAAglC,GACA,OAAAjnC,GAAA,EAAmBA,EAAAinC,EAAA7pC,OAAqB4C,IAAA,CACxC,GAAA0M,GAAAu6B,EAAAjnC,EACA,IAAAilG,EAAAv4F,IAAAu4F,EAAAv4F,EAAA8gG,kBACA,MAAA9gG,IAUA,QAAAokG,IAAAlJ,GACAA,EAAAzI,QAAAziG,OAAAR,OAAA,MACA0rG,EAAAmJ,eAAA,CAEA,IAAAjmF,GAAA88E,EAAAkF,SAAAkE,gBACAlmF,IACAmmF,GAAArJ,EAAA98E,GAMA,QAAAjwB,IAAAsT,EAAAzP,EAAAwyG,GACAA,EACAt7F,GAAAu7F,MAAAhjG,EAAAzP,GAEAkX,GAAAw7F,IAAAjjG,EAAAzP,GAIA,QAAA2yG,IAAAljG,EAAAzP,GACAkX,GAAA07F,KAAAnjG,EAAAzP,GAGA,QAAAuyG,IACArJ,EACA98E,EACAymF,GAEA37F,GAAAgyF,EACAwG,GAAAtjF,EAAAymF,MAA+C12G,GAAAw2G,GAAAzJ,GA4G/C,QAAA4J,IACAvqE,EACA9oC,GAEA,GAAAszG,KACA,KAAAxqE,EACA,MAAAwqE,EAGA,QADAC,MACA1xG,EAAA,EAAAkY,EAAA+uB,EAAA7pC,OAAsC4C,EAAAkY,EAAOlY,IAAA,CAC7C,GAAA6nC,GAAAZ,EAAAjnC,EAGA,IAAA6nC,EAAA1pC,aAAA0pC,EAAA8pE,oBAAAxzG,IACA0pC,EAAAl+B,MAAA,MAAAk+B,EAAAl+B,KAAAioG,KAUAF,EAAAvvG,KAAA0lC,OATA,CACA,GAAAt7B,GAAAs7B,EAAAl+B,KAAAioG,KACAA,EAAAH,EAAAllG,KAAAklG,EAAAllG,MACA,cAAAs7B,EAAAylE,IACAsE,EAAAzvG,KAAApD,MAAA6yG,EAAA/pE,EAAAZ,UAEA2qE,EAAAzvG,KAAA0lC,IAUA,MAHA6pE,GAAA3uF,MAAA8uF,MACAJ,EAAA/T,QAAAgU,GAEAD,EAGA,QAAAI,IAAA3hG,GACA,MAAAA,GAAA09F,WAAA,MAAA19F,EAAA5F,KAGA,QAAAwnG,IACA7D,EACAxH,GAEAA,OACA,QAAAzmG,GAAA,EAAiBA,EAAAiuG,EAAA7wG,OAAgB4C,IACjCyF,MAAAxD,QAAAgsG,EAAAjuG,IACA8xG,GAAA7D,EAAAjuG,GAAAymG,GAEAA,EAAAwH,EAAAjuG,GAAAsQ,KAAA29F,EAAAjuG,GAAAtB,EAGA,OAAA+nG,GAQA,QAAAsL,IAAAnK,GACA,GAAAjK,GAAAiK,EAAAkF,SAGAnuG,EAAAg/F,EAAAh/F,MACA,IAAAA,IAAAg/F,EAAAqU,SAAA,CACA,KAAArzG,EAAAmuG,SAAAkF,UAAArzG,EAAAszG,SACAtzG,IAAAszG,OAEAtzG,GAAAuzG,UAAA/vG,KAAAylG,GAGAA,EAAAqK,QAAAtzG,EACAipG,EAAAuK,MAAAxzG,IAAAwzG,MAAAvK,EAEAA,EAAAsK,aACAtK,EAAAwK,SAEAxK,EAAAyK,SAAA,KACAzK,EAAA0K,UAAA,KACA1K,EAAA2K,iBAAA,EACA3K,EAAA4K,YAAA,EACA5K,EAAA6K,cAAA,EACA7K,EAAA8K,mBAAA,EA6FA,QAAAC,IACA/K,EACAgL,EACAC,GAEAjL,EAAAkL,IAAAF,EACAhL,EAAAkF,SAAAlP,SACAgK,EAAAkF,SAAAlP,OAAAmS,IAmBAgD,GAAAnL,EAAA,cAEA,IAAAoL,EAkCA,OAdAA,GAAA,WACApL,EAAAqL,QAAArL,EAAAsL,UAAAL,IAIAjL,EAAAyK,SAAA,GAAAc,IAAAvL,EAAAoL,EAAAnmG,GACAgmG,GAAA,EAIA,MAAAjL,EAAA5J,SACA4J,EAAA4K,YAAA,EACAO,GAAAnL,EAAA,YAEAA,EAGA,QAAAwL,IACAxL,EACA0E,EACAxhF,EACAuoF,EACAC,GAQA,GAAAC,MACAD,GACA1L,EAAAkF,SAAA0G,iBACAH,EAAA1pG,KAAA8pG,aACA7L,EAAA8L,eAAAC,GAkBA,IAfA/L,EAAAkF,SAAA8G,aAAAP,EACAzL,EAAA5J,OAAAqV,EAEAzL,EAAAiM,SACAjM,EAAAiM,OAAAl1G,OAAA00G,GAEAzL,EAAAkF,SAAA0G,gBAAAF,EAKA1L,EAAAkM,OAAAT,EAAA1pG,MAAA0pG,EAAA1pG,KAAAqlG,MACApH,EAAAmM,WAAAjpF,EAGAwhF,GAAA1E,EAAAkF,SAAAhC,MAAA,CACA9B,GAAAC,eAAA,CAGA,QAFA6B,GAAAlD,EAAAmF,OACAiH,EAAApM,EAAAkF,SAAAmH,cACAj0G,EAAA,EAAmBA,EAAAg0G,EAAA52G,OAAqB4C,IAAA,CACxC,GAAAsQ,GAAA0jG,EAAAh0G,EACA8qG,GAAAx6F,GAAA87F,EAAA97F,EAAAs3F,EAAAkF,SAAAhC,MAAAwB,EAAA1E,GAEAoB,GAAAC,eAAA,EAEArB,EAAAkF,SAAAR,YAIA,GAAAxhF,EAAA,CACA,GAAAymF,GAAA3J,EAAAkF,SAAAkE,gBACApJ,GAAAkF,SAAAkE,iBAAAlmF,EACAmmF,GAAArJ,EAAA98E,EAAAymF,GAGAgC,IACA3L,EAAAsM,OAAA1C,GAAA8B,EAAAD,EAAAl1G,SACAypG,EAAA8I,gBAQA,QAAAyD,IAAAvM,GACA,KAAAA,QAAAqK,UACA,GAAArK,EAAA0K,UAAuB,QAEvB,UAGA,QAAA8B,IAAAxM,EAAAyM,GACA,GAAAA,GAEA,GADAzM,EAAA2K,iBAAA,EACA4B,GAAAvM,GACA,WAEG,IAAAA,EAAA2K,gBACH,MAEA,IAAA3K,EAAA0K,WAAA,OAAA1K,EAAA0K,UAAA,CACA1K,EAAA0K,WAAA,CACA,QAAAtyG,GAAA,EAAmBA,EAAA4nG,EAAAsK,UAAA90G,OAAyB4C,IAC5Co0G,GAAAxM,EAAAsK,UAAAlyG,GAEA+yG,IAAAnL,EAAA,cAIA,QAAA0M,IAAA1M,EAAAyM,GACA,KAAAA,IACAzM,EAAA2K,iBAAA,EACA4B,GAAAvM,KAIAA,EAAA0K,WAAA,CACA1K,EAAA0K,WAAA,CACA,QAAAtyG,GAAA,EAAmBA,EAAA4nG,EAAAsK,UAAA90G,OAAyB4C,IAC5Cs0G,GAAA1M,EAAAsK,UAAAlyG,GAEA+yG,IAAAnL,EAAA,gBAIA,QAAAmL,IAAAnL,EAAA7J,GACA,GAAAwW,GAAA3M,EAAAkF,SAAA/O,EACA,IAAAwW,EACA,OAAAv0G,GAAA,EAAAgP,EAAAulG,EAAAn3G,OAAwC4C,EAAAgP,EAAOhP,IAC/C,IACAu0G,EAAAv0G,GAAApF,KAAAgtG,GACO,MAAA5lG,GACP2lG,EAAA3lG,EAAA4lG,EAAA7J,EAAA,SAIA6J,EAAAmJ,eACAnJ,EAAA4M,MAAA,QAAAzW,GAoBA,QAAA0W,MACA9yG,GAAAitC,GAAAxxC,OAAAs3G,GAAAt3G,OAAA,EACAsyC,MAIAilE,GAAAC,IAAA,EAMA,QAAAC,MACAD,IAAA,CACA,IAAAE,GAAAj/F,CAcA,KAJA+4B,GAAA+D,KAAA,SAAAlsC,EAAApK,GAA8B,MAAAoK,GAAAoP,GAAAxZ,EAAAwZ,KAI9BlU,GAAA,EAAiBA,GAAAitC,GAAAxxC,OAAsBuE,KACvCmzG,EAAAlmE,GAAAjtC,IACAkU,EAAAi/F,EAAAj/F,GACA65B,GAAA75B,GAAA,KACAi/F,EAAAC,KAmBA,IAAAC,GAAAN,GAAAnxG,QACA0xG,EAAArmE,GAAArrC,OAEAkxG,MAGAS,GAAAF,GACAG,GAAAF,GAIAG,IAAA35G,GAAA25G,UACAA,GAAAtrF,KAAA,SAIA,QAAAqrF,IAAAvmE,GAEA,IADA,GAAA5uC,GAAA4uC,EAAAxxC,OACA4C,KAAA,CACA,GAAA80G,GAAAlmE,EAAA5uC,GACA4nG,EAAAkN,EAAAlN,EACAA,GAAAyK,WAAAyC,GAAAlN,EAAA4K,YACAO,GAAAnL,EAAA,YASA,QAAAyN,IAAAzN,GAGAA,EAAA0K,WAAA,EACAoC,GAAAvyG,KAAAylG,GAGA,QAAAsN,IAAAtmE,GACA,OAAA5uC,GAAA,EAAiBA,EAAA4uC,EAAAxxC,OAAkB4C,IACnC4uC,EAAA5uC,GAAAsyG,WAAA,EACA8B,GAAAxlE,EAAA5uC,IAAA,GASA,QAAAs1G,IAAAR,GACA,GAAAj/F,GAAAi/F,EAAAj/F,EACA,UAAA65B,GAAA75B,GAAA,CAEA,GADA65B,GAAA75B,IAAA,EACA++F,GAEK,CAIL,IADA,GAAA50G,GAAA4uC,GAAAxxC,OAAA,EACA4C,EAAA2B,IAAAitC,GAAA5uC,GAAA6V,GAAAi/F,EAAAj/F,IACA7V,GAEA4uC,IAAAjsC,OAAA3C,EAAA,IAAA80G,OARAlmE,IAAAzsC,KAAA2yG,EAWAH,MACAA,IAAA,EACAY,GAAAV,MA4NA,QAAAW,IAAA/U,GACAgV,GAAAltC,QACAmtC,GAAAjV,EAAAgV,IAGA,QAAAC,IAAAjV,EAAAkV,GACA,GAAA31G,GAAAwoE,EACAotC,EAAAnwG,MAAAxD,QAAAw+F,EACA,KAAAmV,GAAA/0G,EAAA4/F,KAAA/jG,OAAAysG,aAAA1I,GAAA,CAGA,GAAAA,EAAAqI,OAAA,CACA,GAAA+M,GAAApV,EAAAqI,OAAAW,IAAA5zF,EACA,IAAA8/F,EAAAjmE,IAAAmmE,GACA,MAEAF,GAAA96G,IAAAg7G,GAEA,GAAAD,EAEA,IADA51G,EAAAygG,EAAArjG,OACA4C,KAAiB01G,GAAAjV,EAAAzgG,GAAA21G,OAIjB,KAFAntC,EAAA9rE,OAAA8rE,KAAAi4B,GACAzgG,EAAAwoE,EAAAprE,OACA4C,KAAiB01G,GAAAjV,EAAAj4B,EAAAxoE,IAAA21G,IAajB,QAAAG,IAAAlgG,EAAAmgG,EAAAzlG,GACA0lG,GAAAvpG,IAAA,WACA,MAAA1S,MAAAg8G,GAAAzlG,IAEA0lG,GAAArpG,IAAA,SAAA8zF,GACA1mG,KAAAg8G,GAAAzlG,GAAAmwF,GAEA/jG,OAAAi+F,eAAA/kF,EAAAtF,EAAA0lG,IAGA,QAAAC,IAAArO,GACAA,EAAAsO,YACA,IAAAC,GAAAvO,EAAAkF,QACAqJ,GAAArL,OAAmBsL,GAAAxO,EAAAuO,EAAArL,OACnBqL,EAAA10E,SAAqB40E,GAAAzO,EAAAuO,EAAA10E,SACrB00E,EAAAxsG,KACA2sG,GAAA1O,GAEA7M,EAAA6M,EAAA15D,UAAyB,GAEzBioE,EAAAI,UAAsBC,GAAA5O,EAAAuO,EAAAI,UACtBJ,EAAAM,OAAAN,EAAAM,QAAAC,IACAC,GAAA/O,EAAAuO,EAAAM,OAcA,QAAAL,IAAAxO,EAAAgP,GACA,GAAAtK,GAAA1E,EAAAkF,SAAAR,cACAxB,EAAAlD,EAAAmF,UAGAvkC,EAAAo/B,EAAAkF,SAAAmH,aACA4C,GAAAjP,EAAAqK,OAEAjJ,IAAAC,cAAA4N,CAkCA,QAAAvmG,KAAAsmG,IAjCA,SAAAtmG,GACAk4D,EAAArmE,KAAAmO,EACA,IAAAvU,GAAAqwG,EAAA97F,EAAAsmG,EAAAtK,EAAA1E,EAqBA0B,GAAAwB,EAAAx6F,EAAAvU,GAKAuU,IAAAs3F,IACAkO,GAAAlO,EAAA,SAAAt3F,IAIAA,EACA04F,IAAAC,eAAA,EAGA,QAAAqN,IAAA1O,GACA,GAAAj+F,GAAAi+F,EAAAkF,SAAAnjG,IACAA,GAAAi+F,EAAA15D,MAAA,kBAAAvkC,GACAmtG,GAAAntG,EAAAi+F,GACAj+F,MACA27F,EAAA37F,KACAA,KAYA,KAJA,GAAA6+D,GAAA9rE,OAAA8rE,KAAA7+D,GACAmhG,EAAAlD,EAAAkF,SAAAhC,MAEA9qG,GADA4nG,EAAAkF,SAAArrE,QACA+mC,EAAAprE,QACA4C,KAAA,CACA,GAAAsQ,GAAAk4D,EAAAxoE,EASA8qG,IAAA9E,EAAA8E,EAAAx6F,IAMK82F,EAAA92F,IACLwlG,GAAAlO,EAAA,QAAAt3F,GAIAyqF,EAAApxF,GAAA,GAGA,QAAAmtG,IAAAntG,EAAAi+F,GACA,IACA,MAAAj+F,GAAA/O,KAAAgtG,GACG,MAAA5lG,GAEH,MADA2lG,GAAA3lG,EAAA4lG,EAAA,cAOA,QAAA4O,IAAA5O,EAAA2O,GAEA,GAAAQ,GAAAnP,EAAAoP,kBAAAt6G,OAAAR,OAAA,KAEA,QAAAoU,KAAAimG,GAAA,CACA,GAAAU,GAAAV,EAAAjmG,GACAq5F,EAAA,kBAAAsN,OAAAxqG,GAQAsqG,GAAAzmG,GAAA,GAAA6iG,IAAAvL,EAAA+B,GAAA98F,IAAAqqG,IAKA5mG,IAAAs3F,IACAuP,GAAAvP,EAAAt3F,EAAA2mG,IAWA,QAAAE,IAAAvhG,EAAAtF,EAAA2mG,GACA,kBAAAA,IACAjB,GAAAvpG,IAAA2qG,GAAA9mG,GACA0lG,GAAArpG,IAAAE,IAEAmpG,GAAAvpG,IAAAwqG,EAAAxqG,KACA,IAAAwqG,EAAAlzE,MACAqzE,GAAA9mG,GACA2mG,EAAAxqG,IACAI,EACAmpG,GAAArpG,IAAAsqG,EAAAtqG,IACAsqG,EAAAtqG,IACAE,GAWAnQ,OAAAi+F,eAAA/kF,EAAAtF,EAAA0lG,IAGA,QAAAoB,IAAA9mG,GACA,kBACA,GAAAwkG,GAAA/6G,KAAAi9G,mBAAAj9G,KAAAi9G,kBAAA1mG,EACA,IAAAwkG,EAOA,MANAA,GAAAuC,OACAvC,EAAAwC,WAEAjP,GAAAzyF,QACAk/F,EAAAhL,SAEAgL,EAAA/4G,OAKA,QAAAs6G,IAAAzO,EAAAnmE,GAEAmmE,EAAAkF,SAAAhC,KACA,QAAAx6F,KAAAmxB,GACAmmE,EAAAt3F,GAAA,MAAAmxB,EAAAnxB,GAAAzD,EAAAxO,EAAAojC,EAAAnxB,GAAAs3F,GAmBA,QAAA+O,IAAA/O,EAAA6O,GAEA,OAAAnmG,KAAAmmG,GAAA,CACA,GAAAc,GAAAd,EAAAnmG,EACA,IAAA7K,MAAAxD,QAAAs1G,GACA,OAAAv3G,GAAA,EAAqBA,EAAAu3G,EAAAn6G,OAAoB4C,IACzCw3G,GAAA5P,EAAAt3F,EAAAinG,EAAAv3G,QAGAw3G,IAAA5P,EAAAt3F,EAAAinG,IAKA,QAAAC,IACA5P,EACA6P,EACAF,EACA5Z,GASA,MAPA2H,GAAAiS,KACA5Z,EAAA4Z,EACAA,aAEA,gBAAAA,KACAA,EAAA3P,EAAA2P,IAEA3P,EAAA8P,OAAAD,EAAAF,EAAA5Z,GAoDA,QAAAga,IAAA/P,GACA,GAAAgQ,GAAAhQ,EAAAkF,SAAA8K,OACAA,KACAhQ,EAAAiQ,UAAA,kBAAAD,GACAA,EAAAh9G,KAAAgtG,GACAgQ,GAIA,QAAAE,IAAAlQ,GACA,GAAAloG,GAAAq4G,GAAAnQ,EAAAkF,SAAA7B,OAAArD,EACAloG,KACAspG,GAAAC,eAAA,EACAvsG,OAAA8rE,KAAA9oE,GAAAvE,QAAA,SAAAmV,GAYAg5F,EAAA1B,EAAAt3F,EAAA5Q,EAAA4Q,MAGA04F,GAAAC,eAAA,GAIA,QAAA8O,IAAA9M,EAAArD,GACA,GAAAqD,EAAA,CAOA,OALAvrG,GAAAhD,OAAAR,OAAA,MACAssE,EAAAwvC,GACAC,QAAAC,QAAAjN,GACAvuG,OAAA8rE,KAAAyiC,GAEAjrG,EAAA,EAAmBA,EAAAwoE,EAAAprE,OAAiB4C,IAIpC,IAHA,GAAAsQ,GAAAk4D,EAAAxoE,GACAm4G,EAAAlN,EAAA36F,GACAhW,EAAAstG,EACAttG,GAAA,CACA,GAAAA,EAAAu9G,WAAAM,IAAA79G,GAAAu9G,UAAA,CACAn4G,EAAA4Q,GAAAhW,EAAAu9G,UAAAM,EACA,OAEA79G,IAAA23G,QAMA,MAAAvyG,IAMA,QAAA04G,IACAlQ,EACAoE,EACA3iG,EACAxL,EACA8oC,GAEA,GAAA6jE,MACAuB,EAAAnE,EAAAvK,QAAAmN,KACA,IAAA7F,EAAAoH,GACA,OAAA/7F,KAAA+7F,GACAvB,EAAAx6F,GAAA87F,EAAA97F,EAAA+7F,EAAAC,WAGArH,GAAAt7F,EAAAqlG,QAA4BqJ,GAAAvN,EAAAnhG,EAAAqlG,OAC5B/J,EAAAt7F,EAAAmhG,QAA4BuN,GAAAvN,EAAAnhG,EAAAmhG,MAI5B,IAAAxsG,GAAA5B,OAAAR,OAAAiC,GACA6Z,EAAA,SAAAvR,EAAApK,EAAAqQ,EAAAtQ,GAAiC,MAAAiR,IAAA/O,EAAAmI,EAAApK,EAAAqQ,EAAAtQ,GAAA,IACjCgxG,EAAAlF,EAAAvK,QAAAC,OAAAhjG,KAAA,KAAAod,GACArO,OACAmhG,QACA7jE,WACAtoC,OAAAR,EACA2sB,UAAAnhB,EAAAkF,OACAypG,WAAAP,GAAA7P,EAAAvK,QAAAsN,OAAA9sG,GACAszG,MAAA,WAAwB,MAAAD,IAAAvqE,EAAA9oC,KASxB,OAPAivG,aAAAF,MACAE,EAAAuE,kBAAAxzG,EACAivG,EAAAmL,kBAAArQ,EAAAvK,QACAh0F,EAAAioG,QACAxE,EAAAzjG,OAAAyjG,EAAAzjG,UAAqCioG,KAAAjoG,EAAAioG,OAGrCxE,EAGA,QAAAiL,IAAA3+E,EAAAD,GACA,OAAAnpB,KAAAmpB,GACAC,EAAAqxE,GAAAz6F,IAAAmpB,EAAAnpB,GA4EA,QAAAkoG,IACAtQ,EACAv+F,EACAxL,EACA8oC,EACAqmE,GAEA,IAAAtI,EAAAkD,GAAA,CAIA,GAAAgI,GAAA/xG,EAAA2uG,SAAA2L,KASA,IANA53G,EAAAqnG,KACAA,EAAAgI,EAAA35F,OAAA2xF,IAKA,kBAAAA,GAAA,CAQA,GAAAuF,EACA,IAAAzI,EAAAkD,EAAAwQ,OACAjL,EAAAvF,MAEAn5E,MADAm5E,EAAA+H,GAAAxC,EAAAyC,EAAA/xG,KAKA,MAAA2xG,IACArC,EACA9jG,EACAxL,EACA8oC,EACAqmE,EAKA3jG,SAIAgvG,GAAAzQ,GAGAjD,EAAAt7F,EAAAivG,QACAC,GAAA3Q,EAAAvK,QAAAh0F,EAIA,IAAA2iG,GAAAyC,GAAAplG,EAAAu+F,EAAAoF,EAGA,IAAApI,EAAAgD,EAAAvK,QAAAU,YACA,MAAA+Z,IAAAlQ,EAAAoE,EAAA3iG,EAAAxL,EAAA8oC,EAKA,IAAAnc,GAAAnhB,EAAAkF,EAKA,IAFAlF,EAAAkF,GAAAlF,EAAAmvG,SAEA5T,EAAAgD,EAAAvK,QAAAqU,UAAA,CAKA,GAAAJ,GAAAjoG,EAAAioG,IACAjoG,MACAioG,IACAjoG,EAAAioG,QAKAmH,GAAApvG,EAGA,IAAA4C,GAAA27F,EAAAvK,QAAApxF,MAAA+gG,CAOA,OANA,IAAAJ,IACA,iBAAAhF,EAAA,KAAA37F,EAAA,IAAAA,EAAA,IACA5C,MAAAolB,iBAAA5wB,GACK+pG,OAAAoE,YAAAxhF,YAAAwiF,MAAArmE,YACLwmE,KAKA,QAAAuL,IACA5L,EACAzuG,EACAs6G,EACAC,GAEA,GAAAC,GAAA/L,EAAAI,iBACA7P,GACAyb,cAAA,EACAz6G,SACA2tG,UAAA6M,EAAA7M,UACA+M,cAAAF,EAAA7L,IACAsG,aAAAxG,EACA4D,iBAAAmI,EAAAruF,UACA0oF,gBAAA2F,EAAAlyE,SACAqyE,WAAAL,GAAA,KACAM,QAAAL,GAAA,MAGAM,EAAApM,EAAAzjG,KAAA6vG,cAKA,OAJAvU,GAAAuU,KACA7b,EAAAC,OAAA4b,EAAA5b,OACAD,EAAAE,gBAAA2b,EAAA3b,iBAEA,GAAAsb,GAAAjR,KAAAvK,GAGA,QAAAob,IAAApvG,GACAA,EAAAo0F,OACAp0F,EAAAo0F,QAEA,QAAA/9F,GAAA,EAAiBA,EAAAy5G,GAAAr8G,OAAyB4C,IAAA,CAC1C,GAAAsQ,GAAAmpG,GAAAz5G,GACA05G,EAAA/vG,EAAAo0F,KAAAztF,GACAqpG,EAAAC,GAAAtpG,EACA3G,GAAAo0F,KAAAztF,GAAAopG,EAAAG,GAAAF,EAAAD,GAAAC,GAIA,QAAAE,IAAAj+F,EAAA44D,GACA,gBAAA/tE,EAAApK,EAAAqQ,EAAAtQ,GACAwf,EAAAnV,EAAApK,EAAAqQ,EAAAtQ,GACAo4E,EAAA/tE,EAAApK,EAAAqQ,EAAAtQ,IAMA,QAAAy8G,IAAAlb,EAAAh0F,GACA,GAAA4iG,GAAA5O,EAAAib,OAAAjb,EAAAib,MAAArM,MAAA,QACAp+F,EAAAwvF,EAAAib,OAAAjb,EAAAib,MAAAzqG,OAAA,SAAgExE,EAAAmhG,QAAAnhG,EAAAmhG,WAA+ByB,GAAA5iG,EAAAivG,MAAA78G,KAC/F,IAAA8S,GAAAlF,EAAAkF,KAAAlF,EAAAkF,MACAo2F,GAAAp2F,EAAAV,IACAU,EAAAV,IAAAxE,EAAAivG,MAAAhsG,UAAAzL,OAAA0N,EAAAV,IAEAU,EAAAV,GAAAxE,EAAAivG,MAAAhsG,SAWA,QAAAS,IACAlP,EACAmvG,EACA3jG,EACAs9B,EACA6yE,EACAC,GAUA,OARAt0G,MAAAxD,QAAA0H,IAAAy7F,EAAAz7F,MACAmwG,EAAA7yE,EACAA,EAAAt9B,EACAA,MAAAolB,IAEAm2E,EAAA6U,KACAD,EAAAE,IAEAC,GAAA97G,EAAAmvG,EAAA3jG,EAAAs9B,EAAA6yE,GAGA,QAAAG,IACA97G,EACAmvG,EACA3jG,EACAs9B,EACA6yE,GAEA,GAAA7U,EAAAt7F,IAAAs7F,EAAA,EAAA6D,QAMA,MAAAiH,KAMA,IAHA9K,EAAAt7F,IAAAs7F,EAAAt7F,EAAAuwG,MACA5M,EAAA3jG,EAAAuwG,KAEA5M,EAEA,MAAAyC,KAaAtqG,OAAAxD,QAAAglC,IACA,kBAAAA,GAAA,KAEAt9B,QACAA,EAAA8pG,aAAwB/V,QAAAz2D,EAAA,IACxBA,EAAA7pC,OAAA,GAEA08G,IAAAE,GACA/yE,EAAAooE,GAAApoE,GACG6yE,IAAAK,KACHlzE,EAAAmoE,GAAAnoE,GAEA,IAAAmmE,GAAAM,CACA,oBAAAJ,GAAA,CACA,GAAApF,EACAwF,GAAAjyG,GAAA2+G,gBAAA9M,GAGAF,EAFA3xG,GAAA4+G,cAAA/M,GAEA,GAAAJ,IACAzxG,GAAA6+G,qBAAAhN,GAAA3jG,EAAAs9B,MACAlY,UAAA5wB,GAEK8mG,EAAAiD,EAAA4D,EAAA3tG,EAAA2uG,SAAA,aAAAQ,IAELkL,GAAAtQ,EAAAv+F,EAAAxL,EAAA8oC,EAAAqmE,GAKA,GAAAJ,IACAI,EAAA3jG,EAAAs9B,MACAlY,UAAA5wB,OAKAivG,GAAAoL,GAAAlL,EAAA3jG,EAAAxL,EAAA8oC,EAEA,OAAAg+D,GAAAmI,IACAM,GAAa6M,GAAAnN,EAAAM,GACbN,GAEA2C,KAIA,QAAAwK,IAAAnN,EAAAM,GAEA,GADAN,EAAAM,KACA,kBAAAN,EAAAE,KAIArI,EAAAmI,EAAAnmE,UACA,OAAAjnC,GAAA,EAAAkY,EAAAk1F,EAAAnmE,SAAA7pC,OAA8C4C,EAAAkY,EAAOlY,IAAA,CACrD,GAAA6nC,GAAAulE,EAAAnmE,SAAAjnC,EACAilG,GAAAp9D,EAAAylE,MAAAtI,EAAAn9D,EAAA6lE,KACA6M,GAAA1yE,EAAA6lE,IAWA,QAAA8M,IACA/Z,EACA7C,GAEA,GAAA0I,GAAAtmG,EAAAkY,EAAAswD,EAAAl4D,CACA,IAAA7K,MAAAxD,QAAAw+F,IAAA,gBAAAA,GAEA,IADA6F,EAAA,GAAA7gG,OAAAg7F,EAAArjG,QACA4C,EAAA,EAAAkY,EAAAuoF,EAAArjG,OAA+B4C,EAAAkY,EAAOlY,IACtCsmG,EAAAtmG,GAAA49F,EAAA6C,EAAAzgG,UAEG,oBAAAygG,GAEH,IADA6F,EAAA,GAAA7gG,OAAAg7F,GACAzgG,EAAA,EAAeA,EAAAygG,EAASzgG,IACxBsmG,EAAAtmG,GAAA49F,EAAA59F,EAAA,EAAAA,OAEG,IAAAa,EAAA4/F,GAGH,IAFAj4B,EAAA9rE,OAAA8rE,KAAAi4B,GACA6F,EAAA,GAAA7gG,OAAA+iE,EAAAprE,QACA4C,EAAA,EAAAkY,EAAAswD,EAAAprE,OAAgC4C,EAAAkY,EAAOlY,IACvCsQ,EAAAk4D,EAAAxoE,GACAsmG,EAAAtmG,GAAA49F,EAAA6C,EAAAnwF,KAAAtQ,EAMA,OAHAilG,GAAAqB,KACA,EAAAoJ,UAAA,GAEApJ,EAQA,QAAAmU,IACAluG,EACAmuG,EACA5P,EACA6P,GAEA,GAAAC,GAAA7gH,KAAA25G,aAAAnnG,EACA,IAAAquG,EAKA,MAJA9P,SACA6P,IACA7P,EAAAv0F,OAA8BokG,GAAA7P,IAE9B8P,EAAA9P,IAAA4P,CAEA,IAAAG,GAAA9gH,KAAAm6G,OAAA3nG,EAUA,OAAAsuG,IAAAH,EASA,QAAAI,IAAAjlG,GACA,MAAAi2F,GAAA/xG,KAAA+yG,SAAA,UAAAj3F,GAAA,IAAA+4C,GAQA,QAAAmsD,IACAC,EACA1qG,EACA2qG,GAEA,GAAAC,GAAAz/G,GAAAy/G,SAAA5qG,IAAA2qG,CACA,OAAAx1G,OAAAxD,QAAAi5G,IACA,IAAAA,EAAAx4G,QAAAs4G,GAEAE,IAAAF,EASA,QAAAG,IACAxxG,EACA2jG,EACAvxG,EACAq/G,EACAC,GAEA,GAAAt/G,EACA,GAAA8E,EAAA9E,GAKK,CACL0J,MAAAxD,QAAAlG,KACAA,EAAAyqG,EAAAzqG,GAEA,IAAAmzG,EA0BA,QAAA5+F,KAAAvU,IAzBA,SAAAuU,GACA,GACA,UAAAA,GACA,UAAAA,GACAgrG,GAAAhrG,GAEA4+F,EAAAvlG,MACS,CACT,GAAA6C,GAAA7C,EAAAqlG,OAAArlG,EAAAqlG,MAAAxiG,IACA0iG,GAAAkM,GAAA3/G,GAAA8/G,YAAAjO,EAAA9gG,EAAA8D,GACA3G,EAAA6xG,WAAA7xG,EAAA6xG,aACA7xG,EAAAqlG,QAAArlG,EAAAqlG,UAEA,KAAA1+F,IAAA4+F,MACAA,EAAA5+F,GAAAvU,EAAAuU,GAEA+qG,GAAA,EACA1xG,EAAAkF,KAAAlF,EAAAkF,QACA,UAAAyB,GAAA,SAAAmrG,GACA1/G,EAAAuU,GAAAmrG,KAMAnrG,QAGA,MAAA3G,GAQA,QAAA+xG,IACA/5G,EACAg6G,GAEA,GAAAluF,GAAA1zB,KAAA6hH,aAAAj6G,EAGA,OAAA8rB,KAAAkuF,EACAl2G,MAAAxD,QAAAwrB,GACAqgF,GAAArgF,GACA0/E,EAAA1/E,IAGAA,EAAA1zB,KAAA6hH,aAAAj6G,GACA5H,KAAA+yG,SAAAjP,gBAAAl8F,GAAA/G,KAAAb,KAAA8hH,cACAC,GAAAruF,EAAA,aAAA9rB,GAAA,GACA8rB,GAOA,QAAAsuF,IACAtuF,EACA9rB,EACA2O,GAGA,MADAwrG,IAAAruF,EAAA,WAAA9rB,GAAA2O,EAAA,IAAAA,EAAA,QACAmd,EAGA,QAAAquF,IACAruF,EACAnd,EACA0rG,GAEA,GAAAv2G,MAAAxD,QAAAwrB,GACA,OAAAztB,GAAA,EAAmBA,EAAAytB,EAAArwB,OAAiB4C,IACpCytB,EAAAztB,IAAA,gBAAAytB,GAAAztB,IACAi8G,GAAAxuF,EAAAztB,GAAAsQ,EAAA,IAAAtQ,EAAAg8G,OAIAC,IAAAxuF,EAAAnd,EAAA0rG,GAIA,QAAAC,IAAA/rG,EAAAI,EAAA0rG,GACA9rG,EAAAy9F,UAAA,EACAz9F,EAAAI,MACAJ,EAAA8rG,SAKA,QAAAE,IAAAvyG,EAAA5N,GACA,GAAAA,EACA,GAAAupG,EAAAvpG,GAKK,CACL,GAAA8S,GAAAlF,EAAAkF,GAAAlF,EAAAkF,GAAA0H,KAA4C5M,EAAAkF,MAC5C,QAAAyB,KAAAvU,GAAA,CACA,GAAAuiG,GAAAzvF,EAAAyB,GACAqpG,EAAA59G,EAAAuU,EACAzB,GAAAyB,GAAAguF,KAAAn9F,OAAAw4G,EAAArb,GAAAqb,QAIA,MAAAhwG,GAKA,QAAAwyG,IAAAvU,GACAA,EAAAiM,OAAA,KACAjM,EAAAgU,aAAA,IACA,IAAAvI,GAAAzL,EAAA5J,OAAA4J,EAAAkF,SAAA8G,aACAwI,EAAA/I,KAAAl1G,OACAypG,GAAAsM,OAAA1C,GAAA5J,EAAAkF,SAAA0G,gBAAA4I,GACAxU,EAAA8L,aAAAC,GAKA/L,EAAAyU,GAAA,SAAA51G,EAAApK,EAAAqQ,EAAAtQ,GAAiC,MAAAiR,IAAAu6F,EAAAnhG,EAAApK,EAAAqQ,EAAAtQ,GAAA,IAGjCwrG,EAAA0U,eAAA,SAAA71G,EAAApK,EAAAqQ,EAAAtQ,GAA6C,MAAAiR,IAAAu6F,EAAAnhG,EAAApK,EAAAqQ,EAAAtQ,GAAA,GAI7C,IAAAmgH,GAAAlJ,KAAA1pG,IAUA2/F,GAAA1B,EAAA,SAAA2U,KAAAvN,MAAA,SACA1F,EAAA1B,EAAA,aAAAA,EAAAkF,SAAAkE,iBAAA,SAmJA,QAAAwL,IAAA5U,EAAAjK,GACA,GAAAwY,GAAAvO,EAAAkF,SAAApwG,OAAAR,OAAA0rG,EAAArrG,YAAAohG,QAEAwY,GAAAx3G,OAAAg/F,EAAAh/F,OACAw3G,EAAA7J,UAAA3O,EAAA2O,UACA6J,EAAAvC,aAAAjW,EAAAiW,aACAuC,EAAAnF,iBAAArT,EAAAqT,iBACAmF,EAAA3C,gBAAA7V,EAAA6V,gBACA2C,EAAAkD,cAAA1b,EAAA0b,cACAlD,EAAAmD,WAAA3b,EAAA2b,WACAnD,EAAAoD,QAAA5b,EAAA4b,QACA5b,EAAAC,SACAuY,EAAAvY,OAAAD,EAAAC,OACAuY,EAAAtY,gBAAAF,EAAAE,iBAIA,QAAA8a,IAAAzQ,GACA,GAAAvK,GAAAuK,EAAAvK,OACA,IAAAuK,EAAAuU,MAAA,CACA,GAAAC,GAAA/D,GAAAzQ,EAAAuU,MAEA,IAAAC,IADAxU,EAAAwU,aACA,CAGAxU,EAAAwU,cAEA,IAAAC,GAAAC,GAAA1U,EAEAyU,IACApmG,EAAA2xF,EAAA2U,cAAAF,GAEAhf,EAAAuK,EAAAvK,QAAA2N,EAAAoR,EAAAxU,EAAA2U,eACAlf,EAAApxF,OACAoxF,EAAAmf,WAAAnf,EAAApxF,MAAA27F,IAIA,MAAAvK,GAGA,QAAAif,IAAA1U,GACA,GAAA6U,GACAC,EAAA9U,EAAAvK,QACAsf,EAAA/U,EAAA2U,cACAK,EAAAhV,EAAAiV,aACA,QAAA7sG,KAAA0sG,GACAA,EAAA1sG,KAAA4sG,EAAA5sG,KACAysG,IAAsBA,MACtBA,EAAAzsG,GAAA8sG,GAAAJ,EAAA1sG,GAAA2sG,EAAA3sG,GAAA4sG,EAAA5sG,IAGA,OAAAysG,GAGA,QAAAK,IAAAJ,EAAAC,EAAAC,GAGA,GAAAz3G,MAAAxD,QAAA+6G,GAAA,CACA,GAAAvW,KACAyW,GAAAz3G,MAAAxD,QAAAi7G,SACAD,EAAAx3G,MAAAxD,QAAAg7G,QACA,QAAAj9G,GAAA,EAAmBA,EAAAg9G,EAAA5/G,OAAmB4C,KAEtCi9G,EAAAv6G,QAAAs6G,EAAAh9G,KAAA,GAAAk9G,EAAAx6G,QAAAs6G,EAAAh9G,IAAA,IACAymG,EAAAtkG,KAAA66G,EAAAh9G,GAGA,OAAAymG,GAEA,MAAAuW,GAIA,QAAAK,IAAA1f,GAMA5jG,KAAAujH,MAAA3f,GAWA,QAAA4f,IAAAC,GACAA,EAAAC,IAAA,SAAAC,GACA,GAAAC,GAAA5jH,KAAA6jH,oBAAA7jH,KAAA6jH,qBACA,IAAAD,EAAAj7G,QAAAg7G,IAAA,EACA,MAAA3jH,KAIA,IAAA2V,GAAA22F,EAAAlpG,UAAA,EAQA,OAPAuS,GAAA47C,QAAAvxD,MACA,kBAAA2jH,GAAAG,QACAH,EAAAG,QAAA9+G,MAAA2+G,EAAAhuG,GACK,kBAAAguG,IACLA,EAAA3+G,MAAA,KAAA2Q,GAEAiuG,EAAAx7G,KAAAu7G,GACA3jH,MAMA,QAAA+jH,IAAAN,GACAA,EAAAO,MAAA,SAAAA,GAEA,MADAhkH,MAAA4jG,QAAA2N,EAAAvxG,KAAA4jG,QAAAogB,GACAhkH,MAMA,QAAAikH,IAAAR,GAMAA,EAAA9E,IAAA,CACA,IAAAA,GAAA,CAKA8E,GAAAjnG,OAAA,SAAAsmG,GACAA,OACA,IAAAoB,GAAAlkH,KACAmkH,EAAAD,EAAAvF,IACAyF,EAAAtB,EAAAuB,QAAAvB,EAAAuB,SACA,IAAAD,EAAAD,GACA,MAAAC,GAAAD,EAGA,IAAA3xG,GAAAswG,EAAAtwG,MAAA0xG,EAAAtgB,QAAApxF,KAWA8xG,EAAA,SAAA1gB,GACA5jG,KAAAujH,MAAA3f,GA6CA,OA3CA0gB,GAAAnkH,UAAAwC,OAAAR,OAAA+hH,EAAA/jH,WACAmkH,EAAAnkH,UAAAqC,YAAA8hH,EACAA,EAAA3F,QACA2F,EAAA1gB,QAAA2N,EACA2S,EAAAtgB,QACAkf,GAEAwB,EAAA,MAAAJ,EAKAI,EAAA1gB,QAAAmN,OACAwT,GAAAD,GAEAA,EAAA1gB,QAAA4Y,UACAgI,GAAAF,GAIAA,EAAA9nG,OAAA0nG,EAAA1nG,OACA8nG,EAAAN,MAAAE,EAAAF,MACAM,EAAAZ,IAAAQ,EAAAR,IAIAe,GAAArjH,QAAA,SAAAqR,GACA6xG,EAAA7xG,GAAAyxG,EAAAzxG,KAGAD,IACA8xG,EAAA1gB,QAAAmf,WAAAvwG,GAAA8xG,GAMAA,EAAA3B,aAAAuB,EAAAtgB,QACA0gB,EAAAxB,gBACAwB,EAAAlB,cAAA5mG,KAAiC8nG,EAAA1gB,SAGjCwgB,EAAAD,GAAAG,EACAA,GAIA,QAAAC,IAAAG,GACA,GAAA3T,GAAA2T,EAAA9gB,QAAAmN,KACA,QAAAx6F,KAAAw6F,GACAgL,GAAA2I,EAAAvkH,UAAA,SAAAoW,GAIA,QAAAiuG,IAAAE,GACA,GAAAlI,GAAAkI,EAAA9gB,QAAA4Y,QACA,QAAAjmG,KAAAimG,GACAY,GAAAsH,EAAAvkH,UAAAoW,EAAAimG,EAAAjmG,IAMA,QAAAouG,IAAAlB,GAIAgB,GAAArjH,QAAA,SAAAqR,GACAgxG,EAAAhxG,GAAA,SACAqJ,EACAW,GAEA,MAAAA,IAYA,cAAAhK,GAAA84F,EAAA9uF,KACAA,EAAAjK,KAAAiK,EAAAjK,MAAAsJ,EACAW,EAAAzc,KAAA4jG,QAAA8a,MAAAliG,OAAAC,IAEA,cAAAhK,GAAA,kBAAAgK,KACAA,GAAwBnY,KAAAmY,EAAAvG,OAAAuG,IAExBzc,KAAA4jG,QAAAnxF,EAAA,KAAAqJ,GAAAW,EACAA,GAnBAzc,KAAA4jG,QAAAnxF,EAAA,KAAAqJ,MA6BA,QAAA8oG,IAAAxI,GACA,MAAAA,OAAAjO,KAAAvK,QAAApxF,MAAA4pG,EAAA7I,KAGA,QAAA58C,IAAAkuD,EAAAryG,GACA,MAAA9G,OAAAxD,QAAA28G,GACAA,EAAAl8G,QAAA6J,IAAA,EACG,gBAAAqyG,GACHA,EAAAvyG,MAAA,KAAA3J,QAAA6J,IAAA,IACGi5F,EAAAoZ,IACHA,EAAAvrE,KAAA9mC,GAMA,QAAAsyG,IAAA96E,EAAAstB,EAAAhmD,GACA,OAAAiF,KAAAyzB,GAAA,CACA,GAAA+6E,GAAA/6E,EAAAzzB,EACA,IAAAwuG,EAAA,CACA,GAAAvyG,GAAAoyG,GAAAG,EAAAtR,iBACAjhG,KAAAlB,EAAAkB,KACAuyG,IAAAztD,GACA0tD,GAAAD,GAEA/6E,EAAAzzB,GAAA,QAMA,QAAAyuG,IAAA3R,GACAA,GACAA,EAAA4R,kBAAAC,WA2KA,QAAAC,IAAA9R,GAIA,IAHA,GAAAzjG,GAAAyjG,EAAAzjG,KACAsB,EAAAmiG,EACA+R,EAAA/R,EACAnI,EAAAka,EAAAH,oBACAG,IAAAH,kBAAAnL,OACAsL,EAAAx1G,OACAA,EAAAy1G,GAAAD,EAAAx1G,QAGA,MAAAs7F,EAAAh6F,IAAAtM,SACAsM,EAAAtB,OACAA,EAAAy1G,GAAAz1G,EAAAsB,EAAAtB,MAGA,OAAA01G,IAAA11G,EAAA21G,YAAA31G,EAAA41G,OAGA,QAAAH,IAAAv3E,EAAAlpC,GACA,OACA2gH,YAAAn+G,GAAA0mC,EAAAy3E,YAAA3gH,EAAA2gH,aACAC,MAAAta,EAAAp9D,EAAA03E,QACA13E,EAAA03E,MAAA5gH,EAAA4gH,OACA5gH,EAAA4gH,OAIA,QAAAF,IACAC,EACAE,GAEA,MAAAva,GAAAqa,IAAAra,EAAAua,GACAr+G,GAAAm+G,EAAAG,GAAAD,IAGA,GAGA,QAAAr+G,IAAAsF,EAAApK,GACA,MAAAoK,GAAApK,EAAAoK,EAAA,IAAApK,EAAAoK,EAAApK,GAAA,GAGA,QAAAojH,IAAA1jH,GACA,MAAA0J,OAAAxD,QAAAlG,GACA2jH,GAAA3jH,GAEA8E,EAAA9E,GACA4jH,GAAA5jH,GAEA,gBAAAA,GACAA,EAGA,GAGA,QAAA2jH,IAAA3jH,GAGA,OADA6jH,GADAnZ,EAAA,GAEAzmG,EAAA,EAAAkY,EAAAnc,EAAAqB,OAAmC4C,EAAAkY,EAAOlY,IAC1CilG,EAAA2a,EAAAH,GAAA1jH,EAAAiE,MAAA,KAAA4/G,IACAnZ,IAAgBA,GAAA,KAChBA,GAAAmZ,EAGA,OAAAnZ,GAGA,QAAAkZ,IAAA5jH,GACA,GAAA0qG,GAAA,EACA,QAAAn2F,KAAAvU,GACAA,EAAAuU,KACAm2F,IAAgBA,GAAA,KAChBA,GAAAn2F,EAGA,OAAAm2F,GAuCA,QAAA2T,IAAA9M,GACA,MAAAuS,IAAAvS,GACA,MAIA,SAAAA,EACA,WADA,GAMA,QAAAwS,IAAAxS,GAEA,IAAAvF,GACA,QAEA,IAAAsS,GAAA/M,GACA,QAIA,IAFAA,IAAA32F,cAEA,MAAAopG,GAAAzS,GACA,MAAAyS,IAAAzS,EAEA,IAAAsF,GAAA7lG,SAAAM,cAAAigG,EACA,OAAAA,GAAA5qG,QAAA,QAEAq9G,GAAAzS,GACAsF,EAAAr2G,cAAAqH,OAAAo8G,oBACApN,EAAAr2G,cAAAqH,OAAAq8G,YAGAF,GAAAzS,GAAA,qBAAAj6D,KAAAu/D,EAAA9kG,YASA,QAAAoyG,IAAAtN,GACA,mBAAAA,GAAA,CACA,GAAAuN,GAAApzG,SAAAilD,cAAA4gD,EACA,OAAAuN,IAIApzG,SAAAM,cAAA,OAIA,MAAAulG,GAMA,QAAAwN,IAAAC,EAAAjT,GACA,GAAAG,GAAAxgG,SAAAM,cAAAgzG,EACA,kBAAAA,EACA9S,GAGAH,EAAAzjG,MAAAyjG,EAAAzjG,KAAAqlG,WAAAjgF,KAAAq+E,EAAAzjG,KAAAqlG,MAAAsR,UACA/S,EAAAr8F,aAAA,uBAEAq8F,GAGA,QAAAjgG,IAAAgjD,EAAA+vD,GACA,MAAAtzG,UAAAO,gBAAAizG,GAAAjwD,GAAA+vD,GAGA,QAAAG,IAAAl2G,GACA,MAAAyC,UAAAyzG,eAAAl2G,GAGA,QAAAm2G,IAAAn2G,GACA,MAAAyC,UAAA0zG,cAAAn2G,GAGA,QAAA0J,IAAA/I,EAAAy1G,EAAAC,GACA11G,EAAA+I,aAAA0sG,EAAAC,GAGA,QAAAxsG,IAAAjE,EAAA23B,GACA33B,EAAAiE,YAAA0zB,GAGA,QAAAh0B,IAAA3D,EAAA23B,GACA33B,EAAA2D,YAAAg0B,GAGA,QAAA58B,IAAAiF,GACA,MAAAA,GAAAjF,WAGA,QAAA2I,IAAA1D,GACA,MAAAA,GAAA0D,YAGA,QAAAysG,IAAAnwG,GACA,MAAAA,GAAAmwG,QAGA,QAAAO,IAAA1wG,EAAA5F,GACA4F,EAAAkD,YAAA9I,EAGA,QAAA4G,IAAAhB,EAAAI,EAAAmwF,GACAvwF,EAAAgB,aAAAZ,EAAAmwF,GAoCA,QAAAogB,IAAAzT,EAAA0T,GACA,GAAAxwG,GAAA88F,EAAAzjG,KAAAo3G,GACA,IAAAzwG,EAAA,CAEA,GAAAs3F,GAAAwF,EAAAjvG,QACA4iH,EAAA3T,EAAA4R,mBAAA5R,EAAAG,IACAyT,EAAApZ,EAAAwK,KACA0O,GACAr7G,MAAAxD,QAAA++G,EAAA1wG,IACA1O,EAAAo/G,EAAA1wG,GAAAywG,GACKC,EAAA1wG,KAAAywG,IACLC,EAAA1wG,OAAAye,IAGAq+E,EAAAzjG,KAAAs3G,SACAx7G,MAAAxD,QAAA++G,EAAA1wG,IAEO0wG,EAAA1wG,GAAA5N,QAAAq+G,GAAA,GAEPC,EAAA1wG,GAAAnO,KAAA4+G,GAHAC,EAAA1wG,IAAAywG,GAMAC,EAAA1wG,GAAAywG,GAuBA,QAAAG,IAAAz6G,EAAApK,GACA,MACAoK,GAAA6J,MAAAjU,EAAAiU,MAEA7J,EAAA6mG,MAAAjxG,EAAAixG,KACA7mG,EAAAmnG,YAAAvxG,EAAAuxG,WACA3I,EAAAx+F,EAAAkD,QAAAs7F,EAAA5oG,EAAAsN,OACAw3G,GAAA16G,EAAApK,IAEA6oG,EAAAz+F,EAAA26G,qBACA36G,EAAAgnG,eAAApxG,EAAAoxG,cACAzI,EAAA3oG,EAAAoxG,aAAAjzG,QAQA,QAAA2mH,IAAA16G,EAAApK,GACA,aAAAoK,EAAA6mG,IAA0B,QAC1B,IAAAttG,EAGA,QAFAilG,EAAAjlG,EAAAyG,EAAAkD,OAAAs7F,EAAAjlG,IAAAgvG,QAAAhvG,EAAAwM,SACAy4F,EAAAjlG,EAAA3D,EAAAsN,OAAAs7F,EAAAjlG,IAAAgvG,QAAAhvG,EAAAwM,MAIA,QAAA60G,IAAAp6E,EAAAq6E,EAAAC,GACA,GAAAvhH,GAAAsQ,EACAhE,IACA,KAAAtM,EAAAshH,EAAoBthH,GAAAuhH,IAAavhH,EACjCsQ,EAAA22B,EAAAjnC,GAAAsQ,IACA20F,EAAA30F,KAAqBhE,EAAAgE,GAAAtQ,EAErB,OAAAsM,GAgmBA,QAAAk1G,IAAAC,EAAArU,IACAqU,EAAA93G,KAAA0hG,YAAA+B,EAAAzjG,KAAA0hG,aACA4H,GAAAwO,EAAArU,GAIA,QAAA6F,IAAAwO,EAAArU,GACA,GAQA98F,GAAAoxG,EAAAC,EARAC,EAAAH,IAAAI,GACAC,EAAA1U,IAAAyU,GACAE,EAAAC,GAAAP,EAAA93G,KAAA0hG,WAAAoW,EAAAtjH,SACA8jH,EAAAD,GAAA5U,EAAAzjG,KAAA0hG,WAAA+B,EAAAjvG,SAEA+jH,KACAC,IAGA,KAAA7xG,IAAA2xG,GACAP,EAAAK,EAAAzxG,GACAqxG,EAAAM,EAAA3xG,GACAoxG,GAQAC,EAAAS,SAAAV,EAAA3lH,MACAsmH,GAAAV,EAAA,SAAAvU,EAAAqU,GACAE,EAAAta,KAAAsa,EAAAta,IAAAib,kBACAH,EAAAhgH,KAAAw/G,KATAU,GAAAV,EAAA,OAAAvU,EAAAqU,GACAE,EAAAta,KAAAsa,EAAAta,IAAAkb,UACAL,EAAA//G,KAAAw/G,GAYA,IAAAO,EAAA9kH,OAAA,CACA,GAAAolH,GAAA,WACA,OAAAxiH,GAAA,EAAqBA,EAAAkiH,EAAA9kH,OAA2B4C,IAChDqiH,GAAAH,EAAAliH,GAAA,WAAAotG,EAAAqU,GAGAG,GACAjT,GAAAvB,EAAAzjG,KAAAo0F,OAAAqP,EAAAzjG,KAAAo0F,SAA6D,SAAAykB,GAE7DA,IAYA,GARAL,EAAA/kH,QACAuxG,GAAAvB,EAAAzjG,KAAAo0F,OAAAqP,EAAAzjG,KAAAo0F,SAA2D,uBAC3D,OAAA/9F,GAAA,EAAqBA,EAAAmiH,EAAA/kH,OAA8B4C,IACnDqiH,GAAAF,EAAAniH,GAAA,mBAAAotG,EAAAqU,MAKAG,EACA,IAAAtxG,IAAAyxG,GACAE,EAAA3xG,IAEA+xG,GAAAN,EAAAzxG,GAAA,SAAAmxG,IAAAK,GAQA,QAAAE,IACA5W,EACAxD,GAEA,GAAAnB,GAAA/pG,OAAAR,OAAA,KACA,KAAAkvG,EACA,MAAA3E,EAEA,IAAAzmG,GAAA2hH,CACA,KAAA3hH,EAAA,EAAaA,EAAAorG,EAAAhuG,OAAiB4C,IAC9B2hH,EAAAvW,EAAAprG,GACA2hH,EAAAc,YACAd,EAAAc,UAAAC,IAEAjc,EAAAkc,GAAAhB,MACAA,EAAAta,IAAAyE,EAAAlE,EAAAkF,SAAA,aAAA6U,EAAAp1G,MAAA,EAEA,OAAAk6F,GAGA,QAAAkc,IAAAhB,GACA,MAAAA,GAAAiB,SAAAjB,EAAA,SAAAjlH,OAAA8rE,KAAAm5C,EAAAc,eAA4EjlG,KAAA,KAG5E,QAAA6kG,IAAAV,EAAA5jB,EAAAqP,EAAAqU,EAAAK,GACA,GAAApjH,GAAAijH,EAAAta,KAAAsa,EAAAta,IAAAtJ,EACA,IAAAr/F,EACA,IACAA,EAAA0uG,EAAAG,IAAAoU,EAAAvU,EAAAqU,EAAAK,GACK,MAAA9/G,GACL2lG,EAAA3lG,EAAAorG,EAAAjvG,QAAA,aAAAwjH,EAAA,SAAA5jB,EAAA,UAYA,QAAA8kB,IAAApB,EAAArU,GACA,GAAA+I,GAAA/I,EAAAI,gBACA,MAAAvI,EAAAkR,KAAA,IAAAA,EAAAjO,KAAAvK,QAAAmlB,cAGA9d,EAAAyc,EAAA93G,KAAAqlG,QAAAhK,EAAAoI,EAAAzjG,KAAAqlG,QAAA,CAGA,GAAA1+F,GAAAi+F,EACAhB,EAAAH,EAAAG,IACAwV,EAAAtB,EAAA93G,KAAAqlG,UACAA,EAAA5B,EAAAzjG,KAAAqlG,SAEA/J,GAAA+J,EAAAlG,UACAkG,EAAA5B,EAAAzjG,KAAAqlG,MAAAz4F,KAAwCy4F,GAGxC,KAAA1+F,IAAA0+F,GACAT,EAAAS,EAAA1+F,GACAyyG,EAAAzyG,KACAi+F,GACAyU,GAAAzV,EAAAj9F,EAAAi+F,EAKA0U,KAAAjU,EAAAjzG,QAAAgnH,EAAAhnH,OACAinH,GAAAzV,EAAA,QAAAyB,EAAAjzG,MAEA,KAAAuU,IAAAyyG,GACA/d,EAAAgK,EAAA1+F,MACA4yG,GAAA5yG,GACAi9F,EAAAv8F,kBAAAmyG,GAAAC,GAAA9yG,IACO+yG,GAAA/yG,IACPi9F,EAAAz8F,gBAAAR,KAMA,QAAA0yG,IAAApQ,EAAAtiG,EAAAvU,GACAunH,GAAAhzG,GAGAizG,GAAAxnH,GACA62G,EAAA9hG,gBAAAR,GAEAsiG,EAAA1hG,aAAAZ,KAEG+yG,GAAA/yG,GACHsiG,EAAA1hG,aAAAZ,EAAAizG,GAAAxnH,IAAA,UAAAA,EAAA,gBACGmnH,GAAA5yG,GACHizG,GAAAxnH,GACA62G,EAAA5hG,kBAAAmyG,GAAAC,GAAA9yG,IAEAsiG,EAAAxhG,eAAA+xG,GAAA7yG,EAAAvU,GAGAwnH,GAAAxnH,GACA62G,EAAA9hG,gBAAAR,GAEAsiG,EAAA1hG,aAAAZ,EAAAvU,GAYA,QAAAynH,IAAA/B,EAAArU,GACA,GAAAwF,GAAAxF,EAAAG,IACA5jG,EAAAyjG,EAAAzjG,KACA85G,EAAAhC,EAAA93G,IACA,MACAq7F,EAAAr7F,EAAA21G,cACAta,EAAAr7F,EAAA41G,SACAva,EAAAye,IACAze,EAAAye,EAAAnE,cACAta,EAAAye,EAAAlE,SALA,CAYA,GAAAmE,GAAAxE,GAAA9R,GAGAuW,EAAA/Q,EAAAgR,kBACA3e,GAAA0e,KACAD,EAAAviH,GAAAuiH,EAAAjE,GAAAkE,KAIAD,IAAA9Q,EAAAiR,aACAjR,EAAA1hG,aAAA,QAAAwyG,GACA9Q,EAAAiR,WAAAH,IAaA,QAAAI,IAAApmG,GAoEA,QAAAqmG,MACAC,WAAA7hH,KAAAub,EAAAna,MAAA0gH,EAAAjkH,GAAAoM,QACA63G,EAAAjkH,EAAA,EArEA,GAQA0M,GAAAw3G,EAAAlkH,EAAAmkH,EAAAH,EARAI,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,EAAA,EACA99B,EAAA,EACA+9B,EAAA,EACAR,EAAA,CAGA,KAAAjkH,EAAA,EAAaA,EAAA0d,EAAAtgB,OAAgB4C,IAG7B,GAFAkkH,EAAAx3G,EACAA,EAAAgR,EAAA03B,WAAAp1C,GACAokH,EACA,KAAA13G,GAAA,KAAAw3G,IAAwCE,GAAA,OACnC,IAAAC,EACL,KAAA33G,GAAA,KAAAw3G,IAAwCG,GAAA,OACnC,IAAAC,EACL,KAAA53G,GAAA,KAAAw3G,IAAwCI,GAAA,OACnC,IAAAC,EACL,KAAA73G,GAAA,KAAAw3G,IAAwCK,GAAA,OACnC,IACL,MAAA73G,GACA,MAAAgR,EAAA03B,WAAAp1C,EAAA,IACA,MAAA0d,EAAA03B,WAAAp1C,EAAA,IACAwkH,GAAA99B,GAAA+9B,EASK,CACL,OAAA/3G,GACA,QAAA23G,GAAA,CAAmC,MACnC,SAAAD,GAAA,CAAmC,MACnC,SAAAE,GAAA,CAA2C,MAC3C,SAAAG,GAA2B,MAC3B,SAAAA,GAA2B,MAC3B,SAAA/9B,GAA4B,MAC5B,SAAAA,GAA4B,MAC5B,UAAA89B,GAA2B,MAC3B,UAAAA,IAEA,QAAA93G,EAAA,CAIA,IAHA,GAAAsC,GAAAhP,EAAA,EACAxD,MAAA,GAEcwS,GAAA,GAEd,OADAxS,EAAAkhB,EAAA43B,OAAAtmC,IADsBA,KAItBxS,GAAAkoH,GAAArxE,KAAA72C,KACA+nH,GAAA,aA5BAx1F,KAAAo1F,GAEAF,EAAAjkH,EAAA,EACAmkH,EAAAzmG,EAAAna,MAAA,EAAAvD,GAAAoM,QAEA23G,GAwCA,QAXAh1F,KAAAo1F,EACAA,EAAAzmG,EAAAna,MAAA,EAAAvD,GAAAoM,OACG,IAAA63G,GACHF,IAQAC,EACA,IAAAhkH,EAAA,EAAeA,EAAAgkH,EAAA5mH,OAAoB4C,IACnCmkH,EAAAQ,GAAAR,EAAAH,EAAAhkH,GAIA,OAAAmkH,GAGA,QAAAQ,IAAAjnG,EAAArS,GACA,GAAArL,GAAAqL,EAAA3I,QAAA,IACA,OAAA1C,GAAA,EAEA,OAAAqL,EAAA,MAAAqS,EAAA,IAIA,OAFArS,EAAA9H,MAAA,EAAAvD,GAEA,MAAA0d,EAAA,IADArS,EAAA9H,MAAAvD,EAAA,GAOA,QAAA4kH,IAAA9jH,GACAknG,QAAAxtG,MAAA,mBAAAsG,GAGA,QAAA+jH,IACAC,EACAx0G,GAEA,MAAAw0G,GACAA,EAAAx4G,IAAA,SAAA2C,GAAgC,MAAAA,GAAAqB,KAAiBjF,OAAA,SAAAE,GAAuB,MAAAA,QAIxE,QAAAw5G,IAAAnS,EAAArmG,EAAAxQ,IACA62G,EAAA9H,QAAA8H,EAAA9H,WAAA3oG,MAAsCoK,OAAAxQ,UAGtC,QAAAipH,IAAApS,EAAArmG,EAAAxQ,IACA62G,EAAA5D,QAAA4D,EAAA5D,WAAA7sG,MAAsCoK,OAAAxQ,UAGtC,QAAAkpH,IACArS,EACArmG,EACAq2G,EACA7mH,EACA4J,EACA88G,IAEA7P,EAAAvH,aAAAuH,EAAAvH,gBAAAlpG,MAAgDoK,OAAAq2G,UAAA7mH,QAAA4J,MAAA88G,cAGhD,QAAAyC,IACAtS,EACArmG,EACAxQ,EACA0mH,EACA0C,EACAC,GAcA3C,KAAAtzG,gBACAszG,GAAAtzG,QACA5C,EAAA,IAAAA,GAEAk2G,KAAAvb,aACAub,GAAAvb,KACA36F,EAAA,IAAAA,GAGAk2G,KAAA/T,gBACA+T,GAAA/T,QACAniG,EAAA,IAAAA,EAEA,IAAA84G,EACA5C,MAAA6C,cACA7C,GAAA6C,OACAD,EAAAzS,EAAA2S,eAAA3S,EAAA2S,kBAEAF,EAAAzS,EAAAyS,SAAAzS,EAAAyS,UAEA,IAAAG,IAAoBzpH,QAAA0mH,aACpBlO,EAAA8Q,EAAA94G,EAEA9G,OAAAxD,QAAAsyG,GACA4Q,EAAA5Q,EAAAjpD,QAAAk6D,GAAAjR,EAAApyG,KAAAqjH,GAEAH,EAAA94G,GADGgoG,EACH4Q,GAAAK,EAAAjR,MAAAiR,GAEAA,EAIA,QAAAC,IACA7S,EACArmG,EACAm5G,GAEA,GAAAC,GACAC,GAAAhT,EAAA,IAAArmG,IACAq5G,GAAAhT,EAAA,UAAArmG,EACA,UAAAo5G,EACA,MAAA7B,IAAA6B,EACG,SAAAD,EAAA,CACH,GAAAG,GAAAD,GAAAhT,EAAArmG,EACA,UAAAs5G,EACA,MAAA54F,MAAAC,UAAA24F,IAKA,QAAAD,IAAAhT,EAAArmG,GACA,GAAAk0F,EACA,WAAAA,EAAAmS,EAAAkT,SAAAv5G,IAEA,OADAuG,GAAA8/F,EAAAmT,UACA/lH,EAAA,EAAAkY,EAAApF,EAAA1V,OAAoC4C,EAAAkY,EAAOlY,IAC3C,GAAA8S,EAAA9S,GAAAuM,SAAA,CACAuG,EAAAnQ,OAAA3C,EAAA,EACA,OAIA,MAAAygG,GAQA,QAAAulB,IACApT,EACA72G,EACA0mH,GAEA,GAAA1B,GAAA0B,MACAn0D,EAAAyyD,EAAAzyD,OACAliD,EAAA20G,EAAA30G,KAGA65G,EADA,KAEA75G,KACA65G,EACA,8CAIA33D,IACA23D,EAAA,MAAAA,EAAA,IAEA,IAAAC,GAAAC,GAAApqH,EAAAkqH,EAEArT,GAAAgG,OACA78G,MAAA,IAAAA,EAAA,IACAooH,WAAA,IAAApoH,EAAA,IACA6Q,SAAA,mBAAwDs5G,EAAA,KAOxD,QAAAC,IACApqH,EACAmqH,GAEA,GAAAE,GAAAC,GAAAtqH,EACA,eAAAqqH,EAAAE,IACAvqH,EAAA,IAAAmqH,EAEA,QAAAE,EAAA,SAAAA,EAAA,SAAAF,EAAA,IAyBA,QAAAG,IAAA5lB,GAKA,GAJAoF,GAAApF,EACAxgG,GAAA4lG,GAAAzoG,OACAm2E,GAAAgzC,GAAAC,GAAA,EAEA/lB,EAAA/9F,QAAA,QAAA+9F,EAAAgmB,YAAA,KAAAxmH,GAAA,EACA,OACAyd,IAAA+iF,EACA6lB,IAAA,KAIA,OAAAI,MACAC,GAAAvrH,KAEAwrH,GAAAD,IACAE,GAAAF,IACK,KAAAA,IACLG,GAAAH,GAIA,QACAjpG,IAAA+iF,EAAAzxB,UAAA,EAAAu3C,IACAD,IAAA7lB,EAAAzxB,UAAAu3C,GAAA,EAAAC,KAIA,QAAAprH,MACA,MAAAyqG,IAAAzwD,aAAAm+B,IAGA,QAAAmzC,MACA,MAAAnzC,KAAAtzE,GAGA,QAAA2mH,IAAAD,GACA,YAAAA,GAAA,KAAAA,EAGA,QAAAG,IAAAH,GACA,GAAAI,GAAA,CAEA,KADAR,GAAAhzC,IACAmzC,MAEA,GADAC,EAAAvrH,KACAwrH,GAAAD,GACAE,GAAAF,OAKA,IAFA,KAAAA,GAAuBI,IACvB,KAAAJ,GAAuBI,IACvB,IAAAA,EAAA,CACAP,GAAAjzC,EACA,QAKA,QAAAszC,IAAAF,GAEA,IADA,GAAAK,GAAAL,GACAD,OACAC,EAAAvrH,QACA4rH,KAeA,QAAApO,IACAhG,EACA+O,EACAsF,GAEAC,GAAAD,CACA,IAAAlrH,GAAA4lH,EAAA5lH,MACA0mH,EAAAd,EAAAc,UACAnV,EAAAsF,EAAAtF,IACA9gG,EAAAomG,EAAAkT,SAAAt5G,IAoBA,IAAAomG,EAAAhC,UAGA,MAFAoV,IAAApT,EAAA72G,EAAA0mH,IAEA,CACG,eAAAnV,EACH6Z,GAAAvU,EAAA72G,EAAA0mH,OACG,cAAAnV,GAAA,aAAA9gG,EACH46G,GAAAxU,EAAA72G,EAAA0mH,OACG,cAAAnV,GAAA,UAAA9gG,EACH66G,GAAAzU,EAAA72G,EAAA0mH,OACG,cAAAnV,GAAA,aAAAA,EACHga,GAAA1U,EAAA72G,EAAA0mH,OACG,KAAAhnH,GAAA4+G,cAAA/M,GAGH,MAFA0Y,IAAApT,EAAA72G,EAAA0mH,IAEA,CAWA,UAGA,QAAA2E,IACAxU,EACA72G,EACA0mH,GAEA,GAAAn0D,GAAAm0D,KAAAn0D,OACAi5D,EAAA9B,GAAA7S,EAAA,iBACA4U,EAAA/B,GAAA7S,EAAA,sBACA6U,EAAAhC,GAAA7S,EAAA,uBACAmS,IAAAnS,EAAA,UACA,iBAAA72G,EAAA,QACAA,EAAA,IAAAwrH,EAAA,QACA,SAAAC,EACA,KAAAzrH,EAAA,IACA,OAAAA,EAAA,IAAAyrH,EAAA,MAGAtC,GAAAtS,EAAA8U,GACA,WAAA3rH,EAAA,yCAEAyrH,EAAA,MAAAC,EAAA,qCAEAn5D,EAAA,MAAAi5D,EAAA,IAAAA,GAAA,6CAEwBxrH,EAAA,mCACZA,EAAA,qDACDoqH,GAAApqH,EAAA,WACX,SAIA,QAAAsrH,IACAzU,EACA72G,EACA0mH,GAEA,GAAAn0D,GAAAm0D,KAAAn0D,OACAi5D,EAAA9B,GAAA7S,EAAA,gBACA2U,GAAAj5D,EAAA,MAAAi5D,EAAA,IAAAA,EACAxC,GAAAnS,EAAA,gBAAA72G,EAAA,IAAAwrH,EAAA,KACArC,GAAAtS,EAAA8U,GAAAvB,GAAApqH,EAAAwrH,GAAA,SAGA,QAAAJ,IACAvU,EACA72G,EACA0mH,GAEA,GAAAn0D,GAAAm0D,KAAAn0D,OACAq5D,EAAA,0JAGAr5D,EAAA,sBAGAgmB,EAAA,uBAAAqzC,EAAA,GACArzC,KAAA,IAAA6xC,GAAApqH,EAFA,6DAGAmpH,GAAAtS,EAAA,SAAAt+B,EAAA,SAGA,QAAAgzC,IACA1U,EACA72G,EACA0mH,GAEA,GAAAj2G,GAAAomG,EAAAkT,SAAAt5G,KACAu0G,EAAA0B,MACAmF,EAAA7G,EAAA6G,KACAt5D,EAAAyyD,EAAAzyD,OACAliD,EAAA20G,EAAA30G,KACAy7G,GAAAD,GAAA,UAAAp7G,EACA2B,EAAAy5G,EACA,SACA,UAAAp7G,EACAs7G,GACA,QAEA7B,EAAA,qBACA75G,KACA65G,EAAA,8BAEA33D,IACA23D,EAAA,MAAAA,EAAA,IAGA,IAAA3xC,GAAA6xC,GAAApqH,EAAAkqH,EACA4B,KACAvzC,EAAA,qCAA8CA,GAG9CywC,GAAAnS,EAAA,YAAA72G,EAAA,KACAmpH,GAAAtS,EAAAzkG,EAAAmmE,EAAA,UACAloE,GAAAkiD,IACA42D,GAAAtS,EAAA,yBAUA,QAAAmV,IAAAl5G,GACA,GAAAV,EAEA82F,GAAAp2F,EAAAi5G,OAEA35G,EAAA65G,GAAA,iBACAn5G,EAAAV,MAAAhN,OAAA0N,EAAAi5G,IAAAj5G,EAAAV,cACAU,GAAAi5G,KAEA7iB,EAAAp2F,EAAA64G,OAEAv5G,EAAA85G,GAAA,iBACAp5G,EAAAV,MAAAhN,OAAA0N,EAAA64G,IAAA74G,EAAAV,cACAU,GAAA64G,KAMA,QAAAh3F,IACAviB,EACAopG,EACArG,EACA/hG,EACAu/F,GAEA,GAAAwC,EAAA,CACA,GAAAgX,GAAA3Q,EACAnP,EAAA+f,EACA5Q,GAAA,SAAA6Q,GAIA,QAHA,IAAAjrH,UAAAC,OACA8qH,EAAAE,GACAF,EAAAnpH,MAAA,KAAA5B,aAEAkrH,GAAAl6G,EAAAopG,EAAApoG,EAAAi5F,IAIA+f,GAAA54G,iBACApB,EACAopG,EACA+Q,IACSn5G,UAAAu/F,WACTv/F,GAIA,QAAAk5G,IACAl6G,EACAopG,EACApoG,EACAi5F,IAEAA,GAAA+f,IAAAj5G,oBAAAf,EAAAopG,EAAApoG,GAGA,QAAAo5G,IAAA9G,EAAArU,GACA,IAAApI,EAAAyc,EAAA93G,KAAAkF,MAAAm2F,EAAAoI,EAAAzjG,KAAAkF,IAAA,CAGA,GAAAA,GAAAu+F,EAAAzjG,KAAAkF,OACAw/F,EAAAoT,EAAA93G,KAAAkF,MACAs5G,IAAA/a,EAAAG,IACAwa,GAAAl5G,GACAu/F,GAAAv/F,EAAAw/F,EAAA39E,GAAA23F,GAAAjb,EAAAjvG,UAUA,QAAAqqH,IAAA/G,EAAArU,GACA,IAAApI,EAAAyc,EAAA93G,KAAA6xG,YAAAxW,EAAAoI,EAAAzjG,KAAA6xG,UAAA,CAGA,GAAAlrG,GAAAi+F,EACAhB,EAAAH,EAAAG,IACAkb,EAAAhH,EAAA93G,KAAA6xG,aACA1Q,EAAAsC,EAAAzjG,KAAA6xG,YAEAvW,GAAA6F,EAAAhC,UACAgC,EAAAsC,EAAAzjG,KAAA6xG,SAAAjlG,KAA2Cu0F,GAG3C,KAAAx6F,IAAAm4G,GACAzjB,EAAA8F,EAAAx6F,MACAi9F,EAAAj9F,GAAA,GAGA,KAAAA,IAAAw6F,GAKA,GAJAyD,EAAAzD,EAAAx6F,GAIA,gBAAAA,GAAA,cAAAA,IACA88F,EAAAnmE,WAA2BmmE,EAAAnmE,SAAA7pC,OAAA,GAC3BmxG,IAAAka,EAAAn4G,IAGA,aAAAA,EAAA,CAGAi9F,EAAA/qF,OAAA+rF,CAEA,IAAAma,GAAA1jB,EAAAuJ,GAAA,GAAA7I,OAAA6I,EACAoa,IAAApb,EAAAH,EAAAsb,KACAnb,EAAAxxG,MAAA2sH,OAGAnb,GAAAj9F,GAAAi+F,GAQA,QAAAoa,IACApb,EACAH,EACAwb,GAEA,OAAArb,EAAAsb,YACA,WAAAzb,EAAAE,KACAwb,GAAAvb,EAAAqb,IACAG,GAAAxb,EAAAqb,IAIA,QAAAE,IAAAvb,EAAAqb,GAGA,GAAAI,IAAA,CAGA,KAAOA,EAAAj8G,SAAAk8G,gBAAA1b,EAA+C,MAAAvrG,IACtD,MAAAgnH,IAAAzb,EAAAxxG,QAAA6sH,EAGA,QAAAG,IAAAxb,EAAAvD,GACA,GAAAjuG,GAAAwxG,EAAAxxG,MACA0mH,EAAAlV,EAAA2b,WACA,OAAAjkB,GAAAwd,MAAAn0D,OACAq3C,EAAA5pG,KAAA4pG,EAAAqE,GAEA/E,EAAAwd,MAAAr2G,KACArQ,EAAAqQ,SAAA49F,EAAA59F,OAEArQ,IAAAiuG,EAwBA,QAAAmf,IAAAx/G,GACA,GAAA8H,GAAA23G,GAAAz/G,EAAA8H,MAGA,OAAA9H,GAAA0/G,YACA9yG,EAAA5M,EAAA0/G,YAAA53G,GACAA,EAIA,QAAA23G,IAAAE,GACA,MAAA7jH,OAAAxD,QAAAqnH,GACA9iB,EAAA8iB,GAEA,gBAAAA,GACAC,GAAAD,GAEAA,EAOA,QAAAE,IAAApc,EAAAqc,GACA,GACAC,GADAjjB,IAGA,IAAAgjB,EAEA,IADA,GAAAtK,GAAA/R,EACA+R,EAAAH,mBACAG,IAAAH,kBAAAnL,OACAsL,EAAAx1G,OAAA+/G,EAAAP,GAAAhK,EAAAx1G,QACA4M,EAAAkwF,EAAAijB,IAKAA,EAAAP,GAAA/b,EAAAzjG,QACA4M,EAAAkwF,EAAAijB,EAIA,KADA,GAAAz+G,GAAAmiG,EACAniG,IAAAtM,QACAsM,EAAAtB,OAAA+/G,EAAAP,GAAAl+G,EAAAtB,QACA4M,EAAAkwF,EAAAijB,EAGA,OAAAjjB,GA8CA,QAAAkjB,IAAAlI,EAAArU,GACA,GAAAzjG,GAAAyjG,EAAAzjG,KACA85G,EAAAhC,EAAA93G,IAEA,MAAAq7F,EAAAr7F,EAAA0/G,cAAArkB,EAAAr7F,EAAA8H,QACAuzF,EAAAye,EAAA4F,cAAArkB,EAAAye,EAAAhyG,QADA,CAMA,GAAA88F,GAAAhiG,EACAqmG,EAAAxF,EAAAG,IACAqc,EAAAnG,EAAA4F,YACAQ,EAAApG,EAAAqG,iBAAArG,EAAAhyG,UAGAs4G,EAAAH,GAAAC,EAEAp4G,EAAA23G,GAAAhc,EAAAzjG,KAAA8H,UAKA27F,GAAAzjG,KAAAmgH,gBAAA7kB,EAAAxzF,EAAAq3F,QACAvyF,KAAe9E,GACfA,CAEA,IAAAu4G,GAAAR,GAAApc,GAAA,EAEA,KAAA7gG,IAAAw9G,GACA/kB,EAAAglB,EAAAz9G,KACA09G,GAAArX,EAAArmG,EAAA,GAGA,KAAAA,IAAAy9G,IACAzb,EAAAyb,EAAAz9G,MACAw9G,EAAAx9G,IAEA09G,GAAArX,EAAArmG,EAAA,MAAAgiG,EAAA,GAAAA,IAgBA,QAAA2b,IAAAtX,EAAA8Q,GAEA,GAAAA,QAAAt3G,QAKA,GAAAwmG,EAAApgG,UACAkxG,EAAAhhH,QAAA,QACAghH,EAAAr3G,MAAA,OAAAlR,QAAA,SAAAuR,GAA6C,MAAAkmG,GAAApgG,UAAA3X,IAAA6R,KAE7CkmG,EAAApgG,UAAA3X,IAAA6oH,OAEG,CACH,GAAAnV,GAAA,KAAAqE,EAAA5nG,aAAA,iBACAujG,GAAA7rG,QAAA,IAAAghH,EAAA,QACA9Q,EAAA1hG,aAAA,SAAAq9F,EAAAmV,GAAAt3G,SASA,QAAA+9G,IAAAvX,EAAA8Q,GAEA,GAAAA,QAAAt3G,QAKA,GAAAwmG,EAAApgG,UACAkxG,EAAAhhH,QAAA,QACAghH,EAAAr3G,MAAA,OAAAlR,QAAA,SAAAuR,GAA6C,MAAAkmG,GAAApgG,UAAA5Q,OAAA8K,KAE7CkmG,EAAApgG,UAAA5Q,OAAA8hH,GAEA9Q,EAAApgG,UAAApV,QACAw1G,EAAA9hG,gBAAA,aAEG,CAGH,IAFA,GAAAy9F,GAAA,KAAAqE,EAAA5nG,aAAA,kBACAo/G,EAAA,IAAA1G,EAAA,IACAnV,EAAA7rG,QAAA0nH,IAAA,GACA7b,IAAAxyD,QAAAquE,EAAA,IAEA7b,KAAAniG,OACAmiG,EACAqE,EAAA1hG,aAAA,QAAAq9F,GAEAqE,EAAA9hG,gBAAA,UAOA,QAAAu5G,IAAAC,GACA,GAAAA,EAAA,CAIA,mBAAAA,GAAA,CACA,GAAA7jB,KAKA,QAJA,IAAA6jB,EAAAC,KACAh0G,EAAAkwF,EAAA+jB,GAAAF,EAAA/9G,MAAA,MAEAgK,EAAAkwF,EAAA6jB,GACA7jB,EACG,sBAAA6jB,GACHE,GAAAF,OADG,IA8CH,QAAAG,IAAA/rH,GACAgsH,GAAA,WACAA,GAAAhsH,KAIA,QAAAisH,IAAA/X,EAAA8Q,GACA,GAAAkH,GAAAhY,EAAAgR,qBAAAhR,EAAAgR,sBACAgH,GAAAloH,QAAAghH,GAAA,IACAkH,EAAAzoH,KAAAuhH,GACAwG,GAAAtX,EAAA8Q,IAIA,QAAAmH,IAAAjY,EAAA8Q,GACA9Q,EAAAgR,oBACAhiH,EAAAgxG,EAAAgR,mBAAAF,GAEAyG,GAAAvX,EAAA8Q,GAGA,QAAAoH,IACAlY,EACAmY,EACA/wF,GAEA,GAAA+mF,GAAAiK,GAAApY,EAAAmY,GACAv+G,EAAAu0G,EAAAv0G,KACA+S,EAAAwhG,EAAAxhG,QACA0rG,EAAAlK,EAAAkK,SACA,KAAAz+G,EAAc,MAAAwtB,IACd,IAAA7rB,GAAA3B,IAAA0+G,GAAAC,GAAAC,GACArhG,EAAA,EACAhM,EAAA,WACA60F,EAAA1jG,oBAAAf,EAAAk9G,GACArxF,KAEAqxF,EAAA,SAAArpH,GACAA,EAAA4T,SAAAg9F,KACA7oF,GAAAkhG,GACAltG,IAIA1d,YAAA,WACA0pB,EAAAkhG,GACAltG,KAEGwB,EAAA,GACHqzF,EAAArjG,iBAAApB,EAAAk9G,GAKA,QAAAL,IAAApY,EAAAmY,GACA,GAQAv+G,GARA8+G,EAAA1nH,OAAAsO,iBAAA0gG,GACA2Y,EAAAD,EAAAE,GAAA,SAAAn/G,MAAA,MACAo/G,EAAAH,EAAAE,GAAA,YAAAn/G,MAAA,MACAq/G,EAAAC,GAAAJ,EAAAE,GACAG,EAAAN,EAAAO,GAAA,SAAAx/G,MAAA,MACAy/G,EAAAR,EAAAO,GAAA,YAAAx/G,MAAA,MACA0/G,EAAAJ,GAAAC,EAAAE,GAGAvsG,EAAA,EACA0rG,EAAA,CA8BA,OA5BAF,KAAAG,GACAQ,EAAA,IACAl/G,EAAA0+G,GACA3rG,EAAAmsG,EACAT,EAAAQ,EAAAruH,QAEG2tH,IAAAiB,GACHD,EAAA,IACAv/G,EAAAw/G,GACAzsG,EAAAwsG,EACAd,EAAAa,EAAA1uH,SAGAmiB,EAAAzY,KAAAC,IAAA2kH,EAAAK,GACAv/G,EAAA+S,EAAA,EACAmsG,EAAAK,EACAb,GACAc,GACA,KACAf,EAAAz+G,EACAA,IAAA0+G,GACAO,EAAAruH,OACA0uH,EAAA1uH,OACA,IAMAoP,OACA+S,UACA0rG,YACAgB,aANAz/G,IAAA0+G,IACAgB,GAAA74E,KAAAi4E,EAAAE,GAAA,cASA,QAAAG,IAAAQ,EAAAC,GAEA,KAAAD,EAAA/uH,OAAAgvH,EAAAhvH,QACA+uH,IAAAhrH,OAAAgrH,EAGA,OAAArlH,MAAAC,IAAAhI,MAAA,KAAAqtH,EAAA9/G,IAAA,SAAAlQ,EAAA4D,GACA,MAAAqsH,IAAAjwH,GAAAiwH,GAAAF,EAAAnsH,OAIA,QAAAqsH,IAAAp0G,GACA,WAAAgnF,OAAAhnF,EAAA1U,MAAA,OAKA,QAAA0G,IAAAmjG,EAAAkf,GACA,GAAA1Z,GAAAxF,EAAAG,GAGAtI,GAAA2N,EAAA2Z,YACA3Z,EAAA2Z,SAAAC,WAAA,EACA5Z,EAAA2Z,WAGA,IAAA5iH,GAAA0gH,GAAAjd,EAAAzjG,KAAAiB,WACA,KAAAo6F,EAAAr7F,KAKAs7F,EAAA2N,EAAA6Z,WAAA,IAAA7Z,EAAA8Z,SAAA,CA4BA,IAxBA,GAAAnC,GAAA5gH,EAAA4gH,IACA/9G,EAAA7C,EAAA6C,KACAmgH,EAAAhjH,EAAAgjH,WACAC,EAAAjjH,EAAAijH,aACAC,EAAAljH,EAAAkjH,iBACAC,EAAAnjH,EAAAmjH,YACAC,EAAApjH,EAAAojH,cACAC,EAAArjH,EAAAqjH,kBACAC,EAAAtjH,EAAAsjH,YACAhjH,EAAAN,EAAAM,MACAijH,EAAAvjH,EAAAujH,WACAC,EAAAxjH,EAAAwjH,eACAC,EAAAzjH,EAAAyjH,aACAC,EAAA1jH,EAAA0jH,OACAC,EAAA3jH,EAAA2jH,YACAC,EAAA5jH,EAAA4jH,gBACAvsG,EAAArX,EAAAqX,SAMA7iB,EAAAqvH,GACAC,EAAAD,GAAAxvB,OACAyvB,KAAA9uH,QACA8uH,IAAA9uH,OACAR,EAAAsvH,EAAAtvH,OAGA,IAAAuvH,IAAAvvH,EAAAq0G,aAAApF,EAAAugB,YAEA,KAAAD,GAAAL,GAAA,KAAAA,EAAA,CAIA,GAAAO,GAAAF,GAAAZ,EACAA,EACAH,EACAkB,EAAAH,GAAAV,EACAA,EACAH,EACAiB,EAAAJ,GAAAX,EACAA,EACAH,EAEAmB,EAAAL,EACAN,GAAAH,EACAA,EACAe,EAAAN,GACA,kBAAAL,KACApjH,EACAgkH,EAAAP,EACAJ,GAAAJ,EACAA,EACAgB,EAAAR,EACAH,GAAAJ,EACAA,EAEAgB,EAAAxoB,EACA9kG,EAAAmgB,GACAA,EAAA/W,MACA+W,GAOAotG,GAAA,IAAA7D,IAAAtH,GACAoL,EAAAC,GAAAN,GAEAh0F,EAAA44E,EAAA6Z,SAAAvlB,EAAA,WACAknB,IACAvD,GAAAjY,EAAAkb,GACAjD,GAAAjY,EAAAib,IAEA7zF,EAAAwyF,WACA4B,GACAvD,GAAAjY,EAAAgb,GAEAM,KAAAtb,IAEAqb,KAAArb,GAEAA,EAAA6Z,SAAA,MAGArf,GAAAzjG,KAAA4kH,MAEA5f,GAAAvB,EAAAzjG,KAAAo0F,OAAAqP,EAAAzjG,KAAAo0F,SAA2D,oBAC3D,GAAAp/F,GAAAi0G,EAAA3nG,WACAujH,EAAA7vH,KAAA8vH,UAAA9vH,EAAA8vH,SAAArhB,EAAA98F,IACAk+G,IACAA,EAAAlhB,MAAAF,EAAAE,KACAkhB,EAAAjhB,IAAAgf,UAEAiC,EAAAjhB,IAAAgf,WAEAyB,KAAApb,EAAA54E,KAKA+zF,KAAAnb,GACAwb,IACAzD,GAAA/X,EAAAgb,GACAjD,GAAA/X,EAAAib,GACApD,GAAA,WACAE,GAAA/X,EAAAkb,GACAjD,GAAAjY,EAAAgb,GACA5zF,EAAAwyF,WAAA6B,IACAK,GAAAP,GACA9tH,WAAA25B,EAAAm0F,GAEArD,GAAAlY,EAAApmG,EAAAwtB,OAMAozE,EAAAzjG,KAAA4kH,OACAjC,OACA0B,KAAApb,EAAA54E,IAGAo0F,GAAAC,GACAr0F,MAIA,QAAA20F,IAAAvhB,EAAAwhB,GAsEA,QAAAC,KAEA70F,EAAAwyF,YAIApf,EAAAzjG,KAAA4kH,QACA3b,EAAA3nG,WAAAwjH,WAAA7b,EAAA3nG,WAAAwjH,cAA6DrhB,EAAA,KAAAA,GAE7D0hB,KAAAlc,GACAwb,IACAzD,GAAA/X,EAAAmc,GACApE,GAAA/X,EAAAoc,GACAvE,GAAA,WACAE,GAAA/X,EAAAqc,GACApE,GAAAjY,EAAAmc,GACA/0F,EAAAwyF,WAAA6B,IACAK,GAAAQ,GACA7uH,WAAA25B,EAAAk1F,GAEApE,GAAAlY,EAAApmG,EAAAwtB,OAKA20F,KAAA/b,EAAA54E,GACAo0F,GAAAC,GACAr0F,KAhGA,GAAA44E,GAAAxF,EAAAG,GAGAtI,GAAA2N,EAAA6Z,YACA7Z,EAAA6Z,SAAAD,WAAA,EACA5Z,EAAA6Z,WAGA,IAAA9iH,GAAA0gH,GAAAjd,EAAAzjG,KAAAiB,WACA,IAAAo6F,EAAAr7F,GACA,MAAAilH,IAIA,KAAA3pB,EAAA2N,EAAA2Z,WAAA,IAAA3Z,EAAA8Z,SAAA,CAIA,GAAAnC,GAAA5gH,EAAA4gH,IACA/9G,EAAA7C,EAAA6C,KACAuiH,EAAAplH,EAAAolH,WACAE,EAAAtlH,EAAAslH,aACAD,EAAArlH,EAAAqlH,iBACAF,EAAAnlH,EAAAmlH,YACAH,EAAAhlH,EAAAglH,MACAQ,EAAAxlH,EAAAwlH,WACAC,EAAAzlH,EAAAylH,eACAC,EAAA1lH,EAAA0lH,WACAruG,EAAArX,EAAAqX,SAEAotG,GAAA,IAAA7D,IAAAtH,GACAoL,EAAAC,GAAAK,GAEAO,EAAAvpB,EACA9kG,EAAAmgB,GACAA,EAAA2tG,MACA3tG,GAOAgZ,EAAA44E,EAAA2Z,SAAArlB,EAAA,WACA0L,EAAA3nG,YAAA2nG,EAAA3nG,WAAAwjH,WACA7b,EAAA3nG,WAAAwjH,SAAArhB,EAAA98F,KAAA,MAEA89G,IACAvD,GAAAjY,EAAAqc,GACApE,GAAAjY,EAAAoc,IAEAh1F,EAAAwyF,WACA4B,GACAvD,GAAAjY,EAAAmc,GAEAK,KAAAxc,KAEAgc,IACAO,KAAAvc,IAEAA,EAAA2Z,SAAA,MAGA8C,GACAA,EAAAR,GAEAA,KAoDA,QAAAH,IAAAjuB,GACA,sBAAAA,KAAArlF,MAAAqlF,GASA,QAAA6tB,IAAA5vH,GACA,GAAAsmG,EAAAtmG,GACA,QAEA,IAAA4wH,GAAA5wH,EAAAuvG,GACA,OAAAhJ,GAAAqqB,GAEAhB,GACA7oH,MAAAxD,QAAAqtH,GACAA,EAAA,GACAA,IAGA5wH,EAAA0nG,SAAA1nG,EAAAtB,QAAA,EAIA,QAAAu1D,IAAApnD,EAAA6hG,IACA,IAAAA,EAAAzjG,KAAA4kH,MACAtkH,GAAAmjG,GAmGA,QAAAmiB,IAAA3c,EAAA4c,EAAA5nB,GACA,GAAA7rG,GAAAyzH,EAAAzzH,MACA0zH,EAAA7c,EAAA0N,QACA,KAAAmP,GAAAhqH,MAAAxD,QAAAlG,GAAA,CASA,OADAokH,GAAAuP,EACA1vH,EAAA,EAAAkY,EAAA06F,EAAAjV,QAAAvgG,OAAwC4C,EAAAkY,EAAOlY,IAE/C,GADA0vH,EAAA9c,EAAAjV,QAAA39F,GACAyvH,EACAtP,EAAAlZ,EAAAlrG,EAAA4zH,GAAAD,KAAA,EACAA,EAAAvP,eACAuP,EAAAvP,gBAGA,IAAAzZ,EAAAipB,GAAAD,GAAA3zH,GAIA,YAHA62G,EAAAgd,gBAAA5vH,IACA4yG,EAAAgd,cAAA5vH,GAMAyvH,KACA7c,EAAAgd,eAAA,IAIA,QAAAD,IAAAD,GACA,gBAAAA,GACAA,EAAAltG,OACAktG,EAAA3zH,MAGA,QAAA8zH,IAAA7tH,GACAA,EAAA4T,OAAAizG,WAAA,EAGA,QAAAiH,IAAA9tH,GAEAA,EAAA4T,OAAAizG,YACA7mH,EAAA4T,OAAAizG,WAAA,EACAkH,GAAA/tH,EAAA4T,OAAA,UAGA,QAAAm6G,IAAAnd,EAAApmG,GACA,GAAAxK,GAAA+K,SAAAwH,YAAA,aACAvS,GAAAwS,UAAAhI,GAAA,MACAomG,EAAAx+F,cAAApS,GAMA,QAAAguH,IAAA5iB,GACA,OAAAA,EAAA4R,mBAAA5R,EAAAzjG,MAAAyjG,EAAAzjG,KAAAiB,WAEAwiG,EADA4iB,GAAA5iB,EAAA4R,kBAAAnL,QAyFA,QAAAoc,IAAA7iB,GACA,GAAA8iB,GAAA9iB,KAAAI,gBACA,OAAA0iB,MAAAhoB,KAAAvK,QAAAqU,SACAie,GAAApf,GAAAqf,EAAAjpF,WAEAmmE,EAIA,QAAA+iB,IAAAvgB,GACA,GAAAjmG,MACAg0F,EAAAiS,EAAA9C,QAEA,QAAAx8F,KAAAqtF,GAAA2O,UACA3iG,EAAA2G,GAAAs/F,EAAAt/F,EAIA,IAAAwa,GAAA6yE,EAAAqT,gBACA,QAAAof,KAAAtlG,GACAnhB,EAAAohG,GAAAqlB,IAAAtlG,EAAAslG,EAEA,OAAAzmH,GAGA,QAAA0mH,IAAAr4G,EAAAs4G,GACA,oBAAAj9E,KAAAi9E,EAAAhjB,KACA,MAAAt1F,GAAA,cACA8yF,MAAAwlB,EAAA9iB,iBAAAlB,YAKA,QAAAikB,IAAAnjB,GACA,KAAAA,IAAAzuG,QACA,GAAAyuG,EAAAzjG,KAAAiB,WACA,SAKA,QAAA4lH,IAAA3oF,EAAA4oF,GACA,MAAAA,GAAAngH,MAAAu3B,EAAAv3B,KAAAmgH,EAAAnjB,MAAAzlE,EAAAylE,IAGA,QAAA8T,IAAAlxG,GACA,MAAAA,GAAA09F,WAAA19F,EAAAu9F,aAoQA,QAAAijB,IAAAhkH,GAEAA,EAAA6gG,IAAAojB,SACAjkH,EAAA6gG,IAAAojB,UAGAjkH,EAAA6gG,IAAAkf,UACA//G,EAAA6gG,IAAAkf,WAIA,QAAAmE,IAAAlkH,GACAA,EAAA/C,KAAAknH,OAAAnkH,EAAA6gG,IAAA17C,wBAGA,QAAAi/D,IAAApkH,GACA,GAAAqkH,GAAArkH,EAAA/C,KAAAqnH,IACAH,EAAAnkH,EAAA/C,KAAAknH,OACA96G,EAAAg7G,EAAA7lH,KAAA2lH,EAAA3lH,KACA8K,EAAA+6G,EAAArmH,IAAAmmH,EAAAnmH,GACA,IAAAqL,GAAAC,EAAA,CACAtJ,EAAA/C,KAAAoe,OAAA,CACA,IAAA9P,GAAAvL,EAAA6gG,IAAA97F,KACAwG,GAAAlN,UAAAkN,EAAAg5G,gBAAA,aAAAl7G,EAAA,MAAAC,EAAA,MACAiC,EAAAi5G,mBAAA,MAmFA,QAAAC,IACA7mH,EACA8mH,GAEA,GAAAC,GAAAD,EAAAE,GAAAF,GAAAG,EACA,IAAAF,EAAAh+E,KAAA/oC,GAAA,CAMA,IAHA,GAEAqlB,GAAAhuB,EAFA6vH,KACApwD,EAAAiwD,EAAAjwD,UAAA,EAEAzxC,EAAA0hG,EAAAx6G,KAAAvM,IAAA,CACA3I,EAAAguB,EAAAhuB,MAEAA,EAAAy/D,GACAowD,EAAArvH,KAAA8qB,KAAAC,UAAA5iB,EAAA/G,MAAA69D,EAAAz/D,IAGA,IAAA+b,GAAAomG,GAAAn0F,EAAA,GAAAvjB,OACAolH,GAAArvH,KAAA,MAAAub,EAAA,KACA0jD,EAAAz/D,EAAAguB,EAAA,GAAAvyB,OAKA,MAHAgkE,GAAA92D,EAAAlN,QACAo0H,EAAArvH,KAAA8qB,KAAAC,UAAA5iB,EAAA/G,MAAA69D,KAEAowD,EAAAh0G,KAAA,MAKA,QAAAi0G,IAAA7e,EAAAjV,GACA,GACA2hB,IADA3hB,EAAAynB,KACAQ,GAAAhT,EAAA,SAYA0M,KACA1M,EAAA0M,YAAAryF,KAAAC,UAAAoyF,GAEA,IAAAoS,GAAAjM,GAAA7S,EAAA,WACA8e,KACA9e,EAAA8e,gBAIA,QAAAC,IAAA/e,GACA,GAAAjpG,GAAA,EAOA,OANAipG,GAAA0M,cACA31G,GAAA,eAAAipG,EAAA,iBAEAA,EAAA8e,eACA/nH,GAAA,SAAAipG,EAAA,kBAEAjpG,EAWA,QAAAioH,IAAAhf,EAAAjV,GACA,GACA0rB,IADA1rB,EAAAynB,KACAQ,GAAAhT,EAAA,SACA,IAAAyW,EAAA,CAaAzW,EAAAyW,YAAAp8F,KAAAC,UAAAq8F,GAAAF,IAGA,GAAAwI,GAAApM,GAAA7S,EAAA,WACAif,KACAjf,EAAAif,gBAIA,QAAAC,IAAAlf,GACA,GAAAjpG,GAAA,EAOA,OANAipG,GAAAyW,cACA1/G,GAAA,eAAAipG,EAAA,iBAEAA,EAAAif,eACAloH,GAAA,UAAAipG,EAAA,mBAEAjpG,EAgBA,QAAAW,IAAAsoG,EAAA+O,GACAA,EAAA5lH,OACAgpH,GAAAnS,EAAA,oBAAA+O,EAAA,WAMA,QAAAxsD,IAAAy9C,EAAA+O,GACAA,EAAA5lH,OACAgpH,GAAAnS,EAAA,kBAAA+O,EAAA,WA0HA,QAAAoQ,IAAAh2H,EAAAi2H,GACA,GAAApiG,GAAAoiG,EAAAC,GAAAC,EACA,OAAAn2H,GAAAggD,QAAAnsB,EAAA,SAAAD,GAA6C,MAAAwiG,IAAAxiG,KAG7C,QAAAyiG,IAAAj9D,EAAAwoC,GA8HA,QAAA00B,GAAAtmH,GACApK,GAAAoK,EACAopD,IAAA6Z,UAAAjjE,GAuEA,QAAAumH,GAAAjS,EAAA15G,EAAAoX,GACA,GAAAizG,GAAAuB,CASA,IARA,MAAA5rH,IAAwBA,EAAAhF,GACxB,MAAAoc,IAAsBA,EAAApc,GAEtB0+G,IACAkS,EAAAlS,EAAA1pG,eAIA0pG,EACA,IAAA2Q,EAAAroC,EAAAvrF,OAAA,EAAkC4zH,GAAA,GAClCroC,EAAAqoC,GAAAwB,gBAAAD,EAD4CvB,SAO5CA,GAAA,CAGA,IAAAA,GAAA,GAEA,OAAAhxH,GAAA2oF,EAAAvrF,OAAA,EAAoC4C,GAAAgxH,EAAUhxH,IAS9C29F,EAAA5/E,KACA4/E,EAAA5/E,IAAA4qE,EAAA3oF,GAAAstG,IAAA3mG,EAAAoX,EAKA4qE,GAAAvrF,OAAA4zH,EACAyB,EAAAzB,GAAAroC,EAAAqoC,EAAA,GAAA1jB,QACK,OAAAilB,EACL50B,EAAAh3F,OACAg3F,EAAAh3F,MAAA05G,MAAA,EAAA15G,EAAAoX,GAEK,MAAAw0G,IACL50B,EAAAh3F,OACAg3F,EAAAh3F,MAAA05G,MAAA,EAAA15G,EAAAoX,GAEA4/E,EAAA5/E,KACA4/E,EAAA5/E,IAAAsiG,EAAA15G,EAAAoX,IAjPA,IANA,GAKA0xF,GAAAgjB,EALA9pC,KACA+pC,EAAA/0B,EAAA+0B,WACAC,EAAAh1B,EAAAi1B,YAAAC,GACAC,EAAAn1B,EAAAo1B,kBAAAF,GACAlxH,EAAA,EAEAwzD,GAAA,CAGA,GAFAs6C,EAAAt6C,EAEAs9D,GAAAO,GAAAP,GAgFK,CACL,GAAAQ,GAAA,EACAC,EAAAT,EAAA97G,cACAw8G,EAAAC,GAAAF,KAAAE,GAAAF,GAAA,GAAAj3E,QAAA,kBAAAi3E,EAAA,gBACAG,EAAAl+D,EAAApZ,QAAAo3E,EAAA,SAAAG,EAAAhpH,EAAAipH,GAaA,MAZAN,GAAAM,EAAAn2H,OACA41H,GAAAE,IAAA,aAAAA,IACA5oH,IACAyxC,QAAA,2BACAA,QAAA,mCAEAy3E,GAAAN,EAAA5oH,KACAA,IAAA/G,MAAA,IAEAo6F,EAAA81B,OACA91B,EAAA81B,MAAAnpH,GAEA,IAEA3I,IAAAwzD,EAAA/3D,OAAAi2H,EAAAj2H,OACA+3D,EAAAk+D,EACAf,EAAAY,EAAAvxH,EAAAsxH,EAAAtxH,OArGA,CACA,GAAA+xH,GAAAv+D,EAAAzyD,QAAA,IACA,QAAAgxH,EAAA,CAEA,GAAAC,GAAAtgF,KAAA8hB,GAAA,CACA,GAAAy+D,GAAAz+D,EAAAzyD,QAAA,SAEA,IAAAkxH,GAAA,GACAj2B,EAAAk2B,mBACAl2B,EAAAg2B,QAAAx+D,EAAA6Z,UAAA,EAAA4kD,IAEAvB,EAAAuB,EAAA,EACA,WAKA,GAAAE,GAAAzgF,KAAA8hB,GAAA,CACA,GAAA4+D,GAAA5+D,EAAAzyD,QAAA,KAEA,IAAAqxH,GAAA,GACA1B,EAAA0B,EAAA,EACA,WAKA,GAAAC,GAAA7+D,EAAAxlC,MAAAskG,GACA,IAAAD,EAAA,CACA3B,EAAA2B,EAAA,GAAA52H,OACA,UAIA,GAAA82H,GAAA/+D,EAAAxlC,MAAA4jG,GACA,IAAAW,EAAA,CACA,GAAAC,GAAAxyH,CACA0wH,GAAA6B,EAAA,GAAA92H,QACAk1H,EAAA4B,EAAA,GAAAC,EAAAxyH,EACA,UAIA,GAAAyyH,GA8EA,WACA,GAAAztH,GAAAwuD,EAAAxlC,MAAA0kG,GACA,IAAA1tH,EAAA,CACA,GAAAgpB,IACA0wF,QAAA15G,EAAA,GACAqoG,SACAroG,MAAAhF,EAEA0wH,GAAA1rH,EAAA,GAAAvJ,OAEA,KADA,GAAA2gB,GAAA5T,IACA4T,EAAAo3C,EAAAxlC,MAAA2kG,OAAAnqH,EAAAgrD,EAAAxlC,MAAA4kG,MACAlC,EAAAloH,EAAA,GAAA/M,QACAuyB,EAAAq/E,MAAA7sG,KAAAgI,EAEA,IAAA4T,EAIA,MAHA4R,GAAA6kG,WAAAz2G,EAAA,GACAs0G,EAAAt0G,EAAA,GAAA3gB,QACAuyB,EAAA5R,IAAApc,EACAguB,KA/FA,IAAAykG,EAAA,EAoGA,SAAAzkG,GACA,GAAA0wF,GAAA1wF,EAAA0wF,QACAmU,EAAA7kG,EAAA6kG,UAEA9B,KACA,MAAAD,GAAAgC,GAAApU,IACAiS,EAAAG,GAEAK,EAAAzS,IAAAoS,IAAApS,GACAiS,EAAAjS,GAQA,QAJAqU,GAAA/B,EAAAtS,MAAAmU,EAEAt8G,EAAAyX,EAAAq/E,MAAA5xG,OACA4xG,EAAA,GAAAvpG,OAAAyS,GACAlY,EAAA,EAAmBA,EAAAkY,EAAOlY,IAAA,CAC1B,GAAA0P,GAAAigB,EAAAq/E,MAAAhvG,EAEA20H,MAAA,IAAAjlH,EAAA,GAAAhN,QAAA,QACA,KAAAgN,EAAA,UAA6BA,GAAA,GAC7B,KAAAA,EAAA,UAA6BA,GAAA,GAC7B,KAAAA,EAAA,UAA6BA,GAAA,GAE7B,IAAA3T,GAAA2T,EAAA,IAAAA,EAAA,IAAAA,EAAA,MACAs/F,GAAAhvG,IACAuM,KAAAmD,EAAA,GACA3T,MAAAg2H,GACAh2H,EACA4hG,EAAAq0B,uBAKA0C,IACA/rC,EAAAxmF,MAAkBmrG,IAAA+S,EAAAmS,cAAAnS,EAAA1pG,cAAAq4F,UAClByjB,EAAApS,GAGA1iB,EAAAh3F,OACAg3F,EAAAh3F,MAAA05G,EAAArR,EAAA0lB,EAAA/kG,EAAAhpB,MAAAgpB,EAAA5R,MA5IAq2G,GACAZ,GAAAf,EAAAt9D,IACAk9D,EAAA,EAEA,WAIA,GAAA/nH,OAAA,GAAAsqH,MAAA,GAAAx5H,MAAA,EACA,IAAAs4H,GAAA,GAEA,IADAkB,EAAAz/D,EAAA5xD,MAAAmwH,KAEAH,GAAAlgF,KAAAuhF,IACAP,GAAAhhF,KAAAuhF,IACAjB,GAAAtgF,KAAAuhF,IACAd,GAAAzgF,KAAAuhF,KAGAx5H,EAAAw5H,EAAAlyH,QAAA,QACA,IACAgxH,GAAAt4H,EACAw5H,EAAAz/D,EAAA5xD,MAAAmwH,EAEAppH,GAAA6qD,EAAA6Z,UAAA,EAAA0kD,GACArB,EAAAqB,GAGAA,EAAA,IACAppH,EAAA6qD,EACAA,EAAA,IAGAwoC,EAAA81B,OAAAnpH,GACAqzF,EAAA81B,MAAAnpH,GA0BA,GAAA6qD,IAAAs6C,EAAA,CACA9R,EAAA81B,OAAA91B,EAAA81B,MAAAt+D,EAIA,QAKAm9D,IA4JA,QAAA71G,IACAo4G,EACAl3B,GA6BA,QAAAm3B,GAAAnkE,GAEAA,EAAAokE,MACAC,GAAA,GAEAC,GAAAtkE,EAAA28C,OACA4nB,GAAA,GAjCAC,GAAAx3B,EAAAynB,MAAAR,GAEAqQ,GAAAt3B,EAAAy3B,UAAAvC,GACAwC,GAAA13B,EAAA4d,aAAAsX,GACAyC,GAAA33B,EAAAyc,iBAAAyY,GAEA0C,GAAA1Q,GAAAlnB,EAAAmnB,QAAA,iBACA0Q,GAAA3Q,GAAAlnB,EAAAmnB,QAAA,oBACA2Q,GAAA5Q,GAAAlnB,EAAAmnB,QAAA,qBAEAsM,GAAAzzB,EAAAyzB,UAEA,IAEA71H,GACAm6H,EAHA/sC,KACAgtC,GAAA,IAAAh4B,EAAAg4B,mBAGAX,GAAA,EACAE,GAAA,CA2NA,OAvMA9C,IAAAyC,GACAzP,KAAA+P,GACAzC,WAAA/0B,EAAA+0B,WACAE,WAAAj1B,EAAAi1B,WACAG,iBAAAp1B,EAAAo1B,iBACAf,qBAAAr0B,EAAAq0B,qBACA6B,kBAAAl2B,EAAAi4B,SACAjvH,MAAA,SAAA2mG,EAAA0B,EAAA0lB,GAGA,GAAAhnB,GAAAgoB,KAAAhoB,IAAA4nB,GAAAhoB,EAIA0a,KAAA,QAAAta,IACAsB,EAAA6mB,GAAA7mB,GAGA,IAAAr+C,IACAnkD,KAAA,EACA8gG,MACAyY,UAAA/W,EACA8W,SAAAgQ,GAAA9mB,GACArwG,OAAA+2H,EACAzuF,YAEAymE,KACA/8C,EAAA+8C,MAGAqoB,GAAAplE,KAAAu4C,OACAv4C,EAAAqlE,WAAA,EASA,QAAAh2H,GAAA,EAAqBA,EAAAw1H,GAAAp4H,OAA0B4C,IAC/Cw1H,GAAAx1H,GAAA2wD,EAAAgtC,EAYA,IATAq3B,IACAiB,GAAAtlE,GACAA,EAAAokE,MACAC,GAAA,IAGAC,GAAAtkE,EAAA28C,OACA4nB,GAAA,GAEAF,EACAkB,GAAAvlE,OACO,CACPwlE,GAAAxlE,GACAylE,GAAAzlE,GACA0lE,GAAA1lE,GACA2lE,GAAA3lE,GAIAA,EAAA4lE,OAAA5lE,EAAArgD,MAAA0+F,EAAA5xG,OAEAo5H,GAAA7lE,GACA8lE,GAAA9lE,GACA+lE,GAAA/lE,EACA,QAAAgmE,GAAA,EAAyBA,EAAApB,GAAAn4H,OAAyBu5H,IAClDpB,GAAAoB,GAAAhmE,EAAAgtC,EAEAi5B,IAAAjmE,GAwCA,GAnBAp1D,EAGOotF,EAAAvrF,QAEP7B,EAAAs7H,KAAAlmE,EAAAmmE,QAAAnmE,EAAAomE,OAEAC,GAAAz7H,GACAmiB,IAAAizC,EAAAmmE,OACAG,MAAAtmE,IARAp1D,EAAAo1D,EAkBA+kE,IAAA/kE,EAAAqlE,UACA,GAAArlE,EAAAmmE,QAAAnmE,EAAAomE,KACAG,GAAAvmE,EAAA+kE,OACS,IAAA/kE,EAAAwmE,UAAA,CACTzB,EAAAa,OAAA,CACA,IAAAhqH,GAAAokD,EAAAymE,YAAA,aAAuD1B,EAAAjiB,cAAAiiB,EAAAjiB,iBAA6DlnG,GAAAokD,MAEpH+kE,GAAAzuF,SAAA9kC,KAAAwuD,GACAA,EAAAhyD,OAAA+2H,CAGAhB,GAIAI,EAAAnkE,IAHA+kE,EAAA/kE,EACAg4B,EAAAxmF,KAAAwuD,GAKA,QAAA0mE,GAAA,EAAuBA,EAAA5B,GAAAr4H,OAA6Bi6H,IACpD5B,GAAA4B,GAAA1mE,EAAAgtC,IAIA5/E,IAAA,WAEA,GAAA4yC,GAAAg4B,IAAAvrF,OAAA,GACAk6H,EAAA3mE,EAAA1pB,SAAA0pB,EAAA1pB,SAAA7pC,OAAA,EACAk6H,IAAA,IAAAA,EAAA9qH,MAAA,MAAA8qH,EAAAhtH,OAAA4qH,GACAvkE,EAAA1pB,SAAA/hC,MAGAyjF,EAAAvrF,QAAA,EACAs4H,EAAA/sC,IAAAvrF,OAAA,GACA03H,EAAAnkE,IAGA8iE,MAAA,SAAAnpH,GACA,GAAAorH,KAgBA1N,IACA,aAAA0N,EAAApoB,KACAooB,EAAA5P,SAAAuK,cAAA/lH,GAFA,CAMA,GAAA28B,GAAAyuF,EAAAzuF,QAKA,IAJA38B,EAAA4qH,GAAA5qH,EAAA8B,OACAmrH,GAAA7B,GAAAprH,EAAAktH,GAAAltH,GAEAqrH,GAAA1uF,EAAA7pC,OAAA,OACA,CACA,GAAA+mH,IACA6Q,GAAA,MAAA1qH,IAAA65G,EAAAgN,GAAA7mH,EAAA8mH,KACAnqF,EAAA9kC,MACAqK,KAAA,EACA23G,aACA75G,SAES,MAAAA,GAAA28B,EAAA7pC,QAAA,MAAA6pC,IAAA7pC,OAAA,GAAAkN,MACT28B,EAAA9kC,MACAqK,KAAA,EACAlC,YAKAqpH,QAAA,SAAArpH,GACAorH,EAAAzuF,SAAA9kC,MACAqK,KAAA,EACAlC,OACAsjG,WAAA,OAIAryG,EAGA,QAAA06H,IAAArjB,GACA,MAAAgT,GAAAhT,EAAA,WACAA,EAAAmiB,KAAA,GAIA,QAAAmB,IAAAtjB,GACA,GAAA16F,GAAA06F,EAAAmT,UAAA3oH,MACA,IAAA8a,EAEA,OADA82F,GAAA4D,EAAA5D,MAAA,GAAAvpG,OAAAyS,GACAlY,EAAA,EAAmBA,EAAAkY,EAAOlY,IAC1BgvG,EAAAhvG,IACAuM,KAAAqmG,EAAAmT,UAAA/lH,GAAAuM,KACAxQ,MAAAkxB,KAAAC,UAAA0lF,EAAAmT,UAAA/lH,GAAAjE,YAGG62G,GAAAmiB,MAEHniB,EAAA2jB,OAAA,GAIA,QAAAD,IAAA1jB,GACA,GAAAl1F,GAAA+nG,GAAA7S,EAAA,MACAl1F,KAIAk1F,EAAAtiG,IAAAoN,GAIA,QAAA84G,IAAA5jB,GACA,GAAAmO,GAAA0E,GAAA7S,EAAA,MACAmO,KACAnO,EAAAmO,MACAnO,EAAAqO,SAAAwW,GAAA7kB,IAIA,QAAAujB,IAAAvjB,GACA,GAAAl1F,EACA,IAAAA,EAAAkoG,GAAAhT,EAAA,UACA,GAAA8kB,GAAAh6G,EAAAiS,MAAAgoG,GACA,KAAAD,EAIA,MAEA9kB,GAAAxS,IAAAs3B,EAAA,GAAAtrH,MACA,IAAAwrH,GAAAF,EAAA,GAAAtrH,OACAyrH,EAAAD,EAAAjoG,MAAAmoG,GACAD,IACAjlB,EAAAglB,MAAAC,EAAA,GAAAzrH,OACAwmG,EAAAmlB,UAAAF,EAAA,GAAAzrH,OACAyrH,EAAA,KACAjlB,EAAAolB,UAAAH,EAAA,GAAAzrH,SAGAwmG,EAAAglB,SAKA,QAAAxB,IAAAxjB,GACA,GAAAl1F,GAAAkoG,GAAAhT,EAAA,OACA,IAAAl1F,EACAk1F,EAAAikB,GAAAn5G,EACAs5G,GAAApkB,GACAl1F,MACAu5G,MAAArkB,QAEG,CACH,MAAAgT,GAAAhT,EAAA,YACAA,EAAAmkB,MAAA,EAEA,IAAAD,GAAAlR,GAAAhT,EAAA,YACAkkB,KACAlkB,EAAAkkB,WAKA,QAAAI,IAAAtkB,EAAAj0G,GACA,GAAAulH,GAAA+T,GAAAt5H,EAAAsoC,SACAi9E,MAAA2S,IACAG,GAAA9S,GACAxmG,IAAAk1F,EAAAkkB,OACAG,MAAArkB,IAUA,QAAAqlB,IAAAhxF,GAEA,IADA,GAAAjnC,GAAAinC,EAAA7pC,OACA4C,KAAA,CACA,OAAAinC,EAAAjnC,GAAAwM,KACA,MAAAy6B,GAAAjnC,EAQAinC,GAAA/hC,OAKA,QAAA8xH,IAAApkB,EAAAslB,GACAtlB,EAAAulB,eACAvlB,EAAAulB,iBAEAvlB,EAAAulB,aAAAh2H,KAAA+1H,GAGA,QAAA7B,IAAAzjB,GAEA,MADAgT,GAAAhT,EAAA,YAEAA,EAAA1L,MAAA,GAIA,QAAAuvB,IAAA7jB,GACA,YAAAA,EAAAtF,IACAsF,EAAAwlB,SAAA3S,GAAA7S,EAAA,YAQG,CACH,GAAAwkB,GAAA3R,GAAA7S,EAAA,OACAwkB,KACAxkB,EAAAwkB,WAAA,OAAAA,EAAA,YAAAA,GAEA,aAAAxkB,EAAAtF,MACAsF,EAAAukB,UAAAvR,GAAAhT,EAAA,WAKA,QAAA8jB,IAAA9jB,GACA,GAAA4c,IACAA,EAAA/J,GAAA7S,EAAA,SACAA,EAAAhC,UAAA4e,GAEA,MAAA5J,GAAAhT,EAAA,qBACAA,EAAA4G,gBAAA,GAIA,QAAAod,IAAAhkB,GACA,GACA5yG,GAAAkY,EAAA3L,EAAAq2G,EAAA7mH,EAAA0mH,EAAA4V,EADAvlH,EAAA8/F,EAAAmT,SAEA,KAAA/lH,EAAA,EAAAkY,EAAApF,EAAA1V,OAA8B4C,EAAAkY,EAAOlY,IAGrC,GAFAuM,EAAAq2G,EAAA9vG,EAAA9S,GAAAuM,KACAxQ,EAAA+W,EAAA9S,GAAAjE,MACAu8H,GAAAjlF,KAAA9mC,GAQA,GANAqmG,EAAA2lB,aAAA,EAEA9V,EAAA+V,GAAAjsH,GACAk2G,IACAl2G,IAAAwvC,QAAA08E,GAAA,KAEAC,GAAArlF,KAAA9mC,GACAA,IAAAwvC,QAAA28E,GAAA,IACA38H,EAAA+nH,GAAA/nH,GACAs8H,GAAA,EACA5V,IACAA,EAAAlW,OACA8rB,GAAA,EAEA,eADA9rH,EAAAw+F,GAAAx+F,MACuCA,EAAA,cAEvCk2G,EAAAkW,QACApsH,EAAAw+F,GAAAx+F,IAEAk2G,EAAAjS,MACA0U,GACAtS,EACA,UAAA7H,GAAAx+F,GACA45G,GAAApqH,EAAA,YAIAs8H,IACAzlB,EAAAhC,WAAAykB,GAAAziB,EAAAtF,IAAAsF,EAAAkT,SAAAt5G,KAAAD,GAEAw4G,GAAAnS,EAAArmG,EAAAxQ,GAEAipH,GAAApS,EAAArmG,EAAAxQ,OAEO,IAAA68H,GAAAvlF,KAAA9mC,GACPA,IAAAwvC,QAAA68E,GAAA,IACA1T,GAAAtS,EAAArmG,EAAAxQ,EAAA0mH,GAAA,EAAA0S,QACO,CACP5oH,IAAAwvC,QAAAu8E,GAAA,GAEA,IAAAO,GAAAtsH,EAAAojB,MAAAmpG,IACAnzH,EAAAkzH,KAAA,EACAlzH,KACA4G,IAAAhJ,MAAA,IAAAoC,EAAAvI,OAAA,KAEA6nH,GAAArS,EAAArmG,EAAAq2G,EAAA7mH,EAAA4J,EAAA88G,OAKK,CAaLuC,GAAApS,EAAArmG,EAAA0gB,KAAAC,UAAAnxB,KAKA,QAAA07H,IAAA7kB,GAEA,IADA,GAAAj0G,GAAAi0G,EACAj0G,GAAA,CACA,OAAAowB,KAAApwB,EAAAyhG,IACA,QAEAzhG,YAEA,SAGA,QAAA65H,IAAAjsH,GACA,GAAAojB,GAAApjB,EAAAojB,MAAA8oG,GACA,IAAA9oG,EAAA,CACA,GAAA22E,KAEA,OADA32E,GAAAx0B,QAAA,SAAA8T,GAAgCq3F,EAAAr3F,EAAA1L,MAAA,SAChC+iG,GAIA,QAAAwvB,IAAA9mB,GAEA,OADA1iG,MACAtM,EAAA,EAAAkY,EAAA82F,EAAA5xG,OAAmC4C,EAAAkY,EAAOlY,IAO1CsM,EAAA0iG,EAAAhvG,GAAAuM,MAAAyiG,EAAAhvG,GAAAjE,KAEA,OAAAuQ,GAIA,QAAAirH,IAAA3kB,GACA,iBAAAA,EAAAtF,KAAA,UAAAsF,EAAAtF,IAGA,QAAAyoB,IAAAnjB,GACA,MACA,UAAAA,EAAAtF,KACA,WAAAsF,EAAAtF,OACAsF,EAAAkT,SAAAt5G,MACA,oBAAAomG,EAAAkT,SAAAt5G,MASA,QAAAqpH,IAAA7mB,GAEA,OADAvI,MACAzmG,EAAA,EAAiBA,EAAAgvG,EAAA5xG,OAAkB4C,IAAA,CACnC,GAAAmK,GAAA6kG,EAAAhvG,EACA+4H,IAAA1lF,KAAAlpC,EAAAoC,QACApC,EAAAoC,KAAApC,EAAAoC,KAAAwvC,QAAAi9E,GAAA,IACAvyB,EAAAtkG,KAAAgI,IAGA,MAAAs8F,GAqCA,QAAAwyB,IAAA19H,EAAAoiG,GACApiG,IACA29H,GAAAC,GAAAx7B,EAAAy7B,YAAA,IACAC,GAAA17B,EAAA0c,eAAAwY,GAEAyG,GAAA/9H,GAEAg+H,GAAAh+H,GAAA,IAGA,QAAAi+H,IAAAhxD,GACA,MAAAo9B,GACA,2DACAp9B,EAAA,IAAAA,EAAA,KAIA,QAAA8wD,IAAAppH,GAEA,GADAA,EAAAupH,OAAA9rB,GAAAz9F,GACA,IAAAA,EAAA1D,KAAA,CAIA,IACA6sH,GAAAnpH,EAAAo9F,MACA,SAAAp9F,EAAAo9F,KACA,MAAAp9F,EAAA41G,SAAA,mBAEA,MAEA,QAAA9lH,GAAA,EAAAkY,EAAAhI,EAAA+2B,SAAA7pC,OAA6C4C,EAAAkY,EAAOlY,IAAA,CACpD,GAAA6nC,GAAA33B,EAAA+2B,SAAAjnC,EACAs5H,IAAAzxF,GACAA,EAAA4xF,SACAvpH,EAAAupH,QAAA,GAGA,GAAAvpH,EAAAioH,aACA,OAAAxB,GAAA,EAAA+C,EAAAxpH,EAAAioH,aAAA/6H,OAAuDu5H,EAAA+C,EAAW/C,IAAA,CAClE,GAAAM,GAAA/mH,EAAAioH,aAAAxB,GAAAM,KACAqC,IAAArC,GACAA,EAAAwC,SACAvpH,EAAAupH,QAAA,KAOA,QAAAF,IAAArpH,EAAAyrG,GACA,OAAAzrG,EAAA1D,KAAA,CAOA,IANA0D,EAAAupH,QAAAvpH,EAAAg3F,QACAh3F,EAAAypH,YAAAhe,GAKAzrG,EAAAupH,QAAAvpH,EAAA+2B,SAAA7pC,SACA,IAAA8S,EAAA+2B,SAAA7pC,QACA,IAAA8S,EAAA+2B,SAAA,GAAAz6B,MAGA,YADA0D,EAAA0pH,YAAA,EAKA,IAFA1pH,EAAA0pH,YAAA,EAEA1pH,EAAA+2B,SACA,OAAAjnC,GAAA,EAAAkY,EAAAhI,EAAA+2B,SAAA7pC,OAA+C4C,EAAAkY,EAAOlY,IACtDu5H,GAAArpH,EAAA+2B,SAAAjnC,GAAA27G,KAAAzrG,EAAAkwF,IAGA,IAAAlwF,EAAAioH,aACA,OAAAxB,GAAA,EAAA+C,EAAAxpH,EAAAioH,aAAA/6H,OAAuDu5H,EAAA+C,EAAW/C,IAClE4C,GAAArpH,EAAAioH,aAAAxB,GAAAM,MAAAtb,IAMA,QAAAhO,IAAAz9F,GACA,WAAAA,EAAA1D,OAGA,IAAA0D,EAAA1D,SAGA0D,EAAA6kH,MACA7kH,EAAAqoH,aACAroH,EAAA2mH,IAAA3mH,EAAAkwF,KACAy5B,GAAA3pH,EAAAo9F,OACA+rB,GAAAnpH,EAAAo9F,MACAwsB,GAAA5pH,KACAxT,OAAA8rE,KAAAt4D,GAAA6S,MAAAm2G,OAIA,QAAAY,IAAA5pH,GACA,KAAAA,EAAAvR,QAAA,CAEA,GADAuR,IAAAvR,OACA,aAAAuR,EAAAo9F,IACA,QAEA,IAAAp9F,EAAAkwF,IACA,SAGA,SAuCA,QAAA25B,IACA1U,EACApd,EACAmd,GAEA,GAAA3e,GAAAwB,EAAA,aAAkC,MAClC,QAAA17F,KAAA84G,GAAA,CAYA5e,GAAA,IAAAl6F,EAAA,KAAAytH,GAAAztH,EAXA84G,EAAA94G,IAWA,IAEA,MAAAk6F,GAAAljG,MAAA,UAGA,QAAAy2H,IACAztH,EACAgrG,GAEA,IAAAA,EACA,oBAGA,IAAA9xG,MAAAxD,QAAAs1G,GACA,UAAAA,EAAAjrG,IAAA,SAAAirG,GAAmD,MAAAyiB,IAAAztH,EAAAgrG,KAAoC/5F,KAAA,QAGvF,IAAAy8G,GAAAC,GAAA7mF,KAAAkkE,EAAAx7G,OACAo+H,EAAAC,GAAA/mF,KAAAkkE,EAAAx7G,MAEA,IAAAw7G,EAAAkL,UAIG,CACH,GAAAnuC,GAAA,GACA+lD,EAAA,GACA7xD,IACA,QAAAl4D,KAAAinG,GAAAkL,UACA6X,GAAAhqH,IACA+pH,GAAAC,GAAAhqH,GAEA4qG,GAAA5qG,IACAk4D,EAAArmE,KAAAmO,IAGAk4D,EAAArmE,KAAAmO,EAGAk4D,GAAAprE,SACAk3E,GAAAimD,GAAA/xD,IAGA6xD,IACA/lD,GAAA+lD,EAOA,2BAA8B/lD,GAL9B2lD,EACA1iB,EAAAx7G,MAAA,WACAo+H,EACA,IAAA5iB,EAAA,kBACAA,EAAAx7G,OAC8B,IA9B9B,MAAAk+H,IAAAE,EACA5iB,EAAAx7G,MACA,oBAA2Bw7G,EAAA,UAgC3B,QAAAgjB,IAAA/xD,GACA,mCAAAA,EAAAl8D,IAAAkuH,IAAAh9G,KAAA,sBAGA,QAAAg9G,IAAAlqH,GACA,GAAAmqH,GAAA3jH,SAAAxG,EAAA,GACA,IAAAmqH,EACA,0BAAAA,CAEA,IAAA7C,GAAA1c,GAAA5qG,EACA,4BAAA2c,KAAAC,UAAA5c,IAAAsnH,EAAA,IAAA3qG,KAAAC,UAAA0qG,GAAA,QAKA,QAAA/oH,IAAA+jG,EAAA+O,GAIA/O,EAAA8nB,cAAA,SAAApmD,GAAsC,YAAAA,EAAA,IAAAqtC,EAAA,WAKtC,QAAAgZ,IAAA/nB,EAAA+O,GACA/O,EAAAgoB,SAAA,SAAAtmD,GACA,YAAAA,EAAA,KAAAs+B,EAAA,SAAA+O,EAAA,WAAAA,EAAAc,WAAAd,EAAAc,UAAAlW,KAAA,iBAAAoV,EAAAc,WAAAd,EAAAc,UAAAjS,KAAA,iBA4BA,QAAAqqB,IACAC,EACAn9B,GAEA,GAAAr4F,GAAA,GAAAy1H,IAAAp9B,EAEA,QACAC,OAAA,sBAFAk9B,EAAAE,GAAAF,EAAAx1H,GAAA,aAEyB,IACzBu4F,gBAAAv4F,EAAAu4F,iBAIA,QAAAm9B,IAAApoB,EAAAttG,GACA,GAAAstG,EAAAgnB,aAAAhnB,EAAAqoB,gBACA,MAAAC,IAAAtoB,EAAAttG,EACG,IAAAstG,EAAA1L,OAAA0L,EAAAuoB,cACH,MAAAC,IAAAxoB,EAAAttG,EACG,IAAAstG,EAAAxS,MAAAwS,EAAAyoB,aACH,MAAAC,IAAA1oB,EAAAttG,EACG,IAAAstG,EAAAikB,KAAAjkB,EAAA2oB,YACH,MAAAC,IAAA5oB,EAAAttG,EACG,iBAAAstG,EAAAtF,KAAAsF,EAAAwkB,WAEA,aAAAxkB,EAAAtF,IACH,MAAAmuB,IAAA7oB,EAAAttG,EAGA,IAAAgvE,EACA,IAAAs+B,EAAAhC,UACAt8B,EAAAonD,GAAA9oB,EAAAhC,UAAAgC,EAAAttG,OACK,CACL,GAAAqE,GAAAipG,EAAA2jB,UAAAxnG,GAAA4sG,GAAA/oB,EAAAttG,GAEA2hC,EAAA2rE,EAAA4G,eAAA,KAAAoiB,GAAAhpB,EAAAttG,GAAA,EACAgvE,GAAA,OAAAs+B,EAAA,SAAAjpG,EAAA,IAAAA,EAAA,KAAAs9B,EAAA,IAAAA,EAAA,QAGA,OAAAjnC,GAAA,EAAmBA,EAAAsF,EAAAiwH,WAAAn4H,OAA6B4C,IAChDs0E,EAAAhvE,EAAAiwH,WAAAv1H,GAAA4yG,EAAAt+B,EAEA,OAAAA,GAlBA,MAAAsnD,IAAAhpB,EAAAttG,IAAA,SAuBA,QAAA41H,IAAAtoB,EAAAttG,GAGA,MAFAstG,GAAAqoB,iBAAA,EACA31H,EAAAu4F,gBAAA17F,KAAA,qBAA0C64H,GAAApoB,EAAAttG,GAAA,KAC1C,OAAAA,EAAAu4F,gBAAAzgG,OAAA,IAAAw1G,EAAA+mB,YAAA,gBAIA,QAAAyB,IAAAxoB,EAAAttG,GAEA,GADAstG,EAAAuoB,eAAA,EACAvoB,EAAAikB,KAAAjkB,EAAA2oB,YACA,MAAAC,IAAA5oB,EAAAttG,EACG,IAAAstG,EAAA+mB,YAAA,CAGH,IAFA,GAAArpH,GAAA,GACA3R,EAAAi0G,EAAAj0G,OACAA,GAAA,CACA,GAAAA,EAAAyhG,IAAA,CACA9vF,EAAA3R,EAAA2R,GACA,OAEA3R,WAEA,MAAA2R,GAMA,MAAA0qH,GAAApoB,EAAAttG,GAAA,IAAAA,EAAAu2H,UAAAvrH,EAAA,IAAAA,EAAA,QAFA0qH,GAAApoB,EAAAttG,GAIA,MAAA41H,IAAAtoB,EAAAttG,GAIA,QAAAk2H,IACA5oB,EACAttG,EACAw2H,EACAC,GAGA,MADAnpB,GAAA2oB,aAAA,EACAS,GAAAppB,EAAAulB,aAAA50H,QAAA+B,EAAAw2H,EAAAC,GAGA,QAAAC,IACAC,EACA32H,EACAw2H,EACAC,GAcA,QAAAG,GAAAtpB,GACA,MAAAkpB,GACAA,EAAAlpB,EAAAttG,GACAstG,EAAA1L,KACAk0B,GAAAxoB,EAAAttG,GACA01H,GAAApoB,EAAAttG,GAjBA,IAAA22H,EAAA7+H,OACA,MAAA2+H,IAAA,MAGA,IAAA7D,GAAA+D,EAAA7vF,OACA,OAAA8rF,GAAAx6G,IACA,IAAAw6G,EAAA,SAAAgE,EAAAhE,EAAAjB,OAAA,IAAA+E,GAAAC,EAAA32H,EAAAw2H,EAAAC,GAEA,GAAAG,EAAAhE,EAAAjB,OAaA,QAAAqE,IACA1oB,EACAttG,EACAw2H,EACAK,GAEA,GAAAz+G,GAAAk1F,EAAAxS,IACAw3B,EAAAhlB,EAAAglB,MACAG,EAAAnlB,EAAAmlB,UAAA,IAAAnlB,EAAA,aACAolB,EAAAplB,EAAAolB,UAAA,IAAAplB,EAAA,YAiBA,OADAA,GAAAyoB,cAAA,GACAc,GAAA,WAAAz+G,EAAA,cACAk6G,EAAAG,EAAAC,EAAA,aACA8D,GAAAd,IAAApoB,EAAAttG,GACA,KAGA,QAAAq2H,IAAA/oB,EAAAttG,GACA,GAAAqE,GAAA,IAIAyhG,EAAAgxB,GAAAxpB,EAAAttG,EACA8lG,KAAazhG,GAAAyhG,EAAA,KAGbwH,EAAAtiG,MACA3G,GAAA,OAAAipG,EAAA,SAGAA,EAAAmO,MACAp3G,GAAA,OAAAipG,EAAA,SAEAA,EAAAqO,WACAt3G,GAAA,kBAGAipG,EAAAmiB,MACAprH,GAAA,aAGAipG,EAAAhC,YACAjnG,GAAA,QAAAipG,EAAA,SAGA,QAAA5yG,GAAA,EAAiBA,EAAAsF,EAAA+2H,WAAAj/H,OAA6B4C,IAC9C2J,GAAArE,EAAA+2H,WAAAr8H,GAAA4yG,EA8BA,IA3BAA,EAAA5D,QACArlG,GAAA,UAAoB2yH,GAAA1pB,EAAA5D,OAAA,MAGpB4D,EAAA9H,QACAnhG,GAAA,aAAuB2yH,GAAA1pB,EAAA9H,OAAA,MAGvB8H,EAAAyS,SACA17G,GAAAowH,GAAAnnB,EAAAyS,QAAA,EAAA//G,EAAA8/G,MAAA,KAEAxS,EAAA2S,eACA57G,GAAAowH,GAAAnnB,EAAA2S,cAAA,EAAAjgH,EAAA8/G,MAAA,KAGAxS,EAAAwkB,aACAztH,GAAA,QAAAipG,EAAA,gBAGAA,EAAAa,cACA9pG,GAAA4yH,GAAA3pB,EAAAa,YAAAnuG,GAAA,KAGAstG,EAAAgG,QACAjvG,GAAA,gBAAoBipG,EAAAgG,MAAA,mBAAAhG,EAAAgG,MAAA,wBAAAhG,EAAAgG,MAAA,iBAGpBhG,EAAA4G,eAAA,CACA,GAAAA,GAAAgjB,GAAA5pB,EAAAttG,EACAk0G,KACA7vG,GAAA6vG,EAAA,KAYA,MATA7vG,KAAAoyC,QAAA,aAEA62D,EAAAgoB,WACAjxH,EAAAipG,EAAAgoB,SAAAjxH,IAGAipG,EAAA8nB,gBACA/wH,EAAAipG,EAAA8nB,cAAA/wH,IAEAA,EAGA,QAAAyyH,IAAAxpB,EAAAttG,GACA,GAAA8lG,GAAAwH,EAAAvH,UACA,IAAAD,EAAA,CACA,GAEAprG,GAAAkY,EAAAypG,EAAA8a,EAFAh2B,EAAA,eACAi2B,GAAA,CAEA,KAAA18H,EAAA,EAAAkY,EAAAkzF,EAAAhuG,OAA8B4C,EAAAkY,EAAOlY,IAAA,CACrC2hH,EAAAvW,EAAAprG,GACAy8H,GAAA,CACA,IAAAE,GAAAr3H,EAAA+lG,WAAAsW,EAAAp1G,KACAowH,KAGAF,IAAAE,EAAA/pB,EAAA+O,EAAAr8G,EAAA8/G,OAEAqX,IACAC,GAAA,EACAj2B,GAAA,UAAekb,EAAA,mBAAAA,EAAA,aAAAA,EAAA5lH,MAAA,WAAA4lH,EAAA,sBAAA10F,KAAAC,UAAAy0F,EAAA5lH,OAAA,KAAA4lH,EAAAh8G,IAAA,SAAAg8G,EAAA,aAAAA,EAAAc,UAAA,cAAAx1F,KAAAC,UAAAy0F,EAAAc,WAAA,UAGf,MAAAia,GACAj2B,EAAAljG,MAAA,cADA,IAKA,QAAAi5H,IAAA5pB,EAAAttG,GACA,GAAAw1H,GAAAloB,EAAA3rE,SAAA,EAMA,QAAA6zF,EAAAtuH,KAAA,CACA,GAAAowH,GAAA/B,GAAAC,EAAAx1H,EAAAq4F,QACA,4CAA+Ci/B,EAAA,6BAAiCA,EAAA/+B,gBAAAvxF,IAAA,SAAAgoE,GAA4E,oBAAqBA,EAAA,MAAkB92D,KAAA,WAInM,QAAA++G,IACA9qB,EACAnsG,GAEA,yBAAA5I,OAAA8rE,KAAAipC,GAAAnlG,IAAA,SAAAgE,GACA,MAAAusH,IAAAvsH,EAAAmhG,EAAAnhG,GAAAhL,KACKkY,KAAA,UAGL,QAAAq/G,IACAvsH,EACAsiG,EACAttG,GAEA,MAAAstG,GAAAxS,MAAAwS,EAAAyoB,aACAyB,GAAAxsH,EAAAsiG,EAAAttG,GAEA,QAAWgL,EAAA,gBAAAo1F,OAAAkN,EAAAkT,SAAAiX,OAAA,aACX,aAAAnqB,EAAAtF,IACAsuB,GAAAhpB,EAAAttG,IAAA,SACA01H,GAAApoB,EAAAttG,IAAA,KAGA,QAAAw3H,IACAxsH,EACAsiG,EACAttG,GAEA,GAAAoY,GAAAk1F,EAAAxS,IACAw3B,EAAAhlB,EAAAglB,MACAG,EAAAnlB,EAAAmlB,UAAA,IAAAnlB,EAAA,aACAolB,EAAAplB,EAAAolB,UAAA,IAAAplB,EAAA,YAEA,OADAA,GAAAyoB,cAAA,EACA,OAAA39G,EAAA,cACAk6G,EAAAG,EAAAC,EAAA,YACA6E,GAAAvsH,EAAAsiG,EAAAttG,GACA,KAGA,QAAAs2H,IACAhpB,EACAttG,EACA03H,EACAC,EACAC,GAEA,GAAAj2F,GAAA2rE,EAAA3rE,QACA,IAAAA,EAAA7pC,OAAA,CACA,GAAA+/H,GAAAl2F,EAAA,EAEA,QAAAA,EAAA7pC,QACA+/H,EAAA/8B,KACA,aAAA+8B,EAAA7vB,KACA,SAAA6vB,EAAA7vB,IAEA,OAAA2vB,GAAAjC,IAAAmC,EAAA73H,EAEA,IAAAw0G,GAAAkjB,EACAI,GAAAn2F,EAAA3hC,EAAA+3H,gBACA,EACAV,EAAAO,GAAAI,EACA,WAAAr2F,EAAA36B,IAAA,SAAAI,GAA8C,MAAAiwH,GAAAjwH,EAAApH,KAAwBkY,KAAA,UAAAs8F,EAAA,IAAAA,EAAA,KAQtE,QAAAsjB,IACAn2F,EACAo2F,GAGA,OADA52B,GAAA,EACAzmG,EAAA,EAAiBA,EAAAinC,EAAA7pC,OAAqB4C,IAAA,CACtC,GAAA4yG,GAAA3rE,EAAAjnC,EACA,QAAA4yG,EAAApmG,KAAA,CAGA,GAAA+wH,GAAA3qB,IACAA,EAAAulB,cAAAvlB,EAAAulB,aAAAqF,KAAA,SAAA9wH,GAA+D,MAAA6wH,IAAA7wH,EAAAuqH,SAAsC,CACrGxwB,EAAA,CACA,QAEA42B,EAAAzqB,IACAA,EAAAulB,cAAAvlB,EAAAulB,aAAAqF,KAAA,SAAA9wH,GAA+D,MAAA2wH,GAAA3wH,EAAAuqH,YAC/DxwB,EAAA,IAGA,MAAAA,GAGA,QAAA82B,IAAA3qB,GACA,WAAA7jF,KAAA6jF,EAAAxS,KAAA,aAAAwS,EAAAtF,KAAA,SAAAsF,EAAAtF,IAGA,QAAAgwB,IAAAptH,EAAA5K,GACA,WAAA4K,EAAA1D,KACAwuH,GAAA9qH,EAAA5K,GACG,IAAA4K,EAAA1D,MAAA0D,EAAA09F,UACH6vB,GAAAvtH,GAEAwtH,GAAAxtH,GAIA,QAAAwtH,IAAApzH,GACA,iBAAAA,EAAAkC,KACAlC,EAAA65G,WACAwZ,GAAA1wG,KAAAC,UAAA5iB,UAAA,IAGA,QAAAmzH,IAAA9J,GACA,YAAA1mG,KAAAC,UAAAymG,EAAArpH,MAAA,IAGA,QAAAmxH,IAAA7oB,EAAAttG,GACA,GAAA8yH,GAAAxlB,EAAAwlB,UAAA,YACAnxF,EAAA20F,GAAAhpB,EAAAttG,GACAmhG,EAAA,MAAA2xB,GAAAnxF,EAAA,IAAAA,EAAA,IACA+nE,EAAA4D,EAAA5D,OAAA,IAA6B4D,EAAA5D,MAAA1iG,IAAA,SAAA7F,GAAgC,MAAAskG,IAAAtkG,EAAA8F,MAAA,IAAA9F,EAAA,QAAiD+W,KAAA,SAC9GogH,EAAAhrB,EAAAkT,SAAA,SAUA,QATA9W,IAAA4uB,GAAA32F,IACAw/D,GAAA,SAEAuI,IACAvI,GAAA,IAAAuI,GAEA4uB,IACAn3B,IAAAuI,EAAA,gBAAA4uB,GAEAn3B,EAAA,IAIA,QAAAi1B,IACAmC,EACAjrB,EACAttG,GAEA,GAAA2hC,GAAA2rE,EAAA4G,eAAA,KAAAoiB,GAAAhpB,EAAAttG,GAAA,EACA,aAAAu4H,EAAA,IAAAlC,GAAA/oB,EAAAttG,IAAA2hC,EAAA,IAAAA,EAAA,QAGA,QAAAq1F,IAAAxxB,GAEA,OADArE,GAAA,GACAzmG,EAAA,EAAiBA,EAAA8qG,EAAA1tG,OAAkB4C,IAAA,CACnC,GAAAusG,GAAAzB,EAAA9qG,EACAymG,IAAA,IAAA8F,EAAA,UAAAoxB,GAAApxB,EAAAxwG,OAAA,IAEA,MAAA0qG,GAAAljG,MAAA,MAIA,QAAAo6H,IAAArzH,GACA,MAAAA,GACAyxC,QAAA,qBACAA,QAAA,qBAsGA,QAAA+hF,IAAAxpD,EAAAtzE,GACA,IACA,UAAAgsB,UAAAsnD,GACG,MAAAp5E,GAEH,MADA8F,GAAAmB,MAAiBjH,MAAAo5E,SACjBznE,GAIA,QAAAkxH,IAAAC,GACA,GAAAj6F,GAAArnC,OAAAR,OAAA,KAEA,iBACA24H,EACAl3B,EACAiK,GAEAjK,OAqBA,IAAArtF,GAAAqtF,EAAAyzB,WACA1rB,OAAA/H,EAAAyzB,YAAAyD,EACAA,CACA,IAAA9wF,EAAAzzB,GACA,MAAAyzB,GAAAzzB,EAIA,IAAA2tH,GAAAD,EAAAnJ,EAAAl3B,GAiBA8I,KACAy3B,IAyBA,OAxBAz3B,GAAA7I,OAAAkgC,GAAAG,EAAArgC,OAAAsgC,GACAz3B,EAAA5I,gBAAAogC,EAAApgC,gBAAAvxF,IAAA,SAAAgoE,GACA,MAAAwpD,IAAAxpD,EAAA4pD,KAsBAn6F,EAAAzzB,GAAAm2F,GA+JA,QAAA03B,IAAAvrB,GACA,GAAAA,EAAAwrB,UACA,MAAAxrB,GAAAwrB,SAEA,IAAAvoE,GAAA9oD,SAAAM,cAAA,MAEA,OADAwoD,GAAAhiD,YAAA++F,EAAAyrB,WAAA,IACAxoE,EAAAriD,UAjzTA,GAAA+xF,IAAA7oG,OAAAxC,UAAA4T,SA+DA+rH,GAAAj0B,EAAA,qBAKA0V,GAAA1V,EAAA,mBAiBAnpG,GAAAC,OAAAxC,UAAAuC,eAmBA6hI,GAAA,SACAvzB,GAAA9E,EAAA,SAAAJ,GACA,MAAAA,GAAA9pD,QAAAuiF,GAAA,SAAA/yH,EAAAmB,GAAkD,MAAAA,KAAAgjE,cAAA,OAMlDy8B,GAAAlG,EAAA,SAAAJ,GACA,MAAAA,GAAAvwD,OAAA,GAAAo6B,cAAAm2B,EAAAtiG,MAAA,KAMAg7H,GAAA,iBACA5xB,GAAA1G,EAAA,SAAAJ,GACA,MAAAA,GACA9pD,QAAAwiF,GAAA,SACAxiF,QAAAwiF,GAAA,SACA5nH,gBAkEAk8G,GAAA,SAAApsH,EAAApK,EAAAqQ,GAA6B,UAK7BkiD,GAAA,SAAArjD,GAA6B,MAAAA,IAoE7BizH,GAAA,uBAEAhgB,IACA,YACA,YACA,UAGAigB,IACA,eACA,UACA,cACA,UACA,eACA,UACA,gBACA,YACA,YACA,eAKAhjI,IAIAijI,sBAAAhiI,OAAAR,OAAA,MAKAyiI,QAAA,EAKAC,eAAA,EAKAxpB,UAAA,EAKA3yC,aAAA,EAKAqlC,aAAA,KAKA+2B,YAAA,KAKAC,mBAKA5jB,SAAAx+G,OAAAR,OAAA,MAMAm+G,cAAAwY,GAMAkM,eAAAlM,GAMA/S,iBAAA+S,GAKAzY,gBAAAvtG,EAKAytG,qBAAA1rD,GAMA2sD,YAAAsX,GAKAmM,gBAAAP,IAKA9qB,GAAAj3G,OAAAuiI,WAyBAv3B,GAAA,UAiBA0d,GAAAv4G,EAmHAqyH,GAAA,gBAGAn3B,GAAA,mBAAAnkG,QACAu7H,GAAAp3B,IAAAnkG,OAAAw7H,UAAAC,UAAA1oH,cACAqxG,GAAAmX,IAAA,eAAA9rF,KAAA8rF,IACAlc,GAAAkc,OAAAz8H,QAAA,cACA48H,GAAAH,OAAAz8H,QAAA,WACA68H,GAAAJ,OAAAz8H,QAAA,aACA88H,GAAAL,IAAA,uBAAA9rF,KAAA8rF,IACAlX,GAAAkX,IAAA,cAAA9rF,KAAA8rF,MAAAG,GAGA5oB,MAAqBD,MAErB6R,IAAA,CACA,IAAAvgB,GACA,IACA,GAAAoO,MACAz5G,QAAAi+F,eAAAwb,GAAA,WACA1pG,IAAA,WAEA67G,IAAA,KAGA1kH,OAAA2L,iBAAA,oBAAA4mG,IACG,MAAAn0G,IAKH,GAAAy9H,IAiHAC,GAhHAx2B,GAAA,WAWA,WAVAn6E,KAAA0wG,KAOAA,IALA13B,QAAA,KAAArkG,GAGA,WAAAA,EAAA,QAAAi8H,IAAAC,SAKAH,IAIArqB,GAAArN,IAAAnkG,OAAAi8H,6BAOA7nB,GACA,mBAAApb,SAAAqL,EAAArL,SACA,mBAAAqb,UAAAhQ,EAAAgQ,QAAAC,SAKA3C,GAAA,WAKA,QAAAuqB,KACAjkC,GAAA,CACA,IAAAkkC,GAAAC,EAAAz8H,MAAA,EACAy8H,GAAA5iI,OAAA,CACA,QAAA4C,GAAA,EAAmBA,EAAA+/H,EAAA3iI,OAAmB4C,IACtC+/H,EAAA//H,KATA,GAEAigI,GAFAD,KACAnkC,GAAA,CAmBA,uBAAAngG,UAAAusG,EAAAvsG,SAAA,CACA,GAAAc,GAAAd,QAAAE,UACAskI,EAAA,SAAAhlI,GAAmC8sG,QAAAxtG,MAAAU,GACnC+kI,GAAA,WACAzjI,EAAA4D,KAAA0/H,GAAAK,MAAAD,GAMAV,IAAkBn/H,WAAAwM,QAEf,uBAAAuzH,oBACHn4B,EAAAm4B,mBAEA,yCAAAA,iBAAAtyH,WAiBAmyH,EAAA,WACA5/H,WAAAy/H,EAAA,QAjBA,CAGA,GAAAO,GAAA,EACArlC,EAAA,GAAAolC,kBAAAN,GACAQ,EAAAvzH,SAAAyzG,eAAA9a,OAAA26B,GACArlC,GAAAD,QAAAulC,GACAC,eAAA,IAEAN,EAAA,WACAI,KAAA,KACAC,EAAA32H,KAAA+7F,OAAA26B,IAUA,gBAAArmG,EAAAksE,GACA,GAAAs6B,EAgBA,IAfAR,EAAA79H,KAAA,WACA,GAAA63B,EACA,IACAA,EAAAp/B,KAAAsrG,GACS,MAAAlkG,GACT2lG,EAAA3lG,EAAAkkG,EAAA,gBAEOs6B,IACPA,EAAAt6B,KAGArK,IACAA,GAAA,EACAokC,MAEAjmG,GAAA,mBAAAt+B,SACA,UAAAA,SAAA,SAAAE,EAAAC,GACA2kI,EAAA5kI,OAUA8jI,IAFA,mBAAA9yG,MAAAq7E,EAAAr7E,KAEAA,IAGA,WACA,QAAAA,KACA7yB,KAAA4S,IAAAjQ,OAAAR,OAAA,MAYA,MAVA0wB,GAAA1yB,UAAAw1C,IAAA,SAAAp/B,GACA,WAAAvW,KAAA4S,IAAA2D,IAEAsc,EAAA1yB,UAAAW,IAAA,SAAAyV,GACAvW,KAAA4S,IAAA2D,IAAA,GAEAsc,EAAA1yB,UAAAquE,MAAA,WACAxuE,KAAA4S,IAAAjQ,OAAAR,OAAA,OAGA0wB,IAOA,IAAA6zG,IAAA,EAMAp4B,GAAA,WACAtuG,KAAA8b,GAAA4qH,KACA1mI,KAAA2mI,QAGAr4B,IAAAnuG,UAAAymI,OAAA,SAAAz+H,GACAnI,KAAA2mI,KAAAv+H,KAAAD,IAGAmmG,GAAAnuG,UAAA0mI,UAAA,SAAA1+H,GACAN,EAAA7H,KAAA2mI,KAAAx+H,IAGAmmG,GAAAnuG,UAAA4vG,OAAA,WACAzB,GAAAzyF,QACAyyF,GAAAzyF,OAAAirH,OAAA9mI,OAIAsuG,GAAAnuG,UAAA+vG,OAAA,WAGA,OADAy2B,GAAA3mI,KAAA2mI,KAAAn9H,QACAvD,EAAA,EAAAkY,EAAAwoH,EAAAtjI,OAAkC4C,EAAAkY,EAAOlY,IACzC0gI,EAAA1gI,GAAAiQ,UAOAo4F,GAAAzyF,OAAA,IACA,IAAA0yF,OAgBAw4B,GAAAr7H,MAAAvL,UACA6mI,GAAArkI,OAAAR,OAAA4kI,KACA,OACA,MACA,QACA,UACA,SACA,OACA,WAEA3lI,QAAA,SAAAojF,GAEA,GAAAyiD,GAAAF,GAAAviD,EACA8oB,GAAA05B,GAAAxiD,EAAA,WAEA,IADA,GAAA7uE,MAAAzP,EAAA9C,UAAAC,OACA6C,KAAAyP,EAAAzP,GAAA9C,UAAA8C,EAEA,IAEAsiH,GAFA7iH,EAAAshI,EAAAjiI,MAAAhF,KAAA2V,GACAm5F,EAAA9uG,KAAA+uG,MAEA,QAAAvqB,GACA,WACA,cACAgkC,EAAA7yG,CACA,MACA,cACA6yG,EAAA7yG,EAAAnM,MAAA,GAMA,MAHAg/G,IAAmB1Z,EAAAo4B,aAAA1e,GAEnB1Z,EAAAY,IAAAQ,SACAvqG,KAMA,IAAAwhI,IAAAxkI,OAAAqgG,oBAAAgkC,IAQA/3B,IACAC,eAAA,GASAF,GAAA,SAAAhtG,GAKA,GAJAhC,KAAAgC,QACAhC,KAAA0vG,IAAA,GAAApB,IACAtuG,KAAAsvG,QAAA,EACAhC,EAAAtrG,EAAA,SAAAhC,MACA0L,MAAAxD,QAAAlG,GAAA,EACAmjI,GACA12B,EACAG,GACA5sG,EAAAglI,GAAAG,IACAnnI,KAAAknI,aAAAllI,OAEAhC,MAAAonI,KAAAplI,GASAgtG,IAAA7uG,UAAAinI,KAAA,SAAA97B,GAEA,OADA78B,GAAA9rE,OAAA8rE,KAAA68B,GACArlG,EAAA,EAAiBA,EAAAwoE,EAAAprE,OAAiB4C,IAClCspG,EAAAjE,EAAA78B,EAAAxoE,GAAAqlG,EAAA78B,EAAAxoE,MAOA+oG,GAAA7uG,UAAA+mI,aAAA,SAAAG,GACA,OAAAphI,GAAA,EAAAkY,EAAAkpH,EAAAhkI,OAAmC4C,EAAAkY,EAAOlY,IAC1C+6F,EAAAqmC,EAAAphI,IAiMA,IAAAyrG,IAAAhwG,GAAAijI,qBAkFAjzB,IAAA9hG,KAAA,SACA4gG,EACAC,EACA5C,GAEA,MAAAA,GAcA0C,EAAAC,EAAAC,EAAA5C,GAbA4C,GAAA,kBAAAA,GAQAD,EAEAD,EAAA1vG,KAAAb,KAAAwwG,EAAAC,IAsBAi0B,GAAAtjI,QAAA,SAAA4iG,GACA0N,GAAA1N,GAAA4M,IAiBA6T,GAAArjH,QAAA,SAAAqR,GACAi/F,GAAAj/F,EAAA,KAAAo+F,IASAa,GAAAgL,MAAA,SAAAlM,EAAAC,GAKA,GAHAD,IAAAmM,KAAkCnM,MAAAx7E,IAClCy7E,IAAAkM,KAAiClM,MAAAz7E,KAEjCy7E,EAAkB,MAAA9tG,QAAAR,OAAAquG,GAAA,KAClB,KAAAA,EAAmB,MAAAC,EACnB,IAAAlE,KACA/vF,GAAA+vF,EAAAiE,EACA,QAAAj6F,KAAAk6F,GAAA,CACA,GAAA7rG,GAAA2nG,EAAAh2F,GACAu3B,EAAA2iE,EAAAl6F,EACA3R,KAAA8G,MAAAxD,QAAAtD,KACAA,OAEA2nG,EAAAh2F,GAAA3R,EACAA,EAAAwC,OAAA0mC,GACApiC,MAAAxD,QAAA4lC,SAEA,MAAAy+D,IAMAmF,GAAAX,MACAW,GAAAhqE,QACAgqE,GAAAR,OACAQ,GAAA8K,SAAA,SAAAhM,EAAAC,GACA,IAAAD,EAAmB,MAAAC,EACnB,IAAAlE,GAAA5pG,OAAAR,OAAA,KAGA,OAFAqa,GAAA+vF,EAAAiE,GACAC,GAAiBj0F,EAAA+vF,EAAAkE,GACjBlE,GAEAmF,GAAAmM,QAAAtN,CAKA,IAAAoB,IAAA,SAAAnB,EAAAC,GACA,WAAAz7E,KAAAy7E,EACAD,EACAC,GAsaA0C,GAAA,SACAI,EACA3jG,EACAs9B,EACA38B,EACAijG,EACApvG,EACAqvG,EACAC,GAEA1zG,KAAAuzG,MACAvzG,KAAA4P,OACA5P,KAAAktC,WACAltC,KAAAuQ,OACAvQ,KAAAwzG,MACAxzG,KAAA2zG,OAAA3+E,GACAh1B,KAAAoE,UACApE,KAAA43G,sBAAA5iF,GACAh1B,KAAAuW,IAAA3G,KAAA2G,IACAvW,KAAAyzG,mBACAzzG,KAAAilH,sBAAAjwF,GACAh1B,KAAA4E,WAAAowB,GACAh1B,KAAAsnI,KAAA,EACAtnI,KAAA4zG,UAAA,EACA5zG,KAAA4zH,cAAA,EACA5zH,KAAA6zG,WAAA,EACA7zG,KAAA8zG,UAAA,EACA9zG,KAAAiiH,QAAA,EACAjiH,KAAA0zG,eACA1zG,KAAAi2G,cAAAjhF,GACAh1B,KAAAqnH,oBAAA,GAGAkgB,IAA0Bz5F,SAI1By5F,IAAAz5F,MAAAp7B,IAAA,WACA,MAAA1S,MAAAilH,mBAGAtiH,OAAA6kI,iBAAAr0B,GAAAhzG,UAAAonI,GAEA,IA+bA1rH,IA/bAm6F,GAAA,SAAAzlG,OACA,KAAAA,MAAA,GAEA,IAAA4F,GAAA,GAAAg9F,GAGA,OAFAh9F,GAAA5F,OACA4F,EAAA09F,WAAA,EACA19F,GAyCAu+F,GAAAxI,EAAA,SAAA15F,GACA,GAAAmiG,GAAA,MAAAniG,EAAA+oC,OAAA,EACA/oC,GAAAmiG,EAAAniG,EAAAhJ,MAAA,GAAAgJ,CACA,IAAA2kG,GAAA,MAAA3kG,EAAA+oC,OAAA,EACA/oC,GAAA2kG,EAAA3kG,EAAAhJ,MAAA,GAAAgJ,CACA,IAAA4C,GAAA,MAAA5C,EAAA+oC,OAAA,EAEA,OADA/oC,GAAA4C,EAAA5C,EAAAhJ,MAAA,GAAAgJ,GAEAA,OACA26F,KAAAgK,EACA/hG,UACAu/F,aA4jBA8e,GAAA,KAuTA5+E,MACA8lE,MACAhlE,MAEAilE,IAAA,EACAC,IAAA,EACAjzG,GAAA,EAmIA6/H,GAAA,EAOAruB,GAAA,SACAvL,EACA65B,EACAznG,EACA2jE,GAEA5jG,KAAA6tG,KACAA,EAAAsO,UAAA/zG,KAAApI,MAEA4jG,GACA5jG,KAAA2nI,OAAA/jC,EAAA+jC,KACA3nI,KAAA4jF,OAAAggB,EAAAhgB,KACA5jF,KAAA6tH,OAAAjqB,EAAAiqB,KACA7tH,KAAAy2G,OAAA7S,EAAA6S,MAEAz2G,KAAA2nI,KAAA3nI,KAAA4jF,KAAA5jF,KAAA6tH,KAAA7tH,KAAAy2G,MAAA,EAEAz2G,KAAAigC,KACAjgC,KAAA8b,KAAA2rH,GACAznI,KAAA+b,QAAA,EACA/b,KAAAs9G,MAAAt9G,KAAA6tH,KACA7tH,KAAA4nI,QACA5nI,KAAA6nI,WACA7nI,KAAA8nI,OAAA,GAAAnC,IACA3lI,KAAA+nI,UAAA,GAAApC,IACA3lI,KAAAoqH,WAEA,GAEA,kBAAAsd,GACA1nI,KAAA4vG,OAAA83B,GAEA1nI,KAAA4vG,OAAAlC,EAAAg6B,GACA1nI,KAAA4vG,SACA5vG,KAAA4vG,OAAA,eASA5vG,KAAAgC,MAAAhC,KAAA6tH,SACA74F,GACAh1B,KAAA0S,MAMA0mG,IAAAj5G,UAAAuS,IAAA,WACA07F,EAAApuG,KACA,IAAAgC,GACA6rG,EAAA7tG,KAAA6tG,EACA,KACA7rG,EAAAhC,KAAA4vG,OAAA/uG,KAAAgtG,KACG,MAAA5lG,GACH,IAAAjI,KAAA4jF,KAGA,KAAA37E,EAFA2lG,GAAA3lG,EAAA4lG,EAAA,uBAAA7tG,KAAA,gBAIG,QAGHA,KAAA2nI,MACAlsB,GAAAz5G,GAEAwsG,IACAxuG,KAAAgoI,cAEA,MAAAhmI,IAMAo3G,GAAAj5G,UAAA2mI,OAAA,SAAAp3B,GACA,GAAA5zF,GAAA4zF,EAAA5zF,EACA9b,MAAA+nI,UAAApyF,IAAA75B,KACA9b,KAAA+nI,UAAAjnI,IAAAgb,GACA9b,KAAA6nI,QAAAz/H,KAAAsnG,GACA1vG,KAAA8nI,OAAAnyF,IAAA75B,IACA4zF,EAAAk3B,OAAA5mI,QAQAo5G,GAAAj5G,UAAA6nI,YAAA,WAIA,IAHA,GAAAC,GAAAjoI,KAEAiG,EAAAjG,KAAA4nI,KAAAvkI,OACA4C,KAAA,CACA,GAAAypG,GAAAu4B,EAAAL,KAAA3hI,EACAgiI,GAAAF,UAAApyF,IAAA+5D,EAAA5zF,KACA4zF,EAAAm3B,UAAAoB,GAGA,GAAAz/H,GAAAxI,KAAA8nI,MACA9nI,MAAA8nI,OAAA9nI,KAAA+nI,UACA/nI,KAAA+nI,UAAAv/H,EACAxI,KAAA+nI,UAAAv5D,QACAhmE,EAAAxI,KAAA4nI,KACA5nI,KAAA4nI,KAAA5nI,KAAA6nI,QACA7nI,KAAA6nI,QAAAr/H,EACAxI,KAAA6nI,QAAAxkI,OAAA,GAOA+1G,GAAAj5G,UAAA+V,OAAA,WAEAlW,KAAA6tH,KACA7tH,KAAAs9G,OAAA,EACGt9G,KAAAy2G,KACHz2G,KAAAg7G,MAEAO,GAAAv7G,OAQAo5G,GAAAj5G,UAAA66G,IAAA,WACA,GAAAh7G,KAAA+b,OAAA,CACA,GAAA/Z,GAAAhC,KAAA0S,KACA,IACA1Q,IAAAhC,KAAAgC,OAIA8E,EAAA9E,IACAhC,KAAA2nI,KACA,CAEA,GAAAtf,GAAAroH,KAAAgC,KAEA,IADAhC,KAAAgC,QACAhC,KAAA4jF,KACA,IACA5jF,KAAAigC,GAAAp/B,KAAAb,KAAA6tG,GAAA7rG,EAAAqmH,GACS,MAAApgH,GACT2lG,EAAA3lG,EAAAjI,KAAA6tG,GAAA,yBAAA7tG,KAAA,oBAGAA,MAAAigC,GAAAp/B,KAAAb,KAAA6tG,GAAA7rG,EAAAqmH,MAUAjP,GAAAj5G,UAAAo9G,SAAA,WACAv9G,KAAAgC,MAAAhC,KAAA0S,MACA1S,KAAAs9G,OAAA,GAMAlE,GAAAj5G,UAAA4vG,OAAA,WAIA,IAHA,GAAAk4B,GAAAjoI,KAEAiG,EAAAjG,KAAA4nI,KAAAvkI,OACA4C,KACAgiI,EAAAL,KAAA3hI,GAAA8pG,UAOAqJ,GAAAj5G,UAAAkI,SAAA,WACA,GAAA4/H,GAAAjoI,IAEA,IAAAA,KAAA+b,OAAA,CAIA/b,KAAA6tG,GAAA8K,mBACA9wG,EAAA7H,KAAA6tG,GAAAsO,UAAAn8G,KAGA,KADA,GAAAiG,GAAAjG,KAAA4nI,KAAAvkI,OACA4C,KACAgiI,EAAAL,KAAA3hI,GAAA4gI,UAAAoB,EAEAjoI,MAAA+b,QAAA,GASA,IAAA2/F,IAAA,GAAAiqB,IA+BA1pB,IACA1O,YAAA,EACAE,cAAA,EACA/6F,IAAAI,EACAF,IAAAE,GAwIAqqG,IAA8B0Q,MAAA,GA8R9BhO,IACA15F,KAAA,SACAktF,EACAyF,EACAoG,EACAC,GAEA,IAAA9L,EAAA4R,mBAAA5R,EAAA4R,kBAAAvM,aAAA,EACArF,EAAA4R,kBAAAhG,GACA5L,EACAogB,GACAvU,EACAC,IAEA+oB,OAAApvB,EAAAzF,EAAAG,QAAAx+E,GAAA8jF,OACK,IAAAzF,EAAAzjG,KAAAu4H,UAAA,CAEL,GAAAC,GAAA/0B,CACAwM,IAAAwoB,SAAAD,OAIAC,SAAA,SAAA3gB,EAAArU,GACA,GAAAzP,GAAAyP,EAAAI,gBAEA4F,IADAhG,EAAA4R,kBAAAyC,EAAAzC,kBAGArhB,EAAA2O,UACA3O,EAAA7yE,UACAsiF,EACAzP,EAAA12D,WAIAz8B,OAAA,SAAA4iG,GACA,GAAAjvG,GAAAivG,EAAAjvG,QACA6gH,EAAA5R,EAAA4R,iBACAA,GAAAxM,aACAwM,EAAAxM,YAAA,EACAO,GAAAiM,EAAA,YAEA5R,EAAAzjG,KAAAu4H,YACA/jI,EAAAq0G,WAMA6C,GAAA2J,GAEA5K,GAAA4K,GAAA,KAKAqjB,QAAA,SAAAj1B,GACA,GAAA4R,GAAA5R,EAAA4R,iBACAA,GAAAvM,eACArF,EAAAzjG,KAAAu4H,UAGA5tB,GAAA0K,GAAA,GAFAA,EAAAC,cAQAxF,GAAA/8G,OAAA8rE,KAAAoxC,IAiKAO,GAAA,EACAH,GAAA,EAgdAsoB,GAAA,GAEA,SAAA9kB,GACAA,EAAAtjH,UAAAojH,MAAA,SAAA3f,GACA,GAAAiK,GAAA7tG,IAEA6tG,GAAA26B,KAAAD,KAWA16B,EAAAwB,QAAA,EAEAzL,KAAAyb,aAIAoD,GAAA5U,EAAAjK,GAEAiK,EAAAkF,SAAAxB,EACAqN,GAAA/Q,EAAArrG,aACAohG,MACAiK,GAOAA,EAAAiU,aAAAjU,EAGAA,EAAA46B,MAAA56B,EACAmK,GAAAnK,GACAkJ,GAAAlJ,GACAuU,GAAAvU,GACAmL,GAAAnL,EAAA,gBACAkQ,GAAAlQ,GACAqO,GAAArO,GACA+P,GAAA/P,GACAmL,GAAAnL,EAAA,WASAA,EAAAkF,SAAA8F,IACAhL,EAAAq6B,OAAAr6B,EAAAkF,SAAA8F,MAwFAyK,IAp+BA,SAAAG,GAIA,GAAAilB,KACAA,GAAAh2H,IAAA,WAA6B,MAAA1S,MAAAm0C,MAC7B,IAAAw0F,KACAA,GAAAj2H,IAAA,WAA8B,MAAA1S,MAAAgzG,QAa9BrwG,OAAAi+F,eAAA6iB,EAAAtjH,UAAA,QAAAuoI,GACA/lI,OAAAi+F,eAAA6iB,EAAAtjH,UAAA,SAAAwoI,GAEAllB,EAAAtjH,UAAAyoI,KAAAh2H,EACA6wG,EAAAtjH,UAAA0oI,QAAA14B,EAEAsT,EAAAtjH,UAAAw9G,OAAA,SACA+pB,EACAznG,EACA2jE,GAEA,GAAAiK,GAAA7tG,IACA,IAAAurG,EAAAtrE,GACA,MAAAw9E,IAAA5P,EAAA65B,EAAAznG,EAAA2jE,EAEAA,SACAA,EAAAhgB,MAAA,CACA,IAAAm3B,GAAA,GAAA3B,IAAAvL,EAAA65B,EAAAznG,EAAA2jE,EAIA,OAHAA,GAAAklC,WACA7oG,EAAAp/B,KAAAgtG,EAAAkN,EAAA/4G,OAEA,WACA+4G,EAAA1yG,cA27BAi7G,IAnkEA,SAAAG,GACA,GAAAslB,GAAA,QACAtlB,GAAAtjH,UAAAk3G,IAAA,SAAAjjG,EAAAzP,GACA,GAAAsjI,GAAAjoI,KAEA6tG,EAAA7tG,IACA,IAAA0L,MAAAxD,QAAAkM,GACA,OAAAnO,GAAA,EAAAkY,EAAA/J,EAAA/Q,OAAuC4C,EAAAkY,EAAOlY,IAC9CgiI,EAAA5wB,IAAAjjG,EAAAnO,GAAAtB,QAGAkpG,EAAAzI,QAAAhxF,KAAAy5F,EAAAzI,QAAAhxF,QAAAhM,KAAAzD,GAGAokI,EAAAzvF,KAAAllC,KACAy5F,EAAAmJ,eAAA,EAGA,OAAAnJ,IAGA4V,EAAAtjH,UAAAi3G,MAAA,SAAAhjG,EAAAzP,GAEA,QAAAmQ,KACA+4F,EAAA0J,KAAAnjG,EAAAU,GACAnQ,EAAAK,MAAA6oG,EAAAzqG,WAHA,GAAAyqG,GAAA7tG,IAOA,OAFA8U,GAAAnQ,KACAkpG,EAAAwJ,IAAAjjG,EAAAU,GACA+4F,GAGA4V,EAAAtjH,UAAAo3G,KAAA,SAAAnjG,EAAAzP,GACA,GAAAsjI,GAAAjoI,KAEA6tG,EAAA7tG,IAEA,KAAAoD,UAAAC,OAEA,MADAwqG,GAAAzI,QAAAziG,OAAAR,OAAA,MACA0rG,CAGA,IAAAniG,MAAAxD,QAAAkM,GAAA,CACA,OAAAwoH,GAAA,EAAAz+G,EAAA/J,EAAA/Q,OAAyCu5H,EAAAz+G,EAASy+G,IAClDqL,EAAA1wB,KAAAnjG,EAAAwoH,GAAAj4H,EAEA,OAAAkpG,GAGA,GAAAm7B,GAAAn7B,EAAAzI,QAAAhxF,EACA,KAAA40H,EACA,MAAAn7B,EAEA,QAAAzqG,UAAAC,OAEA,MADAwqG,GAAAzI,QAAAhxF,GAAA,KACAy5F,CAKA,KAFA,GAAA5tE,GACAh6B,EAAA+iI,EAAA3lI,OACA4C,KAEA,IADAg6B,EAAA+oG,EAAA/iI,MACAtB,GAAAs7B,EAAAt7B,OAAA,CACAqkI,EAAApgI,OAAA3C,EAAA,EACA,OAGA,MAAA4nG,IAGA4V,EAAAtjH,UAAAs6G,MAAA,SAAArmG,GACA,GAAAy5F,GAAA7tG,KAaAgpI,EAAAn7B,EAAAzI,QAAAhxF,EACA,IAAA40H,EAAA,CACAA,IAAA3lI,OAAA,EAAAipG,EAAA08B,IAEA,QADArzH,GAAA22F,EAAAlpG,UAAA,GACA6C,EAAA,EAAAkY,EAAA6qH,EAAA3lI,OAAqC4C,EAAAkY,EAAOlY,IAC5C,IACA+iI,EAAA/iI,GAAAjB,MAAA6oG,EAAAl4F,GACS,MAAA1N,GACT2lG,EAAA3lG,EAAA4lG,EAAA,sBAAAz5F,EAAA,MAIA,MAAAy5F,KAo+DAyV,IAv4DA,SAAAG,GACAA,EAAAtjH,UAAA+4G,QAAA,SAAA7F,EAAAyF,GACA,GAAAjL,GAAA7tG,IACA6tG,GAAA4K,YACAO,GAAAnL,EAAA,eAEA,IAAAo7B,GAAAp7B,EAAAkL,IACAmwB,EAAAr7B,EAAAiM,OACAqvB,EAAA1V,EACAA,IAAA5lB,EACAA,EAAAiM,OAAAzG,EAGA61B,EAYAr7B,EAAAkL,IAAAlL,EAAAu7B,UAAAF,EAAA71B,IAVAxF,EAAAkL,IAAAlL,EAAAu7B,UACAv7B,EAAAkL,IAAA1F,EAAAyF,GAAA,EACAjL,EAAAkF,SAAAwM,WACA1R,EAAAkF,SAAAyM,SAIA3R,EAAAkF,SAAAwM,WAAA1R,EAAAkF,SAAAyM,QAAA,MAKAiU,GAAA0V,EAEAF,IACAA,EAAAI,QAAA,MAEAx7B,EAAAkL,MACAlL,EAAAkL,IAAAswB,QAAAx7B,GAGAA,EAAA5J,QAAA4J,EAAAqK,SAAArK,EAAA5J,SAAA4J,EAAAqK,QAAA4B,SACAjM,EAAAqK,QAAAa,IAAAlL,EAAAkL,MAMA0K,EAAAtjH,UAAAw2G,aAAA,WACA,GAAA9I,GAAA7tG,IACA6tG,GAAAyK,UACAzK,EAAAyK,SAAApiG,UAIAutG,EAAAtjH,UAAA+kH,SAAA,WACA,GAAArX,GAAA7tG,IACA,KAAA6tG,EAAA8K,kBAAA,CAGAK,GAAAnL,EAAA,iBACAA,EAAA8K,mBAAA,CAEA,IAAA/zG,GAAAipG,EAAAqK,SACAtzG,KAAA+zG,mBAAA9K,EAAAkF,SAAAkF,UACApwG,EAAAjD,EAAAuzG,UAAAtK,GAGAA,EAAAyK,UACAzK,EAAAyK,SAAAjwG,UAGA,KADA,GAAApC,GAAA4nG,EAAAsO,UAAA94G,OACA4C,KACA4nG,EAAAsO,UAAAl2G,GAAAoC,UAIAwlG,GAAA15D,MAAA46D,QACAlB,EAAA15D,MAAA46D,OAAAO,UAGAzB,EAAA6K,cAAA,EAEA7K,EAAAu7B,UAAAv7B,EAAAiM,OAAA,MAEAd,GAAAnL,EAAA,aAEAA,EAAA0J,OAEA1J,EAAAkL,MACAlL,EAAAkL,IAAAswB,QAAA,SAmzDA/lB,IArOA,SAAAG,GACAA,EAAAtjH,UAAAmpI,UAAA,SAAA3kI,GACA,MAAA62G,IAAA72G,EAAA3E,OAGAyjH,EAAAtjH,UAAAg5G,QAAA,WACA,GAAAtL,GAAA7tG,KACAgnH,EAAAnZ,EAAAkF,SACAlP,EAAAmjB,EAAAnjB,OACAC,EAAAkjB,EAAAljB,gBACA+V,EAAAmN,EAAAnN,YAEA,IAAAhM,EAAA4K,WAEA,OAAAliG,KAAAs3F,GAAAsM,OACAtM,EAAAsM,OAAA5jG,GAAAw9F,GAAAlG,EAAAsM,OAAA5jG,GAIAs3F,GAAA8L,aAAAE,KAAAjqG,KAAA8pG,aAAAE,GAEA9V,IAAA+J,EAAAgU,eACAhU,EAAAgU,iBAIAhU,EAAA5J,OAAA4V,CAEA,IAAAxG,EACA,KACAA,EAAAxP,EAAAhjG,KAAAgtG,EAAAiU,aAAAjU,EAAA0U,gBACK,MAAAt6G,GACL2lG,EAAA3lG,EAAA4lG,EAAA,mBASAwF,EAAAxF,EAAAiM,OAgBA,MAZAzG,aAAAF,MAQAE,EAAA2C,MAGA3C,EAAAzuG,OAAAi1G,EACAxG,GAMAoQ,EAAAtjH,UAAAopI,GAAAvnB,GACAyB,EAAAtjH,UAAAqpI,GAAA59B,EACA6X,EAAAtjH,UAAAspI,GAAA11H,EACA0vG,EAAAtjH,UAAAupI,GAAAjpB,GACAgD,EAAAtjH,UAAAmsD,GAAAo0D,GACA+C,EAAAtjH,UAAAwpI,GAAAh9B,EACA8W,EAAAtjH,UAAA8K,GAAAiiG,EACAuW,EAAAtjH,UAAAypI,GAAAjoB,GACA8B,EAAAtjH,UAAA0pI,GAAA9oB,GACA0C,EAAAtjH,UAAAiqD,GAAA42D,GACAyC,EAAAtjH,UAAA2pI,GAAA1oB,GACAqC,EAAAtjH,UAAA4pI,GAAA72B,EACAuQ,EAAAtjH,UAAA6pI,GAAAh0B,GACAyN,EAAAtjH,UAAA8pI,GAAAlyB,GACA0L,EAAAtjH,UAAA+pI,GAAA/nB,IAyJAmB,GA0KA,IAAA6mB,KAAAx+B,OAAAzpD,OAAAx2C,OAuCA0+H,IACA53H,KAAA,aACAylG,UAAA,EAEAlH,OACAs5B,QAAAF,GACAG,QAAAH,IAGAI,QAAA,WACAvqI,KAAAgqC,MAAArnC,OAAAR,OAAA,OAGAqoI,UAAA,WACA,GAAAvC,GAAAjoI,IAEA,QAAAuW,KAAA0xH,GAAAj+F,MACAg7E,GAAAijB,EAAAj+F,MAAAzzB,KAIAmmG,OACA2tB,QAAA,SAAA3jC,GACAoe,GAAA9kH,KAAAgqC,MAAAhqC,KAAA85G,OAAA,SAAAtnG,GAA2D,MAAAmkD,IAAA+vC,EAAAl0F,MAE3D83H,QAAA,SAAA5jC,GACAoe,GAAA9kH,KAAAgqC,MAAAhqC,KAAA85G,OAAA,SAAAtnG,GAA2D,OAAAmkD,GAAA+vC,EAAAl0F,OAI3DqxF,OAAA,WACA,GAAAwP,GAAAyD,GAAA92G,KAAAm6G,OAAAxW,SACA8P,EAAAJ,KAAAI,gBACA,IAAAA,EAAA,CAEA,GAAAjhG,GAAAoyG,GAAAnR,EACA,IAAAjhG,IACAxS,KAAAqqI,UAAA1zE,GAAA32D,KAAAqqI,QAAA73H,IACAxS,KAAAsqI,SAAA3zE,GAAA32D,KAAAsqI,QAAA93H,IAEA,MAAA6gG,EAEA,IAAA98F,GAAA,MAAA88F,EAAA98F,IAGAk9F,EAAAtF,KAAAwQ,KAAAlL,EAAAF,IAAA,KAAAE,EAAA,QACAJ,EAAA98F,GACAvW,MAAAgqC,MAAAzzB,GACA88F,EAAA4R,kBAAAjlH,KAAAgqC,MAAAzzB,GAAA0uG,kBAEAjlH,KAAAgqC,MAAAzzB,GAAA88F,EAEAA,EAAAzjG,KAAAu4H,WAAA,EAEA,MAAA90B,KAIAo3B,IACAL,eAKA,SAAA3mB,GAEA,GAAAinB,KACAA,GAAAh4H,IAAA,WAA+B,MAAAhR,KAQ/BiB,OAAAi+F,eAAA6iB,EAAA,SAAAinB,GAKAjnB,EAAAknB,MACAtf,QACA7uG,SACA+0F,eACAq5B,eAAAr7B,GAGAkU,EAAA7wG,MACA6wG,EAAAonB,OAAA16B,EACAsT,EAAAjI,YAEAiI,EAAA7f,QAAAjhG,OAAAR,OAAA,MACAsiH,GAAArjH,QAAA,SAAAqR,GACAgxG,EAAA7f,QAAAnxF,EAAA,KAAA9P,OAAAR,OAAA,QAKAshH,EAAA7f,QAAA8a,MAAA+E,EAEAjnG,EAAAinG,EAAA7f,QAAAmf,WAAA0nB,IAEAjnB,GAAAC,GACAM,GAAAN,GACAQ,GAAAR,GACAkB,GAAAlB,IAGAH,IAEA3gH,OAAAi+F,eAAA0iB,GAAAnjH,UAAA,aACAuS,IAAAy8F,KAGAxsG,OAAAi+F,eAAA0iB,GAAAnjH,UAAA,eACAuS,IAAA,WAEA,MAAA1S,MAAAikG,QAAAjkG,KAAAikG,OAAAC,cAIAof,GAAAzwB,QAAA,OAMA,IAg9CA3sF,IACA4lG,GACA8gB,GACApzC,GACAgzC,GACAC,GAwEAU,GAyLAiB,GA4OA0c,GAl8DA9F,GAAAn5B,EAAA,eAGAk/B,GAAAl/B,EAAA,gCACA2V,GAAA,SAAAjO,EAAA9gG,EAAArC,GACA,MACA,UAAAA,GAAA26H,GAAAx3B,IAAA,WAAA9gG,GACA,aAAArC,GAAA,WAAAmjG,GACA,YAAAnjG,GAAA,UAAAmjG,GACA,UAAAnjG,GAAA,UAAAmjG,GAIA+V,GAAAzd,EAAA,wCAEA0d,GAAA1d,EACA,wYAQAud,GAAA,+BAEAD,GAAA,SAAA32G,GACA,YAAAA,EAAA+oC,OAAA,cAAA/oC,EAAAhJ,MAAA,MAGA6/G,GAAA,SAAA72G,GACA,MAAA22G,IAAA32G,KAAAhJ,MAAA,EAAAgJ,EAAAnP,QAAA,IAGAmmH,GAAA,SAAA9iB,GACA,aAAAA,IAAA,IAAAA,GAsFA8f,IACAn6F,IAAA,6BACA2+G,KAAA,sCAGAC,GAAAp/B,EACA,snBAeAia,GAAAja,EACA,kNAGA,GAGAwvB,GAAA,SAAA9nB,GAA+B,cAAAA,GAE/B+M,GAAA,SAAA/M,GACA,MAAA03B,IAAA13B,IAAAuS,GAAAvS,IAcAyS,GAAArjH,OAAAR,OAAA,MAyGA+oI,GAAAvoI,OAAAuiI,QACA5xH,cAAA+yG,GACA9yG,mBACAkzG,kBACAC,iBACAzsG,gBACAG,eACAN,eACA5I,cACA2I,eACAysG,WACAO,kBACA1vG,kBAKA6vG,IACA7kH,OAAA,SAAAqP,EAAA6hG,GACAyT,GAAAzT,IAEAn9F,OAAA,SAAAwxG,EAAArU,GACAqU,EAAA93G,KAAAo3G,MAAA3T,EAAAzjG,KAAAo3G,MACAF,GAAAY,GAAA,GACAZ,GAAAzT,KAGAi1B,QAAA,SAAAj1B,GACAyT,GAAAzT,GAAA,KA6CAyU,GAAA,GAAA3U,IAAA,UAEAg4B,IAAA,iDA4nBA75B,IACAnvG,OAAAslH,GACAvxG,OAAAuxG,GACA6gB,QAAA,SAAAj1B,GACAoU,GAAApU,EAAAyU,MAsEAa,GAAAhmH,OAAAR,OAAA,MAqCAipI,IACApkB,GACA1V,IAuEA2D,IACA9yG,OAAA2mH,GACA5yG,OAAA4yG,IAoCAuiB,IACAlpI,OAAAsnH,GACAvzG,OAAAuzG,IAKAkB,GAAA,gBAsWAoD,GAAA,MACAJ,GAAA,MAsOArC,IACAnpH,OAAAqsH,GACAt4G,OAAAs4G,IAqFA/M,IACAt/G,OAAAssH,GACAv4G,OAAAu4G,IAKAe,GAAAtjB,EAAA,SAAAo/B,GACA,GAAA5+B,MACA6+B,EAAA,gBACAC,EAAA,OAOA,OANAF,GAAAh5H,MAAAi5H,GAAAnqI,QAAA,SAAAqF,GACA,GAAAA,EAAA,CACA,GAAA+B,GAAA/B,EAAA6L,MAAAk5H,EACAhjI,GAAAnF,OAAA,IAAAqpG,EAAAlkG,EAAA,GAAA6J,QAAA7J,EAAA,GAAA6J,WAGAq6F,IAyDA++B,GAAA,MACAC,GAAA,iBACAxb,GAAA,SAAArX,EAAArmG,EAAAk0F,GAEA,GAAA+kC,GAAAnyF,KAAA9mC,GACAqmG,EAAAnhG,MAAAI,YAAAtF,EAAAk0F,OACG,IAAAglC,GAAApyF,KAAAotD,GACHmS,EAAAnhG,MAAAI,YAAAtF,EAAAk0F,EAAA1kD,QAAA0pF,GAAA,qBACG,CACH,GAAAC,GAAAC,GAAAp5H,EACA,IAAA9G,MAAAxD,QAAAw+F,GAIA,OAAAzgG,GAAA,EAAAC,EAAAwgG,EAAArjG,OAAuC4C,EAAAC,EAASD,IAChD4yG,EAAAnhG,MAAAi0H,GAAAjlC,EAAAzgG,OAGA4yG,GAAAnhG,MAAAi0H,GAAAjlC,IAKAmlC,IAAA,qBAGAD,GAAA1/B,EAAA,SAAAsG,GAGA,GAFAs4B,OAAA93H,SAAAM,cAAA,OAAAoE,MAEA,YADA86F,EAAAxB,GAAAwB,KACAA,IAAAs4B,IACA,MAAAt4B,EAGA,QADAs5B,GAAAt5B,EAAAj3D,OAAA,GAAAo6B,cAAA68B,EAAAhpG,MAAA,GACAvD,EAAA,EAAiBA,EAAA4lI,GAAAxoI,OAAwB4C,IAAA,CACzC,GAAAuM,GAAAq5H,GAAA5lI,GAAA6lI,CACA,IAAAt5H,IAAAs4H,IACA,MAAAt4H,MAgDAkF,IACAvV,OAAAytH,GACA15G,OAAA05G,IAoFAa,GAAAvkB,EAAA,SAAA15F,GACA,OACAogH,WAAApgH,EAAA,SACAqgH,aAAArgH,EAAA,YACAsgH,iBAAAtgH,EAAA,gBACAwiH,WAAAxiH,EAAA,SACA0iH,aAAA1iH,EAAA,YACAyiH,iBAAAziH,EAAA,mBAIAu5H,GAAA/9B,KAAAkb,GACAiI,GAAA,aACAc,GAAA,YAGAR,GAAA,aACAL,GAAA,gBACAU,GAAA,YACAT,GAAA,cACA0a,UAEA/2G,KAAAnrB,OAAAmiI,qBACAh3G,KAAAnrB,OAAAoiI,wBAEAxa,GAAA,mBACAL,GAAA,2BAEAp8F,KAAAnrB,OAAAqiI,oBACAl3G,KAAAnrB,OAAAsiI,uBAEAra,GAAA,kBACAT,GAAA,sBAKA,IAAAV,IAAA3iB,IAAAnkG,OAAA8+D,sBACA9+D,OAAA8+D,sBAAArkE,KAAAuF,QACAvD,WAsDA6rH,GAAA,yBAiXAthH,GAAAm9F,IACA7rG,OAAAy2D,GACAwzE,SAAAxzE,GACA/wD,OAAA,SAAAwrG,EAAAwhB,IAEA,IAAAxhB,EAAAzjG,KAAA4kH,KACAI,GAAAvhB,EAAAwhB,GAEAA,SAKAwX,IACAp3B,GACAo2B,GACA/f,GACA7J,GACA/pG,GACA7G,IAOAk6G,GAAAshB,GAAAjlI,OAAAgkI,IAEAkB,GA5rEA,SAAAC,GAgBA,QAAAC,GAAAh5B,GACA,UAAAL,IAAA+3B,EAAA5kB,QAAA9S,GAAA52F,wBAA2DoY,GAAAw+E,GAG3D,QAAAi5B,GAAAC,EAAA37G,GACA,QAAAwjF,KACA,KAAAA,EAAAxjF,WACA47G,EAAAD,GAIA,MADAn4B,GAAAxjF,YACAwjF,EAGA,QAAAo4B,GAAA9zB,GACA,GAAAj0G,GAAAsmI,EAAAh6H,WAAA2nG,EAEA3N,GAAAtmG,IACAsmI,EAAA9wH,YAAAxV,EAAAi0G,GAKA,QAAA+zB,GAAAv5B,EAAAw5B,EAAA3tB,EAAAC,EAAA2tB,GAEA,GADAz5B,EAAAugB,cAAAkZ,GACAruB,EAAApL,EAAAw5B,EAAA3tB,EAAAC,GAAA,CAIA,GAAAvvG,GAAAyjG,EAAAzjG,KACAs9B,EAAAmmE,EAAAnmE,SACAqmE,EAAAF,EAAAE,GACArI,GAAAqI,IAmBAF,EAAAG,IAAAH,EAAAM,GACAu3B,EAAA33H,gBAAA8/F,EAAAM,GAAAJ,GACA23B,EAAA53H,cAAAigG,EAAAF,GACA05B,EAAA15B,GAIA25B,EAAA35B,EAAAnmE,EAAA2/F,GACA3hC,EAAAt7F,IACAq9H,EAAA55B,EAAAw5B,GAEAp8H,EAAAyuG,EAAA7L,EAAAG,IAAA2L,IAMKhU,EAAAkI,EAAAQ,YACLR,EAAAG,IAAA03B,EAAAxkB,cAAArT,EAAA9iG,MACAE,EAAAyuG,EAAA7L,EAAAG,IAAA2L,KAEA9L,EAAAG,IAAA03B,EAAAzkB,eAAApT,EAAA9iG,MACAE,EAAAyuG,EAAA7L,EAAAG,IAAA2L,KAIA,QAAAV,GAAApL,EAAAw5B,EAAA3tB,EAAAC,GACA,GAAAl5G,GAAAotG,EAAAzjG,IACA,IAAAs7F,EAAAjlG,GAAA,CACA,GAAAinI,GAAAhiC,EAAAmI,EAAA4R,oBAAAh/G,EAAAkiI,SAQA,IAPAj9B,EAAAjlG,IAAA+9F,OAAAkH,EAAAjlG,IAAAkgB,OACAlgB,EAAAotG,GAAA,EAAA6L,EAAAC,GAMAjU,EAAAmI,EAAA4R,mBAKA,MAJAkoB,GAAA95B,EAAAw5B,GACA1hC,EAAA+hC,IACAE,EAAA/5B,EAAAw5B,EAAA3tB,EAAAC,IAEA,GAKA,QAAAguB,GAAA95B,EAAAw5B,GACA3hC,EAAAmI,EAAAzjG,KAAAy9H,iBACAR,EAAAzkI,KAAApD,MAAA6nI,EAAAx5B,EAAAzjG,KAAAy9H,eACAh6B,EAAAzjG,KAAAy9H,cAAA,MAEAh6B,EAAAG,IAAAH,EAAA4R,kBAAAlM,IACAu0B,EAAAj6B,IACA45B,EAAA55B,EAAAw5B,GACAE,EAAA15B,KAIAyT,GAAAzT,GAEAw5B,EAAAzkI,KAAAirG,IAIA,QAAA+5B,GAAA/5B,EAAAw5B,EAAA3tB,EAAAC,GAOA,IANA,GAAAl5G,GAKAsnI,EAAAl6B,EACAk6B,EAAAtoB,mBAEA,GADAsoB,IAAAtoB,kBAAAnL,OACA5O,EAAAjlG,EAAAsnI,EAAA39H,OAAAs7F,EAAAjlG,IAAA4K,YAAA,CACA,IAAA5K,EAAA,EAAmBA,EAAA+iI,EAAAoD,SAAA/oI,SAAyB4C,EAC5C+iI,EAAAoD,SAAAnmI,GAAA6hH,GAAAylB,EAEAV,GAAAzkI,KAAAmlI,EACA,OAKA98H,EAAAyuG,EAAA7L,EAAAG,IAAA2L,GAGA,QAAA1uG,GAAA7L,EAAA4uG,EAAAg6B,GACAtiC,EAAAtmG,KACAsmG,EAAAsiC,GACAA,EAAAt8H,aAAAtM,GACAsmI,EAAAjxH,aAAArV,EAAA4uG,EAAAg6B,GAGAtC,EAAApxH,YAAAlV,EAAA4uG,IAKA,QAAAw5B,GAAA35B,EAAAnmE,EAAA2/F,GACA,GAAAnhI,MAAAxD,QAAAglC,GACA,OAAAjnC,GAAA,EAAqBA,EAAAinC,EAAA7pC,SAAqB4C,EAC1C2mI,EAAA1/F,EAAAjnC,GAAA4mI,EAAAx5B,EAAAG,IAAA,aAEKnI,GAAAgI,EAAA9iG,OACL26H,EAAApxH,YAAAu5F,EAAAG,IAAA03B,EAAAzkB,eAAApT,EAAA9iG,OAIA,QAAA+8H,GAAAj6B,GACA,KAAAA,EAAA4R,mBACA5R,IAAA4R,kBAAAnL,MAEA,OAAA5O,GAAAmI,EAAAE,KAGA,QAAA05B,GAAA55B,EAAAw5B,GACA,OAAAjQ,GAAA,EAAqBA,EAAAoM,EAAA7mI,OAAAkB,SAAyBu5H,EAC9CoM,EAAA7mI,OAAAy6H,GAAA9U,GAAAzU,EAEAptG,GAAAotG,EAAAzjG,KAAAo0F,KACAkH,EAAAjlG,KACAilG,EAAAjlG,EAAA9D,SAA4B8D,EAAA9D,OAAA2lH,GAAAzU,GAC5BnI,EAAAjlG,EAAAwK,SAA4Bo8H,EAAAzkI,KAAAirG,IAO5B,QAAA05B,GAAA15B,GAGA,IAFA,GAAAptG,GACAysC,EAAA2gE,EACA3gE,GACAw4D,EAAAjlG,EAAAysC,EAAAtuC,UAAA8mG,EAAAjlG,IAAA8sG,SAAAhP,WACAmnC,EAAA/zH,aAAAk8F,EAAAG,IAAAvtG,EAAA,IAEAysC,IAAA9tC,MAGAsmG,GAAAjlG,EAAAwtH,KACAxtH,IAAAotG,EAAAjvG,SACA8mG,EAAAjlG,IAAA8sG,SAAAhP,WAEAmnC,EAAA/zH,aAAAk8F,EAAAG,IAAAvtG,EAAA,IAIA,QAAAwnI,GAAAvuB,EAAAC,EAAAnL,EAAA05B,EAAAlmB,EAAAqlB,GACA,KAAUa,GAAAlmB,IAAoBkmB,EAC9Bd,EAAA54B,EAAA05B,GAAAb,EAAA3tB,EAAAC,GAIA,QAAAwuB,GAAAt6B,GACA,GAAAptG,GAAAgP,EACArF,EAAAyjG,EAAAzjG,IACA,IAAAs7F,EAAAt7F,GAEA,IADAs7F,EAAAjlG,EAAA2J,EAAAo0F,OAAAkH,EAAAjlG,IAAAqiI,UAAyDriI,EAAAotG,GACzDptG,EAAA,EAAiBA,EAAA+iI,EAAAV,QAAAjlI,SAAwB4C,EAAO+iI,EAAAV,QAAAriI,GAAAotG,EAEhD,IAAAnI,EAAAjlG,EAAAotG,EAAAnmE,UACA,IAAAj4B,EAAA,EAAiBA,EAAAo+F,EAAAnmE,SAAA7pC,SAA2B4R,EAC5C04H,EAAAt6B,EAAAnmE,SAAAj4B,IAKA,QAAA24H,GAAA1uB,EAAAlL,EAAA05B,EAAAlmB,GACA,KAAUkmB,GAAAlmB,IAAoBkmB,EAAA,CAC9B,GAAAG,GAAA75B,EAAA05B,EACAxiC,GAAA2iC,KACA3iC,EAAA2iC,EAAAt6B,MACAu6B,EAAAD,GACAF,EAAAE,IAEAlB,EAAAkB,EAAAr6B,OAMA,QAAAs6B,GAAAz6B,EAAAwhB,GACA,GAAA3pB,EAAA2pB,IAAA3pB,EAAAmI,EAAAzjG,MAAA,CACA,GAAA3J,GACA8qB,EAAAi4G,EAAAnhI,OAAAxE,OAAA,CAaA,KAZA6nG,EAAA2pB,GAGAA,EAAA9jG,aAGA8jG,EAAA4X,EAAAp5B,EAAAG,IAAAziF,GAGAm6E,EAAAjlG,EAAAotG,EAAA4R,oBAAA/Z,EAAAjlG,IAAA6zG,SAAA5O,EAAAjlG,EAAA2J,OACAk+H,EAAA7nI,EAAA4uH,GAEA5uH,EAAA,EAAiBA,EAAA+iI,EAAAnhI,OAAAxE,SAAuB4C,EACxC+iI,EAAAnhI,OAAA5B,GAAAotG,EAAAwhB,EAEA3pB,GAAAjlG,EAAAotG,EAAAzjG,KAAAo0F,OAAAkH,EAAAjlG,IAAA4B,QACA5B,EAAAotG,EAAAwhB,GAEAA,QAGA8X,GAAAt5B,EAAAG,KAIA,QAAAu6B,GAAA7uB,EAAA8uB,EAAAC,EAAApB,EAAAqB,GAgBA,IAfA,GAQAC,GAAAC,EAAAC,EAAAlvB,EARAmvB,EAAA,EACAC,EAAA,EACAC,EAAAR,EAAA3qI,OAAA,EACAorI,EAAAT,EAAA,GACAU,EAAAV,EAAAQ,GACAG,EAAAV,EAAA5qI,OAAA,EACAurI,EAAAX,EAAA,GACAY,EAAAZ,EAAAU,GAMAG,GAAAZ,EAEAI,GAAAE,GAAAD,GAAAI,GACA1jC,EAAAwjC,GACAA,EAAAT,IAAAM,GACOrjC,EAAAyjC,GACPA,EAAAV,IAAAQ,GACOrnB,GAAAsnB,EAAAG,IACPG,EAAAN,EAAAG,EAAA/B,GACA4B,EAAAT,IAAAM,GACAM,EAAAX,IAAAM,IACOpnB,GAAAunB,EAAAG,IACPE,EAAAL,EAAAG,EAAAhC,GACA6B,EAAAV,IAAAQ,GACAK,EAAAZ,IAAAU,IACOxnB,GAAAsnB,EAAAI,IACPE,EAAAN,EAAAI,EAAAhC,GACAiC,GAAA5D,EAAAjxH,aAAAilG,EAAAuvB,EAAAj7B,IAAA03B,EAAArxH,YAAA60H,EAAAl7B,MACAi7B,EAAAT,IAAAM,GACAO,EAAAZ,IAAAU,IACOxnB,GAAAunB,EAAAE,IACPG,EAAAL,EAAAE,EAAA/B,GACAiC,GAAA5D,EAAAjxH,aAAAilG,EAAAwvB,EAAAl7B,IAAAi7B,EAAAj7B,KACAk7B,EAAAV,IAAAQ,GACAI,EAAAX,IAAAM,KAEAtjC,EAAAkjC,KAAmCA,EAAA7mB,GAAA0mB,EAAAM,EAAAE,IACnCJ,EAAAljC,EAAA0jC,EAAAr4H,KAAA43H,EAAAS,EAAAr4H,KAAA,KACA00F,EAAAmjC,IACAxB,EAAAgC,EAAA/B,EAAA3tB,EAAAuvB,EAAAj7B,KACAo7B,EAAAX,IAAAM,KAEAF,EAAAL,EAAAI,GAQAjnB,GAAAknB,EAAAO,IACAG,EAAAV,EAAAO,EAAA/B,GACAmB,EAAAI,OAAAp5G,GACA85G,GAAA5D,EAAAjxH,aAAAilG,EAAAmvB,EAAA76B,IAAAi7B,EAAAj7B,KACAo7B,EAAAX,IAAAM,KAGA3B,EAAAgC,EAAA/B,EAAA3tB,EAAAuvB,EAAAj7B,KACAo7B,EAAAX,IAAAM,KAKAD,GAAAE,GACArvB,EAAAlU,EAAAgjC,EAAAU,EAAA,SAAAV,EAAAU,EAAA,GAAAn7B,IACAi6B,EAAAvuB,EAAAC,EAAA8uB,EAAAM,EAAAI,EAAA9B,IACK0B,EAAAI,GACLf,EAAA1uB,EAAA8uB,EAAAM,EAAAE,GAIA,QAAAO,GAAArnB,EAAArU,EAAAw5B,EAAAqB,GACA,GAAAxmB,IAAArU,EAAA,CAIA,GAAAG,GAAAH,EAAAG,IAAAkU,EAAAlU,GAEA,IAAArI,EAAAuc,EAAAL,oBAMA,YALAnc,EAAAmI,EAAAK,aAAA2C,UACA24B,EAAAtnB,EAAAlU,IAAAH,EAAAw5B,GAEAx5B,EAAAgU,oBAAA,EASA,IAAAlc,EAAAkI,EAAAO,WACAzI,EAAAuc,EAAA9T,WACAP,EAAA98F,MAAAmxG,EAAAnxG,MACA40F,EAAAkI,EAAAS,WAAA3I,EAAAkI,EAAA4O,SAGA,YADA5O,EAAA4R,kBAAAyC,EAAAzC,kBAIA,IAAAh/G,GACA2J,EAAAyjG,EAAAzjG,IACAs7F,GAAAt7F,IAAAs7F,EAAAjlG,EAAA2J,EAAAo0F,OAAAkH,EAAAjlG,IAAAoiI,WACApiI,EAAAyhH,EAAArU,EAGA,IAAA26B,GAAAtmB,EAAAx6E,SACA2gG,EAAAx6B,EAAAnmE,QACA,IAAAg+D,EAAAt7F,IAAA09H,EAAAj6B,GAAA,CACA,IAAAptG,EAAA,EAAiBA,EAAA+iI,EAAA9yH,OAAA7S,SAAuB4C,EAAO+iI,EAAA9yH,OAAAjQ,GAAAyhH,EAAArU,EAC/CnI,GAAAjlG,EAAA2J,EAAAo0F,OAAAkH,EAAAjlG,IAAAiQ,SAAwDjQ,EAAAyhH,EAAArU,GAExDpI,EAAAoI,EAAA9iG,MACA26F,EAAA8iC,IAAA9iC,EAAA2iC,GACAG,IAAAH,GAA2BE,EAAAv6B,EAAAw6B,EAAAH,EAAAhB,EAAAqB,GACpBhjC,EAAA2iC,IACP3iC,EAAAwc,EAAAn3G,OAAmC26H,EAAArkB,eAAArT,EAAA,IACnCi6B,EAAAj6B,EAAA,KAAAq6B,EAAA,EAAAA,EAAAxqI,OAAA,EAAAwpI,IACO3hC,EAAA8iC,GACPJ,EAAAp6B,EAAAw6B,EAAA,EAAAA,EAAA3qI,OAAA,GACO6nG,EAAAwc,EAAAn3G,OACP26H,EAAArkB,eAAArT,EAAA,IAEKkU,EAAAn3G,OAAA8iG,EAAA9iG,MACL26H,EAAArkB,eAAArT,EAAAH,EAAA9iG,MAEA26F,EAAAt7F,IACAs7F,EAAAjlG,EAAA2J,EAAAo0F,OAAAkH,EAAAjlG,IAAAgpI,YAA2DhpI,EAAAyhH,EAAArU,IAI3D,QAAA67B,GAAA77B,EAAAx+D,EAAAs6F,GAGA,GAAAhkC,EAAAgkC,IAAAjkC,EAAAmI,EAAAzuG,QACAyuG,EAAAzuG,OAAAgL,KAAAy9H,cAAAx4F,MAEA,QAAA5uC,GAAA,EAAqBA,EAAA4uC,EAAAxxC,SAAkB4C,EACvC4uC,EAAA5uC,GAAA2J,KAAAo0F,KAAAvzF,OAAAokC,EAAA5uC,IAWA,QAAA+oI,GAAAx7B,EAAAH,EAAAw5B,GACA,GAAA1hC,EAAAkI,EAAAQ,YAAA3I,EAAAmI,EAAAK,cAGA,MAFAL,GAAAG,MACAH,EAAAgU,oBAAA,GACA,CAOAhU,GAAAG,KACA,IAAAD,GAAAF,EAAAE,IACA3jG,EAAAyjG,EAAAzjG,KACAs9B,EAAAmmE,EAAAnmE,QACA,IAAAg+D,EAAAt7F,KACAs7F,EAAAjlG,EAAA2J,EAAAo0F,OAAAkH,EAAAjlG,IAAAkgB,OAAsDlgB,EAAAotG,GAAA,GACtDnI,EAAAjlG,EAAAotG,EAAA4R,oBAGA,MADAkoB,GAAA95B,EAAAw5B,IACA,CAGA,IAAA3hC,EAAAqI,GAAA,CACA,GAAArI,EAAAh+D,GAEA,GAAAsmE,EAAA47B,gBAES,CAGT,OAFAC,IAAA,EACAjqB,EAAA5R,EAAAt5F,WACA0iH,EAAA,EAA2BA,EAAA1vF,EAAA7pC,OAAuBu5H,IAAA,CAClD,IAAAxX,IAAA4pB,EAAA5pB,EAAAl4E,EAAA0vF,GAAAiQ,GAAA,CACAwC,GAAA,CACA,OAEAjqB,IAAAvrG,YAIA,IAAAw1H,GAAAjqB,EASA,aAtBA4nB,GAAA35B,EAAAnmE,EAAA2/F,EA0BA,IAAA3hC,EAAAt7F,GACA,OAAA2G,KAAA3G,GACA,IAAA0/H,EAAA/4H,GAAA,CACA02H,EAAA55B,EAAAw5B,EACA,YAIKr5B,GAAA5jG,OAAAyjG,EAAA9iG,OACLijG,EAAA5jG,KAAAyjG,EAAA9iG,KAEA,UA9eA,GAAAtK,GAAAgP,EACA+zH,KAEAje,EAAAwhB,EAAAxhB,QACAmgB,EAAAqB,EAAArB,OAEA,KAAAjlI,EAAA,EAAaA,EAAAklI,GAAA9nI,SAAkB4C,EAE/B,IADA+iI,EAAAmC,GAAAllI,OACAgP,EAAA,EAAeA,EAAA81G,EAAA1nH,SAAoB4R,EACnCi2F,EAAA6f,EAAA91G,GAAAk2H,GAAAllI,MACA+iI,EAAAmC,GAAAllI,IAAAmC,KAAA2iH,EAAA91G,GAAAk2H,GAAAllI,IA2BA,IAsYAqpI,GAAAzjC,EAAA,gDAiFA,iBAAA6b,EAAArU,EAAAyF,EAAAo1B,EAAAhvB,EAAAC,GACA,GAAAlU,EAAAoI,GAEA,YADAnI,EAAAwc,IAA4BimB,EAAAjmB,GAI5B,IAAA6nB,IAAA,EACA1C,IAEA,IAAA5hC,EAAAyc,GAEA6nB,GAAA,EACA3C,EAAAv5B,EAAAw5B,EAAA3tB,EAAAC,OACK,CACL,GAAAqwB,GAAAtkC,EAAAwc,EAAAiL,SACA,KAAA6c,GAAAroB,GAAAO,EAAArU,GAEA07B,EAAArnB,EAAArU,EAAAw5B,EAAAqB,OACO,CACP,GAAAsB,EAAA,CAQA,GAJA,IAAA9nB,EAAAiL,UAAAjL,EAAA+nB,aAAAhL,MACA/c,EAAA3wG,gBAAA0tH,IACA3rB,GAAA,GAEA3N,EAAA2N,IACAk2B,EAAAtnB,EAAArU,EAAAw5B,GAEA,MADAqC,GAAA77B,EAAAw5B,GAAA,GACAnlB,CAaAA,GAAA8kB,EAAA9kB,GAGA,GAAAgoB,GAAAhoB,EAAAlU,IACAm8B,EAAAzE,EAAAh6H,WAAAw+H,EAWA,IAVA9C,EACAv5B,EACAw5B,EAIA6C,EAAAld,SAAA,KAAAmd,EACAzE,EAAArxH,YAAA61H,IAGAxkC,EAAAmI,EAAAzuG,QAAA,CAIA,IADA,GAAA8tC,GAAA2gE,EAAAzuG,OACA8tC,GACAA,EAAA8gE,IAAAH,EAAAG,IACA9gE,IAAA9tC,MAEA,IAAA0oI,EAAAj6B,GACA,OAAAptG,GAAA,EAA2BA,EAAA+iI,EAAA7mI,OAAAkB,SAAuB4C,EAClD+iI,EAAA7mI,OAAA8D,GAAA6hH,GAAAzU,EAAAzuG,QAKAsmG,EAAAykC,GACA/B,EAAA+B,GAAAjoB,GAAA,KACSxc,EAAAwc,EAAAnU,MACTo6B,EAAAjmB,IAMA,MADAwnB,GAAA77B,EAAAw5B,EAAA0C,GACAl8B,EAAAG,OA6mDiC03B,WAAAngB,aAOjC6kB,GAAA/jC,EAAA,4CAGAqd,KAEAl2G,SAAAwC,iBAAA,6BACA,GAAAqjG,GAAA7lG,SAAAk8G,aACArW,MAAAg3B,QACA7Z,GAAAnd,EAAA,UAKA,IAAAi3B,KACAtnB,SAAA,SAAA3P,EAAA4c,EAAApiB,GACA,cAAAA,EAAAE,IAAA,CACA,GAAAtzE,GAAA,WACAu1F,GAAA3c,EAAA4c,EAAApiB,EAAAjvG,SAEA67B,MAEAguF,IAAAsX,KACAj/H,WAAA25B,EAAA,GAEA44E,EAAAk3B,aAAAx9H,IAAA1R,KAAAg4G,EAAAjV,QAAAgyB,SACK,aAAAviB,EAAAE,KAAAq8B,GAAA/2B,EAAApmG,SACLomG,EAAAsW,YAAAsG,EAAA/M,UACA+M,EAAA/M,UAAAmF,OAKAhV,EAAArjG,iBAAA,SAAAugH,IACAyP,KACA3sB,EAAArjG,iBAAA,mBAAAsgH,IACAjd,EAAArjG,iBAAA,iBAAAugH,KAGA7M,KACArQ,EAAAg3B,QAAA,MAKAtnB,iBAAA,SAAA1P,EAAA4c,EAAApiB,GACA,cAAAA,EAAAE,IAAA,CACAiiB,GAAA3c,EAAA4c,EAAApiB,EAAAjvG,QAKA,IAAA4rI,GAAAn3B,EAAAk3B,WACAl3B,EAAAk3B,aAAAx9H,IAAA1R,KAAAg4G,EAAAjV,QAAAgyB,KACA6N,KAAA,SAAAzuH,EAAA/O,GAA2C,OAAA0mG,EAAA33F,EAAAg7H,EAAA/pI,OAC3C+vH,GAAAnd,EAAA,aAuEA2b,IACAlwH,KAAA,SAAAu0G,EAAAmO,EAAA3T,GACA,GAAArxG,GAAAglH,EAAAhlH,KAEAqxG,GAAA4iB,GAAA5iB,EACA,IAAA5pC,GAAA4pC,EAAAzjG,MAAAyjG,EAAAzjG,KAAAiB,WACAo/H,EAAAp3B,EAAAq3B,mBACA,SAAAr3B,EAAAnhG,MAAAy4H,QAAA,GAAAt3B,EAAAnhG,MAAAy4H,OACAnuI,IAAAynE,GACA4pC,EAAAzjG,KAAA4kH,MAAA,EACAtkH,GAAAmjG,EAAA,WACAwF,EAAAnhG,MAAAy4H,QAAAF,KAGAp3B,EAAAnhG,MAAAy4H,QAAAnuI,EAAAiuI,EAAA,QAIA/5H,OAAA,SAAA2iG,EAAAmO,EAAA3T,GACA,GAAArxG,GAAAglH,EAAAhlH,KAIAA,KAHAglH,EAAAqB,WAIAhV,EAAA4iB,GAAA5iB,GACAA,EAAAzjG,MAAAyjG,EAAAzjG,KAAAiB,YAEAwiG,EAAAzjG,KAAA4kH,MAAA,EACAxyH,EACAkO,GAAAmjG,EAAA,WACAwF,EAAAnhG,MAAAy4H,QAAAt3B,EAAAq3B,qBAGAtb,GAAAvhB,EAAA,WACAwF,EAAAnhG,MAAAy4H,QAAA,UAIAt3B,EAAAnhG,MAAAy4H,QAAAnuI,EAAA62G,EAAAq3B,mBAAA,SAIAE,OAAA,SACAv3B,EACA4c,EACApiB,EACAqU,EACAK,GAEAA,IACAlP,EAAAnhG,MAAAy4H,QAAAt3B,EAAAq3B,sBAKAG,IACAxxB,MAAAixB,GACAtb,SAQA8b,IACA99H,KAAAm5F,OACA2nB,OAAA3gB,QACA6d,IAAA7d,QACAhkF,KAAAg9E,OACAl5F,KAAAk5F,OACAinB,WAAAjnB,OACAqpB,WAAArpB,OACAknB,aAAAlnB,OACAupB,aAAAvpB,OACAmnB,iBAAAnnB,OACAspB,iBAAAtpB,OACAonB,YAAApnB,OACAsnB,kBAAAtnB,OACAqnB,cAAArnB,OACA1kF,UAAAi+E,OAAAyG,OAAAhpG,SAsDAknB,IACArX,KAAA,aACAu+F,MAAAu/B,GACAr4B,UAAA,EAEApU,OAAA,SAAA5lF,GACA,GAAAgqH,GAAAjoI,KAEAktC,EAAAltC,KAAA+yG,SAAA0G,eACA,IAAAvsE,IAKAA,IAAA57B,OAAA,SAAAqB,GAA6C,MAAAA,GAAA4gG,KAAA8T,GAAA10G,KAE7Cu6B,EAAA7pC,QAAA,CAaA,GAAAsrB,GAAA3uB,KAAA2uB,KAYA4nG,EAAArpF,EAAA,EAIA,IAAAspF,GAAAx2H,KAAAikG,QACA,MAAAsyB,EAKA,IAAAzoF,GAAAooF,GAAAK,EAEA,KAAAzoF,EACA,MAAAyoF,EAGA,IAAAv2H,KAAAuwI,SACA,MAAAja,IAAAr4G,EAAAs4G,EAMA,IAAAz6G,GAAA,gBAAA9b,KAAA,QACA8tC,GAAAv3B,IAAA,MAAAu3B,EAAAv3B,IACAu3B,EAAA+lE,UACA/3F,EAAA,UACAA,EAAAgyB,EAAAylE,IACAlI,EAAAv9D,EAAAv3B,KACA,IAAAo1F,OAAA79D,EAAAv3B,KAAA5N,QAAAmT,GAAAgyB,EAAAv3B,IAAAuF,EAAAgyB,EAAAv3B,IACAu3B,EAAAv3B,GAEA,IAAA3G,IAAAk+B,EAAAl+B,OAAAk+B,EAAAl+B,UAA8CiB,WAAAulH,GAAAp2H,MAC9CwwI,EAAAxwI,KAAA85G,OACA4c,EAAAR,GAAAsa,EAQA,IAJA1iG,EAAAl+B,KAAA0hG,YAAAxjE,EAAAl+B,KAAA0hG,WAAAmyB,KAAA,SAAAphI,GAA0E,eAAAA,EAAAmQ,SAC1Es7B,EAAAl+B,KAAA4kH,MAAA,GAIAkC,GACAA,EAAA9mH,OACA6mH,GAAA3oF,EAAA4oF,KACArP,GAAAqP,GACA,CAGA,GAAAhN,GAAAgN,MAAA9mH,KAAAiB,WAAA2L,KAAqE5M,GAErE,eAAA+e,EAOA,MALA3uB,MAAAuwI,UAAA,EACA37B,GAAA8U,EAAA,wBACAue,EAAAsI,UAAA,EACAtI,EAAAtxB,iBAEA2f,GAAAr4G,EAAAs4G,EACO,eAAA5nG,EAAA,CACP,GAAA04F,GAAAv5E,GACA,MAAA0iG,EAEA,IAAAC,GACA3b,EAAA,WAAwC2b,IACxC77B,IAAAhlG,EAAA,aAAAklH,GACAlgB,GAAAhlG,EAAA,iBAAAklH,GACAlgB,GAAA8U,EAAA,sBAAAkL,GAAgE6b,EAAA7b,KAIhE,MAAA2B,MAiBAxlB,GAAAv0F,GACA+2F,IAAA5H,OACA+kC,UAAA/kC,QACC2kC,UAEDv/B,IAAApiF,IAEA,IAAAgiH,KACA5/B,SAEAlN,OAAA,SAAA5lF,GAQA,OAPAs1F,GAAAvzG,KAAAuzG,KAAAvzG,KAAAikG,OAAAr0F,KAAA2jG,KAAA,OACAhhG,EAAA5P,OAAAR,OAAA,MACAyuI,EAAA5wI,KAAA4wI,aAAA5wI,KAAAktC,SACA2jG,EAAA7wI,KAAAm6G,OAAAxW,YACAz2D,EAAAltC,KAAAktC,YACA4jG,EAAA1a,GAAAp2H,MAEAiG,EAAA,EAAmBA,EAAA4qI,EAAAxtI,OAAwB4C,IAAA,CAC3C,GAAA0M,GAAAk+H,EAAA5qI,EACA,IAAA0M,EAAA4gG,IACA,SAAA5gG,EAAA4D,KAAA,IAAAo1F,OAAAh5F,EAAA4D,KAAA5N,QAAA,WACAukC,EAAA9kC,KAAAuK,GACAJ,EAAAI,EAAA4D,KAAA5D,GACWA,EAAA/C,OAAA+C,EAAA/C,UAAuBiB,WAAAigI,QASlC,GAAAF,EAAA,CAGA,OAFAG,MACAC,KACApU,EAAA,EAAuBA,EAAAgU,EAAAvtI,OAA2Bu5H,IAAA,CAClD,GAAAqU,GAAAL,EAAAhU,EACAqU,GAAArhI,KAAAiB,WAAAigI,EACAG,EAAArhI,KAAAqnH,IAAAga,EAAAz9B,IAAA17C,wBACAvlD,EAAA0+H,EAAA16H,KACAw6H,EAAA3oI,KAAA6oI,GAEAD,EAAA5oI,KAAA6oI,GAGAjxI,KAAA+wI,KAAA9yH,EAAAs1F,EAAA,KAAAw9B,GACA/wI,KAAAgxI,UAGA,MAAA/yH,GAAAs1F,EAAA,KAAArmE,IAGAgkG,aAAA,WAEAlxI,KAAAopI,UACAppI,KAAA85G,OACA95G,KAAA+wI,MACA,GACA,GAEA/wI,KAAA85G,OAAA95G,KAAA+wI,MAGAI,QAAA,WACA,GAAAjkG,GAAAltC,KAAA4wI,aACAF,EAAA1wI,KAAA0wI,YAAA1wI,KAAAwS,MAAA,YACA,IAAA06B,EAAA7pC,QAAArD,KAAAoxI,QAAAlkG,EAAA,GAAAsmE,IAAAk9B,GAAA,CAMAxjG,EAAA9rC,QAAAu1H,IACAzpF,EAAA9rC,QAAAy1H,IACA3pF,EAAA9rC,QAAA21H,GAGA,IAAAsa,GAAAr+H,SAAAq+H,IACAA,GAAAC,YAEApkG,GAAA9rC,QAAA,SAAAuR,GACA,GAAAA,EAAA/C,KAAAoe,MAAA,CACA,GAAA6qF,GAAAlmG,EAAA6gG,IACAt1F,EAAA26F,EAAAnhG,KACAk5G,IAAA/X,EAAA63B,GACAxyH,EAAAlN,UAAAkN,EAAAg5G,gBAAAh5G,EAAAi5G,mBAAA,GACAte,EAAArjG,iBAAA47G,GAAAvY,EAAA+d,QAAA,QAAA32F,GAAAh4B,GACAA,IAAA,aAAAqxC,KAAArxC,EAAAspI,gBACA14B,EAAA1jG,oBAAAi8G,GAAAnxF,GACA44E,EAAA+d,QAAA,KACA9F,GAAAjY,EAAA63B,WAOAhpG,SACA0pG,QAAA,SAAAv4B,EAAA63B,GAEA,IAAA3E,GACA,QAGA,IAAA/rI,KAAAwxI,SACA,MAAAxxI,MAAAwxI,QAOA,IAAAC,GAAA54B,EAAAyrB,WACAzrB,GAAAgR,oBACAhR,EAAAgR,mBAAAzoH,QAAA,SAAAuoH,GAAsDyG,GAAAqhB,EAAA9nB,KAEtDwG,GAAAshB,EAAAf,GACAe,EAAA/5H,MAAAy4H,QAAA,OACAnwI,KAAA+4G,IAAAj/F,YAAA23H,EACA,IAAA3jC,GAAAmjB,GAAAwgB,EAEA,OADAzxI,MAAA+4G,IAAA3+F,YAAAq3H,GACAzxI,KAAAwxI,SAAA1jC,EAAAokB,gBAiCAwf,IACA7nH,cACA8mH,mBAMArtB,IAAA5hH,OAAA8/G,eACA8B,GAAA5hH,OAAA4+G,iBACAgD,GAAA5hH,OAAAsjI,kBACA1hB,GAAA5hH,OAAA2+G,mBACAiD,GAAA5hH,OAAAqkH,oBAGAvpG,EAAA8mG,GAAA1f,QAAA0N,WAAA++B,IACA7zH,EAAA8mG,GAAA1f,QAAAmf,WAAA2uB,IAGApuB,GAAAnjH,UAAAipI,UAAAp7B,GAAAs+B,GAAAx5H,EAGAwwG,GAAAnjH,UAAA+nI,OAAA,SACArvB,EACAC,GAGA,MADAD,MAAA7K,GAAAmY,GAAAtN,OAAA7jF,GACA4jF,GAAA54G,KAAA64G,EAAAC,IAKAxyG,WAAA,WACA5E,GAAA25G,UACAA,IACAA,GAAAtrF,KAAA,OAAAuzF,KAkBC,EAaD,IAkMAquB,IAlMA1Z,KAAAjqB,IARA,SAAA4jC,EAAAC,GACA,GAAAC,GAAA9+H,SAAAM,cAAA,MAEA,OADAw+H,GAAAr4H,UAAA,WAAAm4H,EAAA,MACAE,EAAAr4H,UAAA9Q,QAAAkpI,GAAA,GAKA,cAIAra,GAAA,wBACAua,GAAA,yBAEAxa,GAAArrB,EAAA,SAAAmrB,GACA,GAAA5yC,GAAA4yC,EAAA,GAAAr1E,QAAA+vF,GAAA,QACAC,EAAA3a,EAAA,GAAAr1E,QAAA+vF,GAAA,OACA,WAAA7vF,QAAAuiC,EAAA,gBAAAutD,EAAA,OAmEAC,IACA5S,YAAA,eACA3H,iBACAE,YAyCAsa,IACA7S,YAAA,eACA3H,cAAAG,GACAD,QAAAG,IAGAoa,IACAF,GACAC,IAmBAE,IACAvzB,SACAtuG,QACA6qD,SAKAy9D,GAAAhtB,EACA,6FAMAmtB,GAAAntB,EACA,2DAKA6uB,GAAA7uB,EACA,mSASAwmC,IACA1Z,YAAA,EACA5N,QAAAonB,GACA7gC,WAAA8gC,GACA/W,YACAxC,cACArX,eACAwX,oBACA1Y,iBACAD,mBACAgf,WArqPA,SAAAtU,GACA,MAAAA,GAAA7jH,OAAA,SAAAunE,EAAAv5D,GACA,MAAAu5D,GAAArnE,OAAA8N,EAAAmqH,qBACG57G,KAAA,MAkqPH0uH,KAOAG,IACAC,OAAA,SAAAn3E,GAGA,MAFAu2E,QAAA3+H,SAAAM,cAAA,OACAq+H,GAAAl4H,UAAA2hD,EACAu2E,GAAAt4H,cAgBAm5H,GAAA,kBACAC,GAAA,QACAC,IAEA,aAAAnyI,OAEA,aAAAA,OAEA,iBAAAA,QAEAi6H,GAAA,GAAAt4E,QACA,QAAAswF,GAAAjyI,OACA,WAAAkyI,GAAAlyI,OAAA,WACAmyI,GAAAjvH,KAAA,YAKAkvH,GAAA,wBACAC,GAAA,OAAAD,GAAA,QAAAA,GAAA,IACArY,GAAA,GAAAp4E,QAAA,KAAA0wF,IACArY,GAAA,aACAf,GAAA,GAAAt3E,QAAA,QAAA0wF,GAAA,UACA1Y,GAAA,qBACAN,GAAA,QACAG,GAAA,QAEAa,IAAA,CACA,KAAA54E,QAAA,kBAAA9sC,EAAA2I,GACA+8G,GAAA,KAAA/8G,GAIA,IAkSAu9G,IACA/D,GACAmE,GACAC,GACAC,GACAR,GACAI,GACAC,GAwjBA4D,GACAG,GAl2BArG,GAAAptB,EAAA,4BACAwtB,MAEAjB,IACAya,OAAO,IACPC,OAAO,IACPC,SAAS,IACTC,QAAQ,IACRC,QAAQ,MAER9a,GAAA,wBACAD,GAAA,4BAGAgb,GAAArnC,EAAA,mBACA4tB,GAAA,SAAAlmB,EAAAn4C,GAAqD,MAAAm4C,IAAA2/B,GAAA3/B,IAAA,OAAAn4C,EAAA,IAuQrDyjE,GAAA,YACAN,GAAA,YACAX,GAAA,2BACAG,GAAA,6CAEAgB,GAAA,SACAJ,GAAA,cACAD,GAAA,WAEAjB,GAAAvxB,EAAAomC,GAAAC,QAgiBAvT,GAAA,eACAC,GAAA,UAoCAG,GAAAlzB,EAAAuzB,IA4HAY,GAAA,+CACAF,GAAA,+FAGAhf,IACAgyB,IAAA,GACAC,IAAA,EACAljI,MAAA,GACAwD,MAAA,GACA2/H,GAAA,GACAliI,KAAA,GACAC,MAAA,GACAkiI,KAAA,GACAzI,QAAA,OAMA0I,GAAA,SAAApV,GAAqC,YAAAA,EAAA,iBAErCoC,IACA1zH,KAAA,4BACA2mI,QAAA,2BACAzpI,KAAAwpI,GAAA,0CACAE,KAAAF,GAAA,mBACAlhG,MAAAkhG,GAAA,oBACAG,IAAAH,GAAA,kBACAI,KAAAJ,GAAA,mBACApiI,KAAAoiI,GAAA,6CACAK,OAAAL,GAAA,6CACAniI,MAAAmiI,GAAA,8CA4GAM,IACA/+H,MACAxQ,KAAAs8H,GACAkT,MAAAhhI,GAKAkuH,GAAA,SAAAp9B,GACA5jG,KAAA4jG,UACA5jG,KAAAqrH,KAAAznB,EAAAynB,MAAAR,GACA7qH,KAAAw7H,WAAA1Q,GAAAlnB,EAAAmnB,QAAA,iBACA/qH,KAAAsiI,WAAAxX,GAAAlnB,EAAAmnB,QAAA,WACA/qH,KAAAsxG,WAAA90F,OAAoCq3H,IAAAjwC,EAAA0N,WACpC,IAAAgP,GAAA1c,EAAA0c,eAAAwY,EACA94H,MAAAsjI,eAAA,SAAAzqB,GAAuC,OAAAyH,EAAAzH,EAAAtF,MACvCvzG,KAAA8hI,OAAA,EACA9hI,KAAA8jG,oBAoqBAiwC,IArPA,GAAA7xF,QAAA,uMAIA5vC,MAAA,KAAAmR,KAAA,kBAGA,GAAAy+B,QAAA,2BAEA5vC,MAAA,KAAAmR,KAAA,8CAqLA,SAAAuwH,GACA,gBAAA3B,GACA,QAAApO,GACAnJ,EACAl3B,GAEA,GAAAqwC,GAAAtxI,OAAAR,OAAAkwI,GACAprI,KACAitI,IAKA,IAJAD,EAAA5oB,KAAA,SAAAtkH,EAAAotI,IACAA,EAAAD,EAAAjtI,GAAAmB,KAAArB,IAGA68F,EAAA,CAEAA,EAAAmnB,UACAkpB,EAAAlpB,SACAsnB,EAAAtnB,aAAA3jH,OAAAw8F,EAAAmnB,UAGAnnB,EAAA0N,aACA2iC,EAAA3iC,WAAA90F,EACA7Z,OAAAR,OAAAkwI,EAAA/gC,YACA1N,EAAA0N,YAIA,QAAA/6F,KAAAqtF,GACA,YAAArtF,GAAA,eAAAA,IACA09H,EAAA19H,GAAAqtF,EAAArtF,IAKA,GAAA2tH,GAAA8P,EAAAlZ,EAAAmZ,EAMA,OAFA/P,GAAAj9H,SACAi9H,EAAAgQ,OACAhQ,EAGA,OACAD,UACAmQ,mBAAApQ,GAAAC,MAUA,SACAnJ,EACAl3B,GAEA,GAAAm9B,GAAAr+G,GAAAo4G,EAAAzoH,OAAAuxF,EACAs7B,IAAA6B,EAAAn9B,EACA,IAAArpB,GAAAumD,GAAAC,EAAAn9B,EACA,QACAm9B,MACAl9B,OAAAtpB,EAAAspB,OACAC,gBAAAvpB,EAAAupB,oBAMAuwC,GAAAN,GAAA1B,IACA+B,GAAAC,GAAAD,mBAIAE,GAAApoC,EAAA,SAAApwF,GACA,GAAA+8F,GAAAsN,GAAArqG,EACA,OAAA+8F,MAAAp/F,YAGA86H,GAAAjxB,GAAAnjH,UAAA+nI,MACA5kB,IAAAnjH,UAAA+nI,OAAA,SACArvB,EACAC,GAKA,IAHAD,KAAAsN,GAAAtN,MAGA7lG,SAAAq+H,MAAAx4B,IAAA7lG,SAAAK,gBAIA,MAAArT,KAGA,IAAA4jG,GAAA5jG,KAAA+yG,QAEA,KAAAnP,EAAAC,OAAA,CACA,GAAAi3B,GAAAl3B,EAAAk3B,QACA,IAAAA,EACA,mBAAAA,GACA,MAAAA,EAAAv/E,OAAA,KACAu/E,EAAAwZ,GAAAxZ,QASO,KAAAA,EAAAnI,SAMP,MAAA3yH,KALA86H,KAAArhH,cAOKo/F,KACLiiB,EAAAsJ,GAAAvrB,GAEA,IAAAiiB,EAAA,CAMA,GAAA9T,GAAAotB,GAAAtZ,GACA7C,wBACAZ,WAAAzzB,EAAAyzB,WACAwE,SAAAj4B,EAAAi4B,UACO77H,MACP6jG,EAAAmjB,EAAAnjB,OACAC,EAAAkjB,EAAAljB,eACAF,GAAAC,SACAD,EAAAE,mBASA,MAAAywC,IAAA1zI,KAAAb,KAAA64G,EAAAC,IAiBAwK,GAAA2gB,QAAAmQ,GAEAppC,EAAA,O1C4moB6BnqG,KAAKmqG,EAAqBtrG,EAAoB,MAIrE,SAAUF,EAAQC,EAASC,GAEjC,Y2Cr97BA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAmJ,EAAAnJ,EAAA,IAIA+pG,EAAA,SAAAxmG,GAEA,QAAAwmG,GAAAhhF,GACAxlB,EAAApC,KAAAb,MACAA,KAAAyoB,SA8BA,MAjCArmB,GAAAqnG,EAAAxmG,GAKAN,OAAAi+F,eAAA6I,EAAAtpG,UAAA,SACAuS,IAAA,WACA,MAAA1S,MAAA41H,YAEAroB,YAAA,EACAE,cAAA,IAEAhE,EAAAtpG,UAAAD,WAAA,SAAAgC,GACA,GAAAH,GAAAkB,EAAA9C,UAAAD,WAAAW,KAAAb,KAAAkC,EAIA,OAHAH,OAAA8B,QACA3B,EAAAb,KAAArB,KAAAyoB,QAEA1mB,GAEA0nG,EAAAtpG,UAAAy1H,SAAA,WACA,GAAA51H,KAAAkJ,SACA,KAAAlJ,MAAAmJ,WAEA,IAAAnJ,KAAA6D,OACA,SAAAgF,GAAAS,uBAGA,OAAAtJ,MAAAyoB,QAGAghF,EAAAtpG,UAAAkB,KAAA,SAAAW,GACAiB,EAAA9C,UAAAkB,KAAAR,KAAAb,UAAAyoB,OAAAzmB,IAEAynG,GACChF,EAAAz7F,QACDvJ,GAAAgqG,mB3C497BM,SAAUjqG,EAAQC,EAASC,GAEjC,Y4C5g8BAD,GAAA8D,OACAM,QAAA,EACAxC,KAAA,SAAAW,KACAvB,MAAA,SAAAU,GAA2B,KAAAA,IAC3BT,SAAA,e5Coh8BM,SAAUlB,EAAQC,EAASC,GAEjC,Y6C1h8BA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAM,EAAAnD,EAAA,GAMA+J,EAAA,SAAAxG,GAEA,QAAAwG,GAAAL,EAAAlH,GACAe,EAAApC,KAAAb,MACAA,KAAAoJ,UACApJ,KAAAkC,aACAlC,KAAA6D,QAAA,EAkBA,MAvBAzB,GAAAqH,EAAAxG,GAOAwG,EAAAtJ,UAAA8B,YAAA,WACA,IAAAjC,KAAA6D,OAAA,CAGA7D,KAAA6D,QAAA,CACA,IAAAuF,GAAApJ,KAAAoJ,QACAH,EAAAG,EAAAH,SAEA,IADAjJ,KAAAoJ,QAAA,KACAH,GAAA,IAAAA,EAAA5F,SAAA+F,EAAAjG,YAAAiG,EAAAvF,OAAA,CAGA,GAAA2wI,GAAAvrI,EAAAN,QAAA3I,KAAAkC,aACA,IAAAsyI,GACAvrI,EAAAL,OAAA4rI,EAAA,MAGA/qI,GACC5G,EAAAqB,aACDzE,GAAAgK,uB7Cii8BM,SAAUjK,EAAQC,EAASC,GAEjC,Y8Cxk8BA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAoG,EAAApG,EAAA,GACAoF,EAAApF,EAAA,GACAmD,EAAAnD,EAAA,GAIAgqG,EAAA,SAAAzmG,GAEA,QAAAymG,GAAAnpG,EAAAyL,GACA/I,EAAApC,KAAAb,MACAA,KAAAO,SACAP,KAAAgM,iBACAhM,KAAAy0I,UAAA,EACAz0I,KAAA00I,aAAA,EAgCA,MAtCAtyI,GAAAsnG,EAAAzmG,GAQAymG,EAAAvpG,UAAAD,WAAA,SAAAgC,GACA,MAAAlC,MAAA20I,aAAA50I,UAAAmC,IAEAwnG,EAAAvpG,UAAAw0I,WAAA,WACA,GAAAvrI,GAAApJ,KAAA40I,QAIA,OAHAxrI,OAAAjG,YACAnD,KAAA40I,SAAA50I,KAAAgM,kBAEAhM,KAAA40I,UAEAlrC,EAAAvpG,UAAA00I,QAAA,WACA,GAAAC,GAAA90I,KAAA+0I,WAcA,OAbAD,KACA90I,KAAA00I,aAAA,EACAI,EAAA90I,KAAA+0I,YAAA,GAAAlyI,GAAAqB,aACA4wI,EAAAh0I,IAAAd,KAAAO,OACAR,UAAA,GAAAi1I,GAAAh1I,KAAA20I,aAAA30I,QACA80I,EAAAjxI,QACA7D,KAAA+0I,YAAA,KACAD,EAAAjyI,EAAAqB,aAAAoE,OAGAtI,KAAA+0I,YAAAD,GAGAA,GAEAprC,EAAAvpG,UAAA80I,SAAA,WACA,MAAAj1I,MAAAI,KAAA,GAAA80I,GAAAl1I,QAEA0pG,GACC5jG,EAAAhG,WACDL,GAAAiqG,uBACA,IAAAyrC,GAAAzrC,EAAAvpG,SACAV,GAAA2M,iCACA/L,UAAe2B,MAAA,MACfyyI,WAAgBzyI,MAAA,EAAAwrG,UAAA,GAChBonC,UAAe5yI,MAAA,KAAAwrG,UAAA,GACfunC,aAAkB/yI,MAAA,KAAAwrG,UAAA,GAClBttG,YAAiB8B,MAAAmzI,EAAAj1I,YACjBw0I,aAAkB1yI,MAAAmzI,EAAAT,YAAAlnC,UAAA,GAClBmnC,YAAiB3yI,MAAAmzI,EAAAR,YACjBE,SAAc7yI,MAAAmzI,EAAAN,SACdI,UAAejzI,MAAAmzI,EAAAF,UAEf,IAAAD,GAAA,SAAA/xI,GAEA,QAAA+xI,GAAA1xI,EAAA4I,GACAjJ,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAkM,cAwBA,MA3BA9J,GAAA4yI,EAAA/xI,GAKA+xI,EAAA70I,UAAAwD,OAAA,SAAAxC,GACAnB,KAAA6E,eACA5B,EAAA9C,UAAAwD,OAAA9C,KAAAb,KAAAmB,IAEA6zI,EAAA70I,UAAAyD,UAAA,WACA5D,KAAAkM,YAAAwoI,aAAA,EACA10I,KAAA6E,eACA5B,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEAg1I,EAAA70I,UAAA0E,aAAA,WACA,GAAAqH,GAAAlM,KAAAkM,WACA,IAAAA,EAAA,CACAlM,KAAAkM,YAAA,IACA,IAAA4oI,GAAA5oI,EAAA6oI,WACA7oI,GAAAuoI,UAAA,EACAvoI,EAAA0oI,SAAA,KACA1oI,EAAA6oI,YAAA,KACAD,GACAA,EAAA7yI,gBAIA+yI,GACCvwC,EAAA17F,mBACDmsI,EAAA,WACA,QAAAA,GAAAhpI,GACAlM,KAAAkM,cAYA,MAVAgpI,GAAA/0I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,GAAA2L,GAAAlM,KAAAkM,WACAA,GAAAuoI,WACA,IAAAW,GAAA,GAAAC,GAAAnzI,EAAAgK,GACAnK,EAAAxB,EAAAR,UAAAq1I,EAIA,OAHAA,GAAAvxI,SACAuxI,EAAAN,WAAA5oI,EAAA2oI,WAEA9yI,GAEAmzI,KAEAG,EAAA,SAAApyI,GAEA,QAAAoyI,GAAA/xI,EAAA4I,GACAjJ,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAkM,cAiDA,MApDA9J,GAAAizI,EAAApyI,GAKAoyI,EAAAl1I,UAAA0E,aAAA,WACA,GAAAqH,GAAAlM,KAAAkM,WACA,KAAAA,EAEA,YADAlM,KAAA80I,WAAA,KAGA90I,MAAAkM,YAAA,IACA,IAAA+oI,GAAA/oI,EAAAuoI,SACA,IAAAQ,GAAA,EAEA,YADAj1I,KAAA80I,WAAA,KAIA,IADA5oI,EAAAuoI,UAAAQ,EAAA,EACAA,EAAA,EAEA,YADAj1I,KAAA80I,WAAA,KA0BA,IAAAA,GAAA90I,KAAA80I,WACAQ,EAAAppI,EAAA6oI,WACA/0I,MAAA80I,WAAA,MACAQ,GAAAR,GAAAQ,IAAAR,GACAQ,EAAArzI,eAGAozI,GACCvwI,EAAA9B,a9C+k8BK,SAAUxD,EAAQC,EAASC,GAEjC,Y+Cvv8BA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAgF,EAAA7H,EAAA,IACAqG,EAAArG,EAAA,IACAyG,EAAAzG,EAAA,IACA61I,EAAA71I,EAAA,IACA81I,EAAA91I,EAAA,KACAonG,EAAApnG,EAAA,IACA+1I,EAAA/1I,EAAA,KACA6G,EAAA7G,EAAA,IACAoG,EAAApG,EAAA,GACAolG,EAAAplG,EAAA,IACAG,EAAAH,EAAA,IAMAg2I,EAAA,SAAAzyI,GAEA,QAAAyyI,GAAAC,EAAA5qI,GACA9H,EAAApC,KAAAb,KAAA,MACAA,KAAA21I,MACA31I,KAAA+K,YA2FA,MA/FA3I,GAAAszI,EAAAzyI,GA8DAyyI,EAAAvzI,OAAA,SAAAwzI,EAAA5qI,GACA,SAAA4qI,EAAA,CACA,qBAAAA,GAAA91I,EAAAS,YACA,MAAAq1I,aAAA7vI,GAAAhG,aAAAiL,EACA4qI,EAEA,GAAAD,GAAAC,EAAA5qI,EAEA,IAAAxD,EAAAW,QAAAytI,GACA,UAAA7uC,GAAAj8F,gBAAA8qI,EAAA5qI,EAEA,IAAA5E,EAAAC,UAAAuvI,GACA,UAAAJ,GAAAK,kBAAAD,EAAA5qI,EAEA,sBAAA4qI,GAAApvI,EAAAC,WAAA,gBAAAmvI,GACA,UAAAH,GAAAK,mBAAAF,EAAA5qI,EAEA,IAAAhF,EAAAC,YAAA2vI,GACA,UAAAF,GAAAK,oBAAAH,EAAA5qI,GAGA,SAAAnE,YAAA,OAAA+uI,gBAAA,uBAEAD,EAAAv1I,UAAAD,WAAA,SAAAgC,GACA,GAAAyzI,GAAA31I,KAAA21I,IACA5qI,EAAA/K,KAAA+K,SACA,cAAAA,EACA4qI,EAAA91I,EAAAS,cAAAP,UAAAmC,GAGAyzI,EAAA91I,EAAAS,cAAAP,UAAA,GAAA+kG,GAAAY,oBAAAxjG,EAAA6I,EAAA,KAGA2qI,GACC5vI,EAAAhG,WACDL,GAAAi2I,kB/C8v8BM,SAAUl2I,EAAQC,EAASC,GAEjC,YgD7w8BA,SAAAq2I,GAAAnqI,GACA,GAAA5J,GAAA4J,EAAA5J,MAAAE,EAAA0J,EAAA1J,UACAA,GAAA2B,SACA3B,EAAAb,KAAAW,GACAE,EAAAxB,YAGA,QAAAs1I,GAAApqI,GACA,GAAAzK,GAAAyK,EAAAzK,IAAAe,EAAA0J,EAAA1J,UACAA,GAAA2B,QACA3B,EAAAzB,MAAAU,GApHA,GAAAiB,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA5C,EAAAD,EAAA,GACAoG,EAAApG,EAAA,GAMAk2I,EAAA,SAAA3yI,GAEA,QAAA2yI,GAAAK,EAAAlrI,GACA9H,EAAApC,KAAAb,MACAA,KAAAi2I,UACAj2I,KAAA+K,YAsFA,MA1FA3I,GAAAwzI,EAAA3yI,GAgCA2yI,EAAAzzI,OAAA,SAAA8zI,EAAAlrI,GACA,UAAA6qI,GAAAK,EAAAlrI,IAEA6qI,EAAAz1I,UAAAD,WAAA,SAAAgC,GACA,GAAAX,GAAAvB,KACAi2I,EAAAj2I,KAAAi2I,QACAlrI,EAAA/K,KAAA+K,SACA,UAAAA,EACA/K,KAAAC,UACAiC,EAAA2B,SACA3B,EAAAb,KAAArB,KAAAgC,OACAE,EAAAxB,YAIAu1I,EAAA5vI,KAAA,SAAArE,GACAT,EAAAS,QACAT,EAAAtB,WAAA,EACAiC,EAAA2B,SACA3B,EAAAb,KAAAW,GACAE,EAAAxB,aAEiB,SAAAS,GACjBe,EAAA2B,QACA3B,EAAAzB,MAAAU,KAGAkF,KAAA,cAAAlF,GAEAxB,EAAA6B,KAAA8E,WAAA,WAAwD,KAAAnF,WAKxD,IAAAnB,KAAAC,WACA,IAAAiC,EAAA2B,OACA,MAAAkH,GAAAU,SAAAsqI,EAAA,GAAgE/zI,MAAAhC,KAAAgC,MAAAE,mBAIhE+zI,GAAA5vI,KAAA,SAAArE,GACAT,EAAAS,QACAT,EAAAtB,WAAA,EACAiC,EAAA2B,QACA3B,EAAApB,IAAAiK,EAAAU,SAAAsqI,EAAA,GAA4E/zI,QAAAE,iBAE3D,SAAAf,GACjBe,EAAA2B,QACA3B,EAAApB,IAAAiK,EAAAU,SAAAuqI,EAAA,GAA6E70I,MAAAe,kBAG7EmE,KAAA,cAAAlF,GAEAxB,EAAA6B,KAAA8E,WAAA,WAAwD,KAAAnF,QAKxDy0I,GACC9vI,EAAAhG,WACDL,GAAAm2I,qBhD248BM,SAAUp2I,EAAQC,EAASC,GAEjC,YiD3+8BA,SAAAw2I,KACA,GAAAv2I,EAAA6B,KAAAmiF,eACA,UAAAhkF,GAAA6B,KAAAmiF,cAEA,IAAAhkF,EAAA6B,KAAAsiF,eACA,UAAAnkF,GAAA6B,KAAAsiF,cAGA,UAAAliF,OAAA,yCAGA,QAAAu0I,KACA,GAAAx2I,EAAA6B,KAAAmiF,eACA,UAAAhkF,GAAA6B,KAAAmiF,cAGA,IAAAyyD,OAAA,EACA,KAEA,OADAC,IAAA,2DACApwI,EAAA,EAA2BA,EAAA,EAAOA,IAClC,IAEA,GADAmwI,EAAAC,EAAApwI,GACA,GAAAtG,GAAA6B,KAAA80I,cAAAF,GACA,MAGA,MAAAnuI,IAGA,UAAAtI,GAAA6B,KAAA80I,cAAAF,GAEA,MAAAnuI,GACA,SAAArG,OAAA,oDAIA,QAAA20I,GAAAjzD,EAAAI,GAEA,WADA,KAAAA,IAA6BA,EAAA,MAC7B,GAAA8yD,IAA+BhyD,OAAA,MAAAlB,MAAAI,YAI/B,QAAA+yD,GAAAnzD,EAAA+tD,EAAA3tD,GACA,UAAA8yD,IAA+BhyD,OAAA,OAAAlB,MAAA+tD,OAAA3tD,YAI/B,QAAAgzD,GAAApzD,EAAAI,GACA,UAAA8yD,IAA+BhyD,OAAA,SAAAlB,MAAAI,YAI/B,QAAAizD,GAAArzD,EAAA+tD,EAAA3tD,GACA,UAAA8yD,IAA+BhyD,OAAA,MAAAlB,MAAA+tD,OAAA3tD,YAI/B,QAAAkzD,GAAAtzD,EAAA+tD,EAAA3tD,GACA,UAAA8yD,IAA+BhyD,OAAA,QAAAlB,MAAA+tD,OAAA3tD,YAI/B,QAAAmzD,GAAAvzD,EAAAI,GACA,UAAA8yD,IAA+BhyD,OAAA,MAAAlB,MAAApuC,aAAA,OAAAwuC,YAC/BtjF,KAAA,GAAA02I,GAAAtvC,YAAA,SAAA77F,EAAA/D,GAAyD,MAAA+D,GAAAwpC,UAAqB,OA3E9E,GAAA/yC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA5C,EAAAD,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAoG,EAAApG,EAAA,GACAoF,EAAApF,EAAA,GACAo3I,EAAAp3I,EAAA,GAyCAD,GAAA82I,UAKA92I,EAAAg3I,WAKAh3I,EAAAi3I,aAKAj3I,EAAAk3I,UAKAl3I,EAAAm3I,YAMAn3I,EAAAo3I,aAOA,IAAAL,GAAA,SAAAvzI,GAEA,QAAAuzI,GAAAO,GACA9zI,EAAApC,KAAAb,KACA,IAAAqjF,IACA94E,OAAA,EACAysI,UAAA,WACA,MAAAh3I,MAAAi3I,YAAAf,EAAAr1I,KAAAb,MAAAm2I,KAEAc,aAAA,EACAC,iBAAA,EACAxzD,WACAc,OAAA,MACAtvC,aAAA,OACA1vB,QAAA,EAEA,oBAAAuxH,GACA1zD,EAAAC,IAAAyzD,MAGA,QAAAvkC,KAAAukC,GACAA,EAAAr0I,eAAA8vG,KACAnvB,EAAAmvB,GAAAukC,EAAAvkC,GAIAxyG,MAAAqjF,UA2CA,MApEAjhF,GAAAo0I,EAAAvzI,GA2BAuzI,EAAAr2I,UAAAD,WAAA,SAAAgC,GACA,UAAAi1I,GAAAj1I,EAAAlC,KAAAqjF,UA4BAmzD,EAAAr0I,OAAA,WACA,GAAAA,GAAA,SAAA40I,GACA,UAAAP,GAAAO,GAQA,OANA50I,GAAAuQ,IAAA6jI,EACAp0I,EAAAoiF,KAAAkyD,EACAt0I,EAAA0oI,OAAA6L,EACAv0I,EAAAi1I,IAAAT,EACAx0I,EAAAmqI,MAAAsK,EACAz0I,EAAAk1I,QAAAR,EACA10I,KAEAq0I,GACC1wI,EAAAhG,WACDL,GAAA+2I,gBAMA,IAAAW,GAAA,SAAAl0I,GAEA,QAAAk0I,GAAA7zI,EAAA+/E,GACApgF,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAqjF,UACArjF,KAAA0G,MAAA,CACA,IAAAg9E,GAAAL,EAAAK,QAAAL,EAAAK,WAEAL,GAAA4zD,aAAAvzD,EAAA,sBACAA,EAAA,sCAGA,gBAAAA,IAAA/jF,EAAA6B,KAAA81I,UAAAj0D,EAAAguD,eAAA1xI,GAAA6B,KAAA81I,cAAA,KAAAj0D,EAAAguD,OACA3tD,EAAA,oEAGAL,EAAAguD,KAAArxI,KAAAu3I,cAAAl0D,EAAAguD,KAAAhuD,EAAAK,QAAA,iBACA1jF,KAAAskF,OAoKA,MApLAliF,GAAA+0I,EAAAl0I,GAkBAk0I,EAAAh3I,UAAAkB,KAAA,SAAA4G,GACAjI,KAAA0G,MAAA,CACA,IAAA3C,GAAA/D,KAAAg1C,EAAAjxC,EAAAixC,IAAAquC,EAAAt/E,EAAAs/E,QAAA//E,EAAAS,EAAAT,YACA6xC,EAAA,GAAAq1D,GAAAviG,EAAA+sC,EAAAquC,EACA//E,GAAAjC,KAAA8zC,IAEAgiG,EAAAh3I,UAAAmkF,KAAA,WACA,GAAAvgF,GAAA/D,KAAAqjF,EAAAt/E,EAAAs/E,QAAAymD,EAAA/lI,EAAAs/E,QAAAO,EAAAkmD,EAAAlmD,KAAAY,EAAAslD,EAAAtlD,OAAAlB,EAAAwmD,EAAAxmD,IAAA/4E,EAAAu/H,EAAAv/H,MAAAs5E,EAAAimD,EAAAjmD,SAAAH,EAAAomD,EAAApmD,QAAA2tD,EAAAvH,EAAAuH,KACA2F,EAAA3zD,EAAA2zD,UACAhiG,EAAAxtC,EAAAO,SAAAivI,GAAAn2I,KAAAwiF,EACA,IAAAruC,IAAAvtC,EAAAO,YACAhI,KAAAS,MAAAgH,EAAAO,YAAAC,OAEA,CACAjI,KAAAg1C,MAKAh1C,KAAAw3I,YAAAxiG,EAAAquC,EASA,KANAO,EACAp8E,EAAAO,SAAAitC,EAAAyvC,MAAA5jF,KAAAm0C,EAAAwvC,EAAAlB,EAAA/4E,EAAAq5E,EAAAC,GAGAr8E,EAAAO,SAAAitC,EAAAyvC,MAAA5jF,KAAAm0C,EAAAwvC,EAAAlB,EAAA/4E,MAEA9C,EAAAO,YAEA,MADAhI,MAAAS,MAAAgH,EAAAO,YAAAC,GACA,IAcA,IAXAsC,IACAyqC,EAAAxvB,QAAA69D,EAAA79D,QACAwvB,EAAAE,aAAAmuC,EAAAnuC,cAEA,mBAAAF,KACAA,EAAAkiG,kBAAA7zD,EAAA6zD,iBAGAl3I,KAAAy3I,WAAAziG,EAAA0uC,IAEA2tD,EAAA7pI,EAAAO,SAAAitC,EAAAsvC,MAAAzjF,KAAAm0C,EAAAq8F,GAAA7pI,EAAAO,SAAAitC,EAAAsvC,MAAAzjF,KAAAm0C,MACAvtC,EAAAO,YAEA,MADAhI,MAAAS,MAAAgH,EAAAO,YAAAC,GACA,KAGA,MAAA+sC,IAEAmiG,EAAAh3I,UAAAo3I,cAAA,SAAAlG,EAAAqG,GACA,IAAArG,GAAA,gBAAAA,GACA,MAAAA,EAEA,IAAA1xI,EAAA6B,KAAA81I,UAAAjG,YAAA1xI,GAAA6B,KAAA81I,SACA,MAAAjG,EAEA,IAAAqG,EAAA,CACA,GAAAC,GAAAD,EAAA/uI,QAAA,MACA,IAAAgvI,IACAD,IAAAziE,UAAA,EAAA0iE,IAGA,OAAAD,GACA,wCACA,MAAA/0I,QAAA8rE,KAAA4iE,GAAA9+H,IAAA,SAAAgE,GAA6D,MAAAqhI,WAAArhI,GAAA,IAAAqhI,UAAAvG,EAAA96H,MAAwDkN,KAAA,IACrH,wBACA,MAAAyP,MAAAC,UAAAk+G,EACA,SACA,MAAAA,KAGA8F,EAAAh3I,UAAAs3I,WAAA,SAAAziG,EAAA0uC,GACA,OAAAntE,KAAAmtE,GACAA,EAAAhhF,eAAA6T,IACAy+B,EAAA0vC,iBAAAnuE,EAAAmtE,EAAAntE,KAIA4gI,EAAAh3I,UAAAq3I,YAAA,SAAAxiG,EAAAquC,GAEA,QAAAw0D,GAAA5vI,GACA,GAAAlE,GAAA8zI,EAAA31I,EAAA6B,EAAA7B,WAAA41I,EAAA/zI,EAAA+zI,mBAAAz0D,EAAAt/E,EAAAs/E,OACAy0D,IACAA,EAAAr3I,MAAAwH,GAEA/F,EAAAzB,MAAA,GAAAiqG,GAAA1qG,KAAAqjF,IAmCA,QAAA00D,GAAA9vI,GACA,GAAAlE,GAAAg0I,EAAA71I,EAAA6B,EAAA7B,WAAA41I,EAAA/zI,EAAA+zI,mBAAAz0D,EAAAt/E,EAAAs/E,OACA,QAAArjF,KAAAmkF,WAAA,CAEA,GAAA6zD,GAAA,OAAAh4I,KAAAwjF,OAAA,IAAAxjF,KAAAwjF,OACAruC,EAAA,SAAAn1C,KAAAk1C,aAAAl1C,KAAAm1C,UAAAn1C,KAAAo1C,aAAAp1C,KAAAm1C,QAIA,KAAA6iG,IACAA,EAAA7iG,EAAA,OAEA,KAAA6iG,KAAA,KACAF,GACAA,EAAAp3I,WAEAwB,EAAAb,KAAA4G,GACA/F,EAAAxB,aAGAo3I,GACAA,EAAAr3I,MAAAwH,GAEA/F,EAAAzB,MAAA,GAAAgqG,GAAA,cAAAutC,EAAAh4I,KAAAqjF,MAhEA,GAAAy0D,GAAAz0D,EAAAy0D,kBAaA,IAJA9iG,EAAAivC,UAAA4zD,EACAA,EAAAx0D,UACAw0D,EAAA31I,WAAAlC,KACA63I,EAAAC,qBACA9iG,EAAAijG,QAAA,mBAAAjjG,GAAA,CACA,GAAA8iG,EAAA,CACA,GAAAI,EACAA,GAAA,SAAAjwI,GACAiwI,EAAAJ,mBACAz2I,KAAA4G,IAEAtI,EAAA6B,KAAAsiF,eACA9uC,EAAAovC,WAAA8zD,EAGAljG,EAAAijG,OAAA7zD,WAAA8zD,EAEAA,EAAAJ,qBAEA,GAAAK,EACAA,GAAA,SAAAlwI,GACA,GAAAlE,GAAAo0I,EAAAL,EAAA/zI,EAAA+zI,mBAAA51I,EAAA6B,EAAA7B,WAAAmhF,EAAAt/E,EAAAs/E,OACAy0D,IACAA,EAAAr3I,MAAAwH,GAEA/F,EAAAzB,MAAA,GAAAgqG,GAAA,aAAAzqG,KAAAqjF,KAEAruC,EAAAgvC,QAAAm0D,EACAA,EAAA90D,UACA80D,EAAAj2I,WAAAlC,KACAm4I,EAAAL,qBA8BA9iG,EAAAkvC,mBAAA6zD,EACAA,EAAA71I,WAAAlC,KACA+3I,EAAAD,qBACAC,EAAA10D,WAEA8zD,EAAAh3I,UAAA8B,YAAA,WACA,GAAA8B,GAAA/D,KAAA0G,EAAA3C,EAAA2C,KAAAsuC,EAAAjxC,EAAAixC,KACAtuC,GAAAsuC,GAAA,IAAAA,EAAAmvC,YAAA,kBAAAnvC,GAAAN,OACAM,EAAAN,QAEAzxC,EAAA9C,UAAA8B,YAAApB,KAAAb,OAEAm3I,GACCryI,EAAA9B,WACDvD,GAAA03I,gBAQA,IAAA3sC,GAAA,WACA,QAAAA,GAAA4tC,EAAApjG,EAAAquC,GAMA,OALArjF,KAAAo4I,gBACAp4I,KAAAg1C,MACAh1C,KAAAqjF,UACArjF,KAAAwjF,OAAAxuC,EAAAwuC,OACAxjF,KAAAk1C,aAAAF,EAAAE,cAAAmuC,EAAAnuC,aACAl1C,KAAAk1C,cACA,WAGAl1C,KAAAm1C,SAFA,YAAAH,GAEAA,EAAAE,aAAAF,EAAAG,SAAAjiB,KAAAxQ,MAAAsyB,EAAAG,UAAAH,EAAAI,cAAA,QAGAliB,KAAAxQ,MAAAsyB,EAAAI,cAAA,OAEA,MACA,WACAp1C,KAAAm1C,SAAAH,EAAAiwC,WACA,MACA,YACA,QACAjlF,KAAAm1C,SAAA,YAAAH,KAAAG,SAAAH,EAAAI,cAIA,MAAAo1D,KAEA/qG,GAAA+qG,cAQA,IAAAC,GAAA,SAAAxnG,GAEA,QAAAwnG,GAAAtH,EAAAnuD,EAAAquC,GACApgF,EAAApC,KAAAb,KAAAmjG,GACAnjG,KAAAmjG,UACAnjG,KAAAg1C,MACAh1C,KAAAqjF,UACArjF,KAAAwjF,OAAAxuC,EAAAwuC,OAEA,MARAphF,GAAAqoG,EAAAxnG,GAQAwnG,GACC7oG,MACDnC,GAAAgrG,WAMA,IAAAC,GAAA,SAAAznG,GAEA,QAAAynG,GAAA11D,EAAAquC,GACApgF,EAAApC,KAAAb,KAAA,eAAAg1C,EAAAquC,GAEA,MAJAjhF,GAAAsoG,EAAAznG,GAIAynG,GACCD,EACDhrG,GAAAirG,oBjD6/8BM,SAAUlrG,EAAQC,EAASC,GAEjC,YkD329BA,SAAA24I,GAAA7mH,EAAA8mH,GACA,MAAAt4I,MAAAI,KAAA,GAAAm4I,GAAA/mH,EAAA8mH,IAjDA,GAAAl2I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,EA4CAD,GAAA44I,sBACA,IAAAE,GAAA,WACA,QAAAA,GAAA/mH,EAAA8mH,GACAt4I,KAAAwxB,UACAxxB,KAAAs4I,cAKA,MAHAC,GAAAp4I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAy4I,GAAAt2I,EAAAlC,KAAAwxB,QAAAxxB,KAAAs4I,eAEAC,KAOAC,EAAA,SAAAv1I,GAEA,QAAAu1I,GAAAl1I,EAAAkuB,EAAA8mH,GACAr1I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAs4I,cACAt4I,KAAAy4I,QAAA,EACA,kBAAAjnH,KACAxxB,KAAAwxB,WA8BA,MApCApvB,GAAAo2I,EAAAv1I,GASAu1I,EAAAr4I,UAAAqxB,QAAA,SAAA7lB,EAAAoC,GACA,MAAApC,KAAAoC,GAEAyqI,EAAAr4I,UAAAuD,MAAA,SAAA1B,GACA,GAAAs2I,GAAAt4I,KAAAs4I,YACA/hI,EAAAvU,CACA,IAAAs2I,IACA/hI,EAAA/O,EAAAO,SAAA/H,KAAAs4I,aAAAt2I,MACAyF,EAAAO,YACA,MAAAhI,MAAAsD,YAAA7C,MAAAgH,EAAAO,YAAAC,EAGA,IAAAtC,IAAA,CACA,IAAA3F,KAAAy4I,QAEA,IADA9yI,EAAA6B,EAAAO,SAAA/H,KAAAwxB,SAAAxxB,KAAAuW,UACA9O,EAAAO,YACA,MAAAhI,MAAAsD,YAAA7C,MAAAgH,EAAAO,YAAAC,OAIAjI,MAAAy4I,QAAA,GAEA,IAAA9lC,QAAAhtG,KACA3F,KAAAuW,MACAvW,KAAAsD,YAAAjC,KAAAW,KAGAw2I,GACC1zI,EAAA9B,alDk69BK,SAAUxD,EAAQC,EAASC,GAEjC,YmD/99BA,SAAA4R,GAAAonI,EAAAnxC,GACA,MAAAvnG,MAAAI,KAAA,GAAAu4I,GAAAD,EAAAnxC,IA/CA,GAAAnlG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EA4CAD,GAAA6R,QACA,IAAAqnI,GAAA,WACA,QAAAA,GAAAD,EAAAnxC,GACAvnG,KAAA04I,YACA14I,KAAAunG,UAKA,MAHAoxC,GAAAx4I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA64I,GAAA12I,EAAAlC,KAAA04I,UAAA14I,KAAAunG,WAEAoxC,KAOAC,EAAA,SAAA31I,GAEA,QAAA21I,GAAAt1I,EAAAo1I,EAAAnxC,GACAtkG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAunG,UACAvnG,KAAAwL,MAAA,EAiBA,MAtBApJ,GAAAw2I,EAAA31I,GASA21I,EAAAz4I,UAAAuD,MAAA,SAAA1B,GACA,GAAA2D,EACA,KACAA,EAAA3F,KAAA04I,UAAA73I,KAAAb,KAAAunG,QAAAvlG,EAAAhC,KAAAwL,SAEA,MAAArK,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAwE,GACA3F,KAAAsD,YAAAjC,KAAAW,IAGA42I,GACC9zI,EAAA9B,anDoh+BK,SAAUxD,EAAQC,EAASC,GAEjC,YoDvk+BA,SAAA01B,GAAAsjH,EAAAnxC,GACA,qBAAAmxC,GACA,SAAA9xI,WAAA,8BAEA,OAAA5G,MAAAI,KAAA,GAAAy4I,GAAAH,EAAA14I,MAAA,EAAAunG,IA5CA,GAAAnlG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAyCAD,GAAA21B,MACA,IAAAyjH,GAAA,WACA,QAAAA,GAAAH,EAAAn4I,EAAAu4I,EAAAvxC,GACAvnG,KAAA04I,YACA14I,KAAAO,SACAP,KAAA84I,aACA94I,KAAAunG,UAKA,MAHAsxC,GAAA14I,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAg5I,GAAA93C,EAAAjhG,KAAA04I,UAAA14I,KAAAO,OAAAP,KAAA84I,WAAA94I,KAAAunG,WAEAsxC,IAEAp5I,GAAAo5I,mBAMA,IAAAE,GAAA,SAAA91I,GAEA,QAAA81I,GAAAz1I,EAAAo1I,EAAAn4I,EAAAu4I,EAAAvxC,GACAtkG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAO,SACAP,KAAA84I,aACA94I,KAAAunG,UACAvnG,KAAA4H,MAAA,EAuBA,MA9BAxF,GAAA22I,EAAA91I,GASA81I,EAAA54I,UAAAqF,eAAA,SAAAxD,GACA,GAAAsB,GAAAtD,KAAAsD,WACAA,GAAAjC,KAAAW,GACAsB,EAAA5C,YAEAq4I,EAAA54I,UAAAuD,MAAA,SAAA1B,GACA,GAAA+B,GAAA/D,KAAA04I,EAAA30I,EAAA20I,UAAAnxC,EAAAxjG,EAAAwjG,QACA3/F,EAAA5H,KAAA4H,OACA,KACA8wI,EAAA73I,KAAA0mG,GAAAvnG,KAAAgC,EAAA4F,EAAA5H,KAAAO,SAEAP,KAAAwF,eAAAxF,KAAA84I,WAAAlxI,EAAA5F,GAGA,MAAAb,GACAnB,KAAAsD,YAAA7C,MAAAU,KAGA43I,EAAA54I,UAAAyD,UAAA,WACA5D,KAAAwF,eAAAxF,KAAA84I,YAAA,MAAA9jH,KAEA+jH,GACCj0I,EAAA9B,WACDvD,GAAAs5I,uBpDsn+BM,SAAUv5I,EAAQC,EAASC,GAEjC,YqDvq+BA,SAAA8Q,KAEA,OADAq2F,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,OAAAjL,MAAAI,KAAAS,KAAAm4I,EAAAh0I,UAAA,IAAAhF,MAAAoH,OAAAy/F,KAgEA,QAAAmyC,KAEA,OADAnyC,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,IAAA66F,GAAAZ,OAAAC,kBACAp6F,EAAA,KACA2qG,EAAA7O,IAAAxjG,OAAA,EAUA,OATAuH,GAAAM,YAAAwqG,IACA3qG,EAAA87F,EAAA17F,MACA07F,EAAAxjG,OAAA,mBAAAwjG,KAAAxjG,OAAA,KACAyiG,EAAAe,EAAA17F,QAGA,gBAAAuqG,KACA5P,EAAAe,EAAA17F,OAEA,OAAAJ,GAAA,IAAA87F,EAAAxjG,QAAAwjG,EAAA,YAAA/gG,GAAAhG,WACA+mG,EAAA,GAEA,GAAAC,GAAAj8F,gBAAAg8F,EAAA97F,GAAA3K,KAAA,GAAAknG,GAAAvB,iBAAAD,IA5IA,GAAAhgG,GAAApG,EAAA,GACAonG,EAAApnG,EAAA,IACA4nG,EAAA5nG,EAAA,IACAkL,EAAAlL,EAAA,GAuDAD,GAAA+Q,QAoFA/Q,EAAAu5I,erDiu+BM,SAAUx5I,EAAQC,EAASC,GAEjC,YsD/y+BA,SAAAu5I,GAAA7wG,EAAA8wG,EAAApzC,GAMA,WALA,KAAAA,IAAgCA,EAAAZ,OAAAC,mBAChC,gBAAA+zC,KACApzC,EAAAozC,EACAA,EAAA,MAEAl5I,KAAAI,KAAA,GAAA+4I,GAAA/wG,EAAA8wG,EAAApzC,IAxEA,GAAA1jG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA0jG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,EAoEAD,GAAAw5I,UACA,IAAAE,GAAA,WACA,QAAAA,GAAA/wG,EAAA8wG,EAAApzC,OACA,KAAAA,IAAoCA,EAAAZ,OAAAC,mBACpCnlG,KAAAooC,UACApoC,KAAAk5I,iBACAl5I,KAAA8lG,aAKA,MAHAqzC,GAAAh5I,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAq5I,GAAAn4C,EAAAjhG,KAAAooC,QAAApoC,KAAAk5I,eAAAl5I,KAAA8lG,cAEAqzC,IAEA15I,GAAA05I,kBAMA,IAAAC,GAAA,SAAAn2I,GAEA,QAAAm2I,GAAA91I,EAAA8kC,EAAA8wG,EAAApzC,OACA,KAAAA,IAAoCA,EAAAZ,OAAAC,mBACpCliG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAAk5I,iBACAl5I,KAAA8lG,aACA9lG,KAAA4kG,cAAA,EACA5kG,KAAA4oD,UACA5oD,KAAA+b,OAAA,EACA/b,KAAA4H,MAAA,EA8DA,MAxEAxF,GAAAg3I,EAAAn2I,GAYAm2I,EAAAj5I,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA+b,OAAA/b,KAAA8lG,WACA9lG,KAAAq5I,SAAAr3I,GAGAhC,KAAA4oD,OAAAxgD,KAAApG,IAGAo3I,EAAAj5I,UAAAk5I,SAAA,SAAAr3I,GACA,GAAA2D,GACAiC,EAAA5H,KAAA4H,OACA,KACAjC,EAAA3F,KAAAooC,QAAApmC,EAAA4F,GAEA,MAAAzG,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAA+b,SACA/b,KAAAs5I,UAAA3zI,EAAA3D,EAAA4F,IAEAwxI,EAAAj5I,UAAAm5I,UAAA,SAAA3D,EAAA3zI,EAAA4F,GACA5H,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA21I,EAAA3zI,EAAA4F,KAEAwxI,EAAAj5I,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA,IAAA5kG,KAAA+b,QAAA,IAAA/b,KAAA4oD,OAAAvlD,QACArD,KAAAsD,YAAA5C,YAGA04I,EAAAj5I,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAk5I,eACAl5I,KAAAu5I,sBAAAr0I,EAAAC,EAAAC,EAAAC,GAGArF,KAAAsD,YAAAjC,KAAA8D,IAGAi0I,EAAAj5I,UAAAo5I,sBAAA,SAAAr0I,EAAAC,EAAAC,EAAAC,GACA,GAAAM,EACA,KACAA,EAAA3F,KAAAk5I,eAAAh0I,EAAAC,EAAAC,EAAAC,GAEA,MAAAlE,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEAyzI,EAAAj5I,UAAAqF,eAAA,SAAAF,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA6H,OAAAvC,GACAtF,KAAA+b,SACA6sC,EAAAvlD,OAAA,EACArD,KAAA0D,MAAAklD,EAAAvW,SAEA,IAAAryC,KAAA+b,QAAA/b,KAAA4kG,cACA5kG,KAAAsD,YAAA5C,YAGA04I,GACCpzC,EAAAjhG,gBACDtF,GAAA25I,sBtDw3+BM,SAAU55I,EAAQC,EAASC,GAEjC,YuD/++BA,SAAA85I,GAAAC,EAAAP,EAAApzC,GAMA,WALA,KAAAA,IAAgCA,EAAAZ,OAAAC,mBAChC,gBAAA+zC,KACApzC,EAAAozC,EACAA,EAAA,MAEAl5I,KAAAI,KAAA,GAAAs5I,GAAAD,EAAAP,EAAApzC,IAzDA,GAAA1jG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAqDAD,GAAA+5I,YAGA,IAAAE,GAAA,WACA,QAAAA,GAAA/D,EAAAuD,EAAApzC,OACA,KAAAA,IAAoCA,EAAAZ,OAAAC,mBACpCnlG,KAAA21I,MACA31I,KAAAk5I,iBACAl5I,KAAA8lG,aAKA,MAHA4zC,GAAAv5I,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAA45I,GAAA14C,EAAAjhG,KAAA21I,IAAA31I,KAAAk5I,eAAAl5I,KAAA8lG,cAEA4zC,IAEAj6I,GAAAi6I,oBAMA,IAAAC,GAAA,SAAA12I,GAEA,QAAA02I,GAAAr2I,EAAAqyI,EAAAuD,EAAApzC,OACA,KAAAA,IAAoCA,EAAAZ,OAAAC,mBACpCliG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA21I,MACA31I,KAAAk5I,iBACAl5I,KAAA8lG,aACA9lG,KAAA4kG,cAAA,EACA5kG,KAAA4oD,UACA5oD,KAAA+b,OAAA,EACA/b,KAAA4H,MAAA,EA2DA,MArEAxF,GAAAu3I,EAAA12I,GAYA02I,EAAAx5I,UAAAuD,MAAA,SAAA1B,GACA,GAAAhC,KAAA+b,OAAA/b,KAAA8lG,WAAA,CACA,GAAAozC,GAAAl5I,KAAAk5I,eACAtxI,EAAA5H,KAAA4H,QACA+tI,EAAA31I,KAAA21I,IACAryI,EAAAtD,KAAAsD,WACAtD,MAAA+b,SACA/b,KAAAs5I,UAAA3D,EAAAryI,EAAA41I,EAAAl3I,EAAA4F,OAGA5H,MAAA4oD,OAAAxgD,KAAApG,IAGA23I,EAAAx5I,UAAAm5I,UAAA,SAAA3D,EAAAryI,EAAA41I,EAAAl3I,EAAA4F,GACA5H,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA21I,EAAA3zI,EAAA4F,KAEA+xI,EAAAx5I,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA,IAAA5kG,KAAA+b,QAAA,IAAA/b,KAAA4oD,OAAAvlD,QACArD,KAAAsD,YAAA5C,YAGAi5I,EAAAx5I,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAvB,GAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WACA41I,GACAl5I,KAAA45I,gBAAA10I,EAAAC,EAAAC,EAAAC,GAGA/B,EAAAjC,KAAA8D,IAGAw0I,EAAAx5I,UAAAy5I,gBAAA,SAAA10I,EAAAC,EAAAC,EAAAC,GACA,GACAM,GADA5B,EAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WAEA,KACAqC,EAAAuzI,EAAAh0I,EAAAC,EAAAC,EAAAC,GAEA,MAAAlE,GAEA,WADAmC,GAAA7C,MAAAU,GAGAmC,EAAAjC,KAAAsE,IAEAg0I,EAAAx5I,UAAAoF,YAAA,SAAApE,GACAnB,KAAAsD,YAAA7C,MAAAU,IAEAw4I,EAAAx5I,UAAAqF,eAAA,SAAAF,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA6H,OAAAvC,GACAtF,KAAA+b,SACA6sC,EAAAvlD,OAAA,EACArD,KAAA0D,MAAAklD,EAAAvW,SAEA,IAAAryC,KAAA+b,QAAA/b,KAAA4kG,cACA5kG,KAAAsD,YAAA5C,YAGAi5I,GACC3zC,EAAAjhG,gBACDtF,GAAAk6I,wBvDyi/BM,SAAUn6I,EAAQC,EAASC,GAEjC,YwD5n/BA,SAAAm6I,KAEA,OADAC,MACA7uI,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C6uI,EAAA7uI,EAAA,GAAA7H,UAAA6H,EAKA,OAHA,KAAA6uI,EAAAz2I,QAAAkE,EAAAW,QAAA4xI,EAAA,MACAA,IAAA,IAEA95I,KAAAI,KAAA,GAAA25I,GAAAD,IAIA,QAAAE,KAEA,OADAF,MACA7uI,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C6uI,EAAA7uI,EAAA,GAAA7H,UAAA6H,EAEA,IAAA1K,GAAA,IAKA,OAJA,KAAAu5I,EAAAz2I,QAAAkE,EAAAW,QAAA4xI,EAAA,MACAA,IAAA,IAEAv5I,EAAAu5I,EAAAznG,QACA,GAAA4nG,GAAAvE,eAAAn1I,EAAA,MAAAH,KAAA,GAAA25I,GAAAD,IA7FA,GAAA13I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA03I,EAAAv6I,EAAA,IACA6H,EAAA7H,EAAA,IACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAyEAD,GAAAo6I,oBAcAp6I,EAAAu6I,yBACA,IAAAD,GAAA,WACA,QAAAA,GAAAD,GACA95I,KAAA85I,cAKA,MAHAC,GAAA55I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAm6I,GAAAh4I,EAAAlC,KAAA85I,eAEAC,KAEAG,EAAA,SAAAj3I,GAEA,QAAAi3I,GAAA52I,EAAAw2I,GACA72I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cACAtD,KAAA85I,cAuBA,MA3BA13I,GAAA83I,EAAAj3I,GAMAi3I,EAAA/5I,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAAm6I,yBAEAD,EAAA/5I,UAAAqF,eAAA,SAAAF,GACAtF,KAAAm6I,yBAEAD,EAAA/5I,UAAAwD,OAAA,SAAAxC,GACAnB,KAAAm6I,yBAEAD,EAAA/5I,UAAAyD,UAAA,WACA5D,KAAAm6I,yBAEAD,EAAA/5I,UAAAg6I,sBAAA,WACA,GAAA94I,GAAArB,KAAA85I,YAAAznG,OACAhxC,GACArB,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAqB,IAGArB,KAAAsD,YAAA5C,YAGAw5I,GACCl0C,EAAAjhG,kBxD0s/BK,SAAUvF,EAAQC,EAASC,GAEjC,YyDh0/BA,SAAA06I,KAEA,OADAvzC,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAOA,OAHA,KAAA47F,EAAAxjG,QAAAkE,EAAAW,QAAA2+F,EAAA,MACAA,IAAA,IAEA7mG,KAAAI,KAAAS,KAAAw5I,EAAAr1I,UAAA,IAAAhF,MAAAoH,OAAAy/F,KAGA,QAAAwzC,KAEA,OADAxzC,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAIA,QAAA47F,EAAAxjG,OAAA,CACA,IAAAkE,EAAAW,QAAA2+F,EAAA,IAIA,MAAAA,GAAA,EAHAA,KAAA,GAMA,UAAAC,GAAAj8F,gBAAAg8F,GAAAzmG,KAAA,GAAAk6I,IA9CA,GAAAl4I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAgF,EAAA7H,EAAA,IACAonG,EAAApnG,EAAA,IACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAsBAD,GAAA26I,OAkBA36I,EAAA46I,YACA,IAAAC,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAn6I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAw6I,GAAAr4I,KAEAo4I,IAEA76I,GAAA66I,cAMA,IAAAC,GAAA,SAAAt3I,GAEA,QAAAs3I,GAAAj3I,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAw6I,UAAA,EACAx6I,KAAA6mG,eACA7mG,KAAAyI,iBAqCA,MA1CArG,GAAAm4I,EAAAt3I,GAOAs3I,EAAAp6I,UAAAuD,MAAA,SAAApD,GACAN,KAAA6mG,YAAAz+F,KAAA9H,IAEAi6I,EAAAp6I,UAAAyD,UAAA,WACA,GAAAijG,GAAA7mG,KAAA6mG,YACA3gG,EAAA2gG,EAAAxjG,MACA,QAAA6C,EACAlG,KAAAsD,YAAA5C,eAEA,CACA,OAAAuF,GAAA,EAA2BA,EAAAC,IAAAlG,KAAAw6I,SAA2Bv0I,IAAA,CACtD,GAAA3F,GAAAumG,EAAA5gG,GACAlE,EAAAkkG,EAAAxgG,kBAAAzF,KAAAM,IAAA2F,EACAjG,MAAAyI,eACAzI,KAAAyI,cAAAL,KAAArG,GAEA/B,KAAAc,IAAAiB,GAEA/B,KAAA6mG,YAAA,OAGA0zC,EAAAp6I,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAtF,KAAAw6I,SAAA,CACAx6I,KAAAw6I,UAAA,CACA,QAAAv0I,GAAA,EAA2BA,EAAAjG,KAAAyI,cAAApF,OAA+B4C,IAC1D,GAAAA,IAAAb,EAAA,CACA,GAAArD,GAAA/B,KAAAyI,cAAAxC,EACAlE,GAAAE,cACAjC,KAAA6H,OAAA9F,GAGA/B,KAAAyI,cAAA,KAEAzI,KAAAsD,YAAAjC,KAAA8D,IAEAo1I,GACCv0C,EAAAjhG,gBACDtF,GAAA86I,kBzDy1/BM,SAAU/6I,EAAQC,EAASC,GAEjC,Y0Dp5/BA,SAAA+6I,GAAAC,EAAAh5I,GAEA,WADA,KAAAA,IAA4BA,EAAAjC,EAAAk7I,uBAC5B36I,KAAAI,KAAA,GAAAw6I,GAAAF,EAAAh5I,EAAAm5I,QAAAn5I,EAAAo5I,WArDA,GAAA14I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EACAD,GAAAk7I,uBACAE,SAAA,EACAC,UAAA,GA8CAr7I,EAAAg7I,UACA,IAAAG,GAAA,WACA,QAAAA,GAAAF,EAAAG,EAAAC,GACA96I,KAAA06I,mBACA16I,KAAA66I,UACA76I,KAAA86I,WAKA,MAHAF,GAAAz6I,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAg7I,GAAA74I,EAAAlC,KAAA06I,iBAAA16I,KAAA66I,QAAA76I,KAAA86I,YAEAF,KAOAG,EAAA,SAAA93I,GAEA,QAAA83I,GAAAz3I,EAAAo3I,EAAAM,EAAAC,GACAh4I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cACAtD,KAAA06I,mBACA16I,KAAAg7I,WACAh7I,KAAAi7I,YACAj7I,KAAAk7I,mBAAA,EA0DA,MAjEA94I,GAAA24I,EAAA93I,GASA83I,EAAA56I,UAAAuD,MAAA,SAAA1B,GACA,GAAAhC,KAAAm7I,UACAn7I,KAAAi7I,YACAj7I,KAAAk7I,mBAAA,EACAl7I,KAAAo7I,eAAAp5I,OAGA,CACA,GAAAilB,GAAAjnB,KAAAq7I,oBAAAr5I,EACAilB,IACAjnB,KAAAc,IAAAd,KAAAm7I,UAAAl1C,EAAAxgG,kBAAAzF,KAAAinB,IAEAjnB,KAAAg7I,WACAh7I,KAAAsD,YAAAjC,KAAAW,GACAhC,KAAAi7I,YACAj7I,KAAAk7I,mBAAA,EACAl7I,KAAAo7I,eAAAp5I,MAKA+4I,EAAA56I,UAAAk7I,oBAAA,SAAAr5I,GACA,IACA,MAAAhC,MAAA06I,iBAAA14I,GAEA,MAAAb,GAEA,MADAnB,MAAAsD,YAAA7C,MAAAU,GACA,OAGA45I,EAAA56I,UAAA0E,aAAA,WACA,GAAAd,GAAA/D,KAAAm7I,EAAAp3I,EAAAo3I,SAAAp3I,GAAAq3I,eAAAr3I,EAAAm3I,kBAAAn3I,EAAAk3I,SACAj7I,MAAAo7I,eAAA,KACAp7I,KAAAk7I,mBAAA,EACAC,IACAn7I,KAAA6H,OAAAszI,GACAn7I,KAAAm7I,UAAA,KACAA,EAAAl5I,gBAGA84I,EAAA56I,UAAAm7I,cAAA,WACA,GAAAv3I,GAAA/D,KAAAsD,EAAAS,EAAAT,YAAA63I,EAAAp3I,EAAAo3I,UAAAF,EAAAl3I,EAAAk3I,UAAAG,EAAAr3I,EAAAq3I,eAAAF,EAAAn3I,EAAAm3I,iBACAC,IAAAF,GAAAC,IACA53I,EAAAjC,KAAA+5I,GACAp7I,KAAAo7I,eAAA,KACAp7I,KAAAk7I,mBAAA,IAGAH,EAAA56I,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAs7I,gBACAt7I,KAAA6E,gBAEAk2I,EAAA56I,UAAAqF,eAAA,WACAxF,KAAAs7I,gBACAt7I,KAAA6E,gBAEAk2I,GACC/0C,EAAAjhG,kB1D88/BK,SAAUvF,EAAQC,EAASC,GAEjC,Y2D9kgCA,SAAAu+F,GAAAlzF,GAEA,WADA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,OAC/BvK,KAAAI,KAAA,GAAAm7I,GAAAxwI,IAfA,GAAA3I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkrG,EAAAlrG,EAAA,EAWAD,GAAAw+F,cACA,IAAA+L,GAAA,WACA,QAAAA,GAAAhoG,EAAAgkB,GACAhmB,KAAAgC,QACAhC,KAAAgmB,WAEA,MAAAgkF,KAEAvqG,GAAAuqG,cAEA,IAAAuxC,GAAA,WACA,QAAAA,GAAAxwI,GACA/K,KAAA+K,YAKA,MAHAwwI,GAAAp7I,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAy7I,GAAAv6C,EAAAjhG,KAAA+K,aAEAwwI,KAOAC,EAAA,SAAAv4I,GAEA,QAAAu4I,GAAAl4I,EAAAyH,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+K,YACA/K,KAAAy7I,SAAA,EACAz7I,KAAAy7I,SAAA1wI,EAAAuZ,MAQA,MAbAliB,GAAAo5I,EAAAv4I,GAOAu4I,EAAAr7I,UAAAuD,MAAA,SAAA1B,GACA,GAAAsiB,GAAAtkB,KAAA+K,UAAAuZ,MACAo3H,EAAAp3H,EAAAtkB,KAAAy7I,QACAz7I,MAAAy7I,SAAAn3H,EACAtkB,KAAAsD,YAAAjC,KAAA,GAAA2oG,GAAAhoG,EAAA05I,KAEAF,GACC12I,EAAA9B,a3DkmgCK,SAAUxD,EAAQC,EAASC,GAEjC,Y4D/ogCA,SAAAi8I,GAAA5wI,GAEA,WADA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,OAC/BvK,KAAAI,KAAA,GAAAw7I,GAAA7wI,IAfA,GAAA3I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkrG,EAAAlrG,EAAA,EAWAD,GAAAk8I,WACA,IAAAzxC,GAAA,WACA,QAAAA,GAAAloG,EAAA25I,GACA37I,KAAAgC,QACAhC,KAAA27I,YAEA,MAAAzxC,KAEAzqG,GAAAyqG,WAEA,IAAA0xC,GAAA,WACA,QAAAA,GAAA7wI,GACA/K,KAAA+K,YAKA,MAHA6wI,GAAAz7I,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAA87I,GAAA56C,EAAAjhG,KAAA+K,aAEA6wI,KAEAC,EAAA,SAAA54I,GAEA,QAAA44I,GAAAv4I,EAAAyH,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+K,YAMA,MATA3I,GAAAy5I,EAAA54I,GAKA44I,EAAA17I,UAAAuD,MAAA,SAAA1B,GACA,GAAAsiB,GAAAtkB,KAAA+K,UAAAuZ,KACAtkB,MAAAsD,YAAAjC,KAAA,GAAA6oG,GAAAloG,EAAAsiB,KAEAu3H,GACC/2I,EAAA9B,a5DmqgCK,SAAUxD,EAAQC,EAASC,GAEjC,Y6DptgCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA8H,EAAA3K,EAAA,IACA4K,EAAA5K,EAAA,IACA4qG,EAAA,SAAArnG,GAEA,QAAAqnG,GAAAwxC,EAAAC,GACA,GAAAx6I,GAAAvB,SACA,KAAA87I,IAAyCA,EAAAE,OACzC,KAAAD,IAAmCA,EAAA72C,OAAAC,mBACnCliG,EAAApC,KAAAb,KAAA87I,EAAA,WAAwD,MAAAv6I,GAAA6jB,QACxDplB,KAAA+7I,YACA/7I,KAAAolB,MAAA,EACAplB,KAAA4H,OAAA,EAuBA,MA/BAxF,GAAAkoG,EAAArnG,GAeAqnG,EAAAnqG,UAAA8hG,MAAA,WAGA,IAFA,GACAxhG,GAAAiiG,EADA3+F,EAAA/D,KAAAsiG,EAAAv+F,EAAAu+F,QAAAy5C,EAAAh4I,EAAAg4I,WAEAr5C,EAAAJ,EAAAjwD,WAAAryC,KAAAolB,MAAAs9E,EAAA19E,QAAA+2H,KACAt7I,EAAAiiG,EAAAR,QAAAQ,EAAAn3F,MAAAm3F,EAAA19E,UAIA,GAAAvkB,EAAA,CACA,KAAAiiG,EAAAJ,EAAAjwD,SACAqwD,EAAAzgG,aAEA,MAAAxB,KAGA6pG,EAAA2xC,gBAAA,GACA3xC,GACChgG,EAAAE,eACD/K,GAAA6qG,sBAMA,IAAA0xC,GAAA,SAAA/4I,GAEA,QAAA+4I,GAAAjxI,EAAA82F,EAAAj6F,OACA,KAAAA,IAA+BA,EAAAmD,EAAAnD,OAAA,GAC/B3E,EAAApC,KAAAb,KAAA+K,EAAA82F,GACA7hG,KAAA+K,YACA/K,KAAA6hG,OACA7hG,KAAA4H,QACA5H,KAAA+b,QAAA,EACA/b,KAAA4H,MAAAmD,EAAAnD,QAoDA,MA5DAxF,GAAA45I,EAAA/4I,GAUA+4I,EAAA77I,UAAAsL,SAAA,SAAAF,EAAAyZ,GAEA,OADA,KAAAA,IAA+BA,EAAA,IAC/BhlB,KAAA8b,GACA,MAAA7Y,GAAA9C,UAAAsL,SAAA5K,KAAAb,KAAAuL,EAAAyZ,EAEAhlB,MAAA+b,QAAA,CAKA,IAAA2mF,GAAA,GAAAs5C,GAAAh8I,KAAA+K,UAAA/K,KAAA6hG,KAEA,OADA7hG,MAAAc,IAAA4hG,GACAA,EAAAj3F,SAAAF,EAAAyZ,IAEAg3H,EAAA77I,UAAA6hG,eAAA,SAAAj3F,EAAA+Q,EAAAkJ,OACA,KAAAA,IAA+BA,EAAA,GAC/BhlB,KAAAglB,MAAAja,EAAAqa,MAAAJ,CACA,IAAAs9E,GAAAv3F,EAAAu3F,OAGA,OAFAA,GAAAl6F,KAAApI,MACAsiG,EAAA1pD,KAAAojG,EAAAE,cACA,GAEAF,EAAA77I,UAAA4hG,eAAA,SAAAh3F,EAAA+Q,EAAAkJ,OACA,KAAAA,IAA+BA,EAAA,IAG/Bg3H,EAAA77I,UAAAgiG,SAAA,SAAA52F,EAAAyZ,GACA,QAAAhlB,KAAA+b,OACA,MAAA9Y,GAAA9C,UAAAgiG,SAAAthG,KAAAb,KAAAuL,EAAAyZ,IAGAg3H,EAAAE,YAAA,SAAAxvI,EAAApK,GACA,MAAAoK,GAAAsY,QAAA1iB,EAAA0iB,MACAtY,EAAA9E,QAAAtF,EAAAsF,MACA,EAEA8E,EAAA9E,MAAAtF,EAAAsF,MACA,GAGA,EAGA8E,EAAAsY,MAAA1iB,EAAA0iB,MACA,GAGA,GAGAg3H,GACC3xI,EAAAI,YACDhL,GAAAu8I,iB7D2tgCM,SAAUx8I,EAAQC,EAASC,GAEjC,Y8D30gCA,IAAAy8I,GAAAz8I,EAAA,KACA08I,EAAA18I,EAAA,IAmCAD,GAAAqrG,KAAA,GAAAsxC,GAAAC,cAAAF,EAAAG,a9Dk1gCM,SAAU98I,EAAQC,EAASC,GAEjC,Y+Dx3gCA,IAAA68I,GAAA78I,EAAA,KACA88I,EAAA98I,EAAA,IA8DAD,GAAAo1C,MAAA,GAAA2nG,GAAAC,eAAAF,EAAAG,c/D+3gCM,SAAUl9I,EAAQC,EAASC,GAEjC,YgEh8gCA,IAAAi9I,GAAA,WACA,QAAAA,GAAAC,EAAAC,OACA,KAAAA,IAA2CA,EAAA33C,OAAAC,mBAC3CnlG,KAAA48I,kBACA58I,KAAA68I,oBAEA,MAAAF,KAEAl9I,GAAAk9I,mBhEu8gCM,SAAUn9I,EAAQC,EAASC,GAEjC,YiEj9gCA,IAAAo9I,GAAAp9I,EAAA,IACAq9I,EAAA,WACA,QAAAA,KACA/8I,KAAAyI,iBAWA,MATAs0I,GAAA58I,UAAA68I,mBAAA,WAEA,MADAh9I,MAAAyI,cAAAL,KAAA,GAAA00I,GAAAH,gBAAA38I,KAAA+K,UAAAuZ,QACAtkB,KAAAyI,cAAApF,OAAA,GAEA05I,EAAA58I,UAAA88I,qBAAA,SAAAr1I,GACA,GAAAs1I,GAAAl9I,KAAAyI,cACA00I,EAAAD,EAAAt1I,EACAs1I,GAAAt1I,GAAA,GAAAk1I,GAAAH,gBAAAQ,EAAAP,gBAAA58I,KAAA+K,UAAAuZ,QAEAy4H,IAEAt9I,GAAAs9I,wBjEw9gCM,SAAUv9I,EAAQC,EAASC,GAEjC,YkE1+gCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KASAunG,EAAA,SAAA7mG,GAEA,QAAA6mG,KACA,GAAA3oG,GAAA8B,EAAApC,KAAAb,KAAA,uBACAA,MAAAwS,KAAArR,EAAAqR,KAAA,eACAxS,KAAA4uF,MAAAztF,EAAAytF,MACA5uF,KAAAmjG,QAAAhiG,EAAAgiG,QAEA,MAPA/gG,GAAA0nG,EAAA7mG,GAOA6mG,GACCloG,MACDnC,GAAAqqG,gBlEi/gCM,SAAUtqG,EAAQC,EAASC,GAEjC,YmEzghCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAMA+E,EAAA,SAAArE,GAEA,QAAAqE,GAAAL,GACAhE,EAAApC,KAAAb,MACAA,KAAAiH,QACA,IAAA9F,GAAAS,MAAAf,KAAAb,KAAAiH,EACAA,EAAA5D,OAAA,8CAAA4D,EAAAsL,IAAA,SAAApR,EAAA8E,GAA0G,MAAAA,GAAA,OAAA9E,EAAA4S,aAA4C0P,KAAA,WACtJzjB,MAAAwS,KAAArR,EAAAqR,KAAA,sBACAxS,KAAA4uF,MAAAztF,EAAAytF,MACA5uF,KAAAmjG,QAAAhiG,EAAAgiG,QAEA,MAVA/gG,GAAAkF,EAAArE,GAUAqE,GACC1F,MACDnC,GAAA6H,uBnEghhCM,SAAU9H,EAAQC,EAASC,GAEjC,YoExihCA,SAAA09I,GAAAC,EAAAC,GACA,OAAAr3I,GAAA,EAAAC,EAAAo3I,EAAAj6I,OAA2C4C,EAAAC,EAASD,IAGpD,OAFAkwG,GAAAmnC,EAAAr3I,GACAs3I,EAAA56I,OAAAqgG,oBAAAmT,EAAAh2G,WACA8U,EAAA,EAAAuoI,EAAAD,EAAAl6I,OAAmD4R,EAAAuoI,EAAUvoI,IAAA,CAC7D,GAAAwoI,GAAAF,EAAAtoI,EACAooI,GAAAl9I,UAAAs9I,GAAAtnC,EAAAh2G,UAAAs9I,IAIAh+I,EAAA29I,epE+ihCM,SAAU59I,EAAQC,EAASC,GAEjC,YqE3jhCAD,GAAAuG,YAAA,SAAA2F,GAAqC,MAAAA,IAAA,gBAAAA,GAAAtI,SrEkkhC/B,SAAU7D,EAAQC,EAASC,GAEjC,YsEpkhCA,SAAAoH,GAAA6E,GACA,aAAAA,GAAA,gBAAAA,GAEAlM,EAAAqH,YtE2khCM,SAAUtH,EAAQC,EAASC,GAEjC,YuEhlhCA,SAAA0G,GAAApE,GACA,MAAAA,IAAA,kBAAAA,GAAAjC,WAAA,kBAAAiC,GAAAqE,KAEA5G,EAAA2G,avEulhCM,SAAU5G,EAAQC,EAASC,GAEjC,YwE3lhCA,SAAAoT,MACArT,EAAAqT,QxEmmhCM,SAAUtT,EAAQC,EAASC,GyErlhCjC,QAAAg+I,GAAA5hI,EAAA6hI,GACA39I,KAAA0nB,IAAA5L,EACA9b,KAAA49I,SAAAD,EAnBA,GAAA34I,GAAAiuB,SAAA9yB,UAAA6E,KAIAvF,GAAA6G,WAAA,WACA,UAAAo3I,GAAA14I,EAAAnE,KAAAyF,WAAAuD,OAAAzG,WAAA2iB,eAEAtmB,EAAAymB,YAAA,WACA,UAAAw3H,GAAA14I,EAAAnE,KAAAqlB,YAAArc,OAAAzG,WAAA6iB,gBAEAxmB,EAAAsmB,aACAtmB,EAAAwmB,cAAA,SAAAT,GACAA,GACAA,EAAAwsH,SAQA0L,EAAAv9I,UAAA09I,MAAAH,EAAAv9I,UAAA6mH,IAAA,aACA02B,EAAAv9I,UAAA6xI,MAAA,WACAhyI,KAAA49I,SAAA/8I,KAAAgJ,OAAA7J,KAAA0nB,MAIAjoB,EAAAq+I,OAAA,SAAAr3I,EAAAs3I,GACAh4H,aAAAtf,EAAAu3I,gBACAv3I,EAAAw3I,aAAAF,GAGAt+I,EAAAy+I,SAAA,SAAAz3I,GACAsf,aAAAtf,EAAAu3I,gBACAv3I,EAAAw3I,cAAA,GAGAx+I,EAAA0+I,aAAA1+I,EAAAsc,OAAA,SAAAtV,GACAsf,aAAAtf,EAAAu3I,eAEA,IAAAD,GAAAt3I,EAAAw3I,YACAF,IAAA,IACAt3I,EAAAu3I,eAAA13I,WAAA,WACAG,EAAA23I,YACA33I,EAAA23I,cACKL,KAKLr+I,EAAA,KACAD,EAAA4+I,0BACA5+I,EAAA6+I,+BzE4mhCQ,CACA,CAEF,SAAU9+I,EAAQC,EAASC,I0EnqhCjC,SAAAiK,EAAA0C,GACA7M,EAAAC,QAAA4M,KAGCrM,EAAA,WAAqB,YAMtB,SAAA8jH,GAAAy6B,EAAAC,GACAC,EAAAD,EACAE,EAAAH,EACAlzB,EAAAqzB,EAAA/T,KAAAtf,QAGA,QAAAszB,GAAA9wC,GACA,QAAA4wC,IACApzB,EACA,0GAEAxd,IAEA,GAKA,QAAA+wC,GAAA9vC,GACA,MAAAA,IAAA,kBAAAA,GAAA/uG,UAGA,QAAAk4E,GAAA7uE,GACA,MAAAA,KACA,kBAAAA,GAAA/H,MACA,kBAAA+H,GAAAy1I,QAIA,QAAAC,GAAArxH,GACAA,IACAA,EAAAsxH,QACAtxH,EAAAsxH,UACGtxH,EAAAxrB,aACHwrB,EAAAxrB,eAIA,QAAA+8I,GAAAnjI,GACA,MAAA4iI,GAAAv6I,aACA,GAAAu6I,GAAAv6I,aAAA2X,GAEA4iI,EAAAQ,WAAA98I,OAAA0Z,GAIA,QAAA+uH,GAAA/8B,EAAAt3F,EAAAmwF,GACAnwF,IAAAs3F,GACAA,EAAAt3F,GAAAmwF,EAEAg4C,EAAA/T,KAAAC,eAAA/8B,EAAAt3F,EAAAmwF,GAIA,QAAAw4C,GAAAzpB,GACA,OAAAA,EAAA7pH,KAAAxE,OAAAzE,OAAA8rE,KAAAgnD,EAAA/M,YAAAjlG,KAAA,KA0IA,QAAA07H,GAAAzX,EAAA9jC,GACA,GAAA+6C,IAAA,CAIA,GAAA9wC,GAAA7tG,IAwBA,OAvBAy+I,GAAA3+I,WAAAqC,OAAA,SAAA8+F,GACA,GAAAm+C,GACA1iC,EAAA,WACA0iC,EAAAvxC,EAAA8P,OAAA+pB,EAAA,SAAA2X,EAAAh3B,GACApnB,EAAA5/F,MAAuBgnH,WAAAg3B,cAChBz7C,GAaP,OAPAiK,GAAA15D,MACAuoE,IAEA7O,EAAAuJ,MAAA,eAAAsF,GAIAsiC,EAAA,WACAI,YAOA,QAAAE,GAAAvzI,EAAAqI,GACA,GAAAuqI,IAAA,CAGA,sBAAA90I,QACA,MAAA40I,GAAA3+I,WAAAqC,OAAA,aAGA,IAAA0rG,GAAA7tG,KACAu/I,EAAAvsI,SAAAK,eAkBA,OAjBAorI,GAAA3+I,WAAAqC,OAAA,SAAA8+F,GACA,QAAAhtF,GAAAhM,GACA,GAAA4lG,EAAAkL,IAAA,CACA,UAAAhtG,GAAA8hG,EAAAkL,MAAA9wG,EAAA4T,OAAqD,MAAAolF,GAAA5/F,KAAA4G,EAGrD,QAFAu3I,GAAA3xC,EAAAkL,IAAAxgD,iBAAAxsD,GACA8sG,EAAA5wG,EAAA4T,OACA5V,EAAA,EAAAC,EAAAs5I,EAAAn8I,OAAuC4C,EAAAC,EAASD,IAChD,GAAAu5I,EAAAv5I,KAAA4yG,EAA4B,MAAA5X,GAAA5/F,KAAA4G,IAK5B,MAFAs3I,GAAA/pI,iBAAApB,EAAAH,GAEA+qI,EAAA,WACAO,EAAApqI,oBAAAf,EAAAH,QAOA,QAAAwrI,GAAAn/I,EAAAe,EAAAZ,EAAAC,GACA,GAAAg/I,GAAAp/I,EAAAP,UAAAsB,EAAAZ,EAAAC,EACA,QADyDV,KAAA2/I,mBAAA3/I,KAAA2/I,sBAAAv3I,KAAAs3I,GACzDA,EAQA,QAAAE,GAAAC,GACA,GAAAlB,IAAA,CAGA,GAAA9wC,GAAA7tG,KACA8/I,EAAAp0I,MAAAxD,QAAA23I,QAaA,OAZApB,GAAA3+I,WAAAqC,OAAA,SAAA8+F,GACA,GAAA8+C,GAAAD,EAAAvtI,IAAA,SAAAC,GACA,GAAAK,GAAA,SAAA9L,GAAqC,MAAAk6F,GAAA5/F,MAAuBmR,OAAAzL,QAE5D,OADA8mG,GAAAwJ,IAAA7kG,EAAAK,IACcL,OAAAK,aAEd,mBAEAktI,EAAA3+I,QAAA,SAAAqL,GAA0C,MAAAohG,GAAA0J,KAAA9qG,EAAA+F,KAAA/F,EAAAoG,gBAc1C,QAAAmtI,GAAAC,EAAAC,GACA,GAAAvB,IAAA,CAGA,GAAA9wC,GAAA7tG,IAEA,KAAAy+I,EAAA3+I,WAAAK,UAAAggJ,MAOA,WANA90B,GACA,mIAEA40B,EACApyC,OAKA74E,KAAA64E,EAAAoyC,IACA50B,EACA,yBACA40B,EAAA,8EACAt0C,OAAAkC,EAAAoyC,IACApyC,EAIA,IAAAp3C,GAAA,SAAAwqC,GAcA,MAbA4M,GAAAoyC,GAAA,WACA,GAAAtqI,GAAAjK,MAAAg0B,KAAAt8B,UACA88I,IACAvqI,EAAAvN,KAAApI,MACAihG,EAAA5/F,KAAAsU,IAEAA,EAAAtS,QAAA,EACA49F,EAAA5/F,KAAAsU,EAAA,IAEAsrF,EAAA5/F,KAAAsU,IAIA,iBACAk4F,GAAAoyC,IAKA,OAAAxB,GAAA3+I,WAAAqC,OAAAs0D,GAAA0pF,SAKA,QAAAC,GAAAC,EAAAC,GACAx8B,EAAAu8B,EAAAC,GACAD,EAAAr8B,MAAAu8B,GACAF,EAAAG,UAAA,SAAAC,GACAJ,EAAAlgJ,UAAAugJ,mBAAAvB,EACAkB,EAAAlgJ,UAAAwgJ,cAAArB,EACAe,EAAAlgJ,UAAAygJ,aAAAnB,EACAY,EAAAlgJ,UAAA0gJ,mBAAAjB,EACAS,EAAAlgJ,UAAA2gJ,wBAAAd,EAnWA,GAAAvB,GACAC,EACArzB,EAAA,aA4DAk1B,GACAhW,QAAA,WACA,GAAA18B,GAAA7tG,KACA+gJ,EAAAlzC,EAAAkF,SAAAguC,UACAA,KACAtC,EAAAz1I,QAGA+3I,EAAA3/I,QAAA,SAAAmV,GACAs3F,EAAAt3F,GAAA,GAAAkoI,GAAAz1I,UAHAqiH,EAAA,0DAQA,IAAA21B,GAAAnzC,EAAAkF,SAAAiuC,iBACAA,KACAt1I,MAAAxD,QAAA84I,GACAA,EAAA5/I,QAAA,SAAA6+I,GACApyC,EAAAoyC,EAAA,KAAApyC,EAAAizC,wBAAAb,KAGAt9I,OAAA8rE,KAAAuyE,GAAA5/I,QAAA,SAAA6+I,GACApyC,EAAAmzC,EAAAf,IAAApyC,EAAAizC,wBAAAb,KAKA,IAAAt5I,GAAAknG,EAAAkF,SAAAtqG,aACA,mBAAA9B,KACAA,IAAA9F,KAAAgtG,IAEAlnG,IACAknG,EAAAozC,gBACApzC,EAAA8xC,oBACAh9I,OAAA8rE,KAAA9nE,GAAAvF,QAAA,SAAAmV,GAGA,GAFAq0H,EAAA/8B,EAAAt3F,MAAAye,KAEA4pH,EADA/wC,EAAAozC,aAAA1qI,GAAA5P,EAAA4P,IAMA,WAJA80G,GACA,8DAAA90G,EAAA,KACAs3F,EAIAA,GAAA8xC,iBAAAv3I,KAAAzB,EAAA4P,GAAAxW,UAAA,SAAAiC,GACA6rG,EAAAt3F,GAAAvU,SAMAk/I,cAAA,WACAlhJ,KAAA2/I,kBACA3/I,KAAA2/I,iBAAAv+I,QAAA09I,KAKA2B,GAEAn8I,KAAA,SAAAu0G,EAAA4c,EAAApiB,GACA,GAAAsrC,IAAA,CAIA,GAAAlxH,GAAAgoG,EAAAzzH,MACAoS,EAAAqhH,EAAA7pH,IACAu1I,EAAA1rB,EAAArL,WACA1B,EAAA+M,EAAA/M,SAEA,IAAAzwC,EAAAxqD,GACAA,GAAgBrkB,QAAAqkB,OACX,KAAAA,IAAAwqD,EAAAxqD,EAAArkB,SAOL,WANAiiH,GACA,gDAAA81B,EAAA,KACAA,EAAA,4FAEA9tC,EAAAjvG,QAKA,IAAAgF,GAAAqkB,EAAArkB,QACA/H,GAAA+H,EAAA/H,MAAA+H,EAAAy1I,QAAAv6I,KAAA8E,EAEA,KAAAs/G,EAAA6C,QAAAlY,EAAA4R,kBACAx3F,EAAA1rB,aAAAsxG,EAAA4R,kBAAA47B,mBAAAzsI,GAAArU,UAAA,SAAAkI,GACA5G,GACA+S,MAAAnM,EACA2H,KAAA6d,EAAA7d,aAGK,CACL,IAAA6uI,EAAA3+I,WAAAshJ,UAOA,WANA/1B,GACA,yJAEA81B,EACA9tC,EAAAjvG,QAIA,IAAAi9I,GAAA5zH,EAAAm2E,SAAAiV,EAAAzkG,EAAAqZ,EAAAm2E,UAAAiV,EAAAzkG,EACAqZ,GAAA1rB,cAAAilH,EAAAy3B,EAAA3+I,YAAAshJ,UAAAp8I,MAAAgiH,EAAAq6B,GAAAthJ,UAAA,SAAAkI,GACA5G,GACA+S,MAAAnM,EACA2H,KAAA6d,EAAA7d,UAMOipG,EAAAyoC,aAAAzoC,EAAAyoC,gBAAqCpC,EAAAzpB,IAAAhoG,EAE5C,GAAAu5F,KAGA9wG,OAAA,SAAA2iG,EAAA4c,GACA,GAAAhoG,GAAAgoG,EAAAzzH,MACAu/I,EAAA1oC,EAAAyoC,YAAAzoC,EAAAyoC,WAAApC,EAAAzpB,GACA8rB,IAAA9zH,GAAAwqD,EAAAxqD,EAAArkB,WACAm4I,EAAA3xI,KAAA6d,EAAA7d,OAIAwgI,OAAA,SAAAv3B,EAAA4c,GACA,GAAAl/G,GAAA2oI,EAAAzpB,GACAhoG,EAAAorF,EAAAyoC,YAAAzoC,EAAAyoC,WAAA/qI,EACAkX,KACAqxH,EAAArxH,EAAA1rB,cACA82G,EAAAyoC,WAAA/qI,GAAA,OA2KA,OAJA,mBAAAktG,MAAA,mBAAAhiH,KACAgiH,IAAAC,IAAA08B,EAAA3+I,IAGA2+I,K1E2qhCQ,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CAEF,SAAU5gJ,EAAQC,G2E/hiCxB,QAAA+hJ,KACA,SAAA5/I,OAAA,mCAEA,QAAA6/I,KACA,SAAA7/I,OAAA,qCAsBA,QAAA8/I,GAAAC,GACA,GAAAC,IAAAt7I,WAEA,MAAAA,YAAAq7I,EAAA,EAGA,KAAAC,IAAAJ,IAAAI,IAAAt7I,WAEA,MADAs7I,GAAAt7I,WACAA,WAAAq7I,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACK,MAAA15I,GACL,IAEA,MAAA25I,GAAA/gJ,KAAA,KAAA8gJ,EAAA,GACS,MAAA15I,GAET,MAAA25I,GAAA/gJ,KAAAb,KAAA2hJ,EAAA,KAMA,QAAAE,GAAAC,GACA,GAAAC,IAAAh8H,aAEA,MAAAA,cAAA+7H,EAGA,KAAAC,IAAAN,IAAAM,IAAAh8H,aAEA,MADAg8H,GAAAh8H,aACAA,aAAA+7H,EAEA,KAEA,MAAAC,GAAAD,GACK,MAAA75I,GACL,IAEA,MAAA85I,GAAAlhJ,KAAA,KAAAihJ,GACS,MAAA75I,GAGT,MAAA85I,GAAAlhJ,KAAAb,KAAA8hJ,KAYA,QAAAE,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAA7+I,OACAwxC,EAAAqtG,EAAA96I,OAAAytC,GAEAstG,GAAA,EAEAttG,EAAAxxC,QACA++I,KAIA,QAAAA,KACA,IAAAH,EAAA,CAGA,GAAAz8H,GAAAk8H,EAAAM,EACAC,IAAA,CAGA,KADA,GAAA/7I,GAAA2uC,EAAAxxC,OACA6C,GAAA,CAGA,IAFAg8I,EAAArtG,EACAA,OACAstG,EAAAj8I,GACAg8I,GACAA,EAAAC,GAAAnnC,KAGAmnC,IAAA,EACAj8I,EAAA2uC,EAAAxxC,OAEA6+I,EAAA,KACAD,GAAA,EACAJ,EAAAr8H,IAiBA,QAAA68H,GAAAV,EAAA72I,GACA9K,KAAA2hJ,MACA3hJ,KAAA8K,QAYA,QAAAgI,MAhKA,GAOA8uI,GACAG,EARAO,EAAA9iJ,EAAAC,YAgBA,WACA,IAEAmiJ,EADA,kBAAAt7I,YACAA,WAEAk7I,EAEK,MAAAv5I,GACL25I,EAAAJ,EAEA,IAEAO,EADA,kBAAAh8H,cACAA,aAEA07H,EAEK,MAAAx5I,GACL85I,EAAAN,KAuDA,IAEAS,GAFArtG,KACAotG,GAAA,EAEAE,GAAA,CAyCAG,GAAA9mC,SAAA,SAAAmmC,GACA,GAAAhsI,GAAA,GAAAjK,OAAAtI,UAAAC,OAAA,EACA,IAAAD,UAAAC,OAAA,EACA,OAAA4C,GAAA,EAAuBA,EAAA7C,UAAAC,OAAsB4C,IAC7C0P,EAAA1P,EAAA,GAAA7C,UAAA6C,EAGA4uC,GAAAzsC,KAAA,GAAAi6I,GAAAV,EAAAhsI,IACA,IAAAk/B,EAAAxxC,QAAA4+I,GACAP,EAAAU,IASAC,EAAAliJ,UAAA66G,IAAA,WACAh7G,KAAA2hJ,IAAA38I,MAAA,KAAAhF,KAAA8K,QAEAw3I,EAAAC,MAAA,UACAD,EAAAE,SAAA,EACAF,EAAA1c,OACA0c,EAAAz5F,QACAy5F,EAAAzvD,QAAA,GACAyvD,EAAAG,YAIAH,EAAAxtI,GAAAhC,EACAwvI,EAAAI,YAAA5vI,EACAwvI,EAAAn1C,KAAAr6F,EACAwvI,EAAAK,IAAA7vI,EACAwvI,EAAAM,eAAA9vI,EACAwvI,EAAAO,mBAAA/vI,EACAwvI,EAAAvyH,KAAAjd,EACAwvI,EAAAQ,gBAAAhwI,EACAwvI,EAAAS,oBAAAjwI,EAEAwvI,EAAAvxH,UAAA,SAAAve,GAAqC,UAErC8vI,EAAA7sB,QAAA,SAAAjjH,GACA,SAAA5Q,OAAA,qCAGA0gJ,EAAAU,IAAA,WAA2B,WAC3BV,EAAAW,MAAA,SAAAr7B,GACA,SAAAhmH,OAAA,mCAEA0gJ,EAAAY,MAAA,WAA4B,W3EijiCtB,SAAU1jJ,EAAQC,EAASC,GAEjC,Y4EzuiCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GAMAmG,EAAA,SAAA5C,GAEA,QAAA4C,GAAAjB,EAAAM,EAAAE,GACAnC,EAAApC,KAAAb,MACAA,KAAA4E,SACA5E,KAAAkF,aACAlF,KAAAoF,aACApF,KAAA4H,MAAA,EAaA,MAnBAxF,GAAAyD,EAAA5C,GAQA4C,EAAA1F,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA4E,OAAAK,WAAAjF,KAAAkF,WAAAlD,EAAAhC,KAAAoF,WAAApF,KAAA4H,QAAA5H,OAEA6F,EAAA1F,UAAAwD,OAAA,SAAAlD,GACAT,KAAA4E,OAAAW,YAAA9E,EAAAT,MACAA,KAAAiC,eAEA4D,EAAA1F,UAAAyD,UAAA,WACA5D,KAAA4E,OAAAY,eAAAxF,MACAA,KAAAiC,eAEA4D,GACCf,EAAA9B,WACDvD,GAAAoG,mB5EgviCM,SAAUrG,EAAQC,EAASC,GAEjC,Y6EnwiCA,IAAAijG,GAAA,WACA,QAAAA,GAAAm5C,EAAAx3H,OACA,KAAAA,IAA6BA,EAAAq+E,EAAAr+E,KAC7BtkB,KAAA87I,kBACA97I,KAAAskB,MAwBA,MALAq+E,GAAAxiG,UAAAsL,SAAA,SAAAo2F,EAAA78E,EAAAzZ,GAEA,WADA,KAAAyZ,IAA+BA,EAAA,GAC/B,GAAAhlB,MAAA87I,gBAAA97I,KAAA6hG,GAAAp2F,SAAAF,EAAAyZ,IAEA29E,EAAAr+E,IAAA+0B,KAAA/0B,IAAA+0B,KAAA/0B,IAAA,WAAuD,UAAA+0B,OACvDspD,IAEAljG,GAAAkjG,a7E0xiCM,SAAUnjG,EAAQC,EAASC,GAEjC,Y8E10iCA,IAAAoG,GAAApG,EAAA,GACAyjJ,EAAAzjJ,EAAA,IACAoG,GAAAhG,WAAAsjJ,aAAAD,EAAAC,c9Ei1iCM,SAAU5jJ,EAAQC,EAASC,GAEjC,Y+Er1iCA,IAAAoG,GAAApG,EAAA,GACA2jJ,EAAA3jJ,EAAA,IACAoG,GAAAhG,WAAAwjJ,iBAAAD,EAAAC,kB/E41iCM,SAAU9jJ,EAAQC,EAASC,GAEjC,YgFh2iCA,IAAAoG,GAAApG,EAAA,GACA6jJ,EAAA7jJ,EAAA,IACAoG,GAAAhG,WAAA8mG,cAAA28C,EAAA38C,ehFu2iCM,SAAUpnG,EAAQC,EAASC,GAEjC,YiF32iCA,IAAAoG,GAAApG,EAAA,GACA8jJ,EAAA9jJ,EAAA,IACAoG,GAAAhG,WAAAsH,OAAAo8I,EAAAp8I,QjFk3iCM,SAAU5H,EAAQC,EAASC,GAEjC,YkFt3iCA,IAAAoG,GAAApG,EAAA,GACA+jJ,EAAA/jJ,EAAA,IACAoG,GAAAhG,WAAA+hF,MAAA4hE,EAAA5hE,OlF63iCM,SAAUriF,EAAQC,EAASC,GAEjC,YmFj4iCA,IAAAoG,GAAApG,EAAA,GACAgkJ,EAAAhkJ,EAAA,IACAoG,GAAAhG,WAAA6jJ,KAAAD,EAAAC,MnFw4iCM,SAAUnkJ,EAAQC,EAASC,GAEjC,YoF54iCA,IAAAoG,GAAApG,EAAA,GACAkkJ,EAAAlkJ,EAAA,IACAoG,GAAAhG,WAAA+jJ,UAAAD,EAAAC,WpFm5iCM,SAAUrkJ,EAAQC,EAASC,GAEjC,YqFv5iCA,IAAAoG,GAAApG,EAAA,GACAokJ,EAAApkJ,EAAA,IACAoG,GAAAhG,WAAAyD,MAAAugJ,EAAAvgJ,OrF85iCM,SAAU/D,EAAQC,EAASC,GAEjC,YsFl6iCA,IAAAoG,GAAApG,EAAA,GACAqkJ,EAAArkJ,EAAA,IACAoG,GAAAhG,WAAAkkJ,SAAAD,EAAAC,UtFy6iCM,SAAUxkJ,EAAQC,EAASC,GAEjC,YuF76iCA,IAAAoG,GAAApG,EAAA,GACAukJ,EAAAvkJ,EAAA,IACAoG,GAAAhG,WAAA4/B,KAAAukH,EAAAvkH,MvFo7iCM,SAAUlgC,EAAQC,EAASC,GAEjC,YwFx7iCA,IAAAoG,GAAApG,EAAA,GACAwkJ,EAAAxkJ,EAAA,IACAoG,GAAAhG,WAAAshJ,UAAA8C,EAAA9C,WxF+7iCM,SAAU5hJ,EAAQC,EAASC,GAEjC,YyFn8iCA,IAAAoG,GAAApG,EAAA,GACAykJ,EAAAzkJ,EAAA,IACAoG,GAAAhG,WAAAskJ,iBAAAD,EAAAC,kBzF08iCM,SAAU5kJ,EAAQC,EAASC,GAEjC,Y0F98iCA,IAAAoG,GAAApG,EAAA,GACA2kJ,EAAA3kJ,EAAA,IACAoG,GAAAhG,WAAAwkJ,YAAAD,EAAAC,a1Fq9iCM,SAAU9kJ,EAAQC,EAASC,GAEjC,Y2Fz9iCA,IAAAoG,GAAApG,EAAA,GACA6kJ,EAAA7kJ,EAAA,IACAoG,GAAAhG,WAAAghI,SAAAyjB,EAAAzjB,U3Fg+iCM,SAAUthI,EAAQC,EAASC,GAEjC,Y4Fp+iCA,IAAAoG,GAAApG,EAAA,GACA8kJ,EAAA9kJ,EAAA,IACAoG,GAAAhG,WAAAg9H,GAAA0nB,EAAAC,K5F2+iCM,SAAUjlJ,EAAQC,EAASC,GAEjC,Y6F/+iCA,IAAAoG,GAAApG,EAAA,GACAglJ,EAAAhlJ,EAAA,IACAoG,GAAAhG,WAAAkmB,SAAA0+H,EAAA1+H,U7Fs/iCM,SAAUxmB,EAAQC,EAASC,GAEjC,Y8F1/iCA,IAAAoG,GAAApG,EAAA,GACAilJ,EAAAjlJ,EAAA,IACAoG,GAAAhG,WAAA0Q,MAAAm0I,EAAAn0I,O9FigjCM,SAAUhR,EAAQC,EAASC,GAEjC,Y+FrgjCA,IAAAoG,GAAApG,EAAA,GACAklJ,EAAAllJ,EAAA,IACAoG,GAAAhG,WAAA+kJ,MAAAD,EAAAC,O/F4gjCM,SAAUrlJ,EAAQC,EAASC,GAEjC,YgGhhjCA,IAAAoG,GAAApG,EAAA,GACAolJ,EAAAplJ,EAAA,IACAoG,GAAAhG,WAAAkL,GAAA85I,EAAA95I,IhGuhjCM,SAAUxL,EAAQC,EAASC,GAEjC,YiG3hjCA,IAAAoG,GAAApG,EAAA,GACAqlJ,EAAArlJ,EAAA,IACAoG,GAAAhG,WAAA+5I,kBAAAkL,EAAAlL,mBjGkijCM,SAAUr6I,EAAQC,EAASC,GAEjC,YkGtijCA,IAAAoG,GAAApG,EAAA,GACAslJ,EAAAtlJ,EAAA,IACAoG,GAAAhG,WAAAo0D,MAAA8wF,EAAA9wF,OlG6ijCM,SAAU10D,EAAQC,EAASC,GAEjC,YmGjjjCA,IAAAoG,GAAApG,EAAA,GACAulJ,EAAAvlJ,EAAA,IACAoG,GAAAhG,WAAAs6I,KAAA6K,EAAA7K,MnGwjjCM,SAAU56I,EAAQC,EAASC,GAEjC,YoG5jjCA,IAAAoG,GAAApG,EAAA,GACAwlJ,EAAAxlJ,EAAA,IACAoG,GAAAhG,WAAAuP,MAAA61I,EAAA71I,OpGmkjCM,SAAU7P,EAAQC,EAASC,GAEjC,YqGvkjCA,IAAAoG,GAAApG,EAAA,GACAylJ,EAAAzlJ,EAAA,IACAoG,GAAAhG,WAAAwhG,MAAA6jD,EAAAC,QrG8kjCM,SAAU5lJ,EAAQC,EAASC,GAEjC,YsGlljCA,IAAAoG,GAAApG,EAAA,GACA2lJ,EAAA3lJ,EAAA,IACAoG,GAAAhG,WAAAilB,MAAAsgI,EAAAtgI,OtGyljCM,SAAUvlB,EAAQC,EAASC,GAEjC,YuG7ljCA,IAAAoG,GAAApG,EAAA,GACA4lJ,EAAA5lJ,EAAA,IACAoG,GAAAhG,WAAAylJ,MAAAD,EAAAC,OvGomjCM,SAAU/lJ,EAAQC,EAASC,GAEjC,YwGxmjCA,IAAAoG,GAAApG,EAAA,GACA8lJ,EAAA9lJ,EAAA,IACAoG,GAAAhG,WAAAm2D,IAAAuvF,EAAAvvF,KxG+mjCM,SAAUz2D,EAAQC,EAASC,GAEjC,YyGnnjCA,IAAAoG,GAAApG,EAAA,GACA+lJ,EAAA/lJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAulJ,MAAAD,EAAAC,OzG0njCM,SAAUlmJ,EAAQC,EAASC,GAEjC,Y0G9njCA,IAAAoG,GAAApG,EAAA,GACAimJ,EAAAjmJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAylJ,UAAAD,EAAAC,W1GqojCM,SAAUpmJ,EAAQC,EAASC,GAEjC,Y2GzojCA,IAAAoG,GAAApG,EAAA,GACAmmJ,EAAAnmJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAyoD,OAAAi9F,EAAAj9F,Q3GgpjCM,SAAUppD,EAAQC,EAASC,GAEjC,Y4GppjCA,IAAAoG,GAAApG,EAAA,GACAomJ,EAAApmJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4lJ,YAAAD,EAAAC,a5G2pjCM,SAAUvmJ,EAAQC,EAASC,GAEjC,Y6G/pjCA,IAAAoG,GAAApG,EAAA,GACAsmJ,EAAAtmJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8lJ,WAAAD,EAAAC,Y7GsqjCM,SAAUzmJ,EAAQC,EAASC,GAEjC,Y8G1qjCA,IAAAoG,GAAApG,EAAA,GACAwmJ,EAAAxmJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAgmJ,aAAAD,EAAAC,c9GirjCM,SAAU3mJ,EAAQC,EAASC,GAEjC,Y+GrrjCA,IAAAoG,GAAApG,EAAA,GACA0mJ,EAAA1mJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAkmJ,WAAAD,EAAAC,Y/G4rjCM,SAAU7mJ,EAAQC,EAASC,GAEjC,YgHhsjCA,IAAAoG,GAAApG,EAAA,GACA4mJ,EAAA5mJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAimI,MAAAkgB,EAAAC,OACAzgJ,EAAAhG,WAAAK,UAAAomJ,OAAAD,EAAAC,QhHusjCM,SAAU/mJ,EAAQC,EAASC,GAEjC,YiH5sjCA,IAAAoG,GAAApG,EAAA,GACA8mJ,EAAA9mJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAsmJ,WAAAD,EAAAC,YjHmtjCM,SAAUjnJ,EAAQC,EAASC,GAEjC,YkHvtjCA,IAAAoG,GAAApG,EAAA,GACA6jJ,EAAA7jJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAymG,cAAA28C,EAAA38C,elH8tjCM,SAAUpnG,EAAQC,EAASC,GAEjC,YmHlujCA,IAAAoG,GAAApG,EAAA,GACA8jJ,EAAA9jJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAiH,OAAAo8I,EAAAp8I,QnHyujCM,SAAU5H,EAAQC,EAASC,GAEjC,YoH7ujCA,IAAAoG,GAAApG,EAAA,GACAgnJ,EAAAhnJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAwmJ,UAAAD,EAAAC,WpHovjCM,SAAUnnJ,EAAQC,EAASC,GAEjC,YqHxvjCA,IAAAoG,GAAApG,EAAA,GACAknJ,EAAAlnJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0mJ,UAAAD,EAAAC,WrH+vjCM,SAAUrnJ,EAAQC,EAASC,GAEjC,YsHnwjCA,IAAAoG,GAAApG,EAAA,GACAonJ,EAAApnJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4mJ,YAAAD,EAAAC,atH0wjCM,SAAUvnJ,EAAQC,EAASC,GAEjC,YuH9wjCA,IAAAoG,GAAApG,EAAA,GACAsnJ,EAAAtnJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqL,MAAAw7I,EAAAx7I,OvHqxjCM,SAAUhM,EAAQC,EAASC,GAEjC,YwHzxjCA,IAAAoG,GAAApG,EAAA,GACAunJ,EAAAvnJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA+mJ,SAAAD,EAAAC,UxHgyjCM,SAAU1nJ,EAAQC,EAASC,GAEjC,YyHpyjCA,IAAAoG,GAAApG,EAAA,GACAynJ,EAAAznJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAinJ,aAAAD,EAAAC,czH2yjCM,SAAU5nJ,EAAQC,EAASC,GAEjC,Y0H/yjCA,IAAAoG,GAAApG,EAAA,GACA2nJ,EAAA3nJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAmnJ,eAAAD,EAAAC,gB1HszjCM,SAAU9nJ,EAAQC,EAASC,GAEjC,Y2H1zjCA,IAAAoG,GAAApG,EAAA,GACA6nJ,EAAA7nJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6kB,MAAAuiI,EAAAviI,O3Hi0jCM,SAAUxlB,EAAQC,EAASC,GAEjC,Y4Hr0jCA,IAAAoG,GAAApG,EAAA,GACA8nJ,EAAA9nJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAsnJ,UAAAD,EAAAC,W5H40jCM,SAAUjoJ,EAAQC,EAASC,GAEjC,Y6Hh1jCA,IAAAoG,GAAApG,EAAA,GACAgoJ,EAAAhoJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAwnJ,cAAAD,EAAAC,e7Hu1jCM,SAAUnoJ,EAAQC,EAASC,GAEjC,Y8H31jCA,IAAAoG,GAAApG,EAAA,GACAkoJ,EAAAloJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0nJ,SAAAD,EAAAC,U9Hk2jCM,SAAUroJ,EAAQC,EAASC,GAEjC,Y+Ht2jCA,IAAAoG,GAAApG,EAAA,GACAooJ,EAAApoJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAk4I,qBAAAyP,EAAAzP,sB/H62jCM,SAAU74I,EAAQC,EAASC,GAEjC,YgIj3jCA,IAAAoG,GAAApG,EAAA,GACAqoJ,EAAAroJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6nJ,wBAAAD,EAAAC,yBhIw3jCM,SAAUxoJ,EAAQC,EAASC,GAEjC,YiI53jCA,IAAAoG,GAAApG,EAAA,GACAuoJ,EAAAvoJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA+gG,GAAA+mD,EAAAC,IACApiJ,EAAAhG,WAAAK,UAAA+nJ,IAAAD,EAAAC,KjIm4jCM,SAAU1oJ,EAAQC,EAASC,GAEjC,YkIx4jCA,IAAAoG,GAAApG,EAAA,GACAyoJ,EAAAzoJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAioJ,UAAAD,EAAAC,WlI+4jCM,SAAU5oJ,EAAQC,EAASC,GAEjC,YmIn5jCA,IAAAoG,GAAApG,EAAA,GACA2oJ,EAAA3oJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6oB,MAAAq/H,EAAAr/H,OnI05jCM,SAAUxpB,EAAQC,EAASC,GAEjC,YoI95jCA,IAAAoG,GAAApG,EAAA,GACA4oJ,EAAA5oJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAooJ,QAAAD,EAAAC,SpIq6jCM,SAAU/oJ,EAAQC,EAASC,GAEjC,YqIz6jCA,IAAAoG,GAAApG,EAAA,GACA8oJ,EAAA9oJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAsoJ,WAAAD,EAAAC,YrIg7jCM,SAAUjpJ,EAAQC,EAASC,GAEjC,YsIp7jCA,IAAAoG,GAAApG,EAAA,GACAgpJ,EAAAhpJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAgvF,OAAAu5D,EAAAv5D,QtI27jCM,SAAU3vF,EAAQC,EAASC,GAEjC,YuI/7jCA,IAAAoG,GAAApG,EAAA,GACAipJ,EAAAjpJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAmR,OAAAq3I,EAAAr3I,QvIs8jCM,SAAU9R,EAAQC,EAASC,GAEjC,YwI18jCA,IAAAoG,GAAApG,EAAA,GACAkpJ,EAAAlpJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0oJ,QAAAD,EAAAE,SACAhjJ,EAAAhG,WAAAK,UAAA2oJ,SAAAF,EAAAE,UxIi9jCM,SAAUtpJ,EAAQC,EAASC,GAEjC,YyIt9jCA,IAAAoG,GAAApG,EAAA,GACAqpJ,EAAArpJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAi1B,KAAA2zH,EAAA3zH,MzI69jCM,SAAU51B,EAAQC,EAASC,GAEjC,Y0Ij+jCA,IAAAoG,GAAApG,EAAA,GACAspJ,EAAAtpJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8oJ,UAAAD,EAAAC,W1Iw+jCM,SAAUzpJ,EAAQC,EAASC,GAEjC,Y2I5+jCA,IAAAoG,GAAApG,EAAA,GACAwpJ,EAAAxpJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4gC,MAAAmoH,EAAAnoH,O3Im/jCM,SAAUvhC,EAAQC,EAASC,GAEjC,Y4Iv/jCA,IAAAoG,GAAApG,EAAA,GACAypJ,EAAAzpJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAipJ,QAAAD,EAAAC,S5I8/jCM,SAAU5pJ,EAAQC,EAASC,GAEjC,Y6IlgkCA,IAAAoG,GAAApG,EAAA,GACA2pJ,EAAA3pJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAmpJ,eAAAD,EAAAC,gB7IygkCM,SAAU9pJ,EAAQC,EAASC,GAEjC,Y8I7gkCA,IAAAoG,GAAApG,EAAA,GACA6pJ,EAAA7pJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqpJ,QAAAD,EAAAC,S9IohkCM,SAAUhqJ,EAAQC,EAASC,GAEjC,Y+IxhkCA,IAAAoG,GAAApG,EAAA,GACA+pJ,EAAA/pJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAu1G,KAAA+zC,EAAA/zC,M/I+hkCM,SAAUl2G,EAAQC,EAASC,GAEjC,YgJnikCA,IAAAoG,GAAApG,EAAA,GACAgqJ,EAAAhqJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAwpJ,IAAAD,EAAAE,SACA9jJ,EAAAhG,WAAAK,UAAA0pJ,QAAAH,EAAAE,UhJ0ikCM,SAAUpqJ,EAAQC,EAASC,GAEjC,YiJ/ikCA,IAAAoG,GAAApG,EAAA,GACAo3I,EAAAp3I,EAAA,GACAoG,GAAAhG,WAAAK,UAAAoS,IAAAukI,EAAAvkI,KjJsjkCM,SAAU/S,EAAQC,EAASC,GAEjC,YkJ1jkCA,IAAAoG,GAAApG,EAAA,GACAoqJ,EAAApqJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4pJ,MAAAD,EAAAC,OlJikkCM,SAAUvqJ,EAAQC,EAASC,GAEjC,YmJrkkCA,IAAAoG,GAAApG,EAAA,GACAsqJ,EAAAtqJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8pJ,YAAAD,EAAAC,anJ4kkCM,SAAUzqJ,EAAQC,EAASC,GAEjC,YoJhlkCA,IAAAoG,GAAApG,EAAA,GACAwqJ,EAAAxqJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6M,IAAAk9I,EAAAl9I,KpJulkCM,SAAUxN,EAAQC,EAASC,GAEjC,YqJ3lkCA,IAAAoG,GAAApG,EAAA,GACAilJ,EAAAjlJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAqQ,MAAAm0I,EAAAn0I,OrJkmkCM,SAAUhR,EAAQC,EAASC,GAEjC,YsJtmkCA,IAAAoG,GAAApG,EAAA,GACA4nG,EAAA5nG,EAAA,GACAoG,GAAAhG,WAAAK,UAAA0lG,SAAAyB,EAAAzB,UtJ6mkCM,SAAUrmG,EAAQC,EAASC,GAEjC,YuJjnkCA,IAAAoG,GAAApG,EAAA,GACAyqJ,EAAAzqJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAA84I,SAAAkR,EAAAlR,SACAnzI,EAAAhG,WAAAK,UAAAiqJ,QAAAD,EAAAlR,UvJwnkCM,SAAUz5I,EAAQC,EAASC,GAEjC,YwJ7nkCA,IAAAoG,GAAApG,EAAA,GACA2qJ,EAAA3qJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAmqJ,UAAAD,EAAA7Q,WACA1zI,EAAAhG,WAAAK,UAAAq5I,WAAA6Q,EAAA7Q,YxJookCM,SAAUh6I,EAAQC,EAASC,GAEjC,YyJzokCA,IAAAoG,GAAApG,EAAA,GACA6qJ,EAAA7qJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqqJ,UAAAD,EAAAC,WzJgpkCM,SAAUhrJ,EAAQC,EAASC,GAEjC,Y0JppkCA,IAAAoG,GAAApG,EAAA,GACA+qJ,EAAA/qJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAme,IAAAmsI,EAAAnsI,K1J2pkCM,SAAU9e,EAAQC,EAASC,GAEjC,Y2J/pkCA,IAAAoG,GAAApG,EAAA,GACAgrJ,EAAAhrJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAA0L,UAAA6+I,EAAA7+I,W3JsqkCM,SAAUrM,EAAQC,EAASC,GAEjC,Y4J1qkCA,IAAAoG,GAAApG,EAAA,GACAolG,EAAAplG,EAAA,GACAoG,GAAAhG,WAAAK,UAAAunG,UAAA5C,EAAA4C,W5JirkCM,SAAUloG,EAAQC,EAASC,GAEjC,Y6JrrkCA,IAAAoG,GAAApG,EAAA,GACAqlJ,EAAArlJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAA05I,kBAAAkL,EAAAlL,mB7J4rkCM,SAAUr6I,EAAQC,EAASC,GAEjC,Y8JhskCA,IAAAoG,GAAApG,EAAA,GACAirJ,EAAAjrJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAyqJ,SAAAD,EAAAC,U9JuskCM,SAAUprJ,EAAQC,EAASC,GAEjC,Y+J3skCA,IAAAoG,GAAApG,EAAA,GACAmrJ,EAAAnrJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAo+E,UAAAssE,EAAAtsE,W/JktkCM,SAAU/+E,EAAQC,EAASC,GAEjC,YgKttkCA,IAAAoG,GAAApG,EAAA,GACAorJ,EAAAprJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4qJ,MAAAD,EAAAC,OhK6tkCM,SAAUvrJ,EAAQC,EAASC,GAEjC,YiKjukCA,IAAAoG,GAAApG,EAAA,GACAsrJ,EAAAtrJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8qJ,QAAAD,EAAAC,SjKwukCM,SAAUzrJ,EAAQC,EAASC,GAEjC,YkK5ukCA,IAAAoG,GAAApG,EAAA,GACAwrJ,EAAAxrJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAgrJ,gBAAAD,EAAAC,iBlKmvkCM,SAAU3rJ,EAAQC,EAASC,GAEjC,YmKvvkCA,IAAAoG,GAAApG,EAAA,GACA0rJ,EAAA1rJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAkrJ,YAAAD,EAAAC,anK8vkCM,SAAU7rJ,EAAQC,EAASC,GAEjC,YoKlwkCA,IAAAoG,GAAApG,EAAA,GACA4rJ,EAAA5rJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAorJ,cAAAD,EAAAC,epKywkCM,SAAU/rJ,EAAQC,EAASC,GAEjC,YqK7wkCA,IAAAoG,GAAApG,EAAA,GACAulJ,EAAAvlJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAi6I,KAAA6K,EAAA7K,MrKoxkCM,SAAU56I,EAAQC,EAASC,GAEjC,YsKxxkCA,IAAAoG,GAAApG,EAAA,GACA8rJ,EAAA9rJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAA+G,OAAAskJ,EAAAtkJ,QtK+xkCM,SAAU1H,EAAQC,EAASC,GAEjC,YuKnykCA,IAAAoG,GAAApG,EAAA,GACA+rJ,EAAA/rJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAurJ,OAAAD,EAAAC,QvK0ykCM,SAAUlsJ,EAAQC,EAASC,GAEjC,YwK9ykCA,IAAAoG,GAAApG,EAAA,GACAisJ,EAAAjsJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAyrJ,WAAAD,EAAAC,YxKqzkCM,SAAUpsJ,EAAQC,EAASC,GAEjC,YyKzzkCA,IAAAoG,GAAApG,EAAA,GACAmsJ,EAAAnsJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA2rJ,MAAAD,EAAAC,OzKg0kCM,SAAUtsJ,EAAQC,EAASC,GAEjC,Y0Kp0kCA,IAAAoG,GAAApG,EAAA,GACAqsJ,EAAArsJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6rJ,UAAAD,EAAAC,W1K20kCM,SAAUxsJ,EAAQC,EAASC,GAEjC,Y2K/0kCA,IAAAoG,GAAApG,EAAA,GACAusJ,EAAAvsJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA+rJ,OAAAD,EAAAC,Q3Ks1kCM,SAAU1sJ,EAAQC,EAASC,GAEjC,Y4K11kCA,IAAAoG,GAAApG,EAAA,GACAysJ,EAAAzsJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAisJ,WAAAD,EAAAC,Y5Ki2kCM,SAAU5sJ,EAAQC,EAASC,GAEjC,Y6Kr2kCA,IAAAoG,GAAApG,EAAA,GACA2sJ,EAAA3sJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAy1D,KAAAy2F,EAAAz2F,M7K42kCM,SAAUp2D,EAAQC,EAASC,GAEjC,Y8Kh3kCA,IAAAoG,GAAApG,EAAA,GACA4sJ,EAAA5sJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAosJ,cAAAD,EAAAC,e9Ku3kCM,SAAU/sJ,EAAQC,EAASC,GAEjC,Y+K33kCA,IAAAoG,GAAApG,EAAA,GACA8sJ,EAAA9sJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAggJ,MAAAqM,EAAArM,O/Kk4kCM,SAAU3gJ,EAAQC,EAASC,GAEjC,YgLt4kCA,IAAAoG,GAAApG,EAAA,GACA+sJ,EAAA/sJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAusJ,YAAAD,EAAAC,ahL64kCM,SAAUltJ,EAAQC,EAASC,GAEjC,YiLj5kCA,IAAAoG,GAAApG,EAAA,GACAitJ,EAAAjtJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAysJ,OAAAD,EAAAC,QjLw5kCM,SAAUptJ,EAAQC,EAASC,GAEjC,YkL55kCA,IAAAoG,GAAApG,EAAA,GACAmtJ,EAAAntJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA2sJ,KAAAD,EAAAC,MlLm6kCM,SAAUttJ,EAAQC,EAASC,GAEjC,YmLv6kCA,IAAAoG,GAAApG,EAAA,GACAqtJ,EAAArtJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6sJ,SAAAD,EAAAC,UnL86kCM,SAAUxtJ,EAAQC,EAASC,GAEjC,YoLl7kCA,IAAAoG,GAAApG,EAAA,GACAutJ,EAAAvtJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA+sJ,UAAAD,EAAAC,WpLy7kCM,SAAU1tJ,EAAQC,EAASC,GAEjC,YqL77kCA,IAAAoG,GAAApG,EAAA,GACAytJ,EAAAztJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAitJ,UAAAD,EAAAC,WrLo8kCM,SAAU5tJ,EAAQC,EAASC,GAEjC,YsLx8kCA,IAAAoG,GAAApG,EAAA,GACA2tJ,EAAA3tJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAmtJ,UAAAD,EAAAC,WtL+8kCM,SAAU9tJ,EAAQC,EAASC,GAEjC,YuLn9kCA,IAAAoG,GAAApG,EAAA,GACA6tJ,EAAA7tJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqtJ,YAAAD,EAAAC,avL09kCM,SAAUhuJ,EAAQC,EAASC,GAEjC,YwL99kCA,IAAAoG,GAAApG,EAAA,GACA+tJ,EAAA/tJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAutJ,OAAAD,EAAAE,QACA7nJ,EAAAhG,WAAAK,UAAAwtJ,QAAAF,EAAAE,SxLq+kCM,SAAUnuJ,EAAQC,EAASC,GAEjC,YyL1+kCA,IAAAoG,GAAApG,EAAA,GACAkuJ,EAAAluJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0tJ,UAAAD,EAAAC,WzLi/kCM,SAAUruJ,EAAQC,EAASC,GAEjC,Y0Lr/kCA,IAAAoG,GAAApG,EAAA,GACAouJ,EAAApuJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA4tJ,YAAAD,EAAAC,a1L4/kCM,SAAUvuJ,EAAQC,EAASC,GAEjC,Y2LhglCA,IAAAoG,GAAApG,EAAA,GACAsuJ,EAAAtuJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8tJ,KAAAD,EAAAC,M3LuglCM,SAAUzuJ,EAAQC,EAASC,GAEjC,Y4L3glCA,IAAAoG,GAAApG,EAAA,GACAwuJ,EAAAxuJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAguJ,SAAAD,EAAAC,U5LkhlCM,SAAU3uJ,EAAQC,EAASC,GAEjC,Y6LthlCA,IAAAoG,GAAApG,EAAA,GACA0uJ,EAAA1uJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAkuJ,UAAAD,EAAAC,W7L6hlCM,SAAU7uJ,EAAQC,EAASC,GAEjC,Y8LjilCA,IAAAoG,GAAApG,EAAA,GACA4uJ,EAAA5uJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAouJ,UAAAD,EAAAC,W9LwilCM,SAAU/uJ,EAAQC,EAASC,GAEjC,Y+L5ilCA,IAAAoG,GAAApG,EAAA,GACA8uJ,EAAA9uJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAAs6I,SAAA+T,EAAA/T,U/LmjlCM,SAAUj7I,EAAQC,EAASC,GAEjC,YgMvjlCA,IAAAoG,GAAApG,EAAA,GACA+uJ,EAAA/uJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAuuJ,aAAAD,EAAAC,chM8jlCM,SAAUlvJ,EAAQC,EAASC,GAEjC,YiMlklCA,IAAAoG,GAAApG,EAAA,GACAqqG,EAAArqG,EAAA,GACAoG,GAAAhG,WAAAK,UAAA89F,aAAA8L,EAAA9L,cjMyklCM,SAAUz+F,EAAQC,EAASC,GAEjC,YkM7klCA,IAAAoG,GAAApG,EAAA,GACAivJ,EAAAjvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqlB,QAAAmpI,EAAAnpI,SlMollCM,SAAUhmB,EAAQC,EAASC,GAEjC,YmMxllCA,IAAAoG,GAAApG,EAAA,GACAkvJ,EAAAlvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0uJ,YAAAD,EAAAC,anM+llCM,SAAUrvJ,EAAQC,EAASC,GAEjC,YoMnmlCA,IAAAoG,GAAApG,EAAA,GACAuqG,EAAAvqG,EAAA,GACAoG,GAAAhG,WAAAK,UAAAw7I,UAAA1xC,EAAA0xC,WpM0mlCM,SAAUn8I,EAAQC,EAASC,GAEjC,YqM9mlCA,IAAAoG,GAAApG,EAAA,GACAovJ,EAAApvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAmsG,QAAAwiD,EAAAxiD,SrMqnlCM,SAAU9sG,EAAQC,EAASC,GAEjC,YsMznlCA,IAAAoG,GAAApG,EAAA,GACAqvJ,EAAArvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA6uJ,UAAAD,EAAAC,WtMgolCM,SAAUxvJ,EAAQC,EAASC,GAEjC,YuMpolCA,IAAAoG,GAAApG,EAAA,GACAuvJ,EAAAvvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA0J,OAAAolJ,EAAAplJ,QvM2olCM,SAAUrK,EAAQC,EAASC,GAEjC,YwM/olCA,IAAAoG,GAAApG,EAAA,GACAwvJ,EAAAxvJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAgvJ,YAAAD,EAAAC,axMsplCM,SAAU3vJ,EAAQC,EAASC,GAEjC,YyM1plCA,IAAAoG,GAAApG,EAAA,GACA0vJ,EAAA1vJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAA8kG,WAAAmqD,EAAAnqD,YzMiqlCM,SAAUzlG,EAAQC,EAASC,GAEjC,Y0MrqlCA,IAAAoG,GAAApG,EAAA,GACA2vJ,EAAA3vJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAmvJ,aAAAD,EAAAC,c1M4qlCM,SAAU9vJ,EAAQC,EAASC,GAEjC,Y2MhrlCA,IAAAoG,GAAApG,EAAA,GACA6vJ,EAAA7vJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAqvJ,WAAAD,EAAAC,Y3MurlCM,SAAUhwJ,EAAQC,EAASC,GAEjC,Y4M3rlCA,IAAAoG,GAAApG,EAAA,GACA+vJ,EAAA/vJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAuvJ,eAAAD,EAAAC,gB5MkslCM,SAAUlwJ,EAAQC,EAASC,GAEjC,Y6MtslCA,IAAAoG,GAAApG,EAAA,GACA8lJ,EAAA9lJ,EAAA,GACAoG,GAAAhG,WAAAK,UAAA81D,IAAAuvF,EAAAj9C,U7M6slCM,SAAU/oG,EAAQC,EAASC,GAEjC,Y8MjtlCA,IAAAoG,GAAApG,EAAA,GACAiwJ,EAAAjwJ,EAAA,IACAoG,GAAAhG,WAAAK,UAAAyvJ,OAAAD,EAAAC,Q9MwtlCM,SAAUpwJ,EAAQC,EAASC,GAEjC,Y+M5tlCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAgL,EAAAhL,EAAA,IACAiL,EAAAjL,EAAA,IAMAo2I,EAAA,SAAA7yI,GAEA,QAAA6yI,GAAA+Z,EAAA9kJ,GACA9H,EAAApC,KAAAb,MACAA,KAAA6vJ,YACA7vJ,KAAA+K,YACAA,GAAA,IAAA8kJ,EAAAxsJ,SACArD,KAAAC,WAAA,EACAD,KAAAgC,MAAA6tJ,EAAA,IA4CA,MAnDAztJ,GAAA0zI,EAAA7yI,GAUA6yI,EAAA3zI,OAAA,SAAA0tJ,EAAA9kJ,GACA,GAAA1H,GAAAwsJ,EAAAxsJ,MACA,YAAAA,EACA,GAAAsH,GAAAU,gBAEA,IAAAhI,EACA,GAAAqH,GAAAU,iBAAAykJ,EAAA,GAAA9kJ,GAGA,GAAA+qI,GAAA+Z,EAAA9kJ,IAGA+qI,EAAAxqI,SAAA,SAAAC,GACA,GAAAskJ,GAAAtkJ,EAAAskJ,UAAAjoJ,EAAA2D,EAAA3D,MAAAvE,EAAAkI,EAAAlI,OAAAnB,EAAAqJ,EAAArJ,UACA,KAAAA,EAAA2B,OAAA,CAGA,GAAA+D,GAAAvE,EAEA,WADAnB,GAAAxB,UAGAwB,GAAAb,KAAAwuJ,EAAAjoJ,IACA2D,EAAA3D,QAAA,EACA5H,KAAAyL,SAAAF,KAEAuqI,EAAA31I,UAAAD,WAAA,SAAAgC,GACA,GACA6B,GAAA/D,KAAA6vJ,EAAA9rJ,EAAA8rJ,UAAA9kJ,EAAAhH,EAAAgH,UACA1H,EAAAwsJ,EAAAxsJ,MACA,IAAA0H,EACA,MAAAA,GAAAU,SAAAqqI,EAAAxqI,SAAA,GACAukJ,YAAAjoJ,MALA,EAKAvE,SAAAnB,cAIA,QAAA+D,GAAA,EAA2BA,EAAA5C,IAAAnB,EAAA2B,OAAkCoC,IAC7D/D,EAAAb,KAAAwuJ,EAAA5pJ,GAEA/D,GAAAxB,YAGAo1I,GACChwI,EAAAhG,WACDL,GAAAq2I,uB/MmulCM,SAAUt2I,EAAQC,EAASC,GAEjC,YgNvilCA,SAAAq2I,GAAAnqI,GACA,GAAA5J,GAAA4J,EAAA5J,MAAAoH,EAAAwC,EAAAxC,OACAA,GAAA/H,KAAAW,GACAoH,EAAA1I,WAEA,QAAAs1I,GAAApqI,GACA,GAAAzK,GAAAyK,EAAAzK,GAAAyK,GAAAxC,QACA3I,MAAAU,GAxQA,GAAAiB,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACA4pG,EAAA5pG,EAAA,IAMAowJ,EAAA,SAAA7sJ,GAEA,QAAA6sJ,GAAAC,EAAAhkJ,EAAA4J,EAAAvR,EAAA2G,GACA9H,EAAApC,KAAAb,MACAA,KAAA+vJ,eACA/vJ,KAAA+L,WACA/L,KAAA2V,OACA3V,KAAAoE,UACApE,KAAA+K,YAwOA,MA/OA3I,GAAA0tJ,EAAA7sJ,GAqJA6sJ,EAAA3tJ,OAAA,SAAA6tJ,EAAAjkJ,EAAAhB,GAEA,WADA,KAAAgB,IAAkCA,MAAAipB,IAClC,WAEA,OADArf,MACA1K,EAAA,EAA4BA,EAAA7H,UAAAC,OAAuB4H,IACnD0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA,WAAA6kJ,GAAAE,EAAAjkJ,EAAA4J,EAAA3V,KAAA+K,KAGA+kJ,EAAA3vJ,UAAAD,WAAA,SAAAgC,GACA,GAAA6tJ,GAAA/vJ,KAAA+vJ,aACAp6I,EAAA3V,KAAA2V,KACA5K,EAAA/K,KAAA+K,UACA3B,EAAApJ,KAAAoJ,OACA,IAAA2B,EAmCA,MAAAA,GAAAU,SAAAqkJ,EAAAxkJ,SAAA,GAA4E/K,OAAAP,KAAAkC,aAAAkC,QAAApE,KAAAoE,SAlC5E,KAAAgF,EAAA,CACAA,EAAApJ,KAAAoJ,QAAA,GAAAkgG,GAAA5E,YACA,IAAA8Y,GAAA,QAAAyyC,KAEA,OADAC,MACAjlJ,EAAA,EAAoCA,EAAA7H,UAAAC,OAAuB4H,IAC3DilJ,EAAAjlJ,EAAA,GAAA7H,UAAA6H,EAEA,IAAA1K,GAAA0vJ,EAAA1vJ,OACAwL,EAAAxL,EAAAwL,SAAA3C,EAAA7I,EAAA6I,OACA,IAAA2C,EAAA,CACA,GAAAokJ,GAAA3oJ,EAAAO,SAAAgE,GAAA/G,MAAAhF,KAAAkwJ,EACAC,KAAA1oJ,EAAAO,YACAoB,EAAA3I,MAAAgH,EAAAO,YAAAC,IAGAmB,EAAA/H,KAAA8uJ,GACA/mJ,EAAA1I,gBAIA0I,GAAA/H,KAAA6uJ,EAAA7sJ,QAAA,EAAA6sJ,EAAA,GAAAA,GACA9mJ,EAAA1I,WAIA88G,GAAAj9G,OAAAP,IACAwH,GAAAO,SAAAgoJ,GAAA/qJ,MAAAhF,KAAAoE,QAAAuR,EAAAvO,OAAAo2G,MACA/1G,EAAAO,aACAoB,EAAA3I,MAAAgH,EAAAO,YAAAC,GAGA,MAAAmB,GAAArJ,UAAAmC,IAMA4tJ,EAAAxkJ,SAAA,SAAAC,GACA,GAAAxB,GAAA/J,KACAO,EAAAgL,EAAAhL,OAAA2B,EAAAqJ,EAAArJ,WAAAkC,EAAAmH,EAAAnH,QACA2rJ,EAAAxvJ,EAAAwvJ,aAAAp6I,EAAApV,EAAAoV,KAAA5K,EAAAxK,EAAAwK,UACA3B,EAAA7I,EAAA6I,OACA,KAAAA,EAAA,CACAA,EAAA7I,EAAA6I,QAAA,GAAAkgG,GAAA5E,YACA,IAAA8Y,GAAA,QAAAyyC,KAEA,OADAC,MACAjlJ,EAAA,EAAgCA,EAAA7H,UAAAC,OAAuB4H,IACvDilJ,EAAAjlJ,EAAA,GAAA7H,UAAA6H,EAEA,IAAA1K,GAAA0vJ,EAAA1vJ,OACAwL,EAAAxL,EAAAwL,SAAA3C,EAAA7I,EAAA6I,OACA,IAAA2C,EAAA,CACA,GAAAqkJ,GAAA5oJ,EAAAO,SAAAgE,GAAA/G,MAAAhF,KAAAkwJ,EACAE,KAAA3oJ,EAAAO,YACA+B,EAAAjJ,IAAAiK,EAAAU,SAAAuqI,EAAA,GAAuE70I,IAAAsG,EAAAO,YAAAC,EAAAmB,aAGvEW,EAAAjJ,IAAAiK,EAAAU,SAAAsqI,EAAA,GAAsE/zI,MAAAouJ,EAAAhnJ,iBAGtE,CACA,GAAApH,GAAAkuJ,EAAA7sJ,QAAA,EAAA6sJ,EAAA,GAAAA,CACAnmJ,GAAAjJ,IAAAiK,EAAAU,SAAAsqI,EAAA,GAAkE/zI,QAAAoH,cAIlEo0G,GAAAj9G,QACAiH,GAAAO,SAAAgoJ,GAAA/qJ,MAAAZ,EAAAuR,EAAAvO,OAAAo2G,MACA/1G,EAAAO,aACAoB,EAAA3I,MAAAgH,EAAAO,YAAAC,GAGA8B,EAAAjJ,IAAAsI,EAAArJ,UAAAmC,KAEA4tJ,GACChqJ,EAAAhG,WACDL,GAAAqwJ,2BhNwzlCM,SAAUtwJ,EAAQC,EAASC,GAEjC,YiNx2lCA,SAAA4L,GAAAC,GACA,GAAAxB,GAAA/J,KACAO,EAAAgL,EAAAhL,OAAA2B,EAAAqJ,EAAArJ,WAAAkC,EAAAmH,EAAAnH,QAEAL,EAAAxD,EAAAwvJ,EAAAhsJ,EAAAgsJ,aAAAp6I,EAAA5R,EAAA4R,KAAA5K,EAAAhH,EAAAgH,UACA3B,EAAA7I,EAAA6I,OACA,KAAAA,EAAA,CACAA,EAAA7I,EAAA6I,QAAA,GAAAkgG,GAAA5E,YACA,IAAA8Y,GAAA,QAAAyyC,KAEA,OADAC,MACAjlJ,EAAA,EAA4BA,EAAA7H,UAAAC,OAAuB4H,IACnDilJ,EAAAjlJ,EAAA,GAAA7H,UAAA6H,EAEA,IAAA1K,GAAA0vJ,EAAA1vJ,OACAwL,EAAAxL,EAAAwL,SAAA3C,EAAA7I,EAAA6I,QACAjI,EAAA+uJ,EAAA79G,OACA,IAAAlxC,EACA4I,EAAAjJ,IAAAiK,EAAAU,SAAAuqI,EAAA,GAA+D70I,MAAAiI,iBAE/D,IAAA2C,EAAA,CACA,GAAAqkJ,GAAA5oJ,EAAAO,SAAAgE,GAAA/G,MAAAhF,KAAAkwJ,EACAE,KAAA3oJ,EAAAO,YACA+B,EAAAjJ,IAAAiK,EAAAU,SAAAuqI,EAAA,GAAmE70I,IAAAsG,EAAAO,YAAAC,EAAAmB,aAGnEW,EAAAjJ,IAAAiK,EAAAU,SAAAsqI,EAAA,GAAkE/zI,MAAAouJ,EAAAhnJ,iBAGlE,CACA,GAAApH,GAAAkuJ,EAAA7sJ,QAAA,EAAA6sJ,EAAA,GAAAA,CACAnmJ,GAAAjJ,IAAAiK,EAAAU,SAAAsqI,EAAA,GAA8D/zI,QAAAoH,cAI9Do0G,GAAAj9G,QACAiH,GAAAO,SAAAgoJ,GAAA/qJ,MAAAZ,EAAAuR,EAAAvO,OAAAo2G,MACA/1G,EAAAO,aACA+B,EAAAjJ,IAAAiK,EAAAU,SAAAuqI,EAAA,GAA2D70I,IAAAsG,EAAAO,YAAAC,EAAAmB,aAG3DW,EAAAjJ,IAAAsI,EAAArJ,UAAAmC,IAEA,QAAA6zI,GAAAnqI,GACA,GAAA5J,GAAA4J,EAAA5J,MAAAoH,EAAAwC,EAAAxC,OACAA,GAAA/H,KAAAW,GACAoH,EAAA1I,WAEA,QAAAs1I,GAAApqI,GACA,GAAAzK,GAAAyK,EAAAzK,GAAAyK,GAAAxC,QACA3I,MAAAU,GAnQA,GAAAiB,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACA4pG,EAAA5pG,EAAA,IAMA2wJ,EAAA,SAAAptJ,GAEA,QAAAotJ,GAAAN,EAAAhkJ,EAAA4J,EAAAvR,EAAA2G,GACA9H,EAAApC,KAAAb,MACAA,KAAA+vJ,eACA/vJ,KAAA+L,WACA/L,KAAA2V,OACA3V,KAAAoE,UACApE,KAAA+K,YAyLA,MAhMA3I,GAAAiuJ,EAAAptJ,GAuIAotJ,EAAAluJ,OAAA,SAAA6tJ,EAAAjkJ,EAAAhB,GAEA,WADA,KAAAgB,IAAkCA,MAAAipB,IAClC,WAEA,OADArf,MACA1K,EAAA,EAA4BA,EAAA7H,UAAAC,OAAuB4H,IACnD0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA,WAAAolJ,GAAAL,EAAAjkJ,EAAA4J,EAAA3V,KAAA+K,KAGAslJ,EAAAlwJ,UAAAD,WAAA,SAAAgC,GACA,GAAA6tJ,GAAA/vJ,KAAA+vJ,aACAp6I,EAAA3V,KAAA2V,KACA5K,EAAA/K,KAAA+K,UACA3B,EAAApJ,KAAAoJ,OACA,IAAA2B,EAuCA,MAAAA,GAAAU,SAAAH,EAAA,GAAoD/K,OAAAP,KAAAkC,aAAAkC,QAAApE,KAAAoE,SAtCpD,KAAAgF,EAAA,CACAA,EAAApJ,KAAAoJ,QAAA,GAAAkgG,GAAA5E,YACA,IAAA8Y,GAAA,QAAAyyC,KAEA,OADAC,MACAjlJ,EAAA,EAAoCA,EAAA7H,UAAAC,OAAuB4H,IAC3DilJ,EAAAjlJ,EAAA,GAAA7H,UAAA6H,EAEA,IAAA1K,GAAA0vJ,EAAA1vJ,OACAwL,EAAAxL,EAAAwL,SAAA3C,EAAA7I,EAAA6I,QACAjI,EAAA+uJ,EAAA79G,OACA,IAAAlxC,EACAiI,EAAA3I,MAAAU,OAEA,IAAA4K,EAAA,CACA,GAAAokJ,GAAA3oJ,EAAAO,SAAAgE,GAAA/G,MAAAhF,KAAAkwJ,EACAC,KAAA1oJ,EAAAO,YACAoB,EAAA3I,MAAAgH,EAAAO,YAAAC,IAGAmB,EAAA/H,KAAA8uJ,GACA/mJ,EAAA1I,gBAIA0I,GAAA/H,KAAA6uJ,EAAA7sJ,QAAA,EAAA6sJ,EAAA,GAAAA,GACA9mJ,EAAA1I,WAIA88G,GAAAj9G,OAAAP,IACAwH,GAAAO,SAAAgoJ,GAAA/qJ,MAAAhF,KAAAoE,QAAAuR,EAAAvO,OAAAo2G,MACA/1G,EAAAO,aACAoB,EAAA3I,MAAAgH,EAAAO,YAAAC,GAGA,MAAAmB,GAAArJ,UAAAmC,IAMAmuJ,GACCvqJ,EAAAhG,WACDL,GAAA4wJ,+BjNonmCM,SAAU7wJ,EAAQC,EAASC,GAEjC,YkNv0mCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,GAMA4wJ,EAAA,SAAArtJ,GAEA,QAAAqtJ,GAAAC,GACAttJ,EAAApC,KAAAb,MACAA,KAAAuwJ,oBAsDA,MAzDAnuJ,GAAAkuJ,EAAArtJ,GAmDAqtJ,EAAAnuJ,OAAA,SAAAouJ,GACA,UAAAD,GAAAC,IAEAD,EAAAnwJ,UAAAD,WAAA,SAAAgC,GACA,UAAAsuJ,GAAAtuJ,EAAAlC,KAAAuwJ,oBAEAD,GACCxqJ,EAAAhG,WACDL,GAAA6wJ,iBACA,IAAAE,GAAA,SAAAvtJ,GAEA,QAAAutJ,GAAAltJ,EAAA+I,GACApJ,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAqM,UACArM,KAAAywJ,WAgBA,MApBAruJ,GAAAouJ,EAAAvtJ,GAMAutJ,EAAArwJ,UAAAswJ,SAAA,WACA,IACAzwJ,KAAA0wJ,eAEA,MAAAvvJ,GACAnB,KAAA2D,OAAAxC,KAGAqvJ,EAAArwJ,UAAAuwJ,aAAA,WACA,GAAA/qJ,GAAA3F,KAAAqM,SACA1G,IACA3F,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA2F,KAGA6qJ,GACCxqD,EAAAjhG,kBlN80mCK,SAAUvF,EAAQC,EAASC,GAEjC,YmNh7mCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GAMAixJ,EAAA,SAAA1tJ,GAEA,QAAA0tJ,GAAAlwJ,EAAAsK,GACA9H,EAAApC,KAAAb,MACAA,KAAAS,QACAT,KAAA+K,YA8DA,MAlEA3I,GAAAuuJ,EAAA1tJ,GA8CA0tJ,EAAAxuJ,OAAA,SAAA1B,EAAAsK,GACA,UAAA4lJ,GAAAlwJ,EAAAsK,IAEA4lJ,EAAArlJ,SAAA,SAAAM,GACA,GAAAnL,GAAAmL,EAAAnL,KAAAmL,GAAA1J,WACAzB,UAEAkwJ,EAAAxwJ,UAAAD,WAAA,SAAAgC,GACA,GAAAzB,GAAAT,KAAAS,MACAsK,EAAA/K,KAAA+K,SAEA,IADA7I,EAAAlB,oBAAA,EACA+J,EACA,MAAAA,GAAAU,SAAAklJ,EAAArlJ,SAAA,GACA7K,QAAAyB,cAIAA,GAAAzB,UAGAkwJ,GACC7qJ,EAAAhG,WACDL,GAAAkxJ,mBnNu7mCM,SAAUnxJ,EAAQC,EAASC,GAEjC,YoNzgnCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAiL,EAAAjL,EAAA,IACA6H,EAAA7H,EAAA,IACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,GAMAkxJ,EAAA,SAAA3tJ,GAEA,QAAA2tJ,GAAAC,EAAA3X,GACAj2I,EAAApC,KAAAb,MACAA,KAAA6wJ,UACA7wJ,KAAAk5I,iBAmCA,MAvCA92I,GAAAwuJ,EAAA3tJ,GAcA2tJ,EAAAzuJ,OAAA,WAEA,OADA0uJ,MACA5lJ,EAAA,EAAwBA,EAAA7H,UAAAC,OAAuB4H,IAC/C4lJ,EAAA5lJ,EAAA,GAAA7H,UAAA6H,EAEA,WAAA4lJ,GAAA,IAAAztJ,UAAAC,OACA,UAAAsH,GAAAU,eAEA,IAAA6tI,GAAA,IASA,OARA,kBAAA2X,KAAAxtJ,OAAA,KACA61I,EAAA2X,EAAA1lJ,OAIA,IAAA0lJ,EAAAxtJ,QAAAkE,EAAAW,QAAA2oJ,EAAA,MACAA,IAAA,IAEA,IAAAA,EAAAxtJ,OACA,GAAAsH,GAAAU,gBAEA,GAAAulJ,GAAAC,EAAA3X,IAEA0X,EAAAzwJ,UAAAD,WAAA,SAAAgC,GACA,UAAA4uJ,GAAA5uJ,EAAAlC,KAAA6wJ,QAAA7wJ,KAAAk5I,iBAEA0X,GACC9qJ,EAAAhG,WACDL,GAAAmxJ,oBAMA,IAAAE,GAAA,SAAA7tJ,GAEA,QAAA6tJ,GAAAxtJ,EAAAutJ,EAAA3X,GACAj2I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6wJ,UACA7wJ,KAAAk5I,iBACAl5I,KAAA+wJ,UAAA,EACA/wJ,KAAAgxJ,WAAA,CACA,IAAA9qJ,GAAA2qJ,EAAAxtJ,MACArD,MAAA6oE,MAAA3iE,EACAlG,KAAA0O,OAAA,GAAAhD,OAAAxF,EACA,QAAAD,GAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAA1F,GAAAswJ,EAAA5qJ,GACAgrJ,EAAAhrD,EAAAxgG,kBAAAzF,KAAAO,EAAA,KAAA0F,EACAgrJ,KACAA,EAAA7rJ,WAAAa,EACAjG,KAAAc,IAAAmwJ,KA6BA,MA5CA7uJ,GAAA0uJ,EAAA7tJ,GAmBA6tJ,EAAA3wJ,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA0O,OAAAtJ,GAAAD,EACAG,EAAA4rJ,YACA5rJ,EAAA4rJ,WAAA,EACAlxJ,KAAAgxJ,eAGAF,EAAA3wJ,UAAAqF,eAAA,SAAAF,GACA,GAAAhC,GAAAtD,KAAAsD,YACAS,EAAA/D,KAAAgxJ,EAAAjtJ,EAAAitJ,WAAA9X,EAAAn1I,EAAAm1I,eAAAxqI,EAAA3K,EAAA2K,OACAxI,EAAAwI,EAAArL,MACA,KAAAiC,EAAA4rJ,UAEA,WADA5tJ,GAAA5C,UAIA,MADAV,KAAA+wJ,YACA7qJ,EAAA,CAGA,GAAA8qJ,IAAA9qJ,EAAA,CACA,GAAAlE,GAAAk3I,IAAAl0I,MAAAhF,KAAA0O,IACApL,GAAAjC,KAAAW,GAEAsB,EAAA5C,aAEAowJ,GACC9qD,EAAAjhG,kBpNghnCK,SAAUvF,EAAQC,EAASC,GAEjC,YqNpnnCA,SAAAyxJ,GAAAC,GACA,QAAAA,GAAA,kBAAAA,GAAA1O,aAAA,kBAAA0O,GAAAxO,eAEA,QAAAyO,GAAAD,GACA,QAAAA,GAAA,kBAAAA,GAAAt8I,IAAA,kBAAAs8I,GAAAzO,IAEA,QAAA2O,GAAAF,GACA,QAAAA,GAAA,sBAAAr9I,EAAAlT,KAAAuwJ,GAEA,QAAAG,GAAAH,GACA,QAAAA,GAAA,4BAAAr9I,EAAAlT,KAAAuwJ,GAEA,QAAAI,GAAAJ,GACA,QAAAA,GAAA,kBAAAA,GAAA57I,kBAAA,kBAAA47I,GAAAj8I,oBAxBA,GAAA/S,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACA8H,EAAA9H,EAAA,GACAkD,EAAAlD,EAAA,IACA+H,EAAA/H,EAAA,GACAmD,EAAAnD,EAAA,GACAqU,EAAApR,OAAAxC,UAAA4T,SAqBA09I,EAAA,SAAAxuJ,GAEA,QAAAwuJ,GAAAL,EAAAM,EAAA3lJ,EAAA63F,GACA3gG,EAAApC,KAAAb,MACAA,KAAAoxJ,YACApxJ,KAAA0xJ,YACA1xJ,KAAA+L,WACA/L,KAAA4jG,UAiGA,MAvGAxhG,GAAAqvJ,EAAAxuJ,GAiDAwuJ,EAAAtvJ,OAAA,SAAA0Z,EAAA61I,EAAA9tD,EAAA73F,GAKA,MAJAnJ,GAAAyB,WAAAu/F,KACA73F,EAAA63F,EACAA,MAAA5uE,IAEA,GAAAy8H,GAAA51I,EAAA61I,EAAA3lJ,EAAA63F,IAEA6tD,EAAAE,kBAAA,SAAAP,EAAAM,EAAAl0C,EAAAt7G,EAAA0hG,GACA,GAAA3hG,EACA,IAAAqvJ,EAAAF,IAAAG,EAAAH,GACA,OAAAnrJ,GAAA,EAAAC,EAAAkrJ,EAAA/tJ,OAAmD4C,EAAAC,EAASD,IAC5DwrJ,EAAAE,kBAAAP,EAAAnrJ,GAAAyrJ,EAAAl0C,EAAAt7G,EAAA0hG,OAGA,IAAA4tD,EAAAJ,GAAA,CACA,GAAAQ,GAAAR,CACAA,GAAA57I,iBAAAk8I,EAAAl0C,EAAA5Z,GACA3hG,EAAA,WAAuC,MAAA2vJ,GAAAz8I,oBAAAu8I,EAAAl0C,QAEvC,IAAA6zC,EAAAD,GAAA,CACA,GAAAS,GAAAT,CACAA,GAAAt8I,GAAA48I,EAAAl0C,GACAv7G,EAAA,WAAuC,MAAA4vJ,GAAAlP,IAAA+O,EAAAl0C,QAEvC,KAAA2zC,EAAAC,GAMA,SAAAxqJ,WAAA,uBALA,IAAAkrJ,GAAAV,CACAA,GAAA1O,YAAAgP,EAAAl0C,GACAv7G,EAAA,WAAuC,MAAA6vJ,GAAAlP,eAAA8O,EAAAl0C,IAKvCt7G,EAAApB,IAAA,GAAA+B,GAAAqB,aAAAjC,KAEAwvJ,EAAAtxJ,UAAAD,WAAA,SAAAgC,GACA,GAAAkvJ,GAAApxJ,KAAAoxJ,UACAM,EAAA1xJ,KAAA0xJ,UACA9tD,EAAA5jG,KAAA4jG,QACA73F,EAAA/L,KAAA+L,SACAyxG,EAAAzxG,EAAA,WAEA,OADA4J,MACA1K,EAAA,EAA4BA,EAAA7H,UAAAC,OAAuB4H,IACnD0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA,IAAAtF,GAAA6B,EAAAO,SAAAgE,GAAA/G,UAAA,GAAA2Q,EACAhQ,KAAA8B,EAAAO,YACA9F,EAAAzB,MAAAgH,EAAAO,YAAAC,GAGA/F,EAAAb,KAAAsE,IAES,SAAAsC,GAAiB,MAAA/F,GAAAb,KAAA4G,GAC1BwpJ,GAAAE,kBAAAP,EAAAM,EAAAl0C,EAAAt7G,EAAA0hG,IAEA6tD,GACC3rJ,EAAAhG,WACDL,GAAAgyJ,uBrNsonCM,SAAUjyJ,EAAQC,EAASC,GAEjC,YsNjxnCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAK,EAAAlD,EAAA,IACAoG,EAAApG,EAAA,GACAmD,EAAAnD,EAAA,GAMAqyJ,EAAA,SAAA9uJ,GAEA,QAAA8uJ,GAAA5mC,EAAA6mC,EAAAjmJ,GACA9I,EAAApC,KAAAb,MACAA,KAAAmrH,aACAnrH,KAAAgyJ,gBACAhyJ,KAAA+L,WAyFA,MA9FA3J,GAAA2vJ,EAAA9uJ,GAuDA8uJ,EAAA5vJ,OAAA,SAAAgpH,EAAA6mC,EAAAjmJ,GACA,UAAAgmJ,GAAA5mC,EAAA6mC,EAAAjmJ,IAEAgmJ,EAAA5xJ,UAAAD,WAAA,SAAAgC,GACA,GAAAX,GAAAvB,KACAgyJ,EAAAhyJ,KAAAgyJ,cACAx0C,EAAAx9G,KAAA+L,SAAA,WAEA,OADA4J,MACA1K,EAAA,EAA4BA,EAAA7H,UAAAC,OAAuB4H,IACnD0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA1J,GAAA0wJ,cAAA/vJ,EAAAyT,IACS,SAAA1N,GAAiB/F,EAAAb,KAAA4G,IAC1BiqJ,EAAAlyJ,KAAAmyJ,gBAAA30C,EAAAt7G,EACAU,GAAAyB,WAAA2tJ,IAGA9vJ,EAAApB,IAAA,GAAA+B,GAAAqB,aAAA,WAEA8tJ,EAAAx0C,EAAA00C,OAGAH,EAAA5xJ,UAAA8xJ,cAAA,SAAA/vJ,EAAAyT,GACA,IACA,GAAAhQ,GAAA3F,KAAA+L,SAAA/G,MAAAhF,KAAA2V,EACAzT,GAAAb,KAAAsE,GAEA,MAAAsC,GACA/F,EAAAzB,MAAAwH,KAGA8pJ,EAAA5xJ,UAAAgyJ,gBAAA,SAAA30C,EAAA40C,GACA,IACA,MAAApyJ,MAAAmrH,WAAA3N,IAAA,KAEA,MAAAv1G,GACAmqJ,EAAA3xJ,MAAAwH,KAGA8pJ,GACCjsJ,EAAAhG,WACDL,GAAAsyJ,8BtNwxnCM,SAAUvyJ,EAAQC,EAASC,GAEjC,YuNx4nCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAkL,EAAAlL,EAAA,IACA2yJ,EAAA,SAAArwJ,GAAqC,MAAAA,IAMrCswJ,EAAA,SAAArvJ,GAEA,QAAAqvJ,GAAAC,EAAAp0B,EAAAq0B,EAAAtZ,EAAAnuI,GACA9H,EAAApC,KAAAb,MACAA,KAAAuyJ,eACAvyJ,KAAAm+H,YACAn+H,KAAAwyJ,UACAxyJ,KAAAk5I,iBACAl5I,KAAA+K,YA6GA,MApHA3I,GAAAkwJ,EAAArvJ,GASAqvJ,EAAAnwJ,OAAA,SAAAswJ,EAAAt0B,EAAAq0B,EAAAE,EAAA3nJ,GACA,UAAA3H,UAAAC,OACA,GAAAivJ,GAAAG,EAAAF,aAAAE,EAAAt0B,UAAAs0B,EAAAD,QAAAC,EAAAvZ,gBAAAmZ,EAAAI,EAAA1nJ,eAEAiqB,KAAA09H,GAAA9nJ,EAAAM,YAAAwnJ,GACA,GAAAJ,GAAAG,EAAAt0B,EAAAq0B,EAAAH,EAAAK,GAEA,GAAAJ,GAAAG,EAAAt0B,EAAAq0B,EAAAE,EAAA3nJ,IAEAunJ,EAAAnyJ,UAAAD,WAAA,SAAAgC,GACA,GAAAqJ,GAAAvL,KAAAuyJ,YACA,IAAAvyJ,KAAA+K,UACA,MAAA/K,MAAA+K,UAAAU,SAAA6mJ,EAAAhnJ,SAAA,GACApJ,aACAswJ,QAAAxyJ,KAAAwyJ,QACAr0B,UAAAn+H,KAAAm+H,UACA+a,eAAAl5I,KAAAk5I,eACA3tI,SAGA,KADA,GAAAxH,GAAA/D,KAAAm+H,EAAAp6H,EAAAo6H,UAAA+a,EAAAn1I,EAAAm1I,eAAAsZ,EAAAzuJ,EAAAyuJ,UACA,CACA,GAAAr0B,EAAA,CACA,GAAAw0B,OAAA,EACA,KACAA,EAAAx0B,EAAA5yH,GAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,GAGA,IAAAwxJ,EAAA,CACAzwJ,EAAAxB,UACA,QAGA,GAAAsB,OAAA,EACA,KACAA,EAAAk3I,EAAA3tI,GAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,GAIA,GADAe,EAAAb,KAAAW,GACAE,EAAA2B,OACA,KAEA,KACA0H,EAAAinJ,EAAAjnJ,GAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,MAKAmxJ,EAAAhnJ,SAAA,SAAAC,GACA,GAAArJ,GAAAqJ,EAAArJ,WAAAi8H,EAAA5yH,EAAA4yH,SACA,KAAAj8H,EAAA2B,OAAA,CAGA,GAAA0H,EAAAqnJ,YACA,IACArnJ,UAAAinJ,QAAAjnJ,SAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,OAKAoK,GAAAqnJ,aAAA,CAEA,IAAAz0B,EAAA,CACA,GAAAw0B,OAAA,EACA,KACAA,EAAAx0B,EAAA5yH,SAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,GAGA,IAAAwxJ,EAEA,WADAzwJ,GAAAxB,UAGA,IAAAwB,EAAA2B,OACA,OAGA,GAAA7B,EACA,KACAA,EAAAuJ,EAAA2tI,eAAA3tI,SAEA,MAAApK,GAEA,WADAe,GAAAzB,MAAAU,GAGA,IAAAe,EAAA2B,SAGA3B,EAAAb,KAAAW,IACAE,EAAA2B,QAGA,MAAA7D,MAAAyL,SAAAF,KAEA+mJ,GACCxsJ,EAAAhG,WACDL,GAAA6yJ,sBvN+4nCM,SAAU9yJ,EAAQC,EAASC,GAEjC,YwNrhoCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,GAMAmzJ,EAAA,SAAA5vJ,GAEA,QAAA4vJ,GAAA10B,EAAA20B,EAAAC,GACA9vJ,EAAApC,KAAAb,MACAA,KAAAm+H,YACAn+H,KAAA8yJ,aACA9yJ,KAAA+yJ,aASA,MAdA3wJ,GAAAywJ,EAAA5vJ,GAOA4vJ,EAAA1wJ,OAAA,SAAAg8H,EAAA20B,EAAAC,GACA,UAAAF,GAAA10B,EAAA20B,EAAAC,IAEAF,EAAA1yJ,UAAAD,WAAA,SAAAgC,GACA,GAAA6B,GAAA/D,KAAAm+H,EAAAp6H,EAAAo6H,UAAA20B,EAAA/uJ,EAAA+uJ,WAAAC,EAAAhvJ,EAAAgvJ,UACA,WAAAC,GAAA9wJ,EAAAi8H,EAAA20B,EAAAC,IAEAF,GACC/sJ,EAAAhG,WACDL,GAAAozJ,cACA,IAAAG,GAAA,SAAA/vJ,GAEA,QAAA+vJ,GAAA1vJ,EAAA66H,EAAA20B,EAAAC,GACA9vJ,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAm+H,YACAn+H,KAAA8yJ,aACA9yJ,KAAA+yJ,aACA/yJ,KAAAizJ,QAmBA,MAzBA7wJ,GAAA4wJ,EAAA/vJ,GAQA+vJ,EAAA7yJ,UAAA8yJ,MAAA,WACA,GACAttJ,GADA5B,EAAA/D,KAAAm+H,EAAAp6H,EAAAo6H,UAAA20B,EAAA/uJ,EAAA+uJ,WAAAC,EAAAhvJ,EAAAgvJ,UAEA,KACAptJ,EAAAw4H,GACA,IAAA59H,GAAAoF,EAAAmtJ,EAAAC,CACAxyJ,GACAP,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAO,IAGAP,KAAA4D,YAGA,MAAAzC,GACAnB,KAAA2D,OAAAxC,KAGA6xJ,GACChtD,EAAAjhG,kBxN4hoCK,SAAUvF,EAAQC,EAASC,GAEjC,YyNxloCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA2wJ,EAAAxzJ,EAAA,IACAoG,EAAApG,EAAA,GACAkrG,EAAAlrG,EAAA,GAMAyzJ,EAAA,SAAAlwJ,GAEA,QAAAkwJ,GAAAhoF,EAAApgE,OACA,KAAAogE,IAAgCA,EAAA,OAChC,KAAApgE,IAAmCA,EAAA6/F,EAAArgG,OACnCtH,EAAApC,KAAAb,MACAA,KAAAmrE,SACAnrE,KAAA+K,cACAmoJ,EAAAzsD,UAAAt7B,MAAA,KACAnrE,KAAAmrE,OAAA,GAEApgE,GAAA,kBAAAA,GAAAU,WACAzL,KAAA+K,UAAA6/F,EAAArgG,OA0DA,MArEAnI,GAAA+wJ,EAAAlwJ,GA+CAkwJ,EAAAhxJ,OAAA,SAAAgpE,EAAApgE,GAGA,WAFA,KAAAogE,IAAgCA,EAAA,OAChC,KAAApgE,IAAmCA,EAAA6/F,EAAArgG,OACnC,GAAA4oJ,GAAAhoF,EAAApgE,IAEAooJ,EAAA7nJ,SAAA,SAAAC,GACA,GAAA3D,GAAA2D,EAAA3D,MAAA1F,EAAAqJ,EAAArJ,WAAAipE,EAAA5/D,EAAA4/D,MACAjpE,GAAAb,KAAAuG,GACA1F,EAAA2B,SAGA0H,EAAA3D,OAAA,EACA5H,KAAAyL,SAAAF,EAAA4/D,KAEAgoF,EAAAhzJ,UAAAD,WAAA,SAAAgC,GACA,GACAipE,GAAAnrE,KAAAmrE,OACApgE,EAAA/K,KAAA+K,SACA7I,GAAApB,IAAAiK,EAAAU,SAAA0nJ,EAAA7nJ,SAAA6/D,GACAvjE,MAJA,EAIA1F,aAAAipE,aAGAgoF,GACCrtJ,EAAAhG,WACDL,GAAA0zJ,sBzN+loCM,SAAU3zJ,EAAQC,EAASC,GAEjC,Y0NjkoCA,SAAA0zJ,GAAA9nD,GACA,GAAArlG,GAAAqlG,EAAA/kG,EAAAC,SACA,KAAAP,GAAA,gBAAAqlG,GACA,UAAA+nD,GAAA/nD,EAEA,KAAArlG,OAAA+uB,KAAAs2E,EAAAjoG,OACA,UAAAiwJ,GAAAhoD,EAEA,KAAArlG,EACA,SAAAW,WAAA,yBAEA,OAAA0kG,GAAA/kG,EAAAC,YAGA,QAAA+sJ,GAAAv+I,GACA,GAAA9O,IAAA8O,EAAA3R,MACA,OAAAge,OAAAnb,GACA,EAEA,IAAAA,GAAAstJ,EAAAttJ,IAGAA,EAAA8vB,EAAA9vB,GAAA6G,KAAAG,MAAAH,KAAAY,IAAAzH,IACAA,GAAA,EACA,EAEAA,EAAAutJ,EACAA,EAEAvtJ,GATAA,EAWA,QAAAstJ,GAAAxxJ,GACA,sBAAAA,IAAArC,EAAA6B,KAAAuP,SAAA/O,GAEA,QAAAg0B,GAAAh0B,GACA,GAAA0xJ,IAAA1xJ,CACA,YAAA0xJ,EACAA,EAEAryI,MAAAqyI,GACAA,EAEAA,EAAA,OA/JA,GAAAtxJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA5C,EAAAD,EAAA,GACAoG,EAAApG,EAAA,GACA6G,EAAA7G,EAAA,IAMAm2I,EAAA,SAAA5yI,GAEA,QAAA4yI,GAAArvI,EAAAuE,GAGA,GAFA9H,EAAApC,KAAAb,MACAA,KAAA+K,YACA,MAAAvE,EACA,SAAA5E,OAAA,2BAEA5B,MAAAwG,SAAA4sJ,EAAA5sJ,GAqDA,MA5DApE,GAAAyzI,EAAA5yI,GASA4yI,EAAA1zI,OAAA,SAAAqE,EAAAuE,GACA,UAAA8qI,GAAArvI,EAAAuE,IAEA8qI,EAAAvqI,SAAA,SAAAC,GACA,GAAA3D,GAAA2D,EAAA3D,MAAAsB,EAAAqC,EAAArC,SAAA1C,EAAA+E,EAAA/E,SAAAtE,EAAAqJ,EAAArJ,UACA,IAAAgH,EAEA,WADAhH,GAAAzB,MAAA8K,EAAA9K,MAGA,IAAAkF,GAAAa,EAAAnF,MACA,OAAAsE,GAAAe,SACAxE,GAAAxB,YAGAwB,EAAAb,KAAAsE,EAAA3D,OACAuJ,EAAA3D,QAAA,EACA1F,EAAA2B,YACA,kBAAA2C,GAAAmtJ,QACAntJ,EAAAmtJ,cAIA3zJ,MAAAyL,SAAAF,KAEAsqI,EAAA11I,UAAAD,WAAA,SAAAgC,GACA,GACA6B,GAAA/D,KAAAwG,EAAAzC,EAAAyC,SAAAuE,EAAAhH,EAAAgH,SACA,IAAAA,EACA,MAAAA,GAAAU,SAAAoqI,EAAAvqI,SAAA,GACA1D,MAJA,EAIApB,WAAAtE,cAIA,SACA,GAAAyD,GAAAa,EAAAnF,MACA,IAAAsE,EAAAe,KAAA,CACAxE,EAAAxB,UACA,OAKA,GAFAwB,EAAAb,KAAAsE,EAAA3D,OAEAE,EAAA2B,OAAA,CACA,kBAAA2C,GAAAmtJ,QACAntJ,EAAAmtJ,QAEA,UAKA9d,GACC/vI,EAAAhG,WACDL,GAAAo2I,oBACA,IAAAwd,GAAA,WACA,QAAAA,GAAAvnD,EAAAygB,EAAArmH,OACA,KAAAqmH,IAA6BA,EAAA,OAC7B,KAAArmH,IAA6BA,EAAA4lG,EAAAzoG,QAC7BrD,KAAA8rG,MACA9rG,KAAAusH,MACAvsH,KAAAkG,MAYA,MAVAmtJ,GAAAlzJ,UAAAoG,EAAAC,UAAA,WAAiE,aACjE6sJ,EAAAlzJ,UAAAkB,KAAA,WACA,MAAArB,MAAAusH,IAAAvsH,KAAAkG,KACAQ,MAAA,EACA1E,MAAAhC,KAAA8rG,IAAAvwD,OAAAv7C,KAAAusH,SAEA7lH,MAAA,EACA1E,UAAAgzB,KAGAq+H,KAEAC,EAAA,WACA,QAAAA,GAAAtnD,EAAAugB,EAAArmH,OACA,KAAAqmH,IAA6BA,EAAA,OAC7B,KAAArmH,IAA6BA,EAAAqtJ,EAAAvnD,IAC7BhsG,KAAAgsG,MACAhsG,KAAAusH,MACAvsH,KAAAkG,MAYA,MAVAotJ,GAAAnzJ,UAAAoG,EAAAC,UAAA,WAAgE,MAAAxG,OAChEszJ,EAAAnzJ,UAAAkB,KAAA,WACA,MAAArB,MAAAusH,IAAAvsH,KAAAkG,KACAQ,MAAA,EACA1E,MAAAhC,KAAAgsG,IAAAhsG,KAAAusH,SAEA7lH,MAAA,EACA1E,UAAAgzB,KAGAs+H,KAeAG,EAAA1mJ,KAAAM,IAAA,S1N2toCM,SAAU7N,EAAQC,EAASC,GAEjC,Y2N/1oCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAk0J,EAAAl0J,EAAA,IAMAm0J,EAAA,SAAA5wJ,GAEA,QAAA4wJ,KACA5wJ,EAAApC,KAAAb,MAuCA,MAzCAoC,GAAAyxJ,EAAA5wJ,GAmCA4wJ,EAAA1xJ,OAAA,WACA,UAAA0xJ,IAEAA,EAAA1zJ,UAAAD,WAAA,SAAAgC,GACA0xJ,EAAA9gJ,QAEA+gJ,GACC/tJ,EAAAhG,WACDL,GAAAo0J,mB3Ns2oCM,SAAUr0J,EAAQC,EAASC,GAEjC,Y4N15oCA,SAAA4L,GAAAC,GACA,GAAA+/F,GAAA//F,EAAA+/F,IAAA78B,EAAAljE,EAAAkjE,KAAAprE,EAAAkI,EAAAlI,OAAAuE,EAAA2D,EAAA3D,MAAA1F,EAAAqJ,EAAArJ,UACA,IAAA0F,IAAAvE,EAEA,WADAnB,GAAAxB,UAGA,IAAA6V,GAAAk4D,EAAA7mE,EACA1F,GAAAb,MAAAkV,EAAA+0F,EAAA/0F,KACAhL,EAAA3D,QAAA,EACA5H,KAAAyL,SAAAF,GAfA,GAAAnJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GAiBAo0J,EAAA,SAAA7wJ,GAEA,QAAA6wJ,GAAAxoD,EAAAvgG,GACA9H,EAAApC,KAAAb,MACAA,KAAAsrG,MACAtrG,KAAA+K,YACA/K,KAAAyuE,KAAA9rE,OAAA8rE,KAAA68B,GAoDA,MAzDAlpG,GAAA0xJ,EAAA7wJ,GAsCA6wJ,EAAA3xJ,OAAA,SAAAmpG,EAAAvgG,GACA,UAAA+oJ,GAAAxoD,EAAAvgG,IAEA+oJ,EAAA3zJ,UAAAD,WAAA,SAAAgC,GACA,GAAA6B,GAAA/D,KAAAyuE,EAAA1qE,EAAA0qE,KAAA1jE,EAAAhH,EAAAgH,UACA1H,EAAAorE,EAAAprE,MACA,IAAA0H,EACA,MAAAA,GAAAU,SAAAH,EAAA,GACAggG,IAAAtrG,KAAAsrG,IAAA78B,OAAAprE,SAAAuE,MAAA,EAAA1F,cAIA,QAAAqqH,GAAA,EAA6BA,EAAAlpH,EAAckpH,IAAA,CAC3C,GAAAh2G,GAAAk4D,EAAA89C,EACArqH,GAAAb,MAAAkV,EAAAvW,KAAAsrG,IAAA/0F,KAEArU,EAAAxB,YAGAozJ,GACChuJ,EAAAhG,WACDL,GAAAq0J,mB5Nu6oCM,SAAUt0J,EAAQC,EAASC,GAEjC,Y6N3/oCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GAMAq0J,EAAA,SAAA9wJ,GAEA,QAAA8wJ,GAAAnnJ,EAAApB,EAAAT,GACA9H,EAAApC,KAAAb,MACAA,KAAA4M,QACA5M,KAAAg0J,OAAAxoJ,EACAxL,KAAA+K,YA0EA,MA/EA3I,GAAA2xJ,EAAA9wJ,GAqCA8wJ,EAAA5xJ,OAAA,SAAAyK,EAAApB,EAAAT,GAGA,WAFA,KAAA6B,IAA+BA,EAAA,OAC/B,KAAApB,IAA+BA,EAAA,GAC/B,GAAAuoJ,GAAAnnJ,EAAApB,EAAAT,IAEAgpJ,EAAAzoJ,SAAA,SAAAC,GACA,GAAAqB,GAAArB,EAAAqB,MAAAhF,EAAA2D,EAAA3D,MAAA4D,EAAAD,EAAAC,MAAAtJ,EAAAqJ,EAAArJ,UACA,IAAA0F,GAAA4D,EAEA,WADAtJ,GAAAxB,UAGAwB,GAAAb,KAAAuL,GACA1K,EAAA2B,SAGA0H,EAAA3D,QAAA,EACA2D,EAAAqB,QAAA,EACA5M,KAAAyL,SAAAF,KAEAwoJ,EAAA5zJ,UAAAD,WAAA,SAAAgC,GACA,GAAA0F,GAAA,EACAgF,EAAA5M,KAAA4M,MACApB,EAAAxL,KAAAg0J,OACAjpJ,EAAA/K,KAAA+K,SACA,IAAAA,EACA,MAAAA,GAAAU,SAAAsoJ,EAAAzoJ,SAAA,GACA1D,QAAA4D,QAAAoB,QAAA1K,cAIA,SACA,GAAA0F,KAAA4D,EAAA,CACAtJ,EAAAxB,UACA,OAGA,GADAwB,EAAAb,KAAAuL,KACA1K,EAAA2B,OACA,QAKAkwJ,GACCjuJ,EAAAhG,WACDL,GAAAs0J,mB7NkgpCM,SAAUv0J,EAAQC,EAASC,GAEjC,Y8NjmpCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAirG,EAAAjrG,EAAA,IACAwzJ,EAAAxzJ,EAAA,IAMAu0J,EAAA,SAAAhxJ,GAEA,QAAAgxJ,GAAA1zJ,EAAA2zJ,EAAAnpJ,OACA,KAAAmpJ,IAAmCA,EAAA,OACnC,KAAAnpJ,IAAmCA,EAAA4/F,EAAAG,MACnC7nG,EAAApC,KAAAb,MACAA,KAAAO,SACAP,KAAAk0J,YACAl0J,KAAA+K,cACAmoJ,EAAAzsD,UAAAytD,MAAA,KACAl0J,KAAAk0J,UAAA,GAEAnpJ,GAAA,kBAAAA,GAAAU,WACAzL,KAAA+K,UAAA4/F,EAAAG,MAoBA,MAhCA1oG,GAAA6xJ,EAAAhxJ,GAeAgxJ,EAAA9xJ,OAAA,SAAA5B,EAAAykB,EAAAja,GAGA,WAFA,KAAAia,IAA+BA,EAAA,OAC/B,KAAAja,IAAmCA,EAAA4/F,EAAAG,MACnC,GAAAmpD,GAAA1zJ,EAAAykB,EAAAja,IAEAkpJ,EAAA3oJ,SAAA,SAAAM,GACA,GAAArL,GAAAqL,EAAArL,OAAA2B,EAAA0J,EAAA1J,UACA,OAAAlC,MAAAc,IAAAP,EAAAR,UAAAmC,KAEA+xJ,EAAA9zJ,UAAAD,WAAA,SAAAgC,GACA,GAAA8iB,GAAAhlB,KAAAk0J,UACA3zJ,EAAAP,KAAAO,MAEA,OADAP,MAAA+K,UACAU,SAAAwoJ,EAAA3oJ,SAAA0Z,GACAzkB,SAAA2B,gBAGA+xJ,GACCnuJ,EAAAhG,WACDL,GAAAw0J,yB9NwmpCM,SAAUz0J,EAAQC,EAASC,GAEjC,Y+N1ppCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA2wJ,EAAAxzJ,EAAA,IACAoG,EAAApG,EAAA,GACAkrG,EAAAlrG,EAAA,GACAkL,EAAAlL,EAAA,IACAy0J,EAAAz0J,EAAA,IAMA00J,EAAA,SAAAnxJ,GAEA,QAAAmxJ,GAAAC,EAAAlpF,EAAApgE,OACA,KAAAspJ,IAAiCA,EAAA,GACjCpxJ,EAAApC,KAAAb,MACAA,KAAAmrE,QAAA,EACAnrE,KAAAq0J,QAAA,EACAnB,EAAAzsD,UAAAt7B,GACAnrE,KAAAmrE,OAAA+5B,OAAA/5B,GAAA,MAAA+5B,OAAA/5B,GAEAvgE,EAAAM,YAAAigE,KACApgE,EAAAogE,GAEAvgE,EAAAM,YAAAH,KACAA,EAAA6/F,EAAArgG,OAEAvK,KAAA+K,YACA/K,KAAAq0J,QAAAF,EAAA3tD,OAAA6tD,IACAA,EAAAr0J,KAAA+K,UAAAuZ,MACA+vI,EAoEA,MAtFAjyJ,GAAAgyJ,EAAAnxJ,GA8DAmxJ,EAAAjyJ,OAAA,SAAAmyJ,EAAAnpF,EAAApgE,GAEA,WADA,KAAAupJ,IAAsCA,EAAA,GACtC,GAAAF,GAAAE,EAAAnpF,EAAApgE,IAEAqpJ,EAAA9oJ,SAAA,SAAAC,GACA,GAAA3D,GAAA2D,EAAA3D,MAAAujE,EAAA5/D,EAAA4/D,OAAAjpE,EAAAqJ,EAAArJ,WACAwgG,EAAA1iG,IAEA,IADAkC,EAAAb,KAAAuG,IACA1F,EAAA2B,OAAA,CAGA,QAAAsnE,EACA,MAAAjpE,GAAAxB,UAEA6K,GAAA3D,QAAA,EACA86F,EAAAj3F,SAAAF,EAAA4/D,KAEAipF,EAAAj0J,UAAAD,WAAA,SAAAgC,GACA,GACA6B,GAAA/D,KAAAmrE,EAAApnE,EAAAonE,OAAAkpF,EAAAtwJ,EAAAswJ,OACA,OADAtwJ,GAAAgH,UACAU,SAAA2oJ,EAAA9oJ,SAAA+oJ,GACAzsJ,MAHA,EAGAujE,SAAAjpE,gBAGAkyJ,GACCtuJ,EAAAhG,WACDL,GAAA20J,mB/NiqpCM,SAAU50J,EAAQC,EAASC,GAEjC,YgO3wpCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,GAMA60J,EAAA,SAAAtxJ,GAEA,QAAAsxJ,GAAAC,EAAAjE,GACAttJ,EAAApC,KAAAb,MACAA,KAAAw0J,kBACAx0J,KAAAuwJ,oBAgBA,MApBAnuJ,GAAAmyJ,EAAAtxJ,GAMAsxJ,EAAApyJ,OAAA,SAAAqyJ,EAAAjE,GACA,UAAAgE,GAAAC,EAAAjE,IAEAgE,EAAAp0J,UAAAD,WAAA,SAAAgC,GACA,GACAuyJ,GADA1wJ,EAAA/D,KAAAw0J,EAAAzwJ,EAAAywJ,gBAAAjE,EAAAxsJ,EAAAwsJ,iBAEA,KAEA,MADAkE,GAAAD,IACA,GAAAE,GAAAxyJ,EAAAuyJ,EAAAlE,GAEA,MAAApvJ,GACAe,EAAAzB,MAAAU,KAGAozJ,GACCzuJ,EAAAhG,WACDL,GAAA80J,iBACA,IAAAG,GAAA,SAAAzxJ,GAEA,QAAAyxJ,GAAApxJ,EAAAmxJ,EAAAlE,GACAttJ,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAy0J,WACAz0J,KAAAuwJ,oBACAjtJ,EAAAxC,IAAA2zJ,GACAz0J,KAAA20J,SAaA,MAnBAvyJ,GAAAsyJ,EAAAzxJ,GAQAyxJ,EAAAv0J,UAAAw0J,OAAA,WACA,IACA,GAAAp0J,GAAAP,KAAAuwJ,kBAAA1vJ,KAAAb,UAAAy0J,SACAl0J,IACAP,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAO,IAGA,MAAAY,GACAnB,KAAA2D,OAAAxC,KAGAuzJ,GACC1uD,EAAAjhG,kBhOkxpCK,SAAUvF,EAAQC,EAASC,GAEjC,YiO90pCA,IAAAk1J,GAAAl1J,EAAA,IACAD,GAAA2jJ,aAAAwR,EAAA9E,wBAAA3tJ,QjOq1pCM,SAAU3C,EAAQC,EAASC,GAEjC,YkOx1pCA,IAAAm1J,GAAAn1J,EAAA,IACAD,GAAA6jJ,iBAAAuR,EAAAxE,4BAAAluJ,QlO+1pCM,SAAU3C,EAAQC,EAASC,GAEjC,YmOjvpCA,SAAAknG,KAEA,OADAC,MACA57F,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C47F,EAAA57F,EAAA,GAAA7H,UAAA6H,EAEA,IAAAm9B,GAAA,KACAr9B,EAAA,IAYA,OAXAH,GAAAM,YAAA27F,IAAAxjG,OAAA,MACA0H,EAAA87F,EAAA17F,OAEA,kBAAA07F,KAAAxjG,OAAA,KACA+kC,EAAAy+D,EAAA17F,OAIA,IAAA07F,EAAAxjG,QAAAkE,EAAAW,QAAA2+F,EAAA,MACAA,IAAA,IAEA,GAAAC,GAAAj8F,gBAAAg8F,EAAA97F,GAAA3K,KAAA,GAAAmjJ,GAAAx8C,sBAAA3+D,IAnIA,GAAAx9B,GAAAlL,EAAA,IACA6H,EAAA7H,EAAA,IACAonG,EAAApnG,EAAA,IACA6jJ,EAAA7jJ,EAAA,GAkIAD,GAAAmnG,iBnOy2pCM,SAAUpnG,EAAQC,EAASC,GAEjC,YoOh/pCA,IAAA8jJ,GAAA9jJ,EAAA,GACAD,GAAA2H,OAAAo8I,EAAAn8C,cpOu/pCM,SAAU7nG,EAAQC,EAASC,GAEjC,YqO1/pCA,IAAAo1J,GAAAp1J,EAAA,IACAD,GAAAoiF,MAAAizE,EAAAxE,gBAAAnuJ,QrOigqCM,SAAU3C,EAAQC,EAASC,GAEjC,YsOpgqCA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAoF,EAAApF,EAAA,GACAoG,EAAApG,EAAA,GACAmD,EAAAnD,EAAA,GACAC,EAAAD,EAAA,GACA6pG,EAAA7pG,EAAA,IACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAq1J,EAAAr1J,EAAA,KAMAs1J,EAAA,SAAA/xJ,GAEA,QAAA+xJ,GAAAC,EAAA3xJ,GACA,GAAA2xJ,YAAAnvJ,GAAAhG,WACAmD,EAAApC,KAAAb,KAAAsD,EAAA2xJ,OAEA,CAWA,GAVAhyJ,EAAApC,KAAAb,MACAA,KAAAk1J,cAAAv1J,EAAA6B,KAAA2zJ,UACAn1J,KAAAo1J,QAAA,GAAA3wD,GAAAz7F,QACA,gBAAAisJ,GACAj1J,KAAAsjF,IAAA2xE,EAIAF,EAAAM,OAAAr1J,KAAAi1J,IAEAj1J,KAAAk1J,cACA,SAAAtzJ,OAAA,wCAEA5B,MAAAsD,YAAA,GAAAimG,GAAAxE,eA8MA,MAjOA3iG,GAAA4yJ,EAAA/xJ,GAsBA+xJ,EAAA70J,UAAA+4I,eAAA,SAAAjxI,GACA,MAAAirB,MAAAxQ,MAAAza,EAAA2H,OAwCAolJ,EAAA7yJ,OAAA,SAAA8yJ,GACA,UAAAD,GAAAC,IAEAD,EAAA70J,UAAAC,KAAA,SAAAC,GACA,GAAAi1J,GAAA,GAAAN,GAAAh1J,UAAAsD,YAEA,OADAgyJ,GAAAj1J,WACAi1J,GAEAN,EAAA70J,UAAAo1J,YAAA,WACAv1J,KAAAw1J,OAAA,KACAx1J,KAAAO,SACAP,KAAAsD,YAAA,GAAAimG,GAAAxE,eAEA/kG,KAAAo1J,QAAA,GAAA3wD,GAAAz7F,SAGAgsJ,EAAA70J,UAAAirC,UAAA,SAAAqqH,EAAAC,EAAAC,GACA,GAAA5rJ,GAAA/J,IACA,WAAA8F,GAAAhG,WAAA,SAAAmhG,GACA,GAAAt7F,GAAA6B,EAAAO,SAAA0tJ,IACA9vJ,KAAA8B,EAAAO,YACAi5F,EAAAxgG,MAAAgH,EAAAO,YAAAC,GAGA8B,EAAA1I,KAAAsE,EAEA,IAAA5D,GAAAgI,EAAAhK,UAAA,SAAA4L,GACA,GAAAhG,GAAA6B,EAAAO,SAAA4tJ,GAAAhqJ,EACAhG,KAAA8B,EAAAO,YACAi5F,EAAAxgG,MAAAgH,EAAAO,YAAAC,GAEAtC,GACAs7F,EAAA5/F,KAAAsK,IAEa,SAAAxK,GAAkB,MAAA8/F,GAAAxgG,MAAAU,IAA8B,WAAe,MAAA8/F,GAAAvgG,YAC5E,mBACA,GAAAiF,GAAA6B,EAAAO,SAAA2tJ,IACA/vJ,KAAA8B,EAAAO,YACAi5F,EAAAxgG,MAAAgH,EAAAO,YAAAC,GAGA8B,EAAA1I,KAAAsE,GAEA5D,EAAAE,kBAIA+yJ,EAAA70J,UAAAy1J,eAAA,WACA,GAAAr0J,GAAAvB,KACAk1J,EAAAl1J,KAAAk1J,cACAj0D,EAAAjhG,KAAAo1J,QACAI,EAAA,IACA,KACAA,EAAAx1J,KAAA61J,SACA,GAAAX,GAAAl1J,KAAAsjF,IAAAtjF,KAAA61J,UACA,GAAAX,GAAAl1J,KAAAsjF,KACAtjF,KAAAw1J,SACAx1J,KAAA81J,aACA91J,KAAAw1J,OAAAM,WAAA91J,KAAA81J,YAGA,MAAA7tJ,GAEA,WADAg5F,GAAAxgG,MAAAwH,GAGA,GAAAlG,GAAA,GAAAc,GAAAqB,aAAA,WACA3C,EAAAi0J,OAAA,KACAA,GAAA,IAAAA,EAAArxE,YACAqxE,EAAAxjB,SAGAwjB,GAAAO,OAAA,SAAA9tJ,GACA,GAAA+tJ,GAAAz0J,EAAAy0J,YACAA,IACAA,EAAA30J,KAAA4G,EAEA,IAAA4sC,GAAAtzC,EAAA+B,WACA/B,GAAA+B,YAAAwB,EAAA9B,WAAAb,OAAA,SAAAwJ,GAA6E,WAAA6pJ,EAAArxE,YAAAqxE,EAAAlxE,KAAA34E,IAAoD,SAAA1D,GACjI,GAAAguJ,GAAA10J,EAAA00J,eACAA,IACAA,EAAA50J,SAAA2zB,IAEA/sB,KAAAsyE,KACAi7E,EAAAxjB,MAAA/pI,EAAAsyE,KAAAtyE,EAAA2uG,QAGA3V,EAAAxgG,MAAA,GAAAmG,WAAA,sIAGArF,EAAAg0J,eACa,WACb,GAAAU,GAAA10J,EAAA00J,eACAA,IACAA,EAAA50J,SAAA2zB,IAEAwgI,EAAAxjB,QACAzwI,EAAAg0J,gBAEA1gH,eAAA00D,GAAAxE,eACAhjG,EAAAjB,IAAA+zC,EAAA90C,UAAAwB,EAAA+B,eAGAkyJ,EAAAxxE,QAAA,SAAA/7E,GACA1G,EAAAg0J,cACAt0D,EAAAxgG,MAAAwH,IAEAutJ,EAAAU,QAAA,SAAAjuJ,GACA1G,EAAAg0J,aACA,IAAAY,GAAA50J,EAAA40J,aACAA,IACAA,EAAA90J,KAAA4G,GAEAA,EAAAmuJ,SACAn1D,EAAAvgG,WAGAugG,EAAAxgG,MAAAwH,IAGAutJ,EAAAa,UAAA,SAAApuJ,GACA,GAAAtC,GAAA6B,EAAAO,SAAAxG,EAAA23I,gBAAAjxI,EACAtC,KAAA8B,EAAAO,YACAi5F,EAAAxgG,MAAAgH,EAAAO,YAAAC,GAGAg5F,EAAA5/F,KAAAsE,KAIAqvJ,EAAA70J,UAAAD,WAAA,SAAAgC,GACA,GAAAX,GAAAvB,KACAO,EAAAP,KAAAO,MACA,IAAAA,EACA,MAAAA,GAAAR,UAAAmC,EAEAlC,MAAAw1J,QACAx1J,KAAA41J,gBAEA,IAAA7zJ,GAAA,GAAAc,GAAAqB,YAWA,OAVAnC,GAAAjB,IAAAd,KAAAo1J,QAAAr1J,UAAAmC,IACAH,EAAAjB,IAAA,WACA,GAAA00J,GAAAj0J,EAAAi0J,MACA,KAAAj0J,EAAA6zJ,QAAAnsJ,UAAA5F,SACAmyJ,GAAA,IAAAA,EAAArxE,YACAqxE,EAAAxjB,QAEAzwI,EAAAg0J,iBAGAxzJ,GAEAizJ,EAAA70J,UAAA8B,YAAA,WACA,GAAA8B,GAAA/D,KAAAO,EAAAwD,EAAAxD,OAAAi1J,EAAAzxJ,EAAAyxJ,MACAA,IAAA,IAAAA,EAAArxE,aACAqxE,EAAAxjB,QACAhyI,KAAAu1J,eAEAtyJ,EAAA9C,UAAA8B,YAAApB,KAAAb,MACAO,IACAP,KAAAsD,YAAA,GAAAimG,GAAAxE,gBAGAiwD,GACCvwD,EAAAp7F,iBACD5J,GAAAu1J,oBtO2gqCM,SAAUx1J,EAAQC,EAASC,GAEjC,YuOpwqCA,IAAA6qG,GAAA7qG,EAAA,GACAD,GAAAkkJ,KAAAp5C,EAAAisC,eAAAr0I,QvO2wqCM,SAAU3C,EAAQC,EAASC,GAEjC,YwO9wqCA,IAAA42J,GAAA52J,EAAA,IACAD,GAAAokJ,UAAAyS,EAAAtB,iBAAA7yJ,QxOqxqCM,SAAU3C,EAAQC,EAASC,GAEjC,YyOxxqCA,IAAAiL,GAAAjL,EAAA,GACAD,GAAA8D,MAAAoH,EAAAU,gBAAAlJ,QzO+xqCM,SAAU3C,EAAQC,EAASC,GAEjC,Y0OlyqCA,IAAA62J,GAAA72J,EAAA,IACAD,GAAAukJ,SAAAuS,EAAA3F,mBAAAzuJ,Q1OyyqCM,SAAU3C,EAAQC,EAASC,GAEjC,Y2O5yqCA,IAAAu6I,GAAAv6I,EAAA,GACAD,GAAAigC,KAAAu6G,EAAAvE,eAAAvzI,Q3OmzqCM,SAAU3C,EAAQC,EAASC,GAEjC,Y4OtzqCA,IAAA82J,GAAA92J,EAAA,IACAD,GAAA2hJ,UAAAoV,EAAA/E,oBAAAtvJ,Q5O6zqCM,SAAU3C,EAAQC,EAASC,GAEjC,Y6Oh0qCA,IAAA+2J,GAAA/2J,EAAA,IACAD,GAAA2kJ,iBAAAqS,EAAA1E,2BAAA5vJ,Q7Ou0qCM,SAAU3C,EAAQC,EAASC,GAEjC,Y8O10qCA,IAAA61I,GAAA71I,EAAA,GACAD,GAAA6kJ,YAAA/O,EAAAK,kBAAAzzI,Q9Oi1qCM,SAAU3C,EAAQC,EAASC,GAEjC,Y+Op1qCA,IAAAg3J,GAAAh3J,EAAA,IACAD,GAAAqhI,SAAA41B,EAAApE,mBAAAnwJ,Q/O21qCM,SAAU3C,EAAQC,EAASC,GAEjC,YgP91qCA,IAAAi3J,GAAAj3J,EAAA,IACAD,GAAAglJ,IAAAkS,EAAA9D,aAAA1wJ,QhPq2qCM,SAAU3C,EAAQC,EAASC,GAEjC,YiPx2qCA,IAAAk3J,GAAAl3J,EAAA,IACAD,GAAAumB,SAAA4wI,EAAAzD,mBAAAhxJ,QjP+2qCM,SAAU3C,EAAQC,EAASC,GAEjC,YkPl3qCA,IAAAilJ,GAAAjlJ,EAAA,GACAD,GAAA+Q,MAAAm0I,EAAA3L,alPy3qCM,SAAUx5I,EAAQC,EAASC,GAEjC,YmP53qCA,IAAAm3J,GAAAn3J,EAAA,IACAD,GAAAolJ,MAAAgS,EAAAhD,gBAAA1xJ,QnPm4qCM,SAAU3C,EAAQC,EAASC,GAEjC,YoPt4qCA,IAAAonG,GAAApnG,EAAA,GACAD,GAAAuL,GAAA87F,EAAAj8F,gBAAAG,IpP64qCM,SAAUxL,EAAQC,EAASC,GAEjC,YqPh5qCA,IAAAqlJ,GAAArlJ,EAAA,GACAD,GAAAo6I,kBAAAkL,EAAA/K,yBrPu5qCM,SAAUx6I,EAAQC,EAASC,GAEjC,YsP15qCA,IAAAo3J,GAAAp3J,EAAA,IACAD,GAAAy0D,MAAA4iG,EAAAhD,gBAAA3xJ,QtPi6qCM,SAAU3C,EAAQC,EAASC,GAEjC,YuPp6qCA,IAAAulJ,GAAAvlJ,EAAA,GACAD,GAAA26I,KAAA6K,EAAA5K,YvP26qCM,SAAU76I,EAAQC,EAASC,GAEjC,YwP96qCA,IAAAq3J,GAAAr3J,EAAA,IACAD,GAAA4P,MAAA0nJ,EAAAhD,gBAAA5xJ,QxPq7qCM,SAAU3C,EAAQC,EAASC,GAEjC,YyPx7qCA,IAAAs3J,GAAAt3J,EAAA,IACAD,GAAA2lJ,OAAA4R,EAAArG,gBAAAxuJ,QzP+7qCM,SAAU3C,EAAQC,EAASC,GAEjC,Y0Pl8qCA,IAAAu3J,GAAAv3J,EAAA,IACAD,GAAAslB,MAAAkyI,EAAA7C,gBAAAjyJ,Q1Py8qCM,SAAU3C,EAAQC,EAASC,GAEjC,Y2P58qCA,IAAAw3J,GAAAx3J,EAAA,IACAD,GAAA8lJ,MAAA2R,EAAA3C,gBAAApyJ,Q3Pm9qCM,SAAU3C,EAAQC,EAASC,GAEjC,Y4Pt9qCA,IAAA8lJ,GAAA9lJ,EAAA,GACAD,GAAAw2D,IAAAuvF,EAAAh9C,W5P69qCM,SAAUhpG,EAAQC,EAASC,GAEjC,Y6P/6qCA,SAAAgmJ,GAAAhL,GACA,MAAA16I,MAAAI,KAAA,GAAA+2J,GAAAzc,IAlDA,GAAAt4I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAiF,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA4CAD,GAAAimJ,OACA,IAAAyR,GAAA,WACA,QAAAA,GAAAzc,GACA16I,KAAA06I,mBAKA,MAHAyc,GAAAh3J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAq3J,GAAAl1J,EAAAlC,KAAA06I,oBAEAyc,KAOAC,EAAA,SAAAn0J,GAEA,QAAAm0J,GAAA9zJ,EAAAo3I,GACAz3I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA06I,mBACA16I,KAAA+gG,UAAA,EAwCA,MA5CA3+F,GAAAg1J,EAAAn0J,GAMAm0J,EAAAj3J,UAAAuD,MAAA,SAAA1B,GAGA,GAFAhC,KAAAgC,QACAhC,KAAA+gG,UAAA,GACA/gG,KAAAm7I,UAAA,CACA,GAAAl0H,GAAAzf,EAAAO,SAAA/H,KAAA06I,kBAAA14I,EACA,IAAAilB,IAAAxf,EAAAO,YACAhI,KAAAsD,YAAA7C,MAAAgH,EAAAO,YAAAC,OAEA,CACA,GAAAgpJ,GAAAhrD,EAAAxgG,kBAAAzF,KAAAinB,EACAgqI,GAAAptJ,OACA7D,KAAAq3J,gBAGAr3J,KAAAc,IAAAd,KAAAm7I,UAAA8V,MAKAmG,EAAAj3J,UAAAk3J,cAAA,WACA,GAAAtzJ,GAAA/D,KAAAgC,EAAA+B,EAAA/B,MAAA++F,EAAAh9F,EAAAg9F,SAAAo6C,EAAAp3I,EAAAo3I,SACAA,KACAn7I,KAAA6H,OAAAszI,GACAn7I,KAAAm7I,UAAA,KACAA,EAAAl5I,eAEA8+F,IACA/gG,KAAAgC,MAAA,KACAhC,KAAA+gG,UAAA,EACA/gG,KAAAsD,YAAAjC,KAAAW,KAGAo1J,EAAAj3J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACArF,KAAAq3J,iBAEAD,EAAAj3J,UAAAqF,eAAA,WACAxF,KAAAq3J,iBAEAD,GACCpxD,EAAAjhG,kB7Pu+qCK,SAAUvF,EAAQC,EAASC,GAEjC,Y8PzirCA,SAAAkmJ,GAAA3+H,EAAAlc,GAEA,WADA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,OAC/BvK,KAAAI,KAAA,GAAAk3J,GAAArwI,EAAAlc,IAgDA,QAAAgrI,GAAA7zI,GACAA,EAAAm1J,gBApGA,GAAAj1J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAqoG,EAAAlrG,EAAA,GACAoF,EAAApF,EAAA,EA+CAD,GAAAmmJ,WACA,IAAA0R,GAAA,WACA,QAAAA,GAAArwI,EAAAlc,GACA/K,KAAAinB,WACAjnB,KAAA+K,YAKA,MAHAusJ,GAAAn3J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAw3J,GAAAr1J,EAAAlC,KAAAinB,SAAAjnB,KAAA+K,aAEAusJ,KAOAC,EAAA,SAAAt0J,GAEA,QAAAs0J,GAAAj0J,EAAA2jB,EAAAlc,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAinB,WACAjnB,KAAA+K,YACA/K,KAAA+gG,UAAA,EAsBA,MA3BA3+F,GAAAm1J,EAAAt0J,GAOAs0J,EAAAp3J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAgC,QACAhC,KAAA+gG,UAAA,EACA/gG,KAAAm7I,WACAn7I,KAAAc,IAAAd,KAAAm7I,UAAAn7I,KAAA+K,UAAAU,SAAAsqI,EAAA/1I,KAAAinB,SAAAjnB,QAGAu3J,EAAAp3J,UAAAk3J,cAAA,WACA,GAAAtzJ,GAAA/D,KAAAgC,EAAA+B,EAAA/B,MAAA++F,EAAAh9F,EAAAg9F,SAAAo6C,EAAAp3I,EAAAo3I,SACAA,KACAn7I,KAAA6H,OAAAszI,GACAn7I,KAAAm7I,UAAA,KACAA,EAAAl5I,eAEA8+F,IACA/gG,KAAAgC,MAAA,KACAhC,KAAA+gG,UAAA,EACA/gG,KAAAsD,YAAAjC,KAAAW,KAGAu1J,GACCzyJ,EAAA9B,a9PomrCK,SAAUxD,EAAQC,EAASC,GAEjC,Y+PjqrCA,SAAAkpD,GAAA4uG,GACA,MAAAx3J,MAAAI,KAAA,GAAAq3J,GAAAD,IAxCA,GAAAp1J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAoCAD,GAAAmpD,QACA,IAAA6uG,GAAA,WACA,QAAAA,GAAAD,GACAx3J,KAAAw3J,kBAKA,MAHAC,GAAAt3J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA23J,GAAAx1J,EAAAlC,KAAAw3J,mBAEAC,KAOAC,EAAA,SAAAz0J,GAEA,QAAAy0J,GAAAp0J,EAAAk0J,GACAv0J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4oD,UACA5oD,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAw3J,IAUA,MAdAp1J,GAAAs1J,EAAAz0J,GAMAy0J,EAAAv3J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA4oD,OAAAxgD,KAAApG,IAEA01J,EAAAv3J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA4oD,UACA5oD,KAAAsD,YAAAjC,KAAAunD,IAEA8uG,GACC1xD,EAAAjhG,kB/P+srCK,SAAUvF,EAAQC,EAASC,GAEjC,YgQ3urCA,SAAAqmJ,GAAA/gD,EAAA2yD,GAEA,WADA,KAAAA,IAAsCA,EAAA,MACtC33J,KAAAI,KAAA,GAAAw3J,GAAA5yD,EAAA2yD,IAjDA,GAAAv1J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EA8CAD,GAAAsmJ,aACA,IAAA6R,GAAA,WACA,QAAAA,GAAA5yD,EAAA2yD,GACA33J,KAAAglG,aACAhlG,KAAA23J,mBAKA33J,KAAA63J,gBAJAF,GAAA3yD,IAAA2yD,EAIAG,EAHAC,EASA,MAHAH,GAAAz3J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAC,MAAA63J,gBAAA31J,EAAAlC,KAAAglG,WAAAhlG,KAAA23J,oBAEAC,KAOAG,EAAA,SAAA90J,GAEA,QAAA80J,GAAAz0J,EAAA0hG,GACA/hG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAglG,aACAhlG,KAAA4oD,UAiBA,MArBAxmD,GAAA21J,EAAA90J,GAMA80J,EAAA53J,UAAAuD,MAAA,SAAA1B,GACA,GAAA4mD,GAAA5oD,KAAA4oD,MACAA,GAAAxgD,KAAApG,GACA4mD,EAAAvlD,QAAArD,KAAAglG,aACAhlG,KAAAsD,YAAAjC,KAAAunD,GACA5oD,KAAA4oD,YAGAmvG,EAAA53J,UAAAyD,UAAA,WACA,GAAAglD,GAAA5oD,KAAA4oD,MACAA,GAAAvlD,OAAA,GACArD,KAAAsD,YAAAjC,KAAAunD,GAEA3lD,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEA+3J,GACCjzJ,EAAA9B,YAMD80J,EAAA,SAAA70J,GAEA,QAAA60J,GAAAx0J,EAAA0hG,EAAA2yD,GACA10J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAglG,aACAhlG,KAAA23J,mBACA33J,KAAAg4J,WACAh4J,KAAAwL,MAAA,EA2BA,MAjCApJ,GAAA01J,EAAA70J,GAQA60J,EAAA33J,UAAAuD,MAAA,SAAA1B,GACA,GAAA+B,GAAA/D,KAAAglG,EAAAjhG,EAAAihG,WAAA2yD,EAAA5zJ,EAAA4zJ,iBAAAK,EAAAj0J,EAAAi0J,QAAAxsJ,EAAAzH,EAAAyH,KACAxL,MAAAwL,QACAA,EAAAmsJ,GAAA,GACAK,EAAA5vJ,QAEA,QAAAnC,GAAA+xJ,EAAA30J,OAAoC4C,KAAK,CACzC,GAAA2iD,GAAAovG,EAAA/xJ,EACA2iD,GAAAxgD,KAAApG,GACA4mD,EAAAvlD,SAAA2hG,IACAgzD,EAAApvJ,OAAA3C,EAAA,GACAjG,KAAAsD,YAAAjC,KAAAunD,MAIAkvG,EAAA33J,UAAAyD,UAAA,WAEA,IADA,GAAAG,GAAA/D,KAAAg4J,EAAAj0J,EAAAi0J,QAAA10J,EAAAS,EAAAT,YACA00J,EAAA30J,OAAA,IACA,GAAAulD,GAAAovG,EAAA3lH,OACAuW,GAAAvlD,OAAA,GACAC,EAAAjC,KAAAunD,GAGA3lD,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEA83J,GACChzJ,EAAA9B,ahQiyrCK,SAAUxD,EAAQC,EAASC,GAEjC,YiQx3rCA,SAAAumJ,GAAAgS,GACA,GAAA50J,GAAAD,UAAAC,OACA0H,EAAA6/F,EAAArgG,KACAK,GAAAM,YAAA9H,oBAAAC,OAAA,MACA0H,EAAA3H,oBAAAC,OAAA,GACAA,IAEA,IAAA60J,GAAA,IACA70J,IAAA,IACA60J,EAAA90J,UAAA,GAEA,IAAA+0J,GAAAjzD,OAAAC,iBAIA,OAHA9hG,IAAA,IACA80J,EAAA/0J,UAAA,IAEApD,KAAAI,KAAA,GAAAg4J,GAAAH,EAAAC,EAAAC,EAAAptJ,IA0GA,QAAAstJ,GAAA9sJ,GACA,GAAArJ,GAAAqJ,EAAArJ,WACAo2J,EAAA/sJ,EAAAnH,OACAk0J,IACAp2J,EAAAq2J,aAAAD,GAEAp2J,EAAA2B,SACA0H,EAAAnH,QAAAlC,EAAAs2J,cACAjtJ,EAAAnH,QAAAq0J,YAAAz4J,KAAAyL,SAAAF,IAAA0sJ,iBAGA,QAAAS,GAAAntJ,GACA,GAAA2sJ,GAAA3sJ,EAAA2sJ,uBAAAD,EAAA1sJ,EAAA0sJ,eAAA/1J,EAAAqJ,EAAArJ,WAAA6I,EAAAQ,EAAAR,UACA3G,EAAAlC,EAAAs2J,cACA91D,EAAA1iG,IACAkC,GAAA2B,SACA3B,EAAApB,IAAAsD,EAAAq0J,YAAA1tJ,EAAAU,SAAAktJ,EAAAV,GAAsG/1J,aAAAkC,aACtGs+F,EAAAj3F,SAAAF,EAAA2sJ,IAGA,QAAAS,GAAA/sJ,GACA,GAAA1J,GAAA0J,EAAA1J,WAAAkC,EAAAwH,EAAAxH,OACAlC,GAAAq2J,aAAAn0J,GAnMA,GAAAhC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAqoG,EAAAlrG,EAAA,GACAoF,EAAApF,EAAA,GACAkL,EAAAlL,EAAA,GA8DAD,GAAAwmJ,YACA,IAAAmS,GAAA,WACA,QAAAA,GAAAH,EAAAC,EAAAC,EAAAptJ,GACA/K,KAAAi4J,iBACAj4J,KAAAk4J,yBACAl4J,KAAAm4J,gBACAn4J,KAAA+K,YAKA,MAHAqtJ,GAAAj4J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA64J,GAAA12J,EAAAlC,KAAAi4J,eAAAj4J,KAAAk4J,uBAAAl4J,KAAAm4J,cAAAn4J,KAAA+K,aAEAqtJ,KAEAS,EAAA,WACA,QAAAA,KACA74J,KAAA4oD,UAEA,MAAAiwG,MAOAD,EAAA,SAAA31J,GAEA,QAAA21J,GAAAt1J,EAAA20J,EAAAC,EAAAC,EAAAptJ,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAi4J,iBACAj4J,KAAAk4J,yBACAl4J,KAAAm4J,gBACAn4J,KAAA+K,YACA/K,KAAAw2G,WACA,IAAApyG,GAAApE,KAAAw4J,aAEA,IADAx4J,KAAA84J,aAAA,MAAAZ,KAAA,EACAl4J,KAAA84J,aAAA,CACA,GAAAC,IAAqC72J,WAAAlC,KAAAoE,UAAA6zJ,iBACrCj4J,MAAAc,IAAAsD,EAAAq0J,YAAA1tJ,EAAAU,SAAA4sJ,EAAAJ,EAAAc,QAEA,CACA,GAAAC,IAA8B92J,WAAAlC,KAAAoE,WAC9B60J,GAAiChB,iBAAAC,yBAAAh2J,WAAAlC,KAAA+K,YACjC/K,MAAAc,IAAAsD,EAAAq0J,YAAA1tJ,EAAAU,SAAAktJ,EAAAV,EAAAe,IACAh5J,KAAAc,IAAAiK,EAAAU,SAAAitJ,EAAAR,EAAAe,KA2DA,MA7EA72J,GAAAw2J,EAAA31J,GAqBA21J,EAAAz4J,UAAAuD,MAAA,SAAA1B,GAIA,OADAk3J,GAFA1iD,EAAAx2G,KAAAw2G,SACAtwG,EAAAswG,EAAAnzG,OAEA4C,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAA7B,GAAAoyG,EAAAvwG,GACA2iD,EAAAxkD,EAAAwkD,MACAA,GAAAxgD,KAAApG,GACA4mD,EAAAvlD,QAAArD,KAAAm4J,gBACAe,EAAA90J,GAGA80J,GACAl5J,KAAAm5J,aAAAD,IAGAN,EAAAz4J,UAAAwD,OAAA,SAAAxC,GACAnB,KAAAw2G,SAAAnzG,OAAA,EACAJ,EAAA9C,UAAAwD,OAAA9C,KAAAb,KAAAmB,IAEAy3J,EAAAz4J,UAAAyD,UAAA,WAEA,IADA,GAAAG,GAAA/D,KAAAw2G,EAAAzyG,EAAAyyG,SAAAlzG,EAAAS,EAAAT,YACAkzG,EAAAnzG,OAAA,IACA,GAAAe,GAAAoyG,EAAAnkE,OACA/uC,GAAAjC,KAAA+C,EAAAwkD,QAEA3lD,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEA44J,EAAAz4J,UAAA0E,aAAA,WACA7E,KAAAw2G,SAAA,MAEAoiD,EAAAz4J,UAAAg5J,aAAA,SAAA/0J,GACApE,KAAAu4J,aAAAn0J,EACA,IAAAq0J,GAAAr0J,EAAAq0J,WAGA,IAFAA,EAAAx2J,cACAjC,KAAA6H,OAAA4wJ,IACAz4J,KAAA6D,QAAA7D,KAAA84J,aAAA,CACA10J,EAAApE,KAAAw4J,aACA,IAAAP,GAAAj4J,KAAAi4J,eACAc,GAAqC72J,WAAAlC,KAAAoE,UAAA6zJ,iBACrCj4J,MAAAc,IAAAsD,EAAAq0J,YAAAz4J,KAAA+K,UAAAU,SAAA4sJ,EAAAJ,EAAAc,MAGAH,EAAAz4J,UAAAq4J,YAAA,WACA,GAAAp0J,GAAA,GAAAy0J,EAEA,OADA74J,MAAAw2G,SAAApuG,KAAAhE,GACAA,GAEAw0J,EAAAz4J,UAAAo4J,aAAA,SAAAn0J,GACApE,KAAAsD,YAAAjC,KAAA+C,EAAAwkD,OACA,IAAA4tD,GAAAx2G,KAAAw2G,UACAA,IAAA7tG,QAAAvE,IAAA,IACA,GACAoyG,EAAA5tG,OAAA4tG,EAAA7tG,QAAAvE,GAAA,IAGAw0J,GACC9zJ,EAAA9B,ajQ28rCK,SAAUxD,EAAQC,EAASC,GAEjC,YkQ3ksCA,SAAAymJ,GAAAiT,EAAAC,GACA,MAAAr5J,MAAAI,KAAA,GAAAk5J,GAAAF,EAAAC,IA/CA,GAAAj3J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAM,EAAAnD,EAAA,GACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,EA0CAD,GAAA0mJ,cACA,IAAAmT,GAAA,WACA,QAAAA,GAAAF,EAAAC,GACAr5J,KAAAo5J,WACAp5J,KAAAq5J,kBAKA,MAHAC,GAAAn5J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAw5J,GAAAr3J,EAAAlC,KAAAo5J,SAAAp5J,KAAAq5J,mBAEAC,KAOAC,EAAA,SAAAt2J,GAEA,QAAAs2J,GAAAj2J,EAAA81J,EAAAC,GACAp2J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAo5J,WACAp5J,KAAAq5J,kBACAr5J,KAAAw2G,YACAx2G,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAo5J,IA4EA,MAlFAh3J,GAAAm3J,EAAAt2J,GAQAs2J,EAAAp5J,UAAAuD,MAAA,SAAA1B,GAGA,OAFAw0G,GAAAx2G,KAAAw2G,SACAtwG,EAAAswG,EAAAnzG,OACA4C,EAAA,EAAuBA,EAAAC,EAASD,IAChCuwG,EAAAvwG,GAAA2iD,OAAAxgD,KAAApG,IAGAu3J,EAAAp5J,UAAAwD,OAAA,SAAAxC,GAEA,IADA,GAAAq1G,GAAAx2G,KAAAw2G,SACAA,EAAAnzG,OAAA,IACA,GAAAe,GAAAoyG,EAAAnkE,OACAjuC,GAAArC,aAAAE,cACAmC,EAAAwkD,OAAA,KACAxkD,EAAArC,aAAA,KAEA/B,KAAAw2G,SAAA,KACAvzG,EAAA9C,UAAAwD,OAAA9C,KAAAb,KAAAmB,IAEAo4J,EAAAp5J,UAAAyD,UAAA,WAEA,IADA,GAAA4yG,GAAAx2G,KAAAw2G,SACAA,EAAAnzG,OAAA,IACA,GAAAe,GAAAoyG,EAAAnkE,OACAryC,MAAAsD,YAAAjC,KAAA+C,EAAAwkD,QACAxkD,EAAArC,aAAAE,cACAmC,EAAAwkD,OAAA,KACAxkD,EAAArC,aAAA,KAEA/B,KAAAw2G,SAAA,KACAvzG,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEAu5J,EAAAp5J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAJ,EAAAlF,KAAAw5J,YAAAt0J,GAAAlF,KAAAy5J,WAAAt0J,IAEAo0J,EAAAp5J,UAAAqF,eAAA,SAAAF,GACAtF,KAAAw5J,YAAAl0J,EAAAlB,UAEAm1J,EAAAp5J,UAAAs5J,WAAA,SAAAz3J,GACA,IACA,GAAAq3J,GAAAr5J,KAAAq5J,gBACA7B,EAAA6B,EAAAx4J,KAAAb,KAAAgC,EACAw1J,IACAx3J,KAAA05J,aAAAlC,GAGA,MAAAr2J,GACAnB,KAAA2D,OAAAxC,KAGAo4J,EAAAp5J,UAAAq5J,YAAA,SAAAp1J,GACA,GAAAoyG,GAAAx2G,KAAAw2G,QACA,IAAAA,GAAApyG,EAAA,CACA,GAAAwkD,GAAAxkD,EAAAwkD,OAAA7mD,EAAAqC,EAAArC,YACA/B,MAAAsD,YAAAjC,KAAAunD,GACA4tD,EAAA5tG,OAAA4tG,EAAA7tG,QAAAvE,GAAA,GACApE,KAAA6H,OAAA9F,GACAA,EAAAE,gBAGAs3J,EAAAp5J,UAAAu5J,aAAA,SAAAlC,GACA,GAAAhhD,GAAAx2G,KAAAw2G,SACA5tD,KACA7mD,EAAA,GAAAc,GAAAqB,aACAE,GAAuBwkD,SAAA7mD,eACvBy0G,GAAApuG,KAAAhE,EACA,IAAA6sJ,GAAAhrD,EAAAxgG,kBAAAzF,KAAAw3J,EAAApzJ,IACA6sJ,KAAAptJ,OACA7D,KAAAw5J,YAAAp1J,IAGA6sJ,EAAA7sJ,UACApE,KAAAc,IAAAmwJ,GACAlvJ,EAAAjB,IAAAmwJ,KAGAsI,GACCvzD,EAAAjhG,kBlQgosCK,SAAUvF,EAAQC,EAASC,GAEjC,YmQ5usCA,SAAA2mJ,GAAAgT,GACA,MAAAr5J,MAAAI,KAAA,GAAAu5J,GAAAN,IA5CA,GAAAj3J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAM,EAAAnD,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAqCAD,GAAA4mJ,YACA,IAAAsT,GAAA,WACA,QAAAA,GAAAN,GACAr5J,KAAAq5J,kBAKA,MAHAM,GAAAx5J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA65J,GAAA13J,EAAAlC,KAAAq5J,mBAEAM,KAOAC,EAAA,SAAA32J,GAEA,QAAA22J,GAAAt2J,EAAA+1J,GACAp2J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAq5J,kBACAr5J,KAAA65J,aAAA,EACA75J,KAAAy5J,aAmDA,MAxDAr3J,GAAAw3J,EAAA32J,GAOA22J,EAAAz5J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA4oD,OAAAxgD,KAAApG,IAEA43J,EAAAz5J,UAAAyD,UAAA,WACA,GAAAglD,GAAA5oD,KAAA4oD,MACAA,IACA5oD,KAAAsD,YAAAjC,KAAAunD,GAEA3lD,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEA45J,EAAAz5J,UAAA0E,aAAA,WACA7E,KAAA4oD,OAAA,KACA5oD,KAAA65J,aAAA,GAEAD,EAAAz5J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAy5J,cAEAG,EAAAz5J,UAAAqF,eAAA,WACAxF,KAAA65J,YACA75J,KAAAU,WAGAV,KAAAy5J,cAGAG,EAAAz5J,UAAAs5J,WAAA,WACA,GAAAK,GAAA95J,KAAA85J,mBACAA,KACA95J,KAAA6H,OAAAiyJ,GACAA,EAAA73J,cAEA,IAAA2mD,GAAA5oD,KAAA4oD,MACA5oD,MAAA4oD,QACA5oD,KAAAsD,YAAAjC,KAAAunD,GAEA5oD,KAAA4oD,SACA,IAAA4uG,GAAAhwJ,EAAAO,SAAA/H,KAAAq5J,kBACA7B,KAAA/vJ,EAAAO,YACAhI,KAAAS,MAAAgH,EAAAO,YAAAC,IAGA6xJ,EAAA,GAAAj3J,GAAAqB,aACAlE,KAAA85J,sBACA95J,KAAAc,IAAAg5J,GACA95J,KAAA65J,aAAA,EACAC,EAAAh5J,IAAAmlG,EAAAxgG,kBAAAzF,KAAAw3J,IACAx3J,KAAA65J,aAAA,IAGAD,GACC5zD,EAAAjhG,kBnQ8xsCK,SAAUvF,EAAQC,EAASC,GAEjC,YoQr1sCA,SAAA6mJ,GAAAx6I,GACA,GAAA1L,GAAA,GAAA05J,GAAAhuJ,GACAiuJ,EAAAh6J,KAAAI,KAAAC,EACA,OAAAA,GAAA25J,SArEA,GAAA53J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAiEAD,GAAA8mJ,QACA,IAAAwT,GAAA,WACA,QAAAA,GAAAhuJ,GACA/L,KAAA+L,WAKA,MAHAguJ,GAAA55J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAk6J,GAAA/3J,EAAAlC,KAAA+L,SAAA/L,KAAAg6J,UAEAD,KAOAE,EAAA,SAAAh3J,GAEA,QAAAg3J,GAAA32J,EAAAyI,EAAAiuJ,GACA/2J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+L,WACA/L,KAAAg6J,SAqBA,MAzBA53J,GAAA63J,EAAAh3J,GAWAg3J,EAAA95J,UAAAM,MAAA,SAAAU,GACA,IAAAnB,KAAAmD,UAAA,CACA,GAAAwC,OAAA,EACA,KACAA,EAAA3F,KAAA+L,SAAA5K,EAAAnB,KAAAg6J,QAEA,MAAAE,GAEA,WADAj3J,GAAA9C,UAAAM,MAAAI,KAAAb,KAAAk6J,GAGAl6J,KAAA8D,yBACA9D,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA2F,MAGAs0J,GACCj0D,EAAAjhG,kBpQ85sCK,SAAUvF,EAAQC,EAASC,GAEjC,YqQx+sCA,SAAA+mJ,GAAAr+G,GACA,MAAApoC,MAAAI,KAAA,GAAAmjJ,GAAAx8C,sBAAA3+D,IA1CA,GAAAm7G,GAAA7jJ,EAAA,GA4CAD,GAAAgnJ,crQwhtCM,SAAUjnJ,EAAQC,EAASC,GAEjC,YsQphtCA,SAAAinJ,KACA,MAAA3mJ,MAAAI,KAAA,GAAAknG,GAAAvB,iBAAA,IAnDA,GAAAuB,GAAA5nG,EAAA,GAqDAD,GAAAknJ,atQ6ktCM,SAAUnnJ,EAAQC,EAASC,GAEjC,YuQvktCA,SAAAmnJ,GAAAz+G,EAAA8wG,GACA,MAAAl5I,MAAAI,KAAA,GAAA+pJ,GAAAhR,iBAAA/wG,EAAA8wG,EAAA,IA9DA,GAAAiR,GAAAzqJ,EAAA,GAgEAD,GAAAonJ,avQ2otCM,SAAUrnJ,EAAQC,EAASC,GAEjC,YwQnptCA,SAAAqnJ,GAAAtN,EAAAP,GACA,MAAAl5I,MAAAI,KAAA,GAAAiqJ,GAAA3Q,mBAAAD,EAAAP,EAAA,IA3DA,GAAAmR,GAAA3qJ,EAAA,GA6DAD,GAAAsnJ,exQottCM,SAAUvnJ,EAAQC,EAASC,GAEjC,YyQ7ttCA,SAAA8L,GAAAktI,GACA,MAAA14I,MAAAI,KAAA,GAAA+5J,GAAAzhB,EAAA14I,OAvDA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAoDAD,GAAA+L,OACA,IAAA2uJ,GAAA,WACA,QAAAA,GAAAzhB,EAAAn4I,GACAP,KAAA04I,YACA14I,KAAAO,SAKA,MAHA45J,GAAAh6J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAq6J,GAAAl4J,EAAAlC,KAAA04I,UAAA14I,KAAAO,UAEA45J,KAOAC,EAAA,SAAAn3J,GAEA,QAAAm3J,GAAA92J,EAAAo1I,EAAAn4I,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAO,SACAP,KAAAwL,MAAA,EACAxL,KAAA4H,MAAA,EA2BA,MAjCAxF,GAAAg4J,EAAAn3J,GAQAm3J,EAAAj6J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA04I,UACA14I,KAAAq6J,cAAAr4J,GAGAhC,KAAAwL,SAGA4uJ,EAAAj6J,UAAAk6J,cAAA,SAAAr4J,GACA,GAAA2D,EACA,KACAA,EAAA3F,KAAA04I,UAAA12I,EAAAhC,KAAA4H,QAAA5H,KAAAO,QAEA,MAAAY,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAwE,GACA3F,KAAAwL,SAGA4uJ,EAAAj6J,UAAAyD,UAAA,WACA5D,KAAAsD,YAAAjC,KAAArB,KAAAwL,OACAxL,KAAAsD,YAAA5C,YAEA05J,GACCt1J,EAAA9B,azQ0xtCK,SAAUxD,EAAQC,EAASC,GAEjC,Y0Qv1tCA,SAAAwnJ,GAAAxM,GACA,MAAA16I,MAAAI,KAAA,GAAAk6J,GAAA5f,IAlDA,GAAAt4I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA8CAD,GAAAynJ,UACA,IAAAoT,GAAA,WACA,QAAAA,GAAA5f,GACA16I,KAAA06I,mBAKA,MAHA4f,GAAAn6J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAw6J,GAAAr4J,EAAAlC,KAAA06I,oBAEA4f,KAOAC,EAAA,SAAAt3J,GAEA,QAAAs3J,GAAAj3J,EAAAo3I,GACAz3I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA06I,mBACA16I,KAAA+gG,UAAA,EACA/gG,KAAAw6J,qBAAA,KAkDA,MAvDAp4J,GAAAm4J,EAAAt3J,GAOAs3J,EAAAp6J,UAAAuD,MAAA,SAAA1B,GACA,IACA,GAAA2D,GAAA3F,KAAA06I,iBAAA75I,KAAAb,KAAAgC,EACA2D,IACA3F,KAAAq5I,SAAAr3I,EAAA2D,GAGA,MAAAxE,GACAnB,KAAAsD,YAAA7C,MAAAU,KAGAo5J,EAAAp6J,UAAAyD,UAAA,WACA5D,KAAAy6J,YACAz6J,KAAAsD,YAAA5C,YAEA65J,EAAAp6J,UAAAk5I,SAAA,SAAAr3I,EAAAilB,GACA,GAAAllB,GAAA/B,KAAAw6J,oBACAx6J,MAAAgC,QACAhC,KAAA+gG,UAAA,EACAh/F,IACAA,EAAAE,cACAjC,KAAA6H,OAAA9F,IAEAA,EAAAkkG,EAAAxgG,kBAAAzF,KAAAinB,GACAllB,EAAA8B,QACA7D,KAAAc,IAAAd,KAAAw6J,qBAAAz4J,IAGAw4J,EAAAp6J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAy6J,aAEAF,EAAAp6J,UAAAqF,eAAA,WACAxF,KAAAy6J,aAEAF,EAAAp6J,UAAAs6J,UAAA,WACA,GAAAz6J,KAAA+gG,SAAA,CACA,GAAA/+F,GAAAhC,KAAAgC,MACAD,EAAA/B,KAAAw6J,oBACAz4J,KACA/B,KAAAw6J,qBAAA,KACAz4J,EAAAE,cACAjC,KAAA6H,OAAA9F,IAEA/B,KAAAgC,MAAA,KACAhC,KAAA+gG,UAAA,EACA99F,EAAA9C,UAAAuD,MAAA7C,KAAAb,KAAAgC,KAGAu4J,GACCv0D,EAAAjhG,kB1Q+4tCK,SAAUvF,EAAQC,EAASC,GAEjC,Y2Qx9tCA,SAAA0nJ,GAAAiN,EAAAtpJ,GAEA,WADA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,OAC/BvK,KAAAI,KAAA,GAAAs6J,GAAArG,EAAAtpJ,IAwDA,QAAAgrI,GAAA7zI,GACAA,EAAAy4J,gBAhHA,GAAAv4J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkrG,EAAAlrG,EAAA,EAmDAD,GAAA2nJ,cACA,IAAAsT,GAAA,WACA,QAAAA,GAAArG,EAAAtpJ,GACA/K,KAAAq0J,UACAr0J,KAAA+K,YAKA,MAHA2vJ,GAAAv6J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA66J,GAAA14J,EAAAlC,KAAAq0J,QAAAr0J,KAAA+K,aAEA2vJ,KAOAE,EAAA,SAAA33J,GAEA,QAAA23J,GAAAt3J,EAAA+wJ,EAAAtpJ,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAq0J,UACAr0J,KAAA+K,YACA/K,KAAA66J,sBAAA,KACA76J,KAAA86J,UAAA,KACA96J,KAAA+gG,UAAA,EA4BA,MAnCA3+F,GAAAw4J,EAAA33J,GASA23J,EAAAz6J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA+6J,gBACA/6J,KAAA86J,UAAA94J,EACAhC,KAAA+gG,UAAA,EACA/gG,KAAAc,IAAAd,KAAA66J,sBAAA76J,KAAA+K,UAAAU,SAAAsqI,EAAA/1I,KAAAq0J,QAAAr0J,QAEA46J,EAAAz6J,UAAAyD,UAAA,WACA5D,KAAA26J,gBACA36J,KAAAsD,YAAA5C,YAEAk6J,EAAAz6J,UAAAw6J,cAAA,WACA36J,KAAA+6J,gBACA/6J,KAAA+gG,WACA/gG,KAAAsD,YAAAjC,KAAArB,KAAA86J,WACA96J,KAAA86J,UAAA,KACA96J,KAAA+gG,UAAA,IAGA65D,EAAAz6J,UAAA46J,cAAA,WACA,GAAAF,GAAA76J,KAAA66J,qBACA,QAAAA,IACA76J,KAAA6H,OAAAgzJ,GACAA,EAAA54J,cACAjC,KAAA66J,sBAAA,OAGAD,GACC91J,EAAA9B,a3QuhuCK,SAAUxD,EAAQC,EAASC,GAEjC,Y4QlmuCA,SAAA4nJ,GAAA0T,GAEA,WADA,KAAAA,IAAkCA,EAAA,MAClCh7J,KAAAI,KAAA,GAAA66J,GAAAD,IAvCA,GAAA54J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAoCAD,GAAA6nJ,gBACA,IAAA2T,GAAA,WACA,QAAAA,GAAAD,GACAh7J,KAAAg7J,eAKA,MAHAC,GAAA96J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAm7J,GAAAh5J,EAAAlC,KAAAg7J,gBAEAC,KAOAC,EAAA,SAAAj4J,GAEA,QAAAi4J,GAAA53J,EAAA03J,GACA/3J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAg7J,eACAh7J,KAAAwpJ,SAAA,EAYA,MAhBApnJ,GAAA84J,EAAAj4J,GAMAi4J,EAAA/6J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAwpJ,SAAA,EACAxpJ,KAAAsD,YAAAjC,KAAAW,IAEAk5J,EAAA/6J,UAAAyD,UAAA,WACA5D,KAAAwpJ,SACAxpJ,KAAAsD,YAAAjC,KAAArB,KAAAg7J,cAEAh7J,KAAAsD,YAAA5C,YAEAw6J,GACCp2J,EAAA9B,a5Q8ouCK,SAAUxD,EAAQC,EAASC,GAEjC,Y6Q1quCA,SAAAslB,KAAAja,OACA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,MAC/B,IAAA4wJ,GAAAhH,EAAA3tD,OAAAxhF,GACAo2I,EAAAD,GAAAn2I,EAAAja,EAAAuZ,MAAAvX,KAAAY,IAAAqX,EACA,OAAAhlB,MAAAI,KAAA,GAAAi7J,GAAAD,EAAArwJ,IApDA,GAAA3I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAqoG,EAAAlrG,EAAA,GACAy0J,EAAAz0J,EAAA,IACAoF,EAAApF,EAAA,GACAkoG,EAAAloG,EAAA,GA8CAD,GAAAulB,OACA,IAAAq2I,GAAA,WACA,QAAAA,GAAAr2I,EAAAja,GACA/K,KAAAglB,QACAhlB,KAAA+K,YAKA,MAHAswJ,GAAAl7J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAu7J,GAAAp5J,EAAAlC,KAAAglB,MAAAhlB,KAAA+K,aAEAswJ,KAOAC,EAAA,SAAAr4J,GAEA,QAAAq4J,GAAAh4J,EAAA0hB,EAAAja,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAglB,QACAhlB,KAAA+K,YACA/K,KAAA60C,SACA70C,KAAA+b,QAAA,EACA/b,KAAAoiG,SAAA,EA8CA,MArDAhgG,GAAAk5J,EAAAr4J,GASAq4J,EAAAhwJ,SAAA,SAAAC,GAKA,IAJA,GAAAhL,GAAAgL,EAAAhL,OACAs0C,EAAAt0C,EAAAs0C,MACA9pC,EAAAQ,EAAAR,UACAzH,EAAAiI,EAAAjI,YACAuxC,EAAAxxC,OAAA,GAAAwxC,EAAA,GAAA5vB,KAAAla,EAAAuZ,OAAA,GACAuwB,EAAAxC,QAAAw1D,aAAA7G,QAAA19F,EAEA,IAAAuxC,EAAAxxC,OAAA,GACA,GAAAkkJ,GAAAx6I,KAAAC,IAAA,EAAA6nC,EAAA,GAAA5vB,KAAAla,EAAAuZ,MACAtkB,MAAAyL,SAAAF,EAAAg8I,OAGAhnJ,GAAAwb,QAAA,GAGAu/I,EAAAn7J,UAAAo7J,UAAA,SAAAxwJ,GACA/K,KAAA+b,QAAA,EACA/b,KAAAc,IAAAiK,EAAAU,SAAA6vJ,EAAAhwJ,SAAAtL,KAAAglB,OACAzkB,OAAAP,KAAAsD,YAAAtD,KAAAsD,YAAAyH,gBAGAuwJ,EAAAn7J,UAAAq7J,qBAAA,SAAA3zD,GACA,QAAA7nG,KAAAoiG,QAAA,CAGA,GAAAr3F,GAAA/K,KAAA+K,UACAo4F,EAAA,GAAAs4D,GAAA1wJ,EAAAuZ,MAAAtkB,KAAAglB,MAAA6iF,EACA7nG,MAAA60C,MAAAzsC,KAAA+6F,IACA,IAAAnjG,KAAA+b,QACA/b,KAAAu7J,UAAAxwJ,KAGAuwJ,EAAAn7J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAw7J,qBAAA5zD,EAAA/G,aAAAU,WAAAv/F,KAEAs5J,EAAAn7J,UAAAwD,OAAA,SAAAxC,GACAnB,KAAAoiG,SAAA,EACApiG,KAAA60C,SACA70C,KAAAsD,YAAA7C,MAAAU,IAEAm6J,EAAAn7J,UAAAyD,UAAA,WACA5D,KAAAw7J,qBAAA5zD,EAAA/G,aAAAa,mBAEA45D,GACCx2J,EAAA9B,YACDy4J,EAAA,WACA,QAAAA,GAAAx2I,EAAA4iF,GACA7nG,KAAAilB,OACAjlB,KAAA6nG,eAEA,MAAA4zD,O7QkuuCM,SAAUj8J,EAAQC,EAASC,GAEjC,Y8QjzuCA,SAAA+nJ,GAAAiU,EAAAC,GACA,MAAAA,GACA,GAAAC,GAAA57J,KAAA27J,GACAv7J,KAAA,GAAAy7J,GAAAH,IAEA17J,KAAAI,KAAA,GAAAy7J,GAAAH,IA3DA,GAAAt5J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAoG,EAAApG,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAqDAD,GAAAgoJ,WACA,IAAAoU,GAAA,WACA,QAAAA,GAAAH,GACA17J,KAAA07J,wBAKA,MAHAG,GAAA17J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA+7J,GAAA55J,EAAAlC,KAAA07J,yBAEAG,KAOAC,EAAA,SAAA74J,GAEA,QAAA64J,GAAAx4J,EAAAo4J,GACAz4J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA07J,wBACA17J,KAAA+wJ,WAAA,EACA/wJ,KAAA+7J,8BACA/7J,KAAA0O,UAwDA,MA9DAtM,GAAA05J,EAAA74J,GAQA64J,EAAA37J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAsD,YAAAjC,KAAA6D,GACAlF,KAAAg8J,mBAAA12J,GACAtF,KAAAi8J,eAEAH,EAAA37J,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAA2D,OAAAlD,IAEAq7J,EAAA37J,UAAAqF,eAAA,SAAAF,GACA,GAAAtD,GAAAhC,KAAAg8J,mBAAA12J,EACAtD,IACAhC,KAAAsD,YAAAjC,KAAAW,GAEAhC,KAAAi8J,eAEAH,EAAA37J,UAAAuD,MAAA,SAAA1B,GACA,IACA,GAAAk6J,GAAAl8J,KAAA07J,sBAAA15J,EACAk6J,IACAl8J,KAAAm8J,SAAAD,EAAAl6J,GAGA,MAAAb,GACAnB,KAAAsD,YAAA7C,MAAAU,KAGA26J,EAAA37J,UAAAyD,UAAA,WACA5D,KAAA+wJ,WAAA,EACA/wJ,KAAAi8J,eAEAH,EAAA37J,UAAA67J,mBAAA,SAAAj6J,GACAA,EAAAE,aACA,IAAAm6J,GAAAp8J,KAAA+7J,2BAAApzJ,QAAA5G,GACAC,EAAA,IAMA,QALA,IAAAo6J,IACAp6J,EAAAhC,KAAA0O,OAAA0tJ,GACAp8J,KAAA+7J,2BAAAnzJ,OAAAwzJ,EAAA,GACAp8J,KAAA0O,OAAA9F,OAAAwzJ,EAAA,IAEAp6J,GAEA85J,EAAA37J,UAAAg8J,SAAA,SAAAD,EAAAl6J,GACA,GAAAq6J,GAAAp2D,EAAAxgG,kBAAAzF,KAAAk8J,EAAAl6J,EACAq6J,OAAAx4J,SACA7D,KAAAc,IAAAu7J,GACAr8J,KAAA+7J,2BAAA3zJ,KAAAi0J,IAEAr8J,KAAA0O,OAAAtG,KAAApG,IAEA85J,EAAA37J,UAAA87J,YAAA,WACAj8J,KAAA+wJ,WAAA,IAAA/wJ,KAAA+7J,2BAAA14J,QACArD,KAAAsD,YAAA5C,YAGAo7J,GACC91D,EAAAjhG,iBAMD62J,EAAA,SAAA34J,GAEA,QAAA24J,GAAAr7J,EAAAo7J,GACA14J,EAAApC,KAAAb,MACAA,KAAAO,SACAP,KAAA27J,oBAKA,MATAv5J,GAAAw5J,EAAA34J,GAMA24J,EAAAz7J,UAAAD,WAAA,SAAAgC,GACAlC,KAAA27J,kBAAA57J,UAAA,GAAAu8J,GAAAp6J,EAAAlC,KAAAO,UAEAq7J,GACC91J,EAAAhG,YAMDw8J,EAAA,SAAAr5J,GAEA,QAAAq5J,GAAA13J,EAAArE,GACA0C,EAAApC,KAAAb,MACAA,KAAA4E,SACA5E,KAAAO,SACAP,KAAAu8J,kBAAA,EAmBA,MAxBAn6J,GAAAk6J,EAAAr5J,GAOAq5J,EAAAn8J,UAAAuD,MAAA,SAAAwjG,GACAlnG,KAAAw8J,qBAEAF,EAAAn8J,UAAAwD,OAAA,SAAAxC,GACAnB,KAAAiC,cACAjC,KAAA4E,OAAAnE,MAAAU,IAEAm7J,EAAAn8J,UAAAyD,UAAA,WACA5D,KAAAw8J,qBAEAF,EAAAn8J,UAAAq8J,kBAAA,WACAx8J,KAAAu8J,mBACAv8J,KAAAu8J,kBAAA,EACAv8J,KAAAiC,cACAjC,KAAAO,OAAAR,UAAAC,KAAA4E,UAGA03J,GACCx3J,EAAA9B,a9Q82uCK,SAAUxD,EAAQC,EAASC,GAEjC,Y+Q//uCA,SAAAioJ,KACA,MAAA3nJ,MAAAI,KAAA,GAAAq8J,IA/CA,GAAAr6J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EA4CAD,GAAAkoJ,eACA,IAAA8U,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAt8J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA28J,GAAAx6J,KAEAu6J,KAOAC,EAAA,SAAAz5J,GAEA,QAAAy5J,GAAAp5J,GACAL,EAAApC,KAAAb,KAAAsD,GAKA,MAPAlB,GAAAs6J,EAAAz5J,GAIAy5J,EAAAv8J,UAAAuD,MAAA,SAAA1B,GACAA,EAAAg/F,QAAAhhG,KAAAsD,cAEAo5J,GACC53J,EAAA9B,a/QojvCK,SAAUxD,EAAQC,EAASC,GAEjC,YgRzkvCA,SAAAmoJ,GAAAvP,EAAAqkB,GACA,MAAA38J,MAAAI,KAAA,GAAAw8J,GAAAtkB,EAAAqkB,IAtDA,GAAAv6J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,GACAojG,EAAApjG,EAAA,IAiDAD,GAAAooJ,UACA,IAAA+U,GAAA,WACA,QAAAA,GAAAtkB,EAAAqkB,GACA38J,KAAAs4I,cACAt4I,KAAA28J,UAKA,MAHAC,GAAAz8J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA88J,GAAA36J,EAAAlC,KAAAs4I,YAAAt4I,KAAA28J,WAEAC,KAOAC,EAAA,SAAA55J,GAEA,QAAA45J,GAAAv5J,EAAAg1I,EAAAqkB,GACA15J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAs4I,cACAt4I,KAAA0O,OAAA,GAAAo0F,GAAAjwE,IACA8pI,GACA38J,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA28J,IAoCA,MA1CAv6J,GAAAy6J,EAAA55J,GASA45J,EAAA18J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA0O,OAAA8/D,SAEAquF,EAAA18J,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAA2D,OAAAlD,IAEAo8J,EAAA18J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAs4I,YACAt4I,KAAA88J,gBAAA96J,GAGAhC,KAAA+8J,cAAA/6J,MAGA66J,EAAA18J,UAAA28J,gBAAA,SAAA96J,GACA,GAAAuU,GACAjT,EAAAtD,KAAAsD,WACA,KACAiT,EAAAvW,KAAAs4I,YAAAt2I,GAEA,MAAAb,GAEA,WADAmC,GAAA7C,MAAAU,GAGAnB,KAAA+8J,cAAAxmJ,EAAAvU,IAEA66J,EAAA18J,UAAA48J,cAAA,SAAAxmJ,EAAAvU,GACA,GAAA0M,GAAA1O,KAAA0O,MACAA,GAAAinC,IAAAp/B,KACA7H,EAAA5N,IAAAyV,GACAvW,KAAAsD,YAAAjC,KAAAW,KAGA66J,GACC72D,EAAAjhG,gBACDtF,GAAAo9J,sBhRqovCM,SAAUr9J,EAAQC,EAASC,GAEjC,YiRjsvCA,SAAAsoJ,GAAAzxI,EAAAib,GACA,MAAAs2H,GAAAzP,qBAAAx3I,KAAAb,KAAA,SAAA2L,EAAAoC,GACA,MAAAyjB,GACAA,EAAA7lB,EAAA4K,GAAAxI,EAAAwI,IAEA5K,EAAA4K,KAAAxI,EAAAwI,KAhEA,GAAAuxI,GAAApoJ,EAAA,GAmEAD,GAAAuoJ,2BjRmwvCM,SAAUxoJ,EAAQC,EAASC,GAEjC,YkRtxvCA,SAAAwoJ,GAAA9mD,EAAA3gG,EAAAC,GACA,MAAAV,MAAAI,KAAA,GAAA48J,GAAA57D,EAAA3gG,EAAAC,IAnDA,GAAA0B,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAgDAD,GAAAyoJ,KACA,IAAA8U,GAAA,WACA,QAAAA,GAAA57D,EAAA3gG,EAAAC,GACAV,KAAAohG,iBACAphG,KAAAS,QACAT,KAAAU,WAKA,MAHAs8J,GAAA78J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAk9J,GAAA/6J,EAAAlC,KAAAohG,eAAAphG,KAAAS,MAAAT,KAAAU,YAEAs8J,KAOAC,EAAA,SAAAh6J,GAEA,QAAAg6J,GAAA35J,EAAA89F,EAAA3gG,EAAAC,GACAuC,EAAApC,KAAAb,KAAAsD,EACA,IAAA45J,GAAA,GAAAp4J,GAAA9B,WAAAo+F,EAAA3gG,EAAAC,EACAw8J,GAAAl8J,oBAAA,EACAhB,KAAAc,IAAAo8J,GACAl9J,KAAAk9J,iBAgCA,MAtCA96J,GAAA66J,EAAAh6J,GAQAg6J,EAAA98J,UAAAuD,MAAA,SAAA1B,GACA,GAAAk7J,GAAAl9J,KAAAk9J,cACAA,GAAA77J,KAAAW,GACAk7J,EAAAj8J,gBACAjB,KAAAsD,YAAA7C,MAAAy8J,EAAAh8J,gBAGAlB,KAAAsD,YAAAjC,KAAAW,IAGAi7J,EAAA98J,UAAAwD,OAAA,SAAAxC,GACA,GAAA+7J,GAAAl9J,KAAAk9J,cACAA,GAAAz8J,MAAAU,GACA+7J,EAAAj8J,gBACAjB,KAAAsD,YAAA7C,MAAAy8J,EAAAh8J,gBAGAlB,KAAAsD,YAAA7C,MAAAU,IAGA87J,EAAA98J,UAAAyD,UAAA,WACA,GAAAs5J,GAAAl9J,KAAAk9J,cACAA,GAAAx8J,WACAw8J,EAAAj8J,gBACAjB,KAAAsD,YAAA7C,MAAAy8J,EAAAh8J,gBAGAlB,KAAAsD,YAAA5C,YAGAu8J,GACCn4J,EAAA9B,alR+0vCK,SAAUxD,EAAQC,EAASC,GAEjC,YmR94vCA,SAAA0oJ,GAAAxgJ,EAAAozJ,GACA,MAAAh7J,MAAAI,KAAA,GAAA+8J,GAAAv1J,EAAAozJ,IAlDA,GAAA54J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkqG,EAAAlqG,EAAA,GA8CAD,GAAA2oJ,WACA,IAAA+U,GAAA,WACA,QAAAA,GAAAv1J,EAAAozJ,GAGA,GAFAh7J,KAAA4H,QACA5H,KAAAg7J,eACApzJ,EAAA,EACA,SAAAgiG,GAAA1G,wBAMA,MAHAi6D,GAAAh9J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAq9J,GAAAl7J,EAAAlC,KAAA4H,MAAA5H,KAAAg7J,gBAEAmC,KAOAC,EAAA,SAAAn6J,GAEA,QAAAm6J,GAAA95J,EAAAsE,EAAAozJ,GACA/3J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4H,QACA5H,KAAAg7J,eAoBA,MAxBA54J,GAAAg7J,EAAAn6J,GAMAm6J,EAAAj9J,UAAAuD,MAAA,SAAAiI,GACA,GAAA3L,KAAA4H,UACA5H,KAAAsD,YAAAjC,KAAAsK,GACA3L,KAAAsD,YAAA5C,aAGA08J,EAAAj9J,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,WACAtD,MAAA4H,OAAA,QACA,KAAA5H,KAAAg7J,aACA13J,EAAAjC,KAAArB,KAAAg7J,cAGA13J,EAAA7C,MAAA,GAAAmpG,GAAA1G,0BAGA5/F,EAAA5C,YAEA08J,GACCt4J,EAAA9B,anRs8vCK,SAAUxD,EAAQC,EAASC,GAEjC,YoRrhwCA,SAAAspB,GAAA0vH,EAAAnxC,GACA,MAAAvnG,MAAAI,KAAA,GAAAi9J,GAAA3kB,EAAAnxC,EAAAvnG,OArBA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAkBAD,GAAAupB,OACA,IAAAq0I,GAAA,WACA,QAAAA,GAAA3kB,EAAAnxC,EAAAhnG,GACAP,KAAA04I,YACA14I,KAAAunG,UACAvnG,KAAAO,SAKA,MAHA88J,GAAAl9J,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAu9J,GAAAr8D,EAAAjhG,KAAA04I,UAAA14I,KAAAunG,QAAAvnG,KAAAO,UAEA88J,KAOAC,EAAA,SAAAr6J,GAEA,QAAAq6J,GAAAh6J,EAAAo1I,EAAAnxC,EAAAhnG,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAunG,UACAvnG,KAAAO,SACAP,KAAA4H,MAAA,EACA5H,KAAAunG,WAAAvnG,KAsBA,MA7BAoC,GAAAk7J,EAAAr6J,GASAq6J,EAAAn9J,UAAAqF,eAAA,SAAA+3J,GACAv9J,KAAAsD,YAAAjC,KAAAk8J,GACAv9J,KAAAsD,YAAA5C,YAEA48J,EAAAn9J,UAAAuD,MAAA,SAAA1B,GACA,GAAA2D,IAAA,CACA,KACAA,EAAA3F,KAAA04I,UAAA73I,KAAAb,KAAAunG,QAAAvlG,EAAAhC,KAAA4H,QAAA5H,KAAAO,QAEA,MAAAY,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAwE,GACA3F,KAAAwF,gBAAA,IAGA83J,EAAAn9J,UAAAyD,UAAA,WACA5D,KAAAwF,gBAAA,IAEA83J,GACCx4J,EAAA9B,apRgjwCK,SAAUxD,EAAQC,EAASC,GAEjC,YqR/kwCA,SAAA6oJ,KACA,MAAAvoJ,MAAAI,KAAA,GAAAo9J,IA3CA,GAAAp7J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAuCAD,GAAA8oJ,SACA,IAAAiV,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAr9J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA09J,GAAAv7J,KAEAs7J,KAOAC,EAAA,SAAAx6J,GAEA,QAAAw6J,GAAAn6J,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4kG,cAAA,EACA5kG,KAAA09J,iBAAA,EAqBA,MAzBAt7J,GAAAq7J,EAAAx6J,GAMAw6J,EAAAt9J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA09J,kBACA19J,KAAA09J,iBAAA,EACA19J,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAgC,MAGAy7J,EAAAt9J,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA5kG,KAAA09J,iBACA19J,KAAAsD,YAAA5C,YAGA+8J,EAAAt9J,UAAAqF,eAAA,SAAAF,GACAtF,KAAA6H,OAAAvC,GACAtF,KAAA09J,iBAAA,EACA19J,KAAA4kG,cACA5kG,KAAAsD,YAAA5C,YAGA+8J,GACCz3D,EAAAjhG,kBrRgowCK,SAAUvF,EAAQC,EAASC,GAEjC,YsRnqwCA,SAAA+oJ,GAAArgH,EAAA8wG,GACA,MAAAl5I,MAAAI,KAAA,GAAAu9J,GAAAv1H,EAAA8wG,IAtDA,GAAA92I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAkDAD,GAAAgpJ,YACA,IAAAkV,GAAA,WACA,QAAAA,GAAAv1H,EAAA8wG,GACAl5I,KAAAooC,UACApoC,KAAAk5I,iBAKA,MAHAykB,GAAAx9J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA69J,GAAA17J,EAAAlC,KAAAooC,QAAApoC,KAAAk5I,kBAEAykB,KAOAC,EAAA,SAAA36J,GAEA,QAAA26J,GAAAt6J,EAAA8kC,EAAA8wG,GACAj2I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAAk5I,iBACAl5I,KAAA09J,iBAAA,EACA19J,KAAA4kG,cAAA,EACA5kG,KAAA4H,MAAA,EAsDA,MA7DAxF,GAAAw7J,EAAA36J,GASA26J,EAAAz9J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA09J,iBACA19J,KAAA69J,QAAA77J,IAGA47J,EAAAz9J,UAAA09J,QAAA,SAAA77J,GACA,GAAA4F,GAAA5H,KAAA4H,QACAtE,EAAAtD,KAAAsD,WACA,KACA,GAAAqC,GAAA3F,KAAAooC,QAAApmC,EAAA4F,EACA5H,MAAA09J,iBAAA,EACA19J,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA2F,EAAA3D,EAAA4F,IAEA,MAAAzG,GACAmC,EAAA7C,MAAAU,KAGAy8J,EAAAz9J,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA5kG,KAAA09J,iBACA19J,KAAAsD,YAAA5C,YAGAk9J,EAAAz9J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAvB,GAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WACA41I,GACAl5I,KAAA45I,gBAAA10I,EAAAC,EAAAC,EAAAC,GAGA/B,EAAAjC,KAAA8D,IAGAy4J,EAAAz9J,UAAAy5I,gBAAA,SAAA10I,EAAAC,EAAAC,EAAAC,GACA,GAAAtB,GAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WACA,KACA,GAAAqC,GAAAuzI,EAAAh0I,EAAAC,EAAAC,EAAAC,EACA/B,GAAAjC,KAAAsE,GAEA,MAAAxE,GACAmC,EAAA7C,MAAAU,KAGAy8J,EAAAz9J,UAAAoF,YAAA,SAAApE,GACAnB,KAAAsD,YAAA7C,MAAAU,IAEAy8J,EAAAz9J,UAAAqF,eAAA,SAAAF,GACAtF,KAAA6H,OAAAvC,GACAtF,KAAA09J,iBAAA,EACA19J,KAAA4kG,cACA5kG,KAAAsD,YAAA5C,YAGAk9J,GACC53D,EAAAjhG,kBtR+twCK,SAAUvF,EAAQC,EAASC,GAEjC,YuRjzwCA,SAAAyvF,GAAA/mD,EAAA09D,EAAA/6F,GAIA,WAHA,KAAA+6F,IAAgCA,EAAAZ,OAAAC,uBAChC,KAAAp6F,IAA+BA,MAAAiqB,IAC/B8wE,MAAA,KAAAZ,OAAAC,kBAAAW,EACA9lG,KAAAI,KAAA,GAAA09J,GAAA11H,EAAA09D,EAAA/6F,IA3DA,GAAA3I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAiF,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAqDAD,GAAA0vF,QACA,IAAA2uE,GAAA,WACA,QAAAA,GAAA11H,EAAA09D,EAAA/6F,GACA/K,KAAAooC,UACApoC,KAAA8lG,aACA9lG,KAAA+K,YAKA,MAHA+yJ,GAAA39J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAg+J,GAAA77J,EAAAlC,KAAAooC,QAAApoC,KAAA8lG,WAAA9lG,KAAA+K,aAEA+yJ,IAEAr+J,GAAAq+J,gBAMA,IAAAC,GAAA,SAAA96J,GAEA,QAAA86J,GAAAz6J,EAAA8kC,EAAA09D,EAAA/6F,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAA8lG,aACA9lG,KAAA+K,YACA/K,KAAA4H,MAAA,EACA5H,KAAA+b,OAAA,EACA/b,KAAA4kG,cAAA,EACAkB,EAAAZ,OAAAC,oBACAnlG,KAAA4oD,WAwDA,MAlEAxmD,GAAA27J,EAAA96J,GAaA86J,EAAAzyJ,SAAA,SAAAM,GACA,GAAA1J,GAAA0J,EAAA1J,WAAAyD,EAAAiG,EAAAjG,OAAA3D,EAAA4J,EAAA5J,MAAA4F,EAAAgE,EAAAhE,KACA1F,GAAA87J,sBAAAr4J,EAAA3D,EAAA4F,IAEAm2J,EAAA59J,UAAAuD,MAAA,SAAA1B,GACA,GAAAsB,GAAAtD,KAAAsD,WACA,IAAAA,EAAAO,OAEA,WADA7D,MAAA4D,WAGA,IAAAgE,GAAA5H,KAAA4H,OACA,IAAA5H,KAAA+b,OAAA/b,KAAA8lG,WAAA,CACAxiG,EAAAjC,KAAAW,EACA,IAAA2D,GAAA6B,EAAAO,SAAA/H,KAAAooC,SAAApmC,EAAA4F,EACA,IAAAjC,IAAA8B,EAAAO,YACA1E,EAAA7C,MAAAgH,EAAAO,YAAAC,OAEA,IAAAjI,KAAA+K,UAGA,CACA,GAAAQ,IAA6BrJ,WAAAlC,KAAA2F,SAAA3D,QAAA4F,QAC7B5H,MAAAc,IAAAd,KAAA+K,UAAAU,SAAAsyJ,EAAAzyJ,SAAA,EAAAC,QAJAvL,MAAAg+J,sBAAAr4J,EAAA3D,EAAA4F,OAQA5H,MAAA4oD,OAAAxgD,KAAApG,IAGA+7J,EAAA59J,UAAA69J,sBAAA,SAAAr4J,EAAA3D,EAAA4F,GACA5H,KAAA+b,SACA/b,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA2F,EAAA3D,EAAA4F,KAEAm2J,EAAA59J,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA5kG,KAAA4kG,cAAA,IAAA5kG,KAAA+b,QACA/b,KAAAsD,YAAA5C,YAGAq9J,EAAA59J,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA0D,MAAAyB,IAEA44J,EAAA59J,UAAAqF,eAAA,SAAAF,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA6H,OAAAvC,GACAtF,KAAA+b,SACA6sC,KAAAvlD,OAAA,GACArD,KAAA0D,MAAAklD,EAAAvW,SAEAryC,KAAA4kG,cAAA,IAAA5kG,KAAA+b,QACA/b,KAAAsD,YAAA5C,YAGAq9J,GACC/3D,EAAAjhG,gBACDtF,GAAAs+J,oBvR+2wCM,SAAUv+J,EAAQC,EAASC,GAEjC,YwRt/wCA,SAAAopJ,GAAAj2I,GACA,MAAA7S,MAAAI,KAAA,GAAA69J,GAAAprJ,IAhBA,GAAAzQ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAmD,EAAAnD,EAAA,EAYAD,GAAAqpJ,UACA,IAAAmV,GAAA,WACA,QAAAA,GAAAprJ,GACA7S,KAAA6S,WAKA,MAHAorJ,GAAA99J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAm+J,GAAAh8J,EAAAlC,KAAA6S,YAEAorJ,KAOAC,EAAA,SAAAj7J,GAEA,QAAAi7J,GAAA56J,EAAAuP,GACA5P,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAc,IAAA,GAAA+B,GAAAqB,aAAA2O,IAEA,MALAzQ,GAAA87J,EAAAj7J,GAKAi7J,GACCp5J,EAAA9B,axR4gxCK,SAAUxD,EAAQC,EAASC,GAEjC,YyRnhxCA,SAAAupJ,GAAAvQ,EAAAnxC,GACA,MAAAvnG,MAAAI,KAAA,GAAA2oJ,GAAAlQ,kBAAAH,EAAA14I,MAAA,EAAAunG,IApCA,GAAAwhD,GAAArpJ,EAAA,GAsCAD,GAAAwpJ,azR6jxCM,SAAUzpJ,EAAQC,EAASC,GAEjC,Y0R7ixCA,SAAAqhC,GAAA23G,EAAAQ,EAAA8hB,GACA,MAAAh7J,MAAAI,KAAA,GAAA+9J,GAAAzlB,EAAAQ,EAAA8hB,EAAAh7J,OAzDA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAiqG,EAAAjqG,EAAA,GAqDAD,GAAAshC,OACA,IAAAo9H,GAAA,WACA,QAAAA,GAAAzlB,EAAAQ,EAAA8hB,EAAAz6J,GACAP,KAAA04I,YACA14I,KAAAk5I,iBACAl5I,KAAAg7J,eACAh7J,KAAAO,SAKA,MAHA49J,GAAAh+J,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAAq+J,GAAAn9D,EAAAjhG,KAAA04I,UAAA14I,KAAAk5I,eAAAl5I,KAAAg7J,aAAAh7J,KAAAO,UAEA49J,KAOAC,EAAA,SAAAn7J,GAEA,QAAAm7J,GAAA96J,EAAAo1I,EAAAQ,EAAA8hB,EAAAz6J,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAk5I,iBACAl5I,KAAAg7J,eACAh7J,KAAAO,SACAP,KAAA4H,MAAA,EACA5H,KAAA4kG,cAAA,EACA5kG,KAAAq+J,UAAA,EA6DA,MAtEAj8J,GAAAg8J,EAAAn7J,GAWAm7J,EAAAj+J,UAAAuD,MAAA,SAAA1B,GACA,GAAA4F,GAAA5H,KAAA4H,OACA5H,MAAA04I,UACA14I,KAAAq6J,cAAAr4J,EAAA4F,GAGA5H,KAAAs+J,MAAAt8J,EAAA4F,IAGAw2J,EAAAj+J,UAAAk6J,cAAA,SAAAr4J,EAAA4F,GACA,GAAAjC,EACA,KACAA,EAAA3F,KAAA04I,UAAA12I,EAAA4F,EAAA5H,KAAAO,QAEA,MAAAY,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAwE,GACA3F,KAAAs+J,MAAAt8J,EAAA4F,IAGAw2J,EAAAj+J,UAAAm+J,MAAA,SAAAt8J,EAAA4F,GACA,GAAA5H,KAAAk5I,eAEA,WADAl5I,MAAAu+J,mBAAAv8J,EAAA4F,EAGA5H,MAAAw+J,WAAAx8J,IAEAo8J,EAAAj+J,UAAAo+J,mBAAA,SAAAv8J,EAAA4F,GACA,GAAAjC,EACA,KACAA,EAAA3F,KAAAk5I,eAAAl3I,EAAA4F,GAEA,MAAAzG,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAw+J,WAAA74J,IAEAy4J,EAAAj+J,UAAAq+J,WAAA,SAAAx8J,GACA,GAAAsB,GAAAtD,KAAAsD,WACAtD,MAAAq+J,WACAr+J,KAAAq+J,UAAA,EACA/6J,EAAAjC,KAAAW,GACAsB,EAAA5C,WACAV,KAAA4kG,cAAA,IAGAw5D,EAAAj+J,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,WACAtD,MAAA4kG,kBAAA,KAAA5kG,KAAAg7J,aAIAh7J,KAAA4kG,cACAthG,EAAA7C,MAAA,GAAAkpG,GAAApD,aAJAjjG,EAAAjC,KAAArB,KAAAg7J,cACA13J,EAAA5C,aAMA09J,GACCt5J,EAAA9B,a1R4mxCK,SAAUxD,EAAQC,EAASC,GAEjC,Y2RprxCA,SAAA0pJ,GAAA9Q,EAAAmmB,EAAA/jB,EAAAgkB,GACA,MAAA1+J,MAAAI,KAAA,GAAAu+J,GAAArmB,EAAAmmB,EAAA/jB,EAAAgkB,IAhFA,GAAAt8J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAmD,EAAAnD,EAAA,GACAoG,EAAApG,EAAA,GACA+kG,EAAA/kG,EAAA,GACAqjG,EAAArjG,EAAA,KACAk/J,EAAAl/J,EAAA,IAwEAD,GAAA2pJ,SACA,IAAAuV,GAAA,WACA,QAAAA,GAAArmB,EAAAmmB,EAAA/jB,EAAAgkB,GACA1+J,KAAAs4I,cACAt4I,KAAAy+J,kBACAz+J,KAAA06I,mBACA16I,KAAA0+J,kBAKA,MAHAC,GAAAx+J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA8+J,GAAA38J,EAAAlC,KAAAs4I,YAAAt4I,KAAAy+J,gBAAAz+J,KAAA06I,iBAAA16I,KAAA0+J,mBAEAC,KAOAE,EAAA,SAAA57J,GAEA,QAAA47J,GAAAv7J,EAAAg1I,EAAAmmB,EAAA/jB,EAAAgkB,GACAz7J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAs4I,cACAt4I,KAAAy+J,kBACAz+J,KAAA06I,mBACA16I,KAAA0+J,kBACA1+J,KAAAgb,OAAA,KACAhb,KAAA8+J,wBAAA,EACA9+J,KAAAwL,MAAA,EAmFA,MA5FApJ,GAAAy8J,EAAA57J,GAWA47J,EAAA1+J,UAAAuD,MAAA,SAAA1B,GACA,GAAAuU,EACA,KACAA,EAAAvW,KAAAs4I,YAAAt2I,GAEA,MAAAb,GAEA,WADAnB,MAAAS,MAAAU,GAGAnB,KAAA++J,OAAA/8J,EAAAuU,IAEAsoJ,EAAA1+J,UAAA4+J,OAAA,SAAA/8J,EAAAuU,GACA,GAAAyE,GAAAhb,KAAAgb,MACAA,KACAA,EAAAhb,KAAAgb,OAAA,gBAAAzE,GAAA,GAAAqoJ,GAAAI,QAAA,GAAAj8D,GAAAzwE,IAEA,IACAskC,GADA1iD,EAAA8G,EAAAtI,IAAA6D,EAEA,IAAAvW,KAAAy+J,gBACA,IACA7nG,EAAA52D,KAAAy+J,gBAAAz8J,GAEA,MAAAb,GACAnB,KAAAS,MAAAU,OAIAy1D,GAAA50D,CAEA,KAAAkS,EAAA,CACAA,EAAAlU,KAAA0+J,gBAAA1+J,KAAA0+J,kBAAA,GAAAj6D,GAAAz7F,QACAgS,EAAApI,IAAA2D,EAAArC,EACA,IAAA+qJ,GAAA,GAAAC,GAAA3oJ,EAAArC,EAAAlU,KAEA,IADAA,KAAAsD,YAAAjC,KAAA49J,GACAj/J,KAAA06I,iBAAA,CACA,GAAAzzH,OAAA,EACA,KACAA,EAAAjnB,KAAA06I,iBAAA,GAAAwkB,GAAA3oJ,EAAArC,IAEA,MAAA/S,GAEA,WADAnB,MAAAS,MAAAU,GAGAnB,KAAAc,IAAAmmB,EAAAlnB,UAAA,GAAAo/J,GAAA5oJ,EAAArC,EAAAlU,SAGAkU,EAAArQ,QACAqQ,EAAA7S,KAAAu1D,IAGAioG,EAAA1+J,UAAAwD,OAAA,SAAAxC,GACA,GAAA6Z,GAAAhb,KAAAgb,MACAA,KACAA,EAAA5Z,QAAA,SAAA8S,EAAAqC,GACArC,EAAAzT,MAAAU,KAEA6Z,EAAAwzD,SAEAxuE,KAAAsD,YAAA7C,MAAAU,IAEA09J,EAAA1+J,UAAAyD,UAAA,WACA,GAAAoX,GAAAhb,KAAAgb,MACAA,KACAA,EAAA5Z,QAAA,SAAA8S,EAAAqC,GACArC,EAAAxT,aAEAsa,EAAAwzD,SAEAxuE,KAAAsD,YAAA5C,YAEAm+J,EAAA1+J,UAAAi/J,YAAA,SAAA7oJ,GACAvW,KAAAgb,OAAA6vH,OAAAt0H,IAEAsoJ,EAAA1+J,UAAA8B,YAAA,WACAjC,KAAA6D,SACA7D,KAAA8+J,wBAAA,EACA,IAAA9+J,KAAAwL,OACAvI,EAAA9C,UAAA8B,YAAApB,KAAAb,QAIA6+J,GACC/5J,EAAA9B,YAMDm8J,EAAA,SAAAl8J,GAEA,QAAAk8J,GAAA5oJ,EAAArC,EAAAtP,GACA3B,EAAApC,KAAAb,KAAAkU,GACAlU,KAAAuW,MACAvW,KAAAkU,QACAlU,KAAA4E,SAYA,MAjBAxC,GAAA+8J,EAAAl8J,GAOAk8J,EAAAh/J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAU,YAEAy+J,EAAAh/J,UAAA0E,aAAA,WACA,GAAAd,GAAA/D,KAAA4E,EAAAb,EAAAa,OAAA2R,EAAAxS,EAAAwS,GACAvW,MAAAuW,IAAAvW,KAAA4E,OAAA,KACAA,GACAA,EAAAw6J,YAAA7oJ,IAGA4oJ,GACCr6J,EAAA9B,YASDk8J,EAAA,SAAAj8J,GAEA,QAAAi8J,GAAA3oJ,EAAA8oJ,EAAAC,GACAr8J,EAAApC,KAAAb,MACAA,KAAAuW,MACAvW,KAAAq/J,eACAr/J,KAAAs/J,uBAWA,MAhBAl9J,GAAA88J,EAAAj8J,GAOAi8J,EAAA/+J,UAAAD,WAAA,SAAAgC,GACA,GAAAH,GAAA,GAAAc,GAAAqB,aACAH,EAAA/D,KAAAs/J,EAAAv7J,EAAAu7J,qBAAAD,EAAAt7J,EAAAs7J,YAKA,OAJAC,OAAAz7J,QACA9B,EAAAjB,IAAA,GAAAy+J,GAAAD,IAEAv9J,EAAAjB,IAAAu+J,EAAAt/J,UAAAmC,IACAH,GAEAm9J,GACCp5J,EAAAhG,WACDL,GAAAy/J,mBAMA,IAAAK,GAAA,SAAAt8J,GAEA,QAAAs8J,GAAA36J,GACA3B,EAAApC,KAAAb,MACAA,KAAA4E,SACAA,EAAA4G,QAYA,MAhBApJ,GAAAm9J,EAAAt8J,GAMAs8J,EAAAp/J,UAAA8B,YAAA,WACA,GAAA2C,GAAA5E,KAAA4E,MACAA,GAAAf,QAAA7D,KAAA6D,SACAZ,EAAA9C,UAAA8B,YAAApB,KAAAb,MACA4E,EAAA4G,OAAA,EACA,IAAA5G,EAAA4G,OAAA5G,EAAAk6J,wBACAl6J,EAAA3C,gBAIAs9J,GACC18J,EAAAqB,e3R0wxCK,SAAU1E,EAAQC,EAASC,GAEjC,Y4R1gyCA,SAAA4pJ,KACA,MAAAtpJ,MAAAI,KAAA,GAAAo/J,IAlBA,GAAAp9J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAk0J,EAAAl0J,EAAA,GAcAD,GAAA6pJ,gBAEA,IAAAkW,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAr/J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA0/J,GAAAv9J,KAEAs9J,KAOAC,EAAA,SAAAx8J,GAEA,QAAAw8J,KACAx8J,EAAA+B,MAAAhF,KAAAoD,WAKA,MAPAhB,GAAAq9J,EAAAx8J,GAIAw8J,EAAAt/J,UAAAuD,MAAA,SAAAwjG,GACA0sD,EAAA9gJ,QAEA2sJ,GACC36J,EAAA9B,a5RkiyCK,SAAUxD,EAAQC,EAASC,GAEjC,Y6RjkyCA,SAAA8pJ,KACA,MAAAxpJ,MAAAI,KAAA,GAAAs/J,IAhBA,GAAAt9J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAaAD,GAAA+pJ,SACA,IAAAkW,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAv/J,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAA4/J,GAAA1+D,KAEAy+D,KAOAC,EAAA,SAAA18J,GAEA,QAAA08J,GAAAr8J,GACAL,EAAApC,KAAAb,KAAAsD,GAaA,MAfAlB,GAAAu9J,EAAA18J,GAIA08J,EAAAx/J,UAAAqF,eAAA,SAAAgkJ,GACA,GAAAlmJ,GAAAtD,KAAAsD,WACAA,GAAAjC,KAAAmoJ,GACAlmJ,EAAA5C,YAEAi/J,EAAAx/J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAwF,gBAAA,IAEAm6J,EAAAx/J,UAAAyD,UAAA,WACA5D,KAAAwF,gBAAA,IAEAm6J,GACC76J,EAAA9B,a7RulyCK,SAAUxD,EAAQC,EAASC,GAEjC,Y8RjnyCA,SAAAg2G,GAAAgjC,EAAAQ,EAAA8hB,GACA,MAAAh7J,MAAAI,KAAA,GAAAw/J,GAAAlnB,EAAAQ,EAAA8hB,EAAAh7J,OA1BA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAiqG,EAAAjqG,EAAA,GAsBAD,GAAAi2G,MACA,IAAAkqD,GAAA,WACA,QAAAA,GAAAlnB,EAAAQ,EAAA8hB,EAAAz6J,GACAP,KAAA04I,YACA14I,KAAAk5I,iBACAl5I,KAAAg7J,eACAh7J,KAAAO,SAKA,MAHAq/J,GAAAz/J,UAAAU,KAAA,SAAAogG,EAAA1gG,GACA,MAAAA,GAAAR,UAAA,GAAA8/J,GAAA5+D,EAAAjhG,KAAA04I,UAAA14I,KAAAk5I,eAAAl5I,KAAAg7J,aAAAh7J,KAAAO,UAEAq/J,KAOAC,EAAA,SAAA58J,GAEA,QAAA48J,GAAAv8J,EAAAo1I,EAAAQ,EAAA8hB,EAAAz6J,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAk5I,iBACAl5I,KAAAg7J,eACAh7J,KAAAO,SACAP,KAAA+gG,UAAA,EACA/gG,KAAA4H,MAAA,MACA,KAAAozJ,IACAh7J,KAAA86J,UAAAE,EACAh7J,KAAA+gG,UAAA,GAyDA,MApEA3+F,GAAAy9J,EAAA58J,GAcA48J,EAAA1/J,UAAAuD,MAAA,SAAA1B,GACA,GAAA4F,GAAA5H,KAAA4H,OACA,IAAA5H,KAAA04I,UACA14I,KAAAq6J,cAAAr4J,EAAA4F,OAEA,CACA,GAAA5H,KAAAk5I,eAEA,WADAl5I,MAAAu+J,mBAAAv8J,EAAA4F,EAGA5H,MAAA86J,UAAA94J,EACAhC,KAAA+gG,UAAA,IAGA8+D,EAAA1/J,UAAAk6J,cAAA,SAAAr4J,EAAA4F,GACA,GAAAjC,EACA,KACAA,EAAA3F,KAAA04I,UAAA12I,EAAA4F,EAAA5H,KAAAO,QAEA,MAAAY,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGA,GAAAwE,EAAA,CACA,GAAA3F,KAAAk5I,eAEA,WADAl5I,MAAAu+J,mBAAAv8J,EAAA4F,EAGA5H,MAAA86J,UAAA94J,EACAhC,KAAA+gG,UAAA,IAGA8+D,EAAA1/J,UAAAo+J,mBAAA,SAAAv8J,EAAA4F,GACA,GAAAjC,EACA,KACAA,EAAA3F,KAAAk5I,eAAAl3I,EAAA4F,GAEA,MAAAzG,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAA86J,UAAAn1J,EACA3F,KAAA+gG,UAAA,GAEA8+D,EAAA1/J,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,WACAtD,MAAA+gG,UACAz9F,EAAAjC,KAAArB,KAAA86J,WACAx3J,EAAA5C,YAGA4C,EAAA7C,MAAA,GAAAkpG,GAAApD,aAGAs5D,GACC/6J,EAAA9B,a9RipyCK,SAAUxD,EAAQC,EAASC,GAEjC,Y+RjwyCA,SAAAkqJ,GAAAoG,GACA,MAAAA,GAAAhwJ,MAEAP,EAAAmqJ,Y/R8wyCM,SAAUpqJ,EAAQC,EAASC,GAEjC,YgSzvyCA,SAAAqqJ,GAAA/nJ,GACA,MAAAhC,MAAAI,KAAA,GAAA0/J,GAAA99J,IAjCA,GAAAI,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EA8BAD,GAAAsqJ,OACA,IAAA+V,GAAA,WACA,QAAAA,GAAA99J,GACAhC,KAAAgC,QAKA,MAHA89J,GAAA3/J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAggK,GAAA79J,EAAAlC,KAAAgC,SAEA89J,KAOAC,EAAA,SAAA98J,GAEA,QAAA88J,GAAAz8J,EAAAtB,GACAiB,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAgC,QAKA,MARAI,GAAA29J,EAAA98J,GAKA88J,EAAA5/J,UAAAuD,MAAA,SAAAiI,GACA3L,KAAAsD,YAAAjC,KAAArB,KAAAgC,QAEA+9J,GACCj7J,EAAA9B,ahSgyyCK,SAAUxD,EAAQC,EAASC,GAEjC,YiS3yyCA,SAAAuqJ,KACA,MAAAjqJ,MAAAI,KAAA,GAAA4/J,IApDA,GAAA59J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkoG,EAAAloG,EAAA,GAgDAD,GAAAwqJ,aACA,IAAA+V,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAA7/J,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAkgK,GAAA/9J,KAEA89J,KAOAC,EAAA,SAAAh9J,GAEA,QAAAg9J,GAAA38J,GACAL,EAAApC,KAAAb,KAAAsD,GAeA,MAjBAlB,GAAA69J,EAAAh9J,GAIAg9J,EAAA9/J,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAsD,YAAAjC,KAAAumG,EAAA/G,aAAAU,WAAAv/F,KAEAi+J,EAAA9/J,UAAAwD,OAAA,SAAAxC,GACA,GAAAmC,GAAAtD,KAAAsD,WACAA,GAAAjC,KAAAumG,EAAA/G,aAAAY,YAAAtgG,IACAmC,EAAA5C,YAEAu/J,EAAA9/J,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,WACAA,GAAAjC,KAAAumG,EAAA/G,aAAAa,kBACAp+F,EAAA5C,YAEAu/J,GACCn7J,EAAA9B,ajSq2yCK,SAAUxD,EAAQC,EAASC,GAEjC,YkS95yCA,SAAAsN,GAAAkzJ,GACA,GAAAlzJ,GAAA,kBAAAkzJ,GACA,SAAAv0J,EAAAoC,GAA2B,MAAAmyJ,GAAAv0J,EAAAoC,GAAA,EAAApC,EAAAoC,GAC3B,SAAApC,EAAAoC,GAA2B,MAAApC,GAAAoC,EAAApC,EAAAoC,EAC3B,OAAA/N,MAAAI,KAAA,GAAAorJ,GAAArjD,eAAAn7F,IApCA,GAAAw+I,GAAA9rJ,EAAA,GAsCAD,GAAAuN,OlSq8yCM,SAAUxN,EAAQC,EAASC,GAEjC,YmSr8yCA,SAAA8qJ,GAAAxiD,EAAAC,EAAAnC,GAEA,WADA,KAAAA,IAAgCA,EAAAZ,OAAAC,mBAChCnlG,KAAAI,KAAA,GAAA+/J,GAAAn4D,EAAAC,EAAAnC,IA1CA,GAAA1jG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAiF,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAumG,EAAAvmG,EAAA,GACAsmG,EAAAtmG,EAAA,EAoCAD,GAAA+qJ,WACA,IAAA2V,GAAA,WACA,QAAAA,GAAAn4D,EAAAC,EAAAnC,GACA9lG,KAAAgoG,cACAhoG,KAAAioG,OACAjoG,KAAA8lG,aAKA,MAHAq6D,GAAAhgK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAqgK,GAAAl+J,EAAAlC,KAAAgoG,YAAAhoG,KAAAioG,KAAAjoG,KAAA8lG,cAEAq6D,IAEA1gK,GAAA0gK,mBAMA,IAAAC,GAAA,SAAAn9J,GAEA,QAAAm9J,GAAA98J,EAAA0kG,EAAAK,EAAAvC,GACA7iG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAgoG,cACAhoG,KAAAqoG,MACAroG,KAAA8lG,aACA9lG,KAAA+gG,UAAA,EACA/gG,KAAA4kG,cAAA,EACA5kG,KAAA4oD,UACA5oD,KAAA+b,OAAA,EACA/b,KAAA4H,MAAA,EAmDA,MA7DAxF,GAAAg+J,EAAAn9J,GAYAm9J,EAAAjgK,UAAAuD,MAAA,SAAA1B,GACA,GAAAhC,KAAA+b,OAAA/b,KAAA8lG,WAAA,CACA,GAAAl+F,GAAA5H,KAAA4H,QACA+tI,EAAAnuI,EAAAO,SAAA/H,KAAAgoG,aAAAhoG,KAAAqoG,IAAArmG,GACAsB,EAAAtD,KAAAsD,WACAqyI,KAAAluI,EAAAO,YACA1E,EAAA7C,MAAAgH,EAAAO,YAAAC,IAGAjI,KAAA+b,SACA/b,KAAAs5I,UAAA3D,EAAA3zI,EAAA4F,QAIA5H,MAAA4oD,OAAAxgD,KAAApG,IAGAo+J,EAAAjgK,UAAAm5I,UAAA,SAAA3D,EAAA3zI,EAAA4F,GACA5H,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA21I,EAAA3zI,EAAA4F,KAEAw4J,EAAAjgK,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA,IAAA5kG,KAAA+b,QAAA,IAAA/b,KAAA4oD,OAAAvlD,UACA,IAAArD,KAAA+gG,UACA/gG,KAAAsD,YAAAjC,KAAArB,KAAAqoG,KAEAroG,KAAAsD,YAAA5C,aAGA0/J,EAAAjgK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAhC,GAAAtD,KAAAsD,WACAtD,MAAAqoG,IAAAljG,EACAnF,KAAA+gG,UAAA,EACAz9F,EAAAjC,KAAA8D,IAEAi7J,EAAAjgK,UAAAqF,eAAA,SAAAF,GACA,GAAAsjD,GAAA5oD,KAAA4oD,MACA5oD,MAAA6H,OAAAvC,GACAtF,KAAA+b,SACA6sC,EAAAvlD,OAAA,EACArD,KAAA0D,MAAAklD,EAAAvW,SAEA,IAAAryC,KAAA+b,QAAA/b,KAAA4kG,gBACA,IAAA5kG,KAAA+gG,UACA/gG,KAAAsD,YAAAjC,KAAArB,KAAAqoG,KAEAroG,KAAAsD,YAAA5C,aAGA0/J,GACCp6D,EAAAjhG,gBACDtF,GAAA2gK,uBnSo/yCM,SAAU5gK,EAAQC,EAASC,GAEjC,YoSplzCA,SAAA4e,GAAA4hJ,GACA,GAAA5hJ,GAAA,kBAAA4hJ,GACA,SAAAv0J,EAAAoC,GAA2B,MAAAmyJ,GAAAv0J,EAAAoC,GAAA,EAAApC,EAAAoC,GAC3B,SAAApC,EAAAoC,GAA2B,MAAApC,GAAAoC,EAAApC,EAAAoC,EAC3B,OAAA/N,MAAAI,KAAA,GAAAorJ,GAAArjD,eAAA7pF,IApCA,GAAAktI,GAAA9rJ,EAAA,GAsCAD,GAAA6e,OpS2nzCM,SAAU9e,EAAQC,EAASC,GAEjC,YqS1nzCA,SAAAkrJ,KACA,MAAA5qJ,MAAAI,KAAA,GAAAigK,IA1CA,GAAAj+J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAuCAD,GAAAmrJ,UACA,IAAAyV,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAlgK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAugK,GAAAp+J,KAEAm+J,KAOAC,EAAA,SAAAr9J,GAEA,QAAAq9J,GAAAh9J,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAugK,SAAA,EAWA,MAdAn+J,GAAAk+J,EAAAr9J,GAKAq9J,EAAAngK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAugK,QACAvgK,KAAAsD,YAAAjC,MAAArB,KAAAmqH,KAAAnoH,IAGAhC,KAAAugK,SAAA,EAEAvgK,KAAAmqH,KAAAnoH,GAEAs+J,GACCx7J,EAAA9B,arS0qzCK,SAAUxD,EAAQC,EAASC,GAEjC,YsS3szCA,SAAA6+E,GAAAm6D,EAAAnxC,GACA,OACAohD,EAAAr3I,OAAAzQ,KAAAb,KAAA04I,EAAAnxC,GACAohD,EAAAr3I,OAAAzQ,KAAAb,KAAAwgK,EAAAC,IAAA/nB,EAAAnxC,KA9CA,GAAAi5D,GAAA9gK,EAAA,KACAipJ,EAAAjpJ,EAAA,GAgDAD,GAAA8+E,atS6vzCM,SAAU/+E,EAAQC,EAASC,GAEjC,YuSrxzCA,SAAAqrJ,KAEA,OADA2V,MACAz1J,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3Cy1J,EAAAz1J,EAAA,GAAA7H,UAAA6H,EAEA,IAAA5H,GAAAq9J,EAAAr9J,MACA,QAAAA,EACA,SAAAzB,OAAA,sCAEA,OAAAk1I,GAAAvkI,IAAA1R,KAAAb,KAAA2gK,EAAAD,EAAAr9J,IAGA,QAAAs9J,GAAA5vD,EAAA1tG,GAcA,MAbA,UAAAsI,GAEA,OADAi1J,GAAAj1J,EACA1F,EAAA,EAAuBA,EAAA5C,EAAY4C,IAAA,CACnC,GAAAxD,GAAAm+J,EAAA7vD,EAAA9qG,GACA,aAAAxD,EAIA,MAHAm+J,GAAAn+J,EAMA,MAAAm+J,IAnDA,GAAA9pB,GAAAp3I,EAAA,GAsCAD,GAAAsrJ,SvSu0zCM,SAAUvrJ,EAAQC,EAASC,GAEjC,YwS/1zCA,SAAAurJ,GAAAl/I,GACA,MAAAA,GAAA2+I,EAAA7+I,UAAAhL,KAAAb,KAAA,WAAoE,UAAAykG,GAAAz7F,SAAkC+C,GACtG2+I,EAAA7+I,UAAAhL,KAAAb,KAAA,GAAAykG,GAAAz7F,SAlBA,GAAAy7F,GAAA/kG,EAAA,GACAgrJ,EAAAhrJ,EAAA,GAmBAD,GAAAwrJ,WxSs3zCM,SAAUzrJ,EAAQC,EAASC,GAEjC,YySp4zCA,SAAAyrJ,GAAAnpJ,GACA,MAAA0oJ,GAAA7+I,UAAAhL,KAAAb,KAAA,GAAAwpG,GAAAC,gBAAAznG,IATA,GAAAwnG,GAAA9pG,EAAA,IACAgrJ,EAAAhrJ,EAAA,GAUAD,GAAA0rJ,mBzSm5zCM,SAAU3rJ,EAAQC,EAASC,GAEjC,Y0Sz5zCA,SAAA2rJ,KACA,MAAAX,GAAA7+I,UAAAhL,KAAAb,KAAA,GAAAspG,GAAA5E,cARA,GAAA4E,GAAA5pG,EAAA,IACAgrJ,EAAAhrJ,EAAA,GASAD,GAAA4rJ,e1Su6zCM,SAAU7rJ,EAAQC,EAASC,GAEjC,Y2Sz6zCA,SAAA6rJ,GAAAvmD,EAAAC,EAAAl6F,GAGA,WAFA,KAAAi6F,IAAgCA,EAAAE,OAAAC,uBAChC,KAAAF,IAAgCA,EAAAC,OAAAC,mBAChCulD,EAAA7+I,UAAAhL,KAAAb,KAAA,GAAAupG,GAAAxE,cAAAC,EAAAC,EAAAl6F,IAbA,GAAAw+F,GAAA7pG,EAAA,IACAgrJ,EAAAhrJ,EAAA,GAcAD,GAAA8rJ,iB3S07zCM,SAAU/rJ,EAAQC,EAASC,GAEjC,Y4Sx7zCA,SAAAgsJ,GAAAlgJ,GAEA,WADA,KAAAA,IAA2BA,GAAA,GAC3B,IAAAA,EACA,GAAAb,GAAAU,gBAEAG,EAAA,EACAxL,KAAAI,KAAA,GAAAygK,IAAA,EAAA7gK,OAGAA,KAAAI,KAAA,GAAAygK,GAAAr1J,EAAA,EAAAxL,OA5BA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAiL,EAAAjL,EAAA,GAyBAD,GAAAisJ,QACA,IAAAmV,GAAA,WACA,QAAAA,GAAAr1J,EAAAjL,GACAP,KAAAwL,QACAxL,KAAAO,SAKA,MAHAsgK,GAAA1gK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA+gK,GAAA5+J,EAAAlC,KAAAwL,MAAAxL,KAAAO,UAEAsgK,KAOAC,EAAA,SAAA79J,GAEA,QAAA69J,GAAAx9J,EAAAkI,EAAAjL,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAwL,QACAxL,KAAAO,SAcA,MAlBA6B,GAAA0+J,EAAA79J,GAMA69J,EAAA3gK,UAAAO,SAAA,WACA,IAAAV,KAAAmD,UAAA,CACA,GAAAY,GAAA/D,KAAAO,EAAAwD,EAAAxD,OAAAiL,EAAAzH,EAAAyH,KACA,QAAAA,EACA,MAAAvI,GAAA9C,UAAAO,SAAAG,KAAAb,KAEAwL,IAAA,IACAxL,KAAAwL,QAAA,GAEAjL,EAAAR,UAAAC,KAAA8D,4BAGAg9J,GACCh8J,EAAA9B,a5Sk9zCK,SAAUxD,EAAQC,EAASC,GAEjC,Y6S//zCA,SAAAksJ,GAAAmV,GACA,MAAA/gK,MAAAI,KAAA,GAAA4gK,GAAAD,IAzBA,GAAA3+J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAkBAD,GAAAmsJ,YACA,IAAAoV,GAAA,WACA,QAAAA,GAAAD,GACA/gK,KAAA+gK,WAKA,MAHAC,GAAA7gK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAkhK,GAAA/+J,EAAAlC,KAAA+gK,SAAAxgK,KAEAygK,KAOAC,EAAA,SAAAh+J,GAEA,QAAAg+J,GAAA39J,EAAAy9J,EAAAxgK,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+gK,WACA/gK,KAAAO,SACAP,KAAAkhK,2BAAA,EAwDA,MA7DA9+J,GAAA6+J,EAAAh+J,GAOAg+J,EAAA9gK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAkhK,2BAAA,EACAlhK,KAAAO,OAAAR,UAAAC,OAEAihK,EAAA9gK,UAAAqF,eAAA,SAAAF,GACA,QAAAtF,KAAAkhK,0BACA,MAAAj+J,GAAA9C,UAAAO,SAAAG,KAAAb,OAGAihK,EAAA9gK,UAAAO,SAAA,WAEA,GADAV,KAAAkhK,2BAAA,GACAlhK,KAAAmD,UAAA,CACA,GAAAnD,KAAAmhK,SAGA,GAAAnhK,KAAAohK,oBAAAv9J,OACA,MAAAZ,GAAA9C,UAAAO,SAAAG,KAAAb,UAHAA,MAAAqhK,oBAKArhK,MAAA8D,yBACA9D,KAAAshK,cAAAjgK,SAGA4/J,EAAA9gK,UAAA0E,aAAA,WACA,GAAAd,GAAA/D,KAAAshK,EAAAv9J,EAAAu9J,cAAAF,EAAAr9J,EAAAq9J,mBACAE,KACAA,EAAAr/J,cACAjC,KAAAshK,cAAA,MAEAF,IACAA,EAAAn/J,cACAjC,KAAAohK,oBAAA,MAEAphK,KAAAmhK,QAAA,MAEAF,EAAA9gK,UAAA2D,uBAAA,WACA,GAAAC,GAAA/D,KAAAshK,EAAAv9J,EAAAu9J,cAAAH,EAAAp9J,EAAAo9J,QAAAC,EAAAr9J,EAAAq9J,mBAQA,OAPAphK,MAAAshK,cAAA,KACAthK,KAAAmhK,QAAA,KACAnhK,KAAAohK,oBAAA,KACAn+J,EAAA9C,UAAA2D,uBAAAjD,KAAAb,MACAA,KAAAshK,gBACAthK,KAAAmhK,UACAnhK,KAAAohK,sBACAphK,MAEAihK,EAAA9gK,UAAAkhK,mBAAA,WACArhK,KAAAshK,cAAA,GAAA78D,GAAAz7F,OACA,IAAAm4J,GAAA35J,EAAAO,SAAA/H,KAAA+gK,UAAA/gK,KAAAshK,cACA,IAAAH,IAAA15J,EAAAO,YACA,MAAA/E,GAAA9C,UAAAO,SAAAG,KAAAb,KAEAA,MAAAmhK,UACAnhK,KAAAohK,oBAAAn7D,EAAAxgG,kBAAAzF,KAAAmhK,IAEAF,GACCj7D,EAAAjhG,kB7S8h0CK,SAAUvF,EAAQC,EAASC,GAEjC,Y8Snn0CA,SAAAosJ,GAAAtgJ,GAEA,WADA,KAAAA,IAA2BA,GAAA,GAC3BxL,KAAAI,KAAA,GAAAmhK,GAAA/1J,EAAAxL,OAxBA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAqBAD,GAAAqsJ,OACA,IAAAyV,GAAA,WACA,QAAAA,GAAA/1J,EAAAjL,GACAP,KAAAwL,QACAxL,KAAAO,SAKA,MAHAghK,GAAAphK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAyhK,GAAAt/J,EAAAlC,KAAAwL,MAAAxL,KAAAO,UAEAghK,KAOAC,EAAA,SAAAv+J,GAEA,QAAAu+J,GAAAl+J,EAAAkI,EAAAjL,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAwL,QACAxL,KAAAO,SAcA,MAlBA6B,GAAAo/J,EAAAv+J,GAMAu+J,EAAArhK,UAAAM,MAAA,SAAAU,GACA,IAAAnB,KAAAmD,UAAA,CACA,GAAAY,GAAA/D,KAAAO,EAAAwD,EAAAxD,OAAAiL,EAAAzH,EAAAyH,KACA,QAAAA,EACA,MAAAvI,GAAA9C,UAAAM,MAAAI,KAAAb,KAAAmB,EAEAqK,IAAA,IACAxL,KAAAwL,QAAA,GAEAjL,EAAAR,UAAAC,KAAA8D,4BAGA09J,GACC18J,EAAA9B,a9Sgp0CK,SAAUxD,EAAQC,EAASC,GAEjC,Y+Sxr0CA,SAAAssJ,GAAA+U,GACA,MAAA/gK,MAAAI,KAAA,GAAAqhK,GAAAV,EAAA/gK,OAzBA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAkBAD,GAAAusJ,WACA,IAAAyV,GAAA,WACA,QAAAA,GAAAV,EAAAxgK,GACAP,KAAA+gK,WACA/gK,KAAAO,SAKA,MAHAkhK,GAAAthK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA2hK,GAAAx/J,EAAAlC,KAAA+gK,SAAA/gK,KAAAO,UAEAkhK,KAOAC,EAAA,SAAAz+J,GAEA,QAAAy+J,GAAAp+J,EAAAy9J,EAAAxgK,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+gK,WACA/gK,KAAAO,SAiDA,MArDA6B,GAAAs/J,EAAAz+J,GAMAy+J,EAAAvhK,UAAAM,MAAA,SAAAU,GACA,IAAAnB,KAAAmD,UAAA,CACA,GAAA8D,GAAAjH,KAAAiH,OACAk6J,EAAAnhK,KAAAmhK,QACAC,EAAAphK,KAAAohK,mBACA,IAAAD,EASAnhK,KAAAiH,OAAA,KACAjH,KAAAohK,oBAAA,SAVA,CAGA,GAFAn6J,EAAA,GAAAw9F,GAAAz7F,SACAm4J,EAAA35J,EAAAO,SAAA/H,KAAA+gK,UAAA95J,MACAQ,EAAAO,YACA,MAAA/E,GAAA9C,UAAAM,MAAAI,KAAAb,KAAAyH,EAAAO,YAAAC,EAEAm5J,GAAAn7D,EAAAxgG,kBAAAzF,KAAAmhK,GAMAnhK,KAAA8D,yBACA9D,KAAAiH,SACAjH,KAAAmhK,UACAnhK,KAAAohK,sBACAn6J,EAAA5F,KAAAF,KAGAugK,EAAAvhK,UAAA0E,aAAA,WACA,GAAAd,GAAA/D,KAAAiH,EAAAlD,EAAAkD,OAAAm6J,EAAAr9J,EAAAq9J,mBACAn6J,KACAA,EAAAhF,cACAjC,KAAAiH,OAAA,MAEAm6J,IACAA,EAAAn/J,cACAjC,KAAAohK,oBAAA,MAEAphK,KAAAmhK,QAAA,MAEAO,EAAAvhK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAvB,GAAA/D,KAAAiH,EAAAlD,EAAAkD,OAAAk6J,EAAAp9J,EAAAo9J,QAAAC,EAAAr9J,EAAAq9J,mBACAphK,MAAAiH,OAAA,KACAjH,KAAAmhK,QAAA,KACAnhK,KAAAohK,oBAAA,KACAphK,KAAA8D,yBACA9D,KAAAiH,SACAjH,KAAAmhK,UACAnhK,KAAAohK,sBACAphK,KAAAO,OAAAR,UAAAC,OAEA0hK,GACC17D,EAAAjhG,kB/Sut0CK,SAAUvF,EAAQC,EAASC,GAEjC,YgTlx0CA,SAAAwsJ,GAAA6U,GACA,MAAA/gK,MAAAI,KAAA,GAAAuhK,GAAAZ,IA1CA,GAAA3+J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAsCAD,GAAAysJ,QACA,IAAAyV,GAAA,WACA,QAAAA,GAAAZ,GACA/gK,KAAA+gK,WAQA,MANAY,GAAAxhK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,GAAAqhK,GAAA,GAAAC,GAAA3/J,GACAH,EAAAxB,EAAAR,UAAA6hK,EAEA,OADA7/J,GAAAjB,IAAAmlG,EAAAxgG,kBAAAm8J,EAAA5hK,KAAA+gK,WACAh/J,GAEA4/J,KAOAE,EAAA,SAAA5+J,GAEA,QAAA4+J,KACA5+J,EAAA+B,MAAAhF,KAAAoD,WACApD,KAAA+gG,UAAA,EAkBA,MArBA3+F,GAAAy/J,EAAA5+J,GAKA4+J,EAAA1hK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAgC,QACAhC,KAAA+gG,UAAA,GAEA8gE,EAAA1hK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAy6J,aAEAoH,EAAA1hK,UAAAqF,eAAA,WACAxF,KAAAy6J,aAEAoH,EAAA1hK,UAAAs6J,UAAA,WACAz6J,KAAA+gG,WACA/gG,KAAA+gG,UAAA,EACA/gG,KAAAsD,YAAAjC,KAAArB,KAAAgC,SAGA6/J,GACC77D,EAAAjhG,kBhTk00CK,SAAUvF,EAAQC,EAASC,GAEjC,YiT920CA,SAAA0sJ,GAAAjhF,EAAApgE,GAEA,WADA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,OAC/BvK,KAAAI,KAAA,GAAA0hK,GAAA32F,EAAApgE,IAuCA,QAAAg3J,GAAAx2J,GACA,GAAArJ,GAAAqJ,EAAArJ,WAAAipE,EAAA5/D,EAAA4/D,MACAjpE,GAAA+C,aACAjF,KAAAyL,SAAAF,EAAA4/D,GAvFA,GAAA/oE,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkrG,EAAAlrG,EAAA,EAyCAD,GAAA2sJ,YACA,IAAA0V,GAAA,WACA,QAAAA,GAAA32F,EAAApgE,GACA/K,KAAAmrE,SACAnrE,KAAA+K,YAKA,MAHA+2J,GAAA3hK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAiiK,GAAA9/J,EAAAlC,KAAAmrE,OAAAnrE,KAAA+K,aAEA+2J,KAOAE,EAAA,SAAA/+J,GAEA,QAAA++J,GAAA1+J,EAAA6nE,EAAApgE,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAmrE,SACAnrE,KAAA+K,YACA/K,KAAA+gG,UAAA,EACA/gG,KAAAc,IAAAiK,EAAAU,SAAAs2J,EAAA52F,GAAmEjpE,WAAAlC,KAAAmrE,YAYnE,MAlBA/oE,GAAA4/J,EAAA/+J,GAQA++J,EAAA7hK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA86J,UAAA94J,EACAhC,KAAA+gG,UAAA,GAEAihE,EAAA7hK,UAAA8E,WAAA,WACAjF,KAAA+gG,WACA/gG,KAAA+gG,UAAA,EACA/gG,KAAAsD,YAAAjC,KAAArB,KAAA86J,aAGAkH,GACCl9J,EAAA9B,ajTq60CK,SAAUxD,EAAQC,EAASC,GAEjC,YkT980CA,SAAAk2D,GAAAoyC,EAAAC,GACA,GAAAC,IAAA,CASA,OAHA9kG,WAAAC,QAAA,IACA6kG,GAAA,GAEAloG,KAAAI,KAAA,GAAA6hK,GAAAj6D,EAAAC,EAAAC,IAtDA,GAAA9lG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAmDAD,GAAAm2D,MACA,IAAAqsG,GAAA,WACA,QAAAA,GAAAj6D,EAAAC,EAAAC,OACA,KAAAA,IAAiCA,GAAA,GACjCloG,KAAAgoG,cACAhoG,KAAAioG,OACAjoG,KAAAkoG,UAKA,MAHA+5D,GAAA9hK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAmiK,GAAAhgK,EAAAlC,KAAAgoG,YAAAhoG,KAAAioG,KAAAjoG,KAAAkoG,WAEA+5D,KAOAC,EAAA,SAAAj/J,GAEA,QAAAi/J,GAAA5+J,EAAA0kG,EAAAm6D,EAAAj6D,GACAjlG,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAgoG,cACAhoG,KAAAmiK,QACAniK,KAAAkoG,UACAloG,KAAA4H,MAAA,EAkCA,MAxCAxF,GAAA8/J,EAAAj/J,GAQAN,OAAAi+F,eAAAshE,EAAA/hK,UAAA,QACAuS,IAAA,WACA,MAAA1S,MAAAmiK,OAEAvvJ,IAAA,SAAA5Q,GACAhC,KAAAkoG,SAAA,EACAloG,KAAAmiK,MAAAngK,GAEAurG,YAAA,EACAE,cAAA,IAEAy0D,EAAA/hK,UAAAuD,MAAA,SAAA1B,GACA,GAAAhC,KAAAkoG,QAKA,MAAAloG,MAAAq5I,SAAAr3I,EAJAhC,MAAAioG,KAAAjmG,EACAhC,KAAAsD,YAAAjC,KAAAW,IAMAkgK,EAAA/hK,UAAAk5I,SAAA,SAAAr3I,GACA,GACA2D,GADAiC,EAAA5H,KAAA4H,OAEA,KACAjC,EAAA3F,KAAAgoG,YAAAhoG,KAAAioG,KAAAjmG,EAAA4F,GAEA,MAAAzG,GACAnB,KAAAsD,YAAA7C,MAAAU,GAEAnB,KAAAioG,KAAAtiG,EACA3F,KAAAsD,YAAAjC,KAAAsE,IAEAu8J,GACCp9J,EAAA9B,alTig1CK,SAAUxD,EAAQC,EAASC,GAEjC,YmT3j1CA,SAAA6sJ,GAAA6V,EAAAC,GACA,MAAAriK,MAAAI,KAAA,GAAAkiK,GAAAF,EAAAC,IA7DA,GAAAjgK,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,EAwDAD,GAAA8sJ,eACA,IAAA+V,GAAA,WACA,QAAAA,GAAAF,EAAAC,GACAriK,KAAAoiK,YACApiK,KAAAqiK,WAKA,MAHAC,GAAAniK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAwiK,GAAArgK,EAAAlC,KAAAoiK,UAAApiK,KAAAqiK,YAEAC,IAEA7iK,GAAA6iK,uBAMA,IAAAC,GAAA,SAAAt/J,GAEA,QAAAs/J,GAAAj/J,EAAA8+J,EAAAC,GACAp/J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAoiK,YACApiK,KAAAqiK,WACAriK,KAAA+D,MACA/D,KAAA8pI,MACA9pI,KAAAwiK,cAAA,EACAxiK,KAAAc,IAAAshK,EAAAriK,UAAA,GAAA0iK,GAAAn/J,EAAAtD,QAqDA,MA7DAoC,GAAAmgK,EAAAt/J,GAUAs/J,EAAApiK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAwiK,cAAA,IAAAxiK,KAAA8pI,GAAAzmI,OACArD,KAAA+vB,MAAA,IAGA/vB,KAAA+D,GAAAqE,KAAApG,GACAhC,KAAA0iK,gBAGAH,EAAApiK,UAAAyD,UAAA,WACA5D,KAAAwiK,aACAxiK,KAAA+vB,KAAA,IAAA/vB,KAAA+D,GAAAV,QAAA,IAAArD,KAAA8pI,GAAAzmI,QAGArD,KAAAwiK,cAAA,GAGAD,EAAApiK,UAAAuiK,YAAA,WAEA,IADA,GAAApgD,GAAAtiH,KAAA+D,EAAAu+G,EAAAv+G,GAAA+lI,EAAAxnB,EAAAwnB,GAAAu4B,EAAA//C,EAAA+/C,SACAt+J,EAAAV,OAAA,GAAAymI,EAAAzmI,OAAA,IACA,GAAAqJ,GAAA3I,EAAAsuC,QACA/vC,EAAAwnI,EAAAz3F,QACAswH,GAAA,CACAN,IACAM,EAAAn7J,EAAAO,SAAAs6J,GAAA31J,EAAApK,MACAmF,EAAAO,aACAhI,KAAAsD,YAAA7C,MAAAgH,EAAAO,YAAAC,GAIA06J,EAAAj2J,IAAApK,EAEAqgK,GACA3iK,KAAA+vB,MAAA,KAIAwyI,EAAApiK,UAAA4vB,KAAA,SAAA/tB,GACA,GAAAsB,GAAAtD,KAAAsD,WACAA,GAAAjC,KAAAW,GACAsB,EAAA5C,YAEA6hK,EAAApiK,UAAAyiK,MAAA,SAAA5gK,GACAhC,KAAAwiK,cAAA,IAAAxiK,KAAA+D,GAAAV,OACArD,KAAA+vB,MAAA,IAGA/vB,KAAA8pI,GAAA1hI,KAAApG,GACAhC,KAAA0iK,gBAGAH,GACCz9J,EAAA9B,WACDvD,GAAA8iK,yBACA,IAAAE,GAAA,SAAAx/J,GAEA,QAAAw/J,GAAAn/J,EAAAsB,GACA3B,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4E,SAWA,MAdAxC,GAAAqgK,EAAAx/J,GAKAw/J,EAAAtiK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA4E,OAAAg+J,MAAA5gK,IAEAygK,EAAAtiK,UAAAwD,OAAA,SAAAxC,GACAnB,KAAA4E,OAAAnE,MAAAU,IAEAshK,EAAAtiK,UAAAyD,UAAA,WACA5D,KAAA4E,OAAAhB,aAEA6+J,GACC39J,EAAA9B,anT8n1CK,SAAUxD,EAAQC,EAASC,GAEjC,YoT/x1CA,SAAAmjK,KACA,UAAAp+D,GAAAz7F,QAcA,QAAAm3I,KACA,MAAAuK,GAAA7+I,UAAAhL,KAAAb,KAAA6iK,GAAA5tB,WAlBA,GAAAyV,GAAAhrJ,EAAA,IACA+kG,EAAA/kG,EAAA,EAmBAD,GAAA0gJ,SpTyy1CM,SAAU3gJ,EAAQC,EAASC,GAEjC,YqTzz1CA,SAAAgtJ,GAAA1nD,EAAAC,EAAAl6F,GACA,GAAA3B,EASA,OARAshJ,GAAA7+I,UAAAhL,KAAAb,KAAA,WACA,MAAAA,MAAA00I,YACAtrI,EAGAA,EAAA,GAAAmgG,GAAAxE,cAAAC,EAAAC,EAAAl6F,KAGAkqI,WAhBA,GAAAyV,GAAAhrJ,EAAA,IACA6pG,EAAA7pG,EAAA,GAiBAD,GAAAitJ,erTu01CM,SAAUltJ,EAAQC,EAASC,GAEjC,YsTp01CA,SAAAktJ,GAAAlU,GACA,MAAA14I,MAAAI,KAAA,GAAA0iK,GAAApqB,EAAA14I,OAxBA,GAAAoC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAiqG,EAAAjqG,EAAA,GAoBAD,GAAAmtJ,QACA,IAAAkW,GAAA,WACA,QAAAA,GAAApqB,EAAAn4I,GACAP,KAAA04I,YACA14I,KAAAO,SAKA,MAHAuiK,GAAA3iK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAgjK,GAAA7gK,EAAAlC,KAAA04I,UAAA14I,KAAAO,UAEAuiK,KAOAC,EAAA,SAAA9/J,GAEA,QAAA8/J,GAAAz/J,EAAAo1I,EAAAn4I,GACA0C,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAO,SACAP,KAAAgjK,WAAA,EACAhjK,KAAA4H,MAAA,EAwCA,MA9CAxF,GAAA2gK,EAAA9/J,GAQA8/J,EAAA5iK,UAAA8iK,iBAAA,SAAAjhK,GACAhC,KAAAgjK,UACAhjK,KAAAsD,YAAA7C,MAAA,4CAGAT,KAAAgjK,WAAA,EACAhjK,KAAAkjK,YAAAlhK,IAGA+gK,EAAA5iK,UAAAuD,MAAA,SAAA1B,GACA,GAAA4F,GAAA5H,KAAA4H,OACA5H,MAAA04I,UACA14I,KAAA69J,QAAA77J,EAAA4F,GAGA5H,KAAAijK,iBAAAjhK,IAGA+gK,EAAA5iK,UAAA09J,QAAA,SAAA77J,EAAA4F,GACA,IACA5H,KAAA04I,UAAA12I,EAAA4F,EAAA5H,KAAAO,SACAP,KAAAijK,iBAAAjhK,GAGA,MAAAb,GACAnB,KAAAsD,YAAA7C,MAAAU,KAGA4hK,EAAA5iK,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,WACAtD,MAAA4H,MAAA,GACAtE,EAAAjC,KAAArB,KAAAgjK,UAAAhjK,KAAAkjK,gBAAAluI,IACA1xB,EAAA5C,YAGA4C,EAAA7C,MAAA,GAAAkpG,GAAApD,aAGAw8D,GACCj+J,EAAA9B,atTk21CK,SAAUxD,EAAQC,EAASC,GAEjC,YuT761CA,SAAAotJ,GAAAthJ,GACA,MAAAxL,MAAAI,KAAA,GAAA+iK,GAAA33J,IAlBA,GAAApJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAeAD,GAAAqtJ,MACA,IAAAqW,GAAA,WACA,QAAAA,GAAAt6F,GACA7oE,KAAA6oE,QAKA,MAHAs6F,GAAAhjK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAqjK,GAAAlhK,EAAAlC,KAAA6oE,SAEAs6F,KAOAC,EAAA,SAAAngK,GAEA,QAAAmgK,GAAA9/J,EAAAulE,GACA5lE,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6oE,QACA7oE,KAAAwL,MAAA,EAOA,MAXApJ,GAAAghK,EAAAngK,GAMAmgK,EAAAjjK,UAAAuD,MAAA,SAAAiI,KACA3L,KAAAwL,MAAAxL,KAAA6oE,OACA7oE,KAAAsD,YAAAjC,KAAAsK,IAGAy3J,GACCt+J,EAAA9B,avTq81CK,SAAUxD,EAAQC,EAASC,GAEjC,YwTh91CA,SAAAstJ,GAAAxhJ,GACA,MAAAxL,MAAAI,KAAA,GAAAijK,GAAA73J,IAxCA,GAAApJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkqG,EAAAlqG,EAAA,GAoCAD,GAAAutJ,UACA,IAAAqW,GAAA,WACA,QAAAA,GAAAC,GAEA,GADAtjK,KAAAsjK,aACAtjK,KAAAsjK,WAAA,EACA,SAAA15D,GAAA1G,wBAaA,MAVAmgE,GAAAljK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,WAAAP,KAAAsjK,WAGA/iK,EAAAR,UAAA,GAAA+E,GAAA9B,WAAAd,IAGA3B,EAAAR,UAAA,GAAAwjK,GAAArhK,EAAAlC,KAAAsjK,cAGAD,KAOAE,EAAA,SAAAtgK,GAEA,QAAAsgK,GAAAjgK,EAAAggK,GACArgK,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsjK,aACAtjK,KAAAg0J,OAAA,EACAh0J,KAAAwjK,MAAA,GAAA93J,OAAA43J,GAgBA,MArBAlhK,GAAAmhK,EAAAtgK,GAOAsgK,EAAApjK,UAAAuD,MAAA,SAAA1B,GACA,GAAAyhK,GAAAzjK,KAAAsjK,WACA93J,EAAAxL,KAAAg0J,QACA,IAAAxoJ,EAAAi4J,EACAzjK,KAAAwjK,MAAAh4J,GAAAxJ,MAEA,CACA,GAAA0hK,GAAAl4J,EAAAi4J,EACAljI,EAAAvgC,KAAAwjK,MACAn7C,EAAA9nF,EAAAmjI,EACAnjI,GAAAmjI,GAAA1hK,EACAhC,KAAAsD,YAAAjC,KAAAgnH,KAGAk7C,GACCz+J,EAAA9B,axT8/1CK,SAAUxD,EAAQC,EAASC,GAEjC,YyTvk2CA,SAAAwtJ,GAAA6T,GACA,MAAA/gK,MAAAI,KAAA,GAAAujK,GAAA5C,IApBA,GAAA3+J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAgBAD,GAAAytJ,WACA,IAAAyW,GAAA,WACA,QAAAA,GAAA5C,GACA/gK,KAAA+gK,WAKA,MAHA4C,GAAAxjK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA6jK,GAAA1hK,EAAAlC,KAAA+gK,YAEA4C,KAOAC,EAAA,SAAA3gK,GAEA,QAAA2gK,GAAAtgK,EAAAy9J,GACA99J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+gG,UAAA,EACA/gG,KAAA6jK,gBAAA,EACA7jK,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA+gK,IAwBA,MA7BA3+J,GAAAwhK,EAAA3gK,GAOA2gK,EAAAzjK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA+gG,UACA99F,EAAA9C,UAAAuD,MAAA7C,KAAAb,KAAAgC,IAGA4hK,EAAAzjK,UAAAyD,UAAA,WACA5D,KAAA6jK,eACA5gK,EAAA9C,UAAAyD,UAAA/C,KAAAb,MAGAA,KAAAiC,eAGA2hK,EAAAzjK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA+gG,UAAA,GAEA6iE,EAAAzjK,UAAAqF,eAAA,WACAxF,KAAA6jK,gBAAA,EACA7jK,KAAAmD,WACAF,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAGA4jK,GACC59D,EAAAjhG,kBzTim2CK,SAAUvF,EAAQC,EAASC,GAEjC,Y0Trp2CA,SAAA0tJ,GAAA1U,GACA,MAAA14I,MAAAI,KAAA,GAAA0jK,GAAAprB,IAnBA,GAAAt2I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAgBAD,GAAA2tJ,WACA,IAAA0W,GAAA,WACA,QAAAA,GAAAprB,GACA14I,KAAA04I,YAKA,MAHAorB,GAAA3jK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAgkK,GAAA7hK,EAAAlC,KAAA04I,aAEAorB,KAOAC,EAAA,SAAA9gK,GAEA,QAAA8gK,GAAAzgK,EAAAo1I,GACAz1I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAAgkK,UAAA,EACAhkK,KAAA4H,MAAA,EAoBA,MAzBAxF,GAAA2hK,EAAA9gK,GAOA8gK,EAAA5jK,UAAAuD,MAAA,SAAA1B,GACA,GAAAsB,GAAAtD,KAAAsD,WACAtD,MAAAgkK,UACAhkK,KAAAikK,iBAAAjiK,GAEAhC,KAAAgkK,UACA1gK,EAAAjC,KAAAW,IAGA+hK,EAAA5jK,UAAA8jK,iBAAA,SAAAjiK,GACA,IACA,GAAA2D,GAAA3F,KAAA04I,UAAA12I,EAAAhC,KAAA4H,QACA5H,MAAAgkK,SAAArxD,QAAAhtG,GAEA,MAAAxE,GACAnB,KAAAsD,YAAA7C,MAAAU,KAGA4iK,GACCj/J,EAAA9B,a1T8q2CK,SAAUxD,EAAQC,EAASC,GAEjC,Y2T3t2CA,SAAA4tJ,KAEA,OADAxiJ,MACAG,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3CH,EAAAG,EAAA,GAAA7H,UAAA6H,EAEA,IAAAF,GAAAD,IAAAzH,OAAA,EACAuH,GAAAM,YAAAH,GACAD,EAAAK,MAGAJ,EAAA,IAEA,IAAA7E,GAAA4E,EAAAzH,MACA,YAAA6C,EACAs9I,EAAAn8C,aAAA,GAAA38F,GAAAU,iBAAAN,EAAA,GAAAC,GAAA/K,MAEAkG,EAAA,EACAs9I,EAAAn8C,aAAA,GAAAP,GAAAj8F,gBAAAC,EAAAC,GAAA/K,MAGAwjJ,EAAAn8C,aAAA,GAAA18F,GAAAU,gBAAAN,GAAA/K,MAxCA,GAAA8mG,GAAApnG,EAAA,IACAgL,EAAAhL,EAAA,IACAiL,EAAAjL,EAAA,IACA8jJ,EAAA9jJ,EAAA,IACAkL,EAAAlL,EAAA,GAuCAD,GAAA6tJ,a3Tsv2CM,SAAU9tJ,EAAQC,EAASC,GAEjC,Y4Tvx2CA,SAAA8tJ,GAAAziJ,EAAAia,GAEA,WADA,KAAAA,IAA2BA,EAAA,GAC3BhlB,KAAAI,KAAA,GAAA8jK,GAAAn5J,EAAAia,IAdA,GAAAm/I,GAAAzkK,EAAA,IAgBAD,GAAA+tJ,aACA,IAAA0W,GAAA,WACA,QAAAA,GAAAn5J,EAAAia,GACAhlB,KAAA+K,YACA/K,KAAAglB,QAKA,MAHAk/I,GAAA/jK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,UAAA4jK,GAAAlQ,sBAAA1zJ,EAAAP,KAAAglB,MAAAhlB,KAAA+K,WAAAhL,UAAAmC,IAEAgiK,M5T2y2CM,SAAU1kK,EAAQC,EAASC,GAEjC,Y6Trx2CA,SAAAiuJ,KACA,MAAA3tJ,MAAAI,KAAA,GAAAgkK,IAlDA,GAAAhiK,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA8CAD,GAAAkuJ,SACA,IAAAyW,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAjkK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAskK,GAAAniK,KAEAkiK,KAOAC,EAAA,SAAAphK,GAEA,QAAAohK,GAAA/gK,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+b,OAAA,EACA/b,KAAA4kG,cAAA,EAiCA,MArCAxiG,GAAAiiK,EAAAphK,GAMAohK,EAAAlkK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAskK,mBACAtkK,KAAA+b,SACA/b,KAAAc,IAAAd,KAAAixJ,kBAAAhrD,EAAAxgG,kBAAAzF,KAAAgC,KAEAqiK,EAAAlkK,UAAAyD,UAAA,WACA5D,KAAA4kG,cAAA,EACA,IAAA5kG,KAAA+b,QACA/b,KAAAsD,YAAA5C,YAGA2jK,EAAAlkK,UAAAmkK,iBAAA,WACAtkK,KAAA+b,OAAA/b,KAAA+b,OAAA,EAAA/b,KAAA+b,OAAA,GACA,IAAAk1I,GAAAjxJ,KAAAixJ,iBACAA,KACAA,EAAAhvJ,cACAjC,KAAA6H,OAAAopJ,KAGAoT,EAAAlkK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAsD,YAAAjC,KAAA8D,IAEAk/J,EAAAlkK,UAAAoF,YAAA,SAAApE,GACAnB,KAAAsD,YAAA7C,MAAAU,IAEAkjK,EAAAlkK,UAAAqF,eAAA,WACAxF,KAAAskK,mBACAtkK,KAAA4kG,cAAA,IAAA5kG,KAAA+b,QACA/b,KAAAsD,YAAA5C,YAGA2jK,GACCr+D,EAAAjhG,kB7T602CK,SAAUvF,EAAQC,EAASC,GAEjC,Y8Tj42CA,SAAAmuJ,GAAAzlH,EAAA8wG,GACA,MAAAl5I,MAAAI,KAAA,GAAAmkK,GAAAn8H,EAAA8wG,IAxDA,GAAA92I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAoDAD,GAAAouJ,WACA,IAAA0W,GAAA,WACA,QAAAA,GAAAn8H,EAAA8wG,GACAl5I,KAAAooC,UACApoC,KAAAk5I,iBAKA,MAHAqrB,GAAApkK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAykK,GAAAtiK,EAAAlC,KAAAooC,QAAApoC,KAAAk5I,kBAEAqrB,KAOAC,EAAA,SAAAvhK,GAEA,QAAAuhK,GAAAlhK,EAAA8kC,EAAA8wG,GACAj2I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAooC,UACApoC,KAAAk5I,iBACAl5I,KAAA4H,MAAA,EAwDA,MA7DAxF,GAAAoiK,EAAAvhK,GAOAuhK,EAAArkK,UAAAuD,MAAA,SAAA1B,GACA,GAAA2D,GACAiC,EAAA5H,KAAA4H,OACA,KACAjC,EAAA3F,KAAAooC,QAAApmC,EAAA4F,GAEA,MAAAnH,GAEA,WADAT,MAAAsD,YAAA7C,SAGAT,KAAAs5I,UAAA3zI,EAAA3D,EAAA4F,IAEA48J,EAAArkK,UAAAm5I,UAAA,SAAA3zI,EAAA3D,EAAA4F,GACA,GAAAqpJ,GAAAjxJ,KAAAixJ,iBACAA,IACAA,EAAAhvJ,cAEAjC,KAAAc,IAAAd,KAAAixJ,kBAAAhrD,EAAAxgG,kBAAAzF,KAAA2F,EAAA3D,EAAA4F,KAEA48J,EAAArkK,UAAAyD,UAAA,WACA,GAAAqtJ,GAAAjxJ,KAAAixJ,iBACAA,OAAAptJ,QACAZ,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAGAwkK,EAAArkK,UAAA0E,aAAA,WACA7E,KAAAixJ,kBAAA,MAEAuT,EAAArkK,UAAAqF,eAAA,SAAAF,GACAtF,KAAA6H,OAAAvC,GACAtF,KAAAixJ,kBAAA,KACAjxJ,KAAAmD,WACAF,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAGAwkK,EAAArkK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAk5I,eACAl5I,KAAAykK,eAAAv/J,EAAAC,EAAAC,EAAAC,GAGArF,KAAAsD,YAAAjC,KAAA8D,IAGAq/J,EAAArkK,UAAAskK,eAAA,SAAAv/J,EAAAC,EAAAC,EAAAC,GACA,GAAAM,EACA,KACAA,EAAA3F,KAAAk5I,eAAAh0I,EAAAC,EAAAC,EAAAC,GAEA,MAAAlE,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEA6+J,GACCx+D,EAAAjhG,kB9T+72CK,SAAUvF,EAAQC,EAASC,GAEjC,Y+Txh3CA,SAAAquJ,GAAAtU,EAAAP,GACA,MAAAl5I,MAAAI,KAAA,GAAAskK,GAAAjrB,EAAAP,IAnDA,GAAA92I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA+CAD,GAAAsuJ,aACA,IAAA2W,GAAA,WACA,QAAAA,GAAApkK,EAAA44I,GACAl5I,KAAAM,aACAN,KAAAk5I,iBAKA,MAHAwrB,GAAAvkK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA4kK,GAAAziK,EAAAlC,KAAAM,WAAAN,KAAAk5I,kBAEAwrB,KAOAC,EAAA,SAAA1hK,GAEA,QAAA0hK,GAAArhK,EAAAshK,EAAA1rB,GACAj2I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA4kK,QACA5kK,KAAAk5I,iBACAl5I,KAAA4H,MAAA,EA8CA,MAnDAxF,GAAAuiK,EAAA1hK,GAOA0hK,EAAAxkK,UAAAuD,MAAA,SAAA1B,GACA,GAAAivJ,GAAAjxJ,KAAAixJ,iBACAA,IACAA,EAAAhvJ,cAEAjC,KAAAc,IAAAd,KAAAixJ,kBAAAhrD,EAAAxgG,kBAAAzF,UAAA4kK,MAAA5iK,EAAAhC,KAAA4H,WAEA+8J,EAAAxkK,UAAAyD,UAAA,WACA,GAAAqtJ,GAAAjxJ,KAAAixJ,iBACAA,OAAAptJ,QACAZ,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAGA2kK,EAAAxkK,UAAA0E,aAAA,WACA7E,KAAAixJ,kBAAA,MAEA0T,EAAAxkK,UAAAqF,eAAA,SAAAF,GACAtF,KAAA6H,OAAAvC,GACAtF,KAAAixJ,kBAAA,KACAjxJ,KAAAmD,WACAF,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAGA2kK,EAAAxkK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAvB,GAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WACA41I,GACAl5I,KAAA6kK,kBAAA3/J,EAAAC,EAAAC,EAAAC,GAGA/B,EAAAjC,KAAA8D,IAGAw/J,EAAAxkK,UAAA0kK,kBAAA,SAAA3/J,EAAAC,EAAAC,EAAAC,GACA,GACAM,GADA5B,EAAA/D,KAAAk5I,EAAAn1I,EAAAm1I,eAAA51I,EAAAS,EAAAT,WAEA,KACAqC,EAAAuzI,EAAAh0I,EAAAC,EAAAC,EAAAC,GAEA,MAAAlE,GAEA,WADAmC,GAAA7C,MAAAU,GAGAmC,EAAAjC,KAAAsE,IAEAg/J,GACC3+D,EAAAjhG,kB/Til3CK,SAAUvF,EAAQC,EAASC,GAEjC,YgUpq3CA,SAAAuuJ,GAAAziJ,GACA,WAAAA,EACA,GAAAb,GAAAU,gBAGArL,KAAAI,KAAA,GAAA0kK,GAAAt5J,IA9CA,GAAApJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkqG,EAAAlqG,EAAA,IACAiL,EAAAjL,EAAA,GA0CAD,GAAAwuJ,MACA,IAAA6W,GAAA,WACA,QAAAA,GAAAj8F,GAEA,GADA7oE,KAAA6oE,QACA7oE,KAAA6oE,MAAA,EACA,SAAA+gC,GAAA1G,wBAMA,MAHA4hE,GAAA3kK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAglK,GAAA7iK,EAAAlC,KAAA6oE,SAEAi8F,KAOAC,EAAA,SAAA9hK,GAEA,QAAA8hK,GAAAzhK,EAAAulE,GACA5lE,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6oE,QACA7oE,KAAAwL,MAAA,EAaA,MAjBApJ,GAAA2iK,EAAA9hK,GAMA8hK,EAAA5kK,UAAAuD,MAAA,SAAA1B,GACA,GAAA6mE,GAAA7oE,KAAA6oE,MACAr9D,IAAAxL,KAAAwL,KACAA,IAAAq9D,IACA7oE,KAAAsD,YAAAjC,KAAAW,GACAwJ,IAAAq9D,IACA7oE,KAAAsD,YAAA5C,WACAV,KAAAiC,iBAIA8iK,GACCjgK,EAAA9B,ahUot3CK,SAAUxD,EAAQC,EAASC,GAEjC,YiUhw3CA,SAAAyuJ,GAAA3iJ,GACA,WAAAA,EACA,GAAAb,GAAAU,gBAGArL,KAAAI,KAAA,GAAA4kK,GAAAx5J,IAjDA,GAAApJ,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkqG,EAAAlqG,EAAA,IACAiL,EAAAjL,EAAA,GA6CAD,GAAA0uJ,UACA,IAAA6W,GAAA,WACA,QAAAA,GAAAn8F,GAEA,GADA7oE,KAAA6oE,QACA7oE,KAAA6oE,MAAA,EACA,SAAA+gC,GAAA1G,wBAMA,MAHA8hE,GAAA7kK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAklK,GAAA/iK,EAAAlC,KAAA6oE,SAEAm8F,KAOAC,EAAA,SAAAhiK,GAEA,QAAAgiK,GAAA3hK,EAAAulE,GACA5lE,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6oE,QACA7oE,KAAAugC,KAAA,GAAA70B,OACA1L,KAAAwL,MAAA,EA2BA,MAhCApJ,GAAA6iK,EAAAhiK,GAOAgiK,EAAA9kK,UAAAuD,MAAA,SAAA1B,GACA,GAAAu+B,GAAAvgC,KAAAugC,KACAsoC,EAAA7oE,KAAA6oE,MACAr9D,EAAAxL,KAAAwL,OACA,IAAA+0B,EAAAl9B,OAAAwlE,EACAtoC,EAAAn4B,KAAApG,OAEA,CAEAu+B,EADA/0B,EAAAq9D,GACA7mE,IAGAijK,EAAA9kK,UAAAyD,UAAA,WACA,GAAAN,GAAAtD,KAAAsD,YACAkI,EAAAxL,KAAAwL,KACA,IAAAA,EAAA,EAGA,OAFAq9D,GAAA7oE,KAAAwL,OAAAxL,KAAA6oE,MAAA7oE,KAAA6oE,MAAA7oE,KAAAwL,MACA+0B,EAAAvgC,KAAAugC,KACAt6B,EAAA,EAA2BA,EAAA4iE,EAAW5iE,IAAA,CACtC,GAAAsmH,GAAA/gH,IAAAq9D,CACAvlE,GAAAjC,KAAAk/B,EAAAgsF,IAGAjpH,EAAA5C,YAEAukK,GACCngK,EAAA9B,ajUmz3CK,SAAUxD,EAAQC,EAASC,GAEjC,YkUr33CA,SAAA2uJ,GAAA0S,GACA,MAAA/gK,MAAAI,KAAA,GAAA8kK,GAAAnE,IAzCA,GAAA3+J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAqCAD,GAAA4uJ,WACA,IAAA6W,GAAA,WACA,QAAAA,GAAAnE,GACA/gK,KAAA+gK,WAKA,MAHAmE,GAAA/kK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAolK,GAAAjjK,EAAAlC,KAAA+gK,YAEAmE,KAOAC,EAAA,SAAAliK,GAEA,QAAAkiK,GAAA7hK,EAAAy9J,GACA99J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA+gK,WACA/gK,KAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAA+gK,IAQA,MAZA3+J,GAAA+iK,EAAAliK,GAMAkiK,EAAAhlK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAAU,YAEAykK,EAAAhlK,UAAAqF,eAAA,aAGA2/J,GACCn/D,EAAAjhG,kBlUo63CK,SAAUvF,EAAQC,EAASC,GAEjC,YmUp83CA,SAAA6uJ,GAAA7V,GACA,MAAA14I,MAAAI,KAAA,GAAAglK,GAAA1sB,IA3CA,GAAAt2I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EAwCAD,GAAA8uJ,WACA,IAAA6W,GAAA,WACA,QAAAA,GAAA1sB,GACA14I,KAAA04I,YAKA,MAHA0sB,GAAAjlK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAslK,GAAAnjK,EAAAlC,KAAA04I,aAEA0sB,KAOAC,EAAA,SAAApiK,GAEA,QAAAoiK,GAAA/hK,EAAAo1I,GACAz1I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA04I,YACA14I,KAAA4H,MAAA,EAuBA,MA3BAxF,GAAAijK,EAAApiK,GAMAoiK,EAAAllK,UAAAuD,MAAA,SAAA1B,GACA,GACA2D,GADArC,EAAAtD,KAAAsD,WAEA,KACAqC,EAAA3F,KAAA04I,UAAA12I,EAAAhC,KAAA4H,SAEA,MAAAzG,GAEA,WADAmC,GAAA7C,MAAAU,GAGAnB,KAAAslK,eAAAtjK,EAAA2D,IAEA0/J,EAAAllK,UAAAmlK,eAAA,SAAAtjK,EAAAujK,GACA,GAAAjiK,GAAAtD,KAAAsD,WACAqvG,SAAA4yD,GACAjiK,EAAAjC,KAAAW,GAGAsB,EAAA5C,YAGA2kK,GACCvgK,EAAA9B,anUq/3CK,SAAUxD,EAAQC,EAASC,GAEjC,YoUji4CA,SAAAgvJ,GAAAznI,EAAAlc,EAAArJ,GAGA,WAFA,KAAAqJ,IAA+BA,EAAA6/F,EAAArgG,WAC/B,KAAA7I,IAA4BA,EAAA8sJ,EAAA7T,uBAC5B36I,KAAAI,KAAA,GAAAolK,GAAAv+I,EAAAlc,EAAArJ,EAAAm5I,QAAAn5I,EAAAo5I,WA4DA,QAAA/E,GAAAnqI,GACAA,EAAA1J,WACAm1J,gBAhHA,GAAAj1J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACAkrG,EAAAlrG,EAAA,GACA8uJ,EAAA9uJ,EAAA,GA6CAD,GAAAivJ,cACA,IAAA8W,GAAA,WACA,QAAAA,GAAAv+I,EAAAlc,EAAA8vI,EAAAC,GACA96I,KAAAinB,WACAjnB,KAAA+K,YACA/K,KAAA66I,UACA76I,KAAA86I,WAKA,MAHA0qB,GAAArlK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA0lK,GAAAvjK,EAAAlC,KAAAinB,SAAAjnB,KAAA+K,UAAA/K,KAAA66I,QAAA76I,KAAA86I,YAEA0qB,KAOAC,EAAA,SAAAxiK,GAEA,QAAAwiK,GAAAniK,EAAA2jB,EAAAlc,EAAA8vI,EAAAC,GACA73I,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAinB,WACAjnB,KAAA+K,YACA/K,KAAA66I,UACA76I,KAAA86I,WACA96I,KAAAk7I,mBAAA,EACAl7I,KAAAo7I,eAAA,KA6BA,MArCAh5I,GAAAqjK,EAAAxiK,GAUAwiK,EAAAtlK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAAm7I,UACAn7I,KAAA86I,WACA96I,KAAAo7I,eAAAp5I,EACAhC,KAAAk7I,mBAAA,IAIAl7I,KAAAc,IAAAd,KAAAm7I,UAAAn7I,KAAA+K,UAAAU,SAAAsqI,EAAA/1I,KAAAinB,UAA4F/kB,WAAAlC,QAC5FA,KAAA66I,SACA76I,KAAAsD,YAAAjC,KAAAW,KAIAyjK,EAAAtlK,UAAAk3J,cAAA,WACA,GAAAlc,GAAAn7I,KAAAm7I,SACAA,KACAn7I,KAAA86I,UAAA96I,KAAAk7I,oBACAl7I,KAAAsD,YAAAjC,KAAArB,KAAAo7I,gBACAp7I,KAAAo7I,eAAA,KACAp7I,KAAAk7I,mBAAA,GAEAC,EAAAl5I,cACAjC,KAAA6H,OAAAszI,GACAn7I,KAAAm7I,UAAA,OAGAsqB,GACC3gK,EAAA9B,apU2l4CK,SAAUxD,EAAQC,EAASC,GAEjC,YqUho4CA,SAAA8lB,GAAAkgJ,EAAA36J,OACA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,MAC/B,IAAAo7J,GAAAxR,EAAA3tD,OAAAk/D,GACAE,EAAAD,GAAAD,EAAA36J,EAAAuZ,MAAAvX,KAAAY,IAAA+3J,EACA,OAAA1lK,MAAAI,KAAA,GAAAylK,GAAAD,EAAAD,EAAA56J,EAAA,GAAA8+F,GAAAC,eA9EA,GAAA1nG,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAqoG,EAAAlrG,EAAA,GACAy0J,EAAAz0J,EAAA,IACAoF,EAAApF,EAAA,GACAmqG,EAAAnqG,EAAA,GAwEAD,GAAA+lB,SACA,IAAAqgJ,GAAA,WACA,QAAAA,GAAAD,EAAAD,EAAA56J,EAAA+6J,GACA9lK,KAAA4lK,UACA5lK,KAAA2lK,kBACA3lK,KAAA+K,YACA/K,KAAA8lK,gBAKA,MAHAD,GAAA1lK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAgmK,GAAA7jK,EAAAlC,KAAA2lK,gBAAA3lK,KAAA4lK,QAAA5lK,KAAA+K,UAAA/K,KAAA8lK,iBAEAD,KAOAE,EAAA,SAAA9iK,GAEA,QAAA8iK,GAAAziK,EAAAqiK,EAAAC,EAAA76J,EAAA+6J,GACA7iK,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA2lK,kBACA3lK,KAAA4lK,UACA5lK,KAAA+K,YACA/K,KAAA8lK,gBACA9lK,KAAA0iG,OAAA,KACA1iG,KAAAgmK,kBA8BA,MAtCA5jK,GAAA2jK,EAAA9iK,GAUA8iK,EAAAE,gBAAA,SAAA/jK,GACAA,EAAAzB,MAAAyB,EAAA4jK,gBAEAC,EAAA5lK,UAAA6lK,gBAAA,WACA,GAAAtjE,GAAA1iG,KAAA0iG,MACAA,GAMA1iG,KAAA0iG,SAAAj3F,SAAAzL,UAAA4lK,SAGA5lK,KAAAc,IAAAd,KAAA0iG,OAAA1iG,KAAA+K,UAAAU,SAAAs6J,EAAAE,gBAAAjmK,KAAA4lK,QAAA5lK,QAGA+lK,EAAA5lK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA2lK,iBACA3lK,KAAAgmK,kBAEA/iK,EAAA9C,UAAAuD,MAAA7C,KAAAb,KAAAgC,IAEA+jK,EAAA5lK,UAAA0E,aAAA,WACA7E,KAAA0iG,OAAA,KACA1iG,KAAA+K,UAAA,KACA/K,KAAA8lK,cAAA,MAEAC,GACCjhK,EAAA9B,arUit4CK,SAAUxD,EAAQC,EAASC,GAEjC,YsU304CA,SAAAmvJ,GAAA6W,EAAAQ,EAAAn7J,OACA,KAAAA,IAA+BA,EAAA6/F,EAAArgG,MAC/B,IAAAo7J,GAAAxR,EAAA3tD,OAAAk/D,GACAE,EAAAD,GAAAD,EAAA36J,EAAAuZ,MAAAvX,KAAAY,IAAA+3J,EACA,OAAA1lK,MAAAI,KAAA,GAAA+lK,GAAAP,EAAAD,EAAAO,EAAAn7J,IAtBA,GAAA3I,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAqoG,EAAAlrG,EAAA,GACAy0J,EAAAz0J,EAAA,IACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAgBAD,GAAAovJ,aACA,IAAAsX,GAAA,WACA,QAAAA,GAAAP,EAAAD,EAAAO,EAAAn7J,GACA/K,KAAA4lK,UACA5lK,KAAA2lK,kBACA3lK,KAAAkmK,iBACAlmK,KAAA+K,YAKA,MAHAo7J,GAAAhmK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAqmK,GAAAlkK,EAAAlC,KAAA2lK,gBAAA3lK,KAAA4lK,QAAA5lK,KAAAkmK,eAAAlmK,KAAA+K,aAEAo7J,KAOAC,EAAA,SAAAnjK,GAEA,QAAAmjK,GAAA9iK,EAAAqiK,EAAAC,EAAAM,EAAAn7J,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA2lK,kBACA3lK,KAAA4lK,UACA5lK,KAAAkmK,iBACAlmK,KAAA+K,YACA/K,KAAA0iG,OAAA,KACA1iG,KAAAgmK,kBAgCA,MAxCA5jK,GAAAgkK,EAAAnjK,GAUAmjK,EAAAH,gBAAA,SAAA/jK,GACA,GAAAgkK,GAAAhkK,EAAAgkK,cACAhkK,GAAA4B,yBACA5B,EAAApB,IAAAmlG,EAAAxgG,kBAAAvD,EAAAgkK,KAEAE,EAAAjmK,UAAA6lK,gBAAA,WACA,GAAAtjE,GAAA1iG,KAAA0iG,MACAA,GAMA1iG,KAAA0iG,SAAAj3F,SAAAzL,UAAA4lK,SAGA5lK,KAAAc,IAAAd,KAAA0iG,OAAA1iG,KAAA+K,UAAAU,SAAA26J,EAAAH,gBAAAjmK,KAAA4lK,QAAA5lK,QAGAomK,EAAAjmK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA2lK,iBACA3lK,KAAAgmK,kBAEA/iK,EAAA9C,UAAAuD,MAAA7C,KAAAb,KAAAgC,IAEAokK,EAAAjmK,UAAA0E,aAAA,WACA7E,KAAA0iG,OAAA,KACA1iG,KAAA+K,UAAA,KACA/K,KAAAkmK,eAAA,MAEAE,GACCpgE,EAAAjhG,kBtUo24CK,SAAUvF,EAAQC,EAASC,GAEjC,YuU/64CA,SAAA4sG,KACA,MAAAtsG,MAAAI,KAAA,GAAAimK,IAZA,GAAAjkK,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,EASAD,GAAA6sG,SACA,IAAA+5D,GAAA,WACA,QAAAA,MAKA,MAHAA,GAAAlmK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAumK,GAAApkK,KAEAmkK,KAOAC,EAAA,SAAArjK,GAEA,QAAAqjK,GAAAhjK,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA8K,SASA,MAZA1I,GAAAkkK,EAAArjK,GAKAqjK,EAAAnmK,UAAAuD,MAAA,SAAAiI,GACA3L,KAAA8K,MAAA1C,KAAAuD,IAEA26J,EAAAnmK,UAAAyD,UAAA,WACA5D,KAAAsD,YAAAjC,KAAArB,KAAA8K,OACA9K,KAAAsD,YAAA5C,YAEA4lK,GACCxhK,EAAA9B,avUi84CK,SAAUxD,EAAQC,EAASC,GAEjC,YwU174CA,SAAAsvJ,GAAA1tJ,GACA,GAAAC,GAAAvB,IASA,IARAsB,IACA3B,EAAA6B,KAAAC,IAAA9B,EAAA6B,KAAAC,GAAAC,QAAA/B,EAAA6B,KAAAC,GAAAC,OAAAC,QACAL,EAAA3B,EAAA6B,KAAAC,GAAAC,OAAAC,QAEAhC,EAAA6B,KAAAG,UACAL,EAAA3B,EAAA6B,KAAAG,WAGAL,EACA,SAAAM,OAAA,wBAEA,WAAAN,GAAA,SAAAO,EAAAC,GACA,GAAAE,EACAT,GAAAxB,UAAA,SAAA4L,GAAsC,MAAA3J,GAAA2J,GAAoB,SAAAxK,GAAkB,MAAAW,GAAAX,IAAsB,WAAe,MAAAU,GAAAG,OAlEjH,GAAArC,GAAAD,EAAA,EAqEAD,GAAAuvJ,axUo/4CM,SAAUxvJ,EAAQC,EAASC,GAEjC,YyU/g5CA,SAAAmK,GAAA08J,GACA,MAAAvmK,MAAAI,KAAA,GAAAomK,GAAAD,IA7CA,GAAAnkK,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAwCAD,GAAAoK,QACA,IAAA28J,GAAA,WACA,QAAAA,GAAAD,GACAvmK,KAAAumK,mBAUA,MARAC,GAAArmK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,GAAAkmK,GAAA,GAAAC,GAAAxkK,GACAykK,EAAApmK,EAAAR,UAAA0mK,EAIA,OAHAE,GAAA9iK,QACA4iK,EAAA3lK,IAAAmlG,EAAAxgG,kBAAAghK,EAAAzmK,KAAAumK,mBAEAI,GAEAH,KAOAE,EAAA,SAAAzjK,GAEA,QAAAyjK,GAAApjK,GACAL,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6J,OAAA,GAAA46F,GAAAz7F,QACA1F,EAAAjC,KAAArB,KAAA6J,QAkCA,MAtCAzH,GAAAskK,EAAAzjK,GAMAyjK,EAAAvmK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA4mK,cAEAF,EAAAvmK,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAA2D,OAAAlD,IAEAimK,EAAAvmK,UAAAqF,eAAA,SAAAF,GACAtF,KAAA4D,aAEA8iK,EAAAvmK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA6J,OAAAxI,KAAAW,IAEA0kK,EAAAvmK,UAAAwD,OAAA,SAAAxC,GACAnB,KAAA6J,OAAApJ,MAAAU,GACAnB,KAAAsD,YAAA7C,MAAAU,IAEAulK,EAAAvmK,UAAAyD,UAAA,WACA5D,KAAA6J,OAAAnJ,WACAV,KAAAsD,YAAA5C,YAEAgmK,EAAAvmK,UAAA0E,aAAA,WACA7E,KAAA6J,OAAA,MAEA68J,EAAAvmK,UAAAymK,WAAA,WACA,GAAAC,GAAA7mK,KAAA6J,MACAg9J,IACAA,EAAAnmK,UAEA,IAAA4C,GAAAtD,KAAAsD,YACAwjK,EAAA9mK,KAAA6J,OAAA,GAAA46F,GAAAz7F,OACA1F,GAAAjC,KAAAylK,IAEAJ,GACC1gE,EAAAjhG,kBzUkk5CK,SAAUvF,EAAQC,EAASC,GAEjC,Y0Uxn5CA,SAAAyvJ,GAAA4X,EAAAC,GAEA,WADA,KAAAA,IAAsCA,EAAA,GACtChnK,KAAAI,KAAA,GAAA6mK,GAAAF,EAAAC,IAzDA,GAAA5kK,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuC,EAAApF,EAAA,GACA+kG,EAAA/kG,EAAA,EAqDAD,GAAA0vJ,aACA,IAAA8X,GAAA,WACA,QAAAA,GAAAF,EAAAC,GACAhnK,KAAA+mK,aACA/mK,KAAAgnK,mBAKA,MAHAC,GAAA9mK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAmnK,GAAAhlK,EAAAlC,KAAA+mK,WAAA/mK,KAAAgnK,oBAEAC,KAOAC,EAAA,SAAAjkK,GAEA,QAAAikK,GAAA5jK,EAAAyjK,EAAAC,GACA/jK,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cACAtD,KAAA+mK,aACA/mK,KAAAgnK,mBACAhnK,KAAAmnK,SAAA,GAAA1iE,GAAAz7F,SACAhJ,KAAAwL,MAAA,EACAlI,EAAAjC,KAAArB,KAAAmnK,QAAA,IA2CA,MAnDA/kK,GAAA8kK,EAAAjkK,GAUAikK,EAAA/mK,UAAAuD,MAAA,SAAA1B,GAMA,OALAglK,GAAAhnK,KAAAgnK,iBAAA,EAAAhnK,KAAAgnK,iBAAAhnK,KAAA+mK,WACAzjK,EAAAtD,KAAAsD,YACAyjK,EAAA/mK,KAAA+mK,WACAI,EAAAnnK,KAAAmnK,QACAjhK,EAAAihK,EAAA9jK,OACA4C,EAAA,EAAuBA,EAAAC,IAAAlG,KAAA6D,OAAyBoC,IAChDkhK,EAAAlhK,GAAA5E,KAAAW,EAEA,IAAA2Q,GAAA3S,KAAAwL,MAAAu7J,EAAA,CAIA,IAHAp0J,GAAA,GAAAA,EAAAq0J,GAAA,IAAAhnK,KAAA6D,QACAsjK,EAAA90H,QAAA3xC,aAEAV,KAAAwL,MAAAw7J,GAAA,IAAAhnK,KAAA6D,OAAA,CACA,GAAAorJ,GAAA,GAAAxqD,GAAAz7F,OACAm+J,GAAA/+J,KAAA6mJ,GACA3rJ,EAAAjC,KAAA4tJ,KAGAiY,EAAA/mK,UAAAwD,OAAA,SAAAxC,GACA,GAAAgmK,GAAAnnK,KAAAmnK,OACA,IAAAA,EACA,KAAAA,EAAA9jK,OAAA,IAAArD,KAAA6D,QACAsjK,EAAA90H,QAAA5xC,MAAAU,EAGAnB,MAAAsD,YAAA7C,MAAAU,IAEA+lK,EAAA/mK,UAAAyD,UAAA,WACA,GAAAujK,GAAAnnK,KAAAmnK,OACA,IAAAA,EACA,KAAAA,EAAA9jK,OAAA,IAAArD,KAAA6D,QACAsjK,EAAA90H,QAAA3xC,UAGAV,MAAAsD,YAAA5C,YAEAwmK,EAAA/mK,UAAA0E,aAAA,WACA7E,KAAAwL,MAAA,EACAxL,KAAAmnK,QAAA,MAEAD,GACCpiK,EAAA9B,a1Usr5CK,SAAUxD,EAAQC,EAASC,GAEjC,Y2U9y5CA,SAAAulG,GAAAmiE,GACA,GAAAr8J,GAAA6/F,EAAArgG,MACA88J,EAAA,KACAC,EAAApiE,OAAAC,iBAgBA,OAfAv6F,GAAAM,YAAA9H,UAAA,MACA2H,EAAA3H,UAAA,IAEAwH,EAAAM,YAAA9H,UAAA,IACA2H,EAAA3H,UAAA,GAEA8vJ,EAAAzsD,UAAArjG,UAAA,MACAkkK,EAAAlkK,UAAA,IAEAwH,EAAAM,YAAA9H,UAAA,IACA2H,EAAA3H,UAAA,GAEA8vJ,EAAAzsD,UAAArjG,UAAA,MACAikK,EAAAjkK,UAAA,IAEApD,KAAAI,KAAA,GAAAmnK,GAAAH,EAAAC,EAAAC,EAAAv8J,IAyGA,QAAAy8J,GAAAj8J,GACA,GAAArJ,GAAAqJ,EAAArJ,WAAAklK,EAAA77J,EAAA67J,eAAAv9J,EAAA0B,EAAA1B,MACAA,IACA3H,EAAAulK,YAAA59J,GAEA0B,EAAA1B,OAAA3H,EAAA0kK,aACA5mK,KAAAyL,SAAAF,EAAA67J,GAEA,QAAAM,GAAAn8J,GACA,GAAA67J,GAAA77J,EAAA67J,eAAAllK,EAAAqJ,EAAArJ,WAAA6I,EAAAQ,EAAAR,UAAAs8J,EAAA97J,EAAA87J,uBACAx9J,EAAA3H,EAAA0kK,aACAlkE,EAAA1iG,KACAoE,GAAmBs+F,SAAA3gG,aAAA,MACnB4lK,GAAyBzlK,aAAA2H,SAAAzF,UACzBA,GAAArC,aAAAgJ,EAAAU,SAAAm8J,EAAAR,EAAAO,GACAjlE,EAAA5hG,IAAAsD,EAAArC,cACA2gG,EAAAj3F,SAAAF,EAAA87J,GAEA,QAAAO,GAAAr8J,GACA,GAAArJ,GAAAqJ,EAAArJ,WAAA2H,EAAA0B,EAAA1B,OAAAzF,EAAAmH,EAAAnH,OACAA,MAAAs+F,QAAAt+F,EAAArC,cACAqC,EAAAs+F,OAAA76F,OAAAzD,EAAArC,cAEAG,EAAAulK,YAAA59J,GA7JA,GAAAzH,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAkrG,EAAAlrG,EAAA,GACAoF,EAAApF,EAAA,GACAwzJ,EAAAxzJ,EAAA,IACAkL,EAAAlL,EAAA,GAsBAD,GAAAwlG,YACA,IAAAsiE,GAAA,WACA,QAAAA,GAAAH,EAAAC,EAAAC,EAAAv8J,GACA/K,KAAAonK,iBACApnK,KAAAqnK,yBACArnK,KAAAsnK,gBACAtnK,KAAA+K,YAKA,MAHAw8J,GAAApnK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA8nK,GAAA3lK,EAAAlC,KAAAonK,eAAApnK,KAAAqnK,uBAAArnK,KAAAsnK,cAAAtnK,KAAA+K,aAEAw8J,KAEAO,EAAA,SAAA7kK,GAEA,QAAA6kK,KACA7kK,EAAA+B,MAAAhF,KAAAoD,WACApD,KAAA+nK,sBAAA,EAaA,MAhBA3lK,GAAA0lK,EAAA7kK,GAKA6kK,EAAA3nK,UAAAkB,KAAA,SAAAW,GACAhC,KAAA+nK,wBACA9kK,EAAA9C,UAAAkB,KAAAR,KAAAb,KAAAgC,IAEAW,OAAAi+F,eAAAknE,EAAA3nK,UAAA,wBACAuS,IAAA,WACA,MAAA1S,MAAA+nK,uBAEAx6D,YAAA,EACAE,cAAA,IAEAq6D,GACCrjE,EAAAz7F,SAMD6+J,EAAA,SAAA5kK,GAEA,QAAA4kK,GAAAvkK,EAAA8jK,EAAAC,EAAAC,EAAAv8J,GACA9H,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cACAtD,KAAAonK,iBACApnK,KAAAqnK,yBACArnK,KAAAsnK,gBACAtnK,KAAA+K,YACA/K,KAAAmnK,UACA,IAAAt9J,GAAA7J,KAAA4mK,YACA,WAAAS,MAAA,GACA,GAAArO,IAA8B92J,WAAAlC,KAAA6J,SAAAzF,QAAA,MAC9B60J,GAAiCmO,iBAAAC,yBAAAnlK,WAAAlC,KAAA+K,YACjC/K,MAAAc,IAAAiK,EAAAU,SAAAm8J,EAAAR,EAAApO,IACAh5J,KAAAc,IAAAiK,EAAAU,SAAAi8J,EAAAL,EAAApO,QAEA,CACA,GAAAF,IAAqC72J,WAAAlC,KAAA6J,SAAAu9J,iBACrCpnK,MAAAc,IAAAiK,EAAAU,SAAA+7J,EAAAJ,EAAArO,KA6CA,MA/DA32J,GAAAylK,EAAA5kK,GAqBA4kK,EAAA1nK,UAAAuD,MAAA,SAAA1B,GAGA,OAFAmlK,GAAAnnK,KAAAmnK,QACAjhK,EAAAihK,EAAA9jK,OACA4C,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAgpJ,GAAAkY,EAAAlhK,EACAgpJ,GAAAprJ,SACAorJ,EAAA5tJ,KAAAW,GACAitJ,EAAA+Y,sBAAAhoK,KAAAsnK,eACAtnK,KAAAynK,YAAAxY,MAKA4Y,EAAA1nK,UAAAwD,OAAA,SAAAxC,GAEA,IADA,GAAAgmK,GAAAnnK,KAAAmnK,QACAA,EAAA9jK,OAAA,GACA8jK,EAAA90H,QAAA5xC,MAAAU,EAEAnB,MAAAsD,YAAA7C,MAAAU,IAEA0mK,EAAA1nK,UAAAyD,UAAA,WAEA,IADA,GAAAujK,GAAAnnK,KAAAmnK,QACAA,EAAA9jK,OAAA,IACA,GAAA4kK,GAAAd,EAAA90H,OACA41H,GAAApkK,QACAokK,EAAAvnK,WAGAV,KAAAsD,YAAA5C,YAEAmnK,EAAA1nK,UAAAymK,WAAA,WACA,GAAA/8J,GAAA,GAAAi+J,EAIA,OAHA9nK,MAAAmnK,QAAA/+J,KAAAyB,GACA7J,KAAAsD,YACAjC,KAAAwI,GACAA,GAEAg+J,EAAA1nK,UAAAsnK,YAAA,SAAA59J,GACAA,EAAAnJ,UACA,IAAAymK,GAAAnnK,KAAAmnK,OACAA,GAAAv+J,OAAAu+J,EAAAx+J,QAAAkB,GAAA,IAEAg+J,GACC/iK,EAAA9B,a3Uw15CK,SAAUxD,EAAQC,EAASC,GAEjC,Y4U365CA,SAAA4vJ,GAAA8J,EAAAC,GACA,MAAAr5J,MAAAI,KAAA,GAAA8nK,GAAA9O,EAAAC,IArDA,GAAAj3J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAmD,EAAAnD,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA6CAD,GAAA6vJ,cACA,IAAA4Y,GAAA,WACA,QAAAA,GAAA9O,EAAAC,GACAr5J,KAAAo5J,WACAp5J,KAAAq5J,kBAKA,MAHA6O,GAAA/nK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAooK,GAAAjmK,EAAAlC,KAAAo5J,SAAAp5J,KAAAq5J,mBAEA6O,KAOAC,EAAA,SAAAllK,GAEA,QAAAklK,GAAA7kK,EAAA81J,EAAAC,GACAp2J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAo5J,WACAp5J,KAAAq5J,kBACAr5J,KAAAw2G,YACAx2G,KAAAc,IAAAd,KAAAooK,iBAAAniE,EAAAxgG,kBAAAzF,KAAAo5J,MAkGA,MAxGAh3J,GAAA+lK,EAAAllK,GAQAklK,EAAAhoK,UAAAuD,MAAA,SAAA1B,GACA,GAAAw0G,GAAAx2G,KAAAw2G,QACA,IAAAA,EAEA,OADAtwG,GAAAswG,EAAAnzG,OACA4C,EAAA,EAA2BA,EAAAC,EAASD,IACpCuwG,EAAAvwG,GAAA4D,OAAAxI,KAAAW,IAIAmmK,EAAAhoK,UAAAwD,OAAA,SAAAxC,GACA,GAAAq1G,GAAAx2G,KAAAw2G,QAEA,IADAx2G,KAAAw2G,SAAA,KACAA,EAGA,IAFA,GAAAtwG,GAAAswG,EAAAnzG,OACAuE,GAAA,IACAA,EAAA1B,GAAA,CACA,GAAA9B,GAAAoyG,EAAA5uG,EACAxD,GAAAyF,OAAApJ,MAAAU,GACAiD,EAAArC,aAAAE,cAGAgB,EAAA9C,UAAAwD,OAAA9C,KAAAb,KAAAmB,IAEAgnK,EAAAhoK,UAAAyD,UAAA,WACA,GAAA4yG,GAAAx2G,KAAAw2G,QAEA,IADAx2G,KAAAw2G,SAAA,KACAA,EAGA,IAFA,GAAAtwG,GAAAswG,EAAAnzG,OACAuE,GAAA,IACAA,EAAA1B,GAAA,CACA,GAAA9B,GAAAoyG,EAAA5uG,EACAxD,GAAAyF,OAAAnJ,WACA0D,EAAArC,aAAAE,cAGAgB,EAAA9C,UAAAyD,UAAA/C,KAAAb,OAEAmoK,EAAAhoK,UAAA0E,aAAA,WACA,GAAA2xG,GAAAx2G,KAAAw2G,QAEA,IADAx2G,KAAAw2G,SAAA,KACAA,EAGA,IAFA,GAAAtwG,GAAAswG,EAAAnzG,OACAuE,GAAA,IACAA,EAAA1B,GAAA,CACA,GAAA9B,GAAAoyG,EAAA5uG,EACAxD,GAAAyF,OAAA5H,cACAmC,EAAArC,aAAAE,gBAIAkmK,EAAAhoK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAJ,IAAAlF,KAAAo5J,SAAA,CACA,GAAAC,GAAAr5J,KAAAq5J,gBACA7B,EAAAhwJ,EAAAO,SAAAsxJ,GAAAl0J,EACA,IAAAqyJ,IAAA/vJ,EAAAO,YACA,MAAAhI,MAAAS,MAAAgH,EAAAO,YAAAC,EAGA,IAAAgnJ,GAAA,GAAAxqD,GAAAz7F,QACAjH,EAAA,GAAAc,GAAAqB,aACAE,GAA+ByF,OAAAolJ,EAAAltJ,eAC/B/B,MAAAw2G,SAAApuG,KAAAhE,EACA,IAAA6sJ,GAAAhrD,EAAAxgG,kBAAAzF,KAAAw3J,EAAApzJ,EACA6sJ,GAAAptJ,OACA7D,KAAAynK,YAAAznK,KAAAw2G,SAAAnzG,OAAA,IAGA4tJ,EAAA7sJ,UACArC,EAAAjB,IAAAmwJ,IAEAjxJ,KAAAsD,YAAAjC,KAAA4tJ,OAIAjvJ,MAAAynK,YAAAznK,KAAAw2G,SAAA7tG,QAAAzD,KAGAijK,EAAAhoK,UAAAoF,YAAA,SAAApE,GACAnB,KAAAS,MAAAU,IAEAgnK,EAAAhoK,UAAAqF,eAAA,SAAAo/J,GACAA,IAAA5kK,KAAAooK,kBACApoK,KAAAynK,YAAAznK,KAAAw2G,SAAA7tG,QAAAi8J,EAAAxgK,WAGA+jK,EAAAhoK,UAAAsnK,YAAA,SAAA7/J,GACA,QAAAA,EAAA,CAGA,GAAA4uG,GAAAx2G,KAAAw2G,SACApyG,EAAAoyG,EAAA5uG,GACAiC,EAAAzF,EAAAyF,OAAA9H,EAAAqC,EAAArC,YACAy0G,GAAA5tG,OAAAhB,EAAA,GACAiC,EAAAnJ,WACAqB,EAAAE,gBAEAkmK,GACCniE,EAAAjhG,kB5Us+5CK,SAAUvF,EAAQC,EAASC,GAEjC,Y6Uzm6CA,SAAA8vJ,GAAA6J,GACA,MAAAr5J,MAAAI,KAAA,GAAAomK,GAAAnN,IAjDA,GAAAj3J,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACA8H,EAAA9H,EAAA,GACA+H,EAAA/H,EAAA,GACAsmG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EA0CAD,GAAA+vJ,YACA,IAAAgX,GAAA,WACA,QAAAA,GAAAnN,GACAr5J,KAAAq5J,kBAKA,MAHAmN,GAAArmK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAA2mK,GAAAxkK,EAAAlC,KAAAq5J,mBAEAmN,KAOAE,EAAA,SAAAzjK,GAEA,QAAAyjK,GAAApjK,EAAA+1J,GACAp2J,EAAApC,KAAAb,KAAAsD,GACAtD,KAAAsD,cACAtD,KAAAq5J,kBACAr5J,KAAA4mK,aAmDA,MAxDAxkK,GAAAskK,EAAAzjK,GAOAyjK,EAAAvmK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA4mK,WAAAthK,IAEAohK,EAAAvmK,UAAAoF,YAAA,SAAA9E,EAAA6E,GACAtF,KAAA2D,OAAAlD,IAEAimK,EAAAvmK,UAAAqF,eAAA,SAAAF,GACAtF,KAAA4mK,WAAAthK,IAEAohK,EAAAvmK,UAAAuD,MAAA,SAAA1B,GACAhC,KAAA6J,OAAAxI,KAAAW,IAEA0kK,EAAAvmK,UAAAwD,OAAA,SAAAxC,GACAnB,KAAA6J,OAAApJ,MAAAU,GACAnB,KAAAsD,YAAA7C,MAAAU,GACAnB,KAAAqoK,kCAEA3B,EAAAvmK,UAAAyD,UAAA,WACA5D,KAAA6J,OAAAnJ,WACAV,KAAAsD,YAAA5C,WACAV,KAAAqoK,kCAEA3B,EAAAvmK,UAAAkoK,+BAAA,WACAroK,KAAAsoK,qBACAtoK,KAAAsoK,oBAAArmK,eAGAykK,EAAAvmK,UAAAymK,WAAA,SAAAthK,OACA,KAAAA,IAAkCA,EAAA,MAClCA,IACAtF,KAAA6H,OAAAvC,GACAA,EAAArD,cAEA,IAAA4kK,GAAA7mK,KAAA6J,MACAg9J,IACAA,EAAAnmK,UAEA,IAAAmJ,GAAA7J,KAAA6J,OAAA,GAAA46F,GAAAz7F,OACAhJ,MAAAsD,YAAAjC,KAAAwI,EACA,IAAA2tJ,GAAAhwJ,EAAAO,SAAA/H,KAAAq5J,kBACA,IAAA7B,IAAA/vJ,EAAAO,YAAA,CACA,GAAA7G,GAAAsG,EAAAO,YAAAC,CACAjI,MAAAsD,YAAA7C,MAAAU,GACAnB,KAAA6J,OAAApJ,MAAAU,OAGAnB,MAAAc,IAAAd,KAAAsoK,oBAAAriE,EAAAxgG,kBAAAzF,KAAAw3J,KAGAkP,GACC1gE,EAAAjhG,kB7Ugq6CK,SAAUvF,EAAQC,EAASC,GAEjC,Y8Uhv6CA,SAAAgwJ,KAEA,OADA/5I,MACA1K,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA,IAAAm9B,EACA,mBAAAzyB,KAAAtS,OAAA,KACA+kC,EAAAzyB,EAAAxK,MAEA,IAAA07F,GAAAlxF,CACA,OAAA3V,MAAAI,KAAA,GAAAmoK,GAAA1hE,EAAAz+D,IAxDA,GAAAhmC,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAyjG,EAAAtmG,EAAA,GACAumG,EAAAvmG,EAAA,EAoDAD,GAAAiwJ,gBACA,IAAA6Y,GAAA,WACA,QAAAA,GAAA1hE,EAAAz+D,GACApoC,KAAA6mG,cACA7mG,KAAAooC,UAKA,MAHAmgI,GAAApoK,UAAAU,KAAA,SAAAqB,EAAA3B,GACA,MAAAA,GAAAR,UAAA,GAAAyoK,GAAAtmK,EAAAlC,KAAA6mG,YAAA7mG,KAAAooC,WAEAmgI,KAOAC,EAAA,SAAAvlK,GAEA,QAAAulK,GAAAllK,EAAAujG,EAAAz+D,GACAnlC,EAAApC,KAAAb,KAAAsD,GACAtD,KAAA6mG,cACA7mG,KAAAooC,UACApoC,KAAAinG,YACA,IAAA/gG,GAAA2gG,EAAAxjG,MACArD,MAAA0O,OAAA,GAAAhD,OAAAxF,EACA,QAAAD,GAAA,EAAuBA,EAAAC,EAASD,IAChCjG,KAAAinG,UAAA7+F,KAAAnC,EAEA,QAAAA,GAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAA3F,GAAAumG,EAAA5gG,EACAjG,MAAAc,IAAAmlG,EAAAxgG,kBAAAzF,KAAAM,IAAA2F,KAsCA,MAnDA7D,GAAAomK,EAAAvlK,GAgBAulK,EAAAroK,UAAA8E,WAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAtF,KAAA0O,OAAAtJ,GAAAD,CACA,IAAA8hG,GAAAjnG,KAAAinG,SACA,IAAAA,EAAA5jG,OAAA,GACA,GAAAolK,GAAAxhE,EAAAt+F,QAAAvD,IACA,IAAAqjK,GACAxhE,EAAAr+F,OAAA6/J,EAAA,KAIAD,EAAAroK,UAAAqF,eAAA,aAGAgjK,EAAAroK,UAAAuD,MAAA,SAAA1B,GACA,OAAAhC,KAAAinG,UAAA5jG,OAAA,CACA,GAAAsS,IAAA3T,GAAAoF,OAAApH,KAAA0O,OACA1O,MAAAooC,QACApoC,KAAAonG,YAAAzxF,GAGA3V,KAAAsD,YAAAjC,KAAAsU,KAIA6yJ,EAAAroK,UAAAinG,YAAA,SAAAzxF,GACA,GAAAhQ,EACA,KACAA,EAAA3F,KAAAooC,QAAApjC,MAAAhF,KAAA2V,GAEA,MAAAxU,GAEA,WADAnB,MAAAsD,YAAA7C,MAAAU,GAGAnB,KAAAsD,YAAAjC,KAAAsE,IAEA6iK,GACCxiE,EAAAjhG,kB9Uqy6CK,SAAUvF,EAAQC,EAASC,GAEjC,Y+U/56CA,SAAAkwJ,GAAAxnH,GACA,MAAApoC,MAAAI,KAAA,GAAAolJ,GAAA/8C,YAAArgE,IARA,GAAAo9G,GAAA9lJ,EAAA,GAUAD,GAAAmwJ,U/U666CM,SAAUpwJ,EAAQC,EAASC,GAEjC,YgVz76CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAM,EAAAnD,EAAA,GAeA6iG,EAAA,SAAAt/F,GAEA,QAAAs/F,GAAAx3F,EAAA82F,GACA5+F,EAAApC,KAAAb,MAgBA,MAlBAoC,GAAAmgG,EAAAt/F,GAcAs/F,EAAApiG,UAAAsL,SAAA,SAAAF,EAAAyZ,GAEA,WADA,KAAAA,IAA+BA,EAAA,GAC/BhlB,MAEAuiG,GACC1/F,EAAAqB,aACDzE,GAAA8iG,UhVg86CM,SAAU/iG,EAAQC,EAASC,GAEjC,YiV3+6CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA8H,EAAA3K,EAAA,IACAgpK,EAAAhpK,EAAA,KAMAipK,EAAA,SAAA1lK,GAEA,QAAA0lK,GAAA59J,EAAA82F,GACA5+F,EAAApC,KAAAb,KAAA+K,EAAA82F,GACA7hG,KAAA+K,YACA/K,KAAA6hG,OAiCA,MArCAz/F,GAAAumK,EAAA1lK,GAMA0lK,EAAAxoK,UAAA6hG,eAAA,SAAAj3F,EAAA+Q,EAAAkJ,GAGA,WAFA,KAAAA,IAA+BA,EAAA,GAE/B,OAAAA,KAAA,EACA/hB,EAAA9C,UAAA6hG,eAAAnhG,KAAAb,KAAA+K,EAAA+Q,EAAAkJ,IAGAja,EAAAu3F,QAAAl6F,KAAApI,MAIA+K,EAAA03F,YAAA13F,EAAA03F,UAAAimE,EAAAE,eAAAjgG,sBAAA59D,EAAAk3F,MAAA39F,KAAAyG,EAAA,UAEA49J,EAAAxoK,UAAA4hG,eAAA,SAAAh3F,EAAA+Q,EAAAkJ,GAKA,OAJA,KAAAA,IAA+BA,EAAA,GAI/B,OAAAA,KAAA,UAAAA,GAAAhlB,KAAAglB,MAAA,EACA,MAAA/hB,GAAA9C,UAAA4hG,eAAAlhG,KAAAb,KAAA+K,EAAA+Q,EAAAkJ,EAKA,KAAAja,EAAAu3F,QAAAj/F,SACAqlK,EAAAE,eAAAC,qBAAA/sJ,GACA/Q,EAAA03F,cAAAztE,KAKA2zI,GACCt+J,EAAAI,YACDhL,GAAAkpK,wBjVk/6CM,SAAUnpK,EAAQC,EAASC,GAEjC,YkVxi7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA+H,EAAA5K,EAAA,IACAopK,EAAA,SAAA7lK,GAEA,QAAA6lK,KACA7lK,EAAA+B,MAAAhF,KAAAoD,WAuBA,MAzBAhB,GAAA0mK,EAAA7lK,GAIA6lK,EAAA3oK,UAAA8hG,MAAA,SAAAS,GACA1iG,KAAA+b,QAAA,EACA/b,KAAAyiG,cAAAztE,EACA,IACAv0B,GADA6hG,EAAAtiG,KAAAsiG,QAEA16F,GAAA,EACA4D,EAAA82F,EAAAj/F,MACAq/F,MAAAJ,EAAAjwD,OACA,IACA,GAAA5xC,EAAAiiG,EAAAR,QAAAQ,EAAAn3F,MAAAm3F,EAAA19E,OACA,cAESpd,EAAA4D,IAAAk3F,EAAAJ,EAAAjwD,SAET,IADAryC,KAAA+b,QAAA,EACAtb,EAAA,CACA,OAAAmH,EAAA4D,IAAAk3F,EAAAJ,EAAAjwD,UACAqwD,EAAAzgG,aAEA,MAAAxB,KAGAqoK,GACCx+J,EAAAE,eACD/K,GAAAqpK,2BlV+i7CM,SAAUtpK,EAAQC,EAASC,GAEjC,YmVnl7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAwmK,EAAArpK,EAAA,KACA2K,EAAA3K,EAAA,IAMA48I,EAAA,SAAAr5I,GAEA,QAAAq5I,GAAAvxI,EAAA82F,GACA5+F,EAAApC,KAAAb,KAAA+K,EAAA82F,GACA7hG,KAAA+K,YACA/K,KAAA6hG,OAiCA,MArCAz/F,GAAAk6I,EAAAr5I,GAMAq5I,EAAAn8I,UAAA6hG,eAAA,SAAAj3F,EAAA+Q,EAAAkJ,GAGA,WAFA,KAAAA,IAA+BA,EAAA,GAE/B,OAAAA,KAAA,EACA/hB,EAAA9C,UAAA6hG,eAAAnhG,KAAAb,KAAA+K,EAAA+Q,EAAAkJ,IAGAja,EAAAu3F,QAAAl6F,KAAApI,MAIA+K,EAAA03F,YAAA13F,EAAA03F,UAAAsmE,EAAAC,UAAA3qB,aAAAtzI,EAAAk3F,MAAA39F,KAAAyG,EAAA,UAEAuxI,EAAAn8I,UAAA4hG,eAAA,SAAAh3F,EAAA+Q,EAAAkJ,GAKA,OAJA,KAAAA,IAA+BA,EAAA,GAI/B,OAAAA,KAAA,UAAAA,GAAAhlB,KAAAglB,MAAA,EACA,MAAA/hB,GAAA9C,UAAA4hG,eAAAlhG,KAAAb,KAAA+K,EAAA+Q,EAAAkJ,EAKA,KAAAja,EAAAu3F,QAAAj/F,SACA0lK,EAAAC,UAAA1qB,eAAAxiI,GACA/Q,EAAA03F,cAAAztE,KAKAsnH,GACCjyI,EAAAI,YACDhL,GAAA68I,cnV0l7CM,SAAU98I,EAAQC,EAASC,GAEjC,YoVhp7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA+H,EAAA5K,EAAA,IACA28I,EAAA,SAAAp5I,GAEA,QAAAo5I,KACAp5I,EAAA+B,MAAAhF,KAAAoD,WAuBA,MAzBAhB,GAAAi6I,EAAAp5I,GAIAo5I,EAAAl8I,UAAA8hG,MAAA,SAAAS,GACA1iG,KAAA+b,QAAA,EACA/b,KAAAyiG,cAAAztE,EACA,IACAv0B,GADA6hG,EAAAtiG,KAAAsiG,QAEA16F,GAAA,EACA4D,EAAA82F,EAAAj/F,MACAq/F,MAAAJ,EAAAjwD,OACA,IACA,GAAA5xC,EAAAiiG,EAAAR,QAAAQ,EAAAn3F,MAAAm3F,EAAA19E,OACA,cAESpd,EAAA4D,IAAAk3F,EAAAJ,EAAAjwD,SAET,IADAryC,KAAA+b,QAAA,EACAtb,EAAA,CACA,OAAAmH,EAAA4D,IAAAk3F,EAAAJ,EAAAjwD,UACAqwD,EAAAzgG,aAEA,MAAAxB,KAGA47I,GACC/xI,EAAAE,eACD/K,GAAA48I,iBpVup7CM,SAAU78I,EAAQC,EAASC,GAEjC,YqV3r7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA8H,EAAA3K,EAAA,IAMAg9I,EAAA,SAAAz5I,GAEA,QAAAy5I,GAAA3xI,EAAA82F,GACA5+F,EAAApC,KAAAb,KAAA+K,EAAA82F,GACA7hG,KAAA+K,YACA/K,KAAA6hG,OA4BA,MAhCAz/F,GAAAs6I,EAAAz5I,GAMAy5I,EAAAv8I,UAAAsL,SAAA,SAAAF,EAAAyZ,GAEA,WADA,KAAAA,IAA+BA,EAAA,GAC/BA,EAAA,EACA/hB,EAAA9C,UAAAsL,SAAA5K,KAAAb,KAAAuL,EAAAyZ,IAEAhlB,KAAAglB,QACAhlB,KAAAuL,QACAvL,KAAA+K,UAAAk3F,MAAAjiG,MACAA,OAEA08I,EAAAv8I,UAAA+hG,QAAA,SAAA32F,EAAAyZ,GACA,MAAAA,GAAA,GAAAhlB,KAAA6D,OACAZ,EAAA9C,UAAA+hG,QAAArhG,KAAAb,KAAAuL,EAAAyZ,GACAhlB,KAAAmiG,SAAA52F,EAAAyZ,IAEA03H,EAAAv8I,UAAA6hG,eAAA,SAAAj3F,EAAA+Q,EAAAkJ,GAKA,WAJA,KAAAA,IAA+BA,EAAA,GAI/B,OAAAA,KAAA,UAAAA,GAAAhlB,KAAAglB,MAAA,EACA/hB,EAAA9C,UAAA6hG,eAAAnhG,KAAAb,KAAA+K,EAAA+Q,EAAAkJ,GAGAja,EAAAk3F,MAAAjiG,OAEA08I,GACCryI,EAAAI,YACDhL,GAAAi9I,erVks7CM,SAAUl9I,EAAQC,EAASC,GAEjC,YsVlv7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEA+H,EAAA5K,EAAA,IACA+8I,EAAA,SAAAx5I,GAEA,QAAAw5I,KACAx5I,EAAA+B,MAAAhF,KAAAoD,WAEA,MAJAhB,GAAAq6I,EAAAx5I,GAIAw5I,GACCnyI,EAAAE,eACD/K,GAAAg9I,kBtVyv7CM,SAAUj9I,EAAQC,EAASC,GAEjC,YuVxw7CA,IAAAupK,GAAAvpK,EAAA,KACAwpK,EAAAxpK,EAAA,IA+BAD,GAAAsrG,eAAA,GAAAm+D,GAAAJ,wBAAAG,EAAAN,uBvV+w7CM,SAAUnpK,EAAQC,EAASC,GAEjC,YwVjz7CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAmD,EAAAnD,EAAA,GACAypK,EAAAzpK,EAAA,IACA0pK,EAAA1pK,EAAA,IAMA2pK,EAAA,SAAApmK,GAEA,QAAAomK,GAAAC,EAAAv+J,GACA9H,EAAApC,KAAAb,KAAA,SAAAkC,GACA,GAAA5B,GAAAN,KACA4H,EAAAtH,EAAA08I,oBAKA,OAJA96I,GAAApB,IAAA,GAAA+B,GAAAqB,aAAA,WACA5D,EAAA28I,qBAAAr1I,MAEAtH,EAAAipK,iBAAArnK,GACAA,IAEAlC,KAAAspK,WACAtpK,KAAAyI,iBACAzI,KAAA+K,YAYA,MAzBA3I,GAAAinK,EAAApmK,GAeAomK,EAAAlpK,UAAAopK,iBAAA,SAAArnK,GAEA,OADAsnK,GAAAxpK,KAAAspK,SAAAjmK,OACA4C,EAAA,EAAuBA,EAAAujK,EAAoBvjK,IAAA,CAC3C,GAAAk9F,GAAAnjG,KAAAspK,SAAArjK,EACA/D,GAAApB,IAAAd,KAAA+K,UAAAU,SAAA,SAAA1H,GACA,GAAAo/F,GAAAp/F,EAAAo/F,QAAAjhG,EAAA6B,EAAA7B,UACAihG,GAAA0E,aAAA7G,QAAA9+F,IACaihG,EAAA/9E,OAAkB+9E,UAAAjhG,kBAG/BmnK,GACCvjK,EAAAhG,WACDL,GAAA4pK,iBACAD,EAAAhsB,YAAAisB,GAAAF,EAAApsB,wBxVwz7CM,SAAUv9I,EAAQC,EAASC,GAEjC,YyVr27CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAkiG,EAAA/kG,EAAA,GACAmD,EAAAnD,EAAA,GACAypK,EAAAzpK,EAAA,IACA0pK,EAAA1pK,EAAA,IAMA+pK,EAAA,SAAAxmK,GAEA,QAAAwmK,GAAAH,EAAAv+J,GACA9H,EAAApC,KAAAb,MACAA,KAAAspK,WACAtpK,KAAAyI,iBACAzI,KAAA+K,YAsBA,MA3BA3I,GAAAqnK,EAAAxmK,GAOAwmK,EAAAtpK,UAAAD,WAAA,SAAAgC,GACA,GAAAkH,GAAApJ,KACA4H,EAAAwB,EAAA4zI,oBAIA,OAHA96I,GAAApB,IAAA,GAAA+B,GAAAqB,aAAA,WACAkF,EAAA6zI,qBAAAr1I,MAEA3E,EAAA9C,UAAAD,WAAAW,KAAAb,KAAAkC,IAEAunK,EAAAtpK,UAAAupK,MAAA,WAIA,OAHAtgK,GAAApJ,KACAwpK,EAAApgK,EAAAkgK,SAAAjmK,OAEA4C,EAAA,EAAuBA,EAAAujK,EAAoBvjK,KAC3C,WACA,GAAAk9F,GAAA/5F,EAAAkgK,SAAArjK,EAEAmD,GAAA2B,UAAAU,SAAA,WAAwD03F,EAAA0E,aAAA7G,QAAA53F,IAAyC+5F,EAAA/9E,WAIjGqkJ,GACChlE,EAAAz7F,QACDvJ,GAAAgqK,gBACAL,EAAAhsB,YAAAqsB,GAAAN,EAAApsB,wBzV427CM,SAAUv9I,EAAQC,EAASC,GAEjC,Y0V357CA,IAAA0C,GAAApC,WAAAoC,WAAA,SAAAC,EAAAC,GAEA,QAAAC,KAAmBvC,KAAAwC,YAAAH,EADnB,OAAAI,KAAAH,KAAAI,eAAAD,KAAAJ,EAAAI,GAAAH,EAAAG,GAEAJ,GAAAlC,UAAA,OAAAmC,EAAAK,OAAAR,OAAAG,IAAAC,EAAApC,UAAAmC,EAAAnC,UAAA,GAAAoC,KAEAuD,EAAApG,EAAA,GACAkoG,EAAAloG,EAAA,IACAiqK,EAAAjqK,EAAA,KACAkqK,EAAAlqK,EAAA,KACAo9I,EAAAp9I,EAAA,IACA2qG,EAAA3qG,EAAA,IACAmqK,EAAA,IACAz/D,EAAA,SAAAnnG,GAEA,QAAAmnG,GAAA0/D,GACA7mK,EAAApC,KAAAb,KAAAqqG,EAAA2xC,cAAA6tB,GACA7pK,KAAA8pK,kBACA9pK,KAAA+pK,kBACA/pK,KAAAgqK,mBACAhqK,KAAAiqK,cAuMA,MA7MA7nK,GAAAgoG,EAAAnnG,GAQAmnG,EAAAjqG,UAAA+pK,WAAA,SAAAC,GACA,GAAAxhK,GAAAwhK,EAAAxhK,QAAA,IACA,SAAAA,EACA,SAAA/G,OAAA,8DAEA,OAAA+G,GAAAyhG,EAAA6xC,iBAEA7xC,EAAAjqG,UAAAiqK,qBAAA,SAAAD,EAAAz7J,EAAAjO,GACA,QAAA0pK,EAAAxhK,QAAA,KACA,SAAA/G,OAAA,sDAEA,SAAAuoK,EAAAxhK,QAAA,KACA,SAAA/G,OAAA,wDAEA,IAAA0nK,GAAAl/D,EAAAigE,aAAAF,EAAAz7J,EAAAjO,GACA6pK,EAAA,GAAAX,GAAAN,eAAAC,EAAAtpK,KAEA,OADAA,MAAAgqK,gBAAA5hK,KAAAkiK,GACAA,GAEAlgE,EAAAjqG,UAAAoqK,oBAAA,SAAAJ,EAAAz7J,EAAAjO,GACA,QAAA0pK,EAAAxhK,QAAA,KACA,SAAA/G,OAAA,uDAEA,IAAA0nK,GAAAl/D,EAAAigE,aAAAF,EAAAz7J,EAAAjO,GACA2I,EAAA,GAAAwgK,GAAAH,cAAAH,EAAAtpK,KAEA,OADAA,MAAA+pK,eAAA3hK,KAAAgB,GACAA,GAEAghG,EAAAjqG,UAAAqqK,2BAAA,SAAAlqK,EAAAmqK,GACA,GAAAlpK,GAAAvB,KACAspK,IAQA,OAPAhpK,GAAAP,UAAA,SAAAiC,GACAsnK,EAAAlhK,MAA2Bgd,MAAA7jB,EAAA6jB,MAAAqlJ,EAAA5iE,aAAAD,EAAA/G,aAAAU,WAAAv/F,MAClB,SAAAb,GACTmoK,EAAAlhK,MAA2Bgd,MAAA7jB,EAAA6jB,MAAAqlJ,EAAA5iE,aAAAD,EAAA/G,aAAAY,YAAAtgG,MAClB,WACTmoK,EAAAlhK,MAA2Bgd,MAAA7jB,EAAA6jB,MAAAqlJ,EAAA5iE,aAAAD,EAAA/G,aAAAa,qBAE3B4nE,GAEAl/D,EAAAjqG,UAAAuqK,iBAAA,SAAApqK,EAAAqqK,GACA,GAAAppK,GAAAvB,SACA,KAAA2qK,IAA+CA,EAAA,KAC/C,IAIA5oK,GAJA6oK,KACAC,GAAyBD,SAAAE,OAAA,GACzBC,EAAA3gE,EACA4gE,4BAAAL,GAAA9tB,iBAoBA,OAlBA78I,MAAAyL,SAAA,WACA1J,EAAAzB,EAAAP,UAAA,SAAA4L,GACA,GAAA3J,GAAA2J,CAEAA,aAAA7F,GAAAhG,aACAkC,EAAAT,EAAAipK,2BAAAxoK,EAAAT,EAAA6jB,QAEAwlJ,EAAAxiK,MAA6Bgd,MAAA7jB,EAAA6jB,MAAAyiF,aAAAD,EAAA/G,aAAAU,WAAAv/F,MAChB,SAAAb,GACbypK,EAAAxiK,MAA6Bgd,MAAA7jB,EAAA6jB,MAAAyiF,aAAAD,EAAA/G,aAAAY,YAAAtgG,MAChB,WACbypK,EAAAxiK,MAA6Bgd,MAAA7jB,EAAA6jB,MAAAyiF,aAAAD,EAAA/G,aAAAa,sBAEpB,GACTqpE,IAAA7lE,OAAAC,mBACAnlG,KAAAyL,SAAA,WAAuC,MAAA1J,GAAAE,eAAqC8oK,GAE5E/qK,KAAAiqK,WAAA7hK,KAAAyiK,IAEAI,KAAA,SAAAd,EAAAz7J,EAAA2zF,GACAwoE,EAAAC,OAAA,EACAD,EAAAK,SAAA9gE,EAAAigE,aAAAF,EAAAz7J,EAAA2zF,GAAA,MAIA+H,EAAAjqG,UAAAgrK,oBAAA,SAAAC,GACA,GAAAP,IAAyBD,OAAAQ,EAAAN,OAAA,EAEzB,OADA9qK,MAAAiqK,WAAA7hK,KAAAyiK,IAEAI,KAAA,SAAAd,GACA,GAAAkB,GAAA,gBAAAlB,QACAU,GAAAC,OAAA,EACAD,EAAAK,SAAAG,EAAA94J,IAAA,SAAA43J,GACA,MAAA//D,GAAA4gE,4BAAAb,QAKA//D,EAAAjqG,UAAA8hG,MAAA,WAEA,IADA,GAAA8nE,GAAA/pK,KAAA+pK,eACAA,EAAA1mK,OAAA,GACA0mK,EAAA13H,QAAAq3H,OAEAzmK,GAAA9C,UAAA8hG,MAAAphG,KAAAb,KAEA,KADA,GAAAsrK,GAAAtrK,KAAAiqK,WAAA34J,OAAA,SAAAgoC,GAAsE,MAAAA,GAAAwxH,QACtEQ,EAAAjoK,OAAA,IACA,GAAAi2C,GAAAgyH,EAAAj5H,OACAryC,MAAA8pK,gBAAAxwH,EAAAsxH,OAAAtxH,EAAA4xH,YAGA9gE,EAAA4gE,4BAAA,SAAAb,GACA,mBAAAA,GACA,UAAArtB,GAAAH,gBAAAz3C,OAAAC,kBAMA,QAJAj/F,GAAAikK,EAAA9mK,OACAkoK,GAAA,EACAC,EAAAtmE,OAAAC,kBACA4lE,EAAA7lE,OAAAC,kBACAl/F,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAmf,GAAAnf,EAAAjG,KAAAi8I,gBACAtpI,EAAAw3J,EAAAlkK,EACA,QAAA0M,GACA,QACA,QACA,KACA,SACA44J,EAAAnmJ,CACA,MACA,SACAmmJ,GAAA,CACA,MACA,SACA,GAAAC,IAAAtmE,OAAAC,kBACA,SAAAvjG,OAAA,iGAGA4pK,GAAAD,GAAA,EAAAA,EAAAnmJ,CACA,MACA,SACA,GAAA2lJ,IAAA7lE,OAAAC,kBACA,SAAAvjG,OAAA,iGAGAmpK,GAAAQ,GAAA,EAAAA,EAAAnmJ,CACA,MACA,SACA,SAAAxjB,OAAA,0FACA+Q,EAAA,OAGA,MAAAo4J,GAAA,EACA,GAAAjuB,GAAAH,gBAAA6uB,GAGA,GAAA1uB,GAAAH,gBAAA6uB,EAAAT,IAGA3gE,EAAAigE,aAAA,SAAAF,EAAAz7J,EAAA2zF,EAAAopE,GAEA,OADA,KAAAA,IAAqDA,GAAA,IACrD,IAAAtB,EAAAxhK,QAAA,KACA,SAAA/G,OAAA,yEAiBA,QAdAsE,GAAAikK,EAAA9mK,OACAqoK,KACAC,EAAAxB,EAAAxhK,QAAA,KACAijK,GAAA,IAAAD,EAAA,EAAAA,GAAA3rK,KAAAi8I,gBACArmB,EAAA,gBAAAlnH,GACA,SAAA/C,GAA0B,MAAAA,IAC1B,SAAAA,GAEA,MAAA8/J,IAAA/8J,EAAA/C,YAAAg+J,GAAAN,eACA36J,EAAA/C,GAAA29J,SAEA56J,EAAA/C,IAEA4/J,GAAA,EACAtlK,EAAA,EAAuBA,EAAAC,EAASD,IAAA,CAChC,GAAAmf,GAAAnf,EAAAjG,KAAAi8I,gBAAA2vB,EACA/jE,MAAA,GACAl1F,EAAAw3J,EAAAlkK,EACA,QAAA0M,GACA,QACA,QACA,KACA,SACA44J,EAAAnmJ,CACA,MACA,SACAmmJ,GAAA,CACA,MACA,SACA1jE,EAAAD,EAAA/G,aAAAa,gBACA,MACA,SACA,KACA,SACAmG,EAAAD,EAAA/G,aAAAY,YAAAY,GAAA,QACA,MACA,SACAwF,EAAAD,EAAA/G,aAAAU,WAAAq0B,EAAAjjH,IAGAk1F,GACA6jE,EAAAtjK,MAAmCgd,MAAAmmJ,GAAA,EAAAA,EAAAnmJ,EAAAyiF,iBAGnC,MAAA6jE,IAEAthE,GACCC,EAAAC,qBACD7qG,GAAA2qG,iB1Vk67CM,SAAU5qG,EAAQC,EAASC,GAEjC,Y2Vho8CA,IAAAC,GAAAD,EAAA,GACAmsK,EAAA,WACA,QAAAA,GAAArqK,GACAA,EAAAmnE,uBACA3oE,KAAA6oK,qBAAArnK,EAAAqnK,qBAAAvkK,KAAA9C,GACAxB,KAAA2oE,sBAAAnnE,EAAAmnE,sBAAArkE,KAAA9C,IAEAA,EAAAsqK,0BACA9rK,KAAA6oK,qBAAArnK,EAAAuqK,wBAAAznK,KAAA9C,GACAxB,KAAA2oE,sBAAAnnE,EAAAsqK,yBAAAxnK,KAAA9C,IAEAA,EAAAwqK,6BACAhsK,KAAA6oK,qBAAArnK,EAAAyqK,2BAAA3nK,KAAA9C,GACAxB,KAAA2oE,sBAAAnnE,EAAAwqK,4BAAA1nK,KAAA9C,IAEAA,EAAA0qK,yBACAlsK,KAAA6oK,qBAAArnK,EAAA2qK,uBAAA7nK,KAAA9C,GACAxB,KAAA2oE,sBAAAnnE,EAAA0qK,wBAAA5nK,KAAA9C,IAEAA,EAAA4qK,wBACApsK,KAAA6oK,qBAAArnK,EAAA6qK,sBAAA/nK,KAAA9C,GACAxB,KAAA2oE,sBAAAnnE,EAAA4qK,uBAAA9nK,KAAA9C,KAGAxB,KAAA6oK,qBAAArnK,EAAAukB,aAAAzhB,KAAA9C,GACAxB,KAAA2oE,sBAAA,SAAA1oC,GAAwD,MAAAz+B,GAAA8E,WAAA25B,EAAA,UAGxD,MAAA4rI,KAEApsK,GAAAosK,kCACApsK,EAAAmpK,eAAA,GAAAiD,GAAAlsK,EAAA6B,O3Vuo8CM,SAAUhC,EAAQC,EAASC,GAEjC,Y4Vxq8CA,IAAAs/J,GAAA,WACA,QAAAA,KACAh/J,KAAA0O,UAwBA,MAtBAswJ,GAAA7+J,UAAA0qI,OAAA,SAAAt0H,GAEA,MADAvW,MAAA0O,OAAA6H,GAAA,MACA,GAEAyoJ,EAAA7+J,UAAAyS,IAAA,SAAA2D,EAAAvU,GAEA,MADAhC,MAAA0O,OAAA6H,GAAAvU,EACAhC,MAEAg/J,EAAA7+J,UAAAuS,IAAA,SAAA6D,GACA,MAAAvW,MAAA0O,OAAA6H,IAEAyoJ,EAAA7+J,UAAAiB,QAAA,SAAA6+B,EAAAsnE,GACA,GAAA74F,GAAA1O,KAAA0O,MACA,QAAA6H,KAAA7H,GACAA,EAAAhM,eAAA6T,IAAA,OAAA7H,EAAA6H,IACA0pB,EAAAp/B,KAAA0mG,EAAA74F,EAAA6H,OAIAyoJ,EAAA7+J,UAAAquE,MAAA,WACAxuE,KAAA0O,WAEAswJ,IAEAv/J,GAAAu/J,W5V+q8CM,SAAUx/J,EAAQC,EAASC,GAEjC,c6V9s8CA,SAAA4+I,EAAAD,GAIA,GAAA1+I,GAAAD,EAAA,GACA4sK,EAAA,WACA,QAAAA,GAAA9qK,GAEA,GADAxB,KAAAwB,OACAA,EAAA68I,cAAA,kBAAA78I,GAAA68I,aACAr+I,KAAAq+I,aAAA78I,EAAA68I,aAAA/5I,KAAA9C,GACAxB,KAAAs+I,eAAA98I,EAAA88I,eAAAh6I,KAAA9C,OAEA,CACAxB,KAAAusK,WAAA,EACAvsK,KAAAwsK,iBACAxsK,KAAAysK,uBAAA,EAEAzsK,KAAA0sK,wBAEA1sK,KAAAq+I,aAAAr+I,KAAA2sK,oCAEA3sK,KAAA4sK,oBAEA5sK,KAAAq+I,aAAAr+I,KAAA6sK,gCAEA7sK,KAAA8sK,uBAEA9sK,KAAAq+I,aAAAr+I,KAAA+sK,mCAEA/sK,KAAAgtK,yBAEAhtK,KAAAq+I,aAAAr+I,KAAAitK,qCAIAjtK,KAAAq+I,aAAAr+I,KAAAktK,8BAEA,IAAAC,GAAA,QAAA7uB,GAAA7wH,SACA6wH,GAAA8uB,SAAAZ,cAAA/+I,GAEA0/I,GAAAC,SAAAptK,KACAA,KAAAs+I,eAAA6uB,GAmKA,MAhKAb,GAAAnsK,UAAAktK,SAAA,SAAAr4J,GACA,MAAAhV,MAAAwB,KAAAmB,OAAAxC,UAAA4T,SAAAlT,KAAAmU,IAEAs3J,EAAAnsK,UAAAusK,sBAAA,WACA,2BAAA1sK,KAAAqtK,SAAArtK,KAAAwB,KAAA8gJ,UAEAgqB,EAAAnsK,UAAA2sK,qBAAA,WACA,MAAAn6D,SAAA3yG,KAAAwB,KAAA8rK,iBAEAhB,EAAAnsK,UAAA6sK,uBAAA,WACA,GAAAh6J,GAAAhT,KAAAwB,KAAAwR,QACA,OAAA2/F,SAAA3/F,GAAA,sBAAAA,GAAAM,cAAA,YAEAg5J,EAAAnsK,UAAAysK,kBAAA,WACA,GAAAprK,GAAAxB,KAAAwB,IAGA,IAAAA,EAAA+rK,cAAA/rK,EAAAgsK,cAAA,CACA,GAAAC,IAAA,EACAC,EAAAlsK,EAAA60J,SAMA,OALA70J,GAAA60J,UAAA,WACAoX,GAAA,GAEAjsK,EAAA+rK,YAAA,QACA/rK,EAAA60J,UAAAqX,EACAD,EAEA,UAIAnB,EAAAnsK,UAAAwtK,iBAAA,SAAAnwD,GAEA,OADA7nG,MACA1K,EAAA,EAAwBA,EAAA7H,UAAAC,OAAuB4H,IAC/C0K,EAAA1K,EAAA,GAAA7H,UAAA6H,EAEA,IAAAtG,GAAA,QAAAgB,KACA,GAAA5B,GAAA4B,EAAA63G,EAAAz5G,EAAAy5G,QAAA7nG,EAAA5R,EAAA4R,IACA,mBAAA6nG,GACAA,EAAAx4G,UAAAgwB,GAAArf,GAGA,GAAAsd,UAAA,GAAAuqF,KAKA,OAFA74G,GAAA64G,UACA74G,EAAAgR,OACAhR,GAEA2nK,EAAAnsK,UAAAytK,6BAAA,SAAAj4J,GAEA,MADA3V,MAAAwsK,cAAAxsK,KAAAusK,YAAAvsK,KAAA2tK,iBAAA3oK,UAAAgwB,GAAArf,GACA3V,KAAAusK,cAEAD,EAAAnsK,UAAAwsK,kCAAA,WACA,GAAAhoK,GAAA,QAAA05I,KACA,GAAA+uB,GAAA/uB,EAAA+uB,SACA3/I,EAAA2/I,EAAAQ,6BAAAxqK,UAEA,OADAgqK,GAAA5rK,KAAA8gJ,QAAA9mC,SAAA4xD,EAAAO,iBAAAP,EAAAS,aAAApgJ,IACAA,EAGA,OADA9oB,GAAAyoK,SAAAptK,KACA2E,GAEA2nK,EAAAnsK,UAAA0sK,8BAAA,WAIA,GAAArrK,GAAAxB,KAAAwB,KACAssK,EAAA,gBAAAtsK,EAAAuL,KAAAyhC,SAAA,IACAu/H,EAAA,QAAAC,GAAA55J,GACA,GAAAg5J,GAAAY,EAAAZ,QACAh5J,GAAA7T,SAAAiB,GACA,gBAAA4S,GAAAxE,MACA,IAAAwE,EAAAxE,KAAAjH,QAAAmlK,IACAV,EAAAS,cAAAz5J,EAAAxE,KAAApG,MAAAskK,EAAAzqK,SAGA0qK,GAAAX,SAAAptK,KACAwB,EAAAgU,iBAAA,UAAAu4J,GAAA,EACA,IAAAppK,GAAA,QAAA05I,KACA,GAAAt6I,GAAAs6I,EAAAyvB,EAAA/pK,EAAA+pK,cAAAV,EAAArpK,EAAAqpK,SACA3/I,EAAA2/I,EAAAQ,6BAAAxqK,UAEA,OADAgqK,GAAA5rK,KAAA+rK,YAAAO,EAAArgJ,EAAA,KACAA,EAIA,OAFA9oB,GAAAyoK,SAAAptK,KACA2E,EAAAmpK,gBACAnpK,GAEA2nK,EAAAnsK,UAAA0tK,aAAA,SAAApgJ,GAGA,GAAAztB,KAAAysK,sBAGAzsK,KAAAwB,KAAA8E,WAAAtG,KAAA2tK,iBAAA3tK,KAAA6tK,aAAApgJ,GAAA,OAEA,CACA,GAAAwgJ,GAAAjuK,KAAAwsK,cAAA/+I,EACA,IAAAwgJ,EAAA,CACAjuK,KAAAysK,uBAAA,CACA,KACAwB,IAEA,QACAjuK,KAAAs+I,eAAA7wH,GACAztB,KAAAysK,uBAAA,MAKAH,EAAAnsK,UAAA4sK,iCAAA,WACA,GAAAxrK,GAAAvB,KACAkuK,EAAA,GAAAluK,MAAAwB,KAAA8rK,cACAY,GAAAC,MAAA9X,UAAA,SAAAjiJ,GACA,GAAAqZ,GAAArZ,EAAAxE,IACArO,GAAAssK,aAAApgJ,GAEA,IAAA9oB,GAAA,QAAA05I,KACA,GAAAt6I,GAAAs6I,EAAA6vB,EAAAnqK,EAAAmqK,QAAAd,EAAArpK,EAAAqpK,SACA3/I,EAAA2/I,EAAAQ,6BAAAxqK,UAEA,OADA8qK,GAAAE,MAAAb,YAAA9/I,GACAA,EAIA,OAFA9oB,GAAAupK,UACAvpK,EAAAyoK,SAAAptK,KACA2E,GAEA2nK,EAAAnsK,UAAA8sK,mCAAA,WACA,GAAAtoK,GAAA,QAAA05I,KACA,GAAA+uB,GAAA/uB,EAAA+uB,SACA5rK,EAAA4rK,EAAA5rK,KACA+9I,EAAA/9I,EAAAwR,SACAooD,EAAAmkF,EAAAlsI,gBACAoa,EAAA2/I,EAAAQ,6BAAAxqK,WAGAirK,EAAA9uB,EAAAjsI,cAAA,SAQA,OAPA+6J,GAAAnqF,mBAAA,WACAkpF,EAAAS,aAAApgJ,GACA4gJ,EAAAnqF,mBAAA,KACA9oB,EAAAhhD,YAAAi0J,GACAA,EAAA,MAEAjzG,EAAAthD,YAAAu0J,GACA5gJ,EAGA,OADA9oB,GAAAyoK,SAAAptK,KACA2E,GAEA2nK,EAAAnsK,UAAA+sK,6BAAA,WACA,GAAAvoK,GAAA,QAAA05I,KACA,GAAA+uB,GAAA/uB,EAAA+uB,SACA3/I,EAAA2/I,EAAAQ,6BAAAxqK,UAEA,OADAgqK,GAAA5rK,KAAA8E,WAAA8mK,EAAAO,iBAAAP,EAAAS,aAAApgJ,GAAA,GACAA,EAGA,OADA9oB,GAAAyoK,SAAAptK,KACA2E,GAEA2nK,IAEA7sK,GAAA6sK,sBACA7sK,EAAAupK,UAAA,GAAAsD,GAAA3sK,EAAA6B,Q7Vit8C6BX,KAAKpB,EAASC,EAAoB,IAAI4+I,eAAgB5+I,EAAoB,IAAI2+I,eAIrG,SAAU7+I,EAAQC,EAASC,GAEjC,Y8Vr68CA,IAAAC,GAAAD,EAAA,GACA4uK,EAAA5uK,EAAA,IACAD,GAAA6yB,IAAA3yB,EAAA6B,KAAA8wB,KAAA,WAA+C,MAAAg8I,GAAAC,gB9V468CzC,SAAU/uK,EAAQC,EAASC,GAEjC,Y+Vh78CA,IAAA6uK,GAAA,WACA,QAAAA,KACAvuK,KAAAkoC,KAAA,EACAloC,KAAAwuK,WACAxuK,KAAAyuK,SAsCA,MApCAF,GAAApuK,UAAAuS,IAAA,SAAA6D,GACA,GAAAtQ,GAAAjG,KAAAyuK,MAAA9lK,QAAA4N,EACA,YAAAtQ,MAAA+uB,GAAAh1B,KAAAwuK,QAAAvoK,IAEAsoK,EAAApuK,UAAAyS,IAAA,SAAA2D,EAAAvU,GACA,GAAAiE,GAAAjG,KAAAyuK,MAAA9lK,QAAA4N,EASA,QARA,IAAAtQ,GACAjG,KAAAyuK,MAAArmK,KAAAmO,GACAvW,KAAAwuK,QAAApmK,KAAApG,GACAhC,KAAAkoC,QAGAloC,KAAAwuK,QAAAvoK,GAAAjE,EAEAhC,MAEAuuK,EAAApuK,UAAA0qI,OAAA,SAAAt0H,GACA,GAAAtQ,GAAAjG,KAAAyuK,MAAA9lK,QAAA4N,EACA,YAAAtQ,IAGAjG,KAAAwuK,QAAA5lK,OAAA3C,EAAA,GACAjG,KAAAyuK,MAAA7lK,OAAA3C,EAAA,GACAjG,KAAAkoC,QACA,IAEAqmI,EAAApuK,UAAAquE,MAAA,WACAxuE,KAAAyuK,MAAAprK,OAAA,EACArD,KAAAwuK,QAAAnrK,OAAA,EACArD,KAAAkoC,KAAA,GAEAqmI,EAAApuK,UAAAiB,QAAA,SAAA6+B,EAAAsnE,GACA,OAAAthG,GAAA,EAAuBA,EAAAjG,KAAAkoC,KAAejiC,IACtCg6B,EAAAp/B,KAAA0mG,EAAAvnG,KAAAwuK,QAAAvoK,GAAAjG,KAAAyuK,MAAAxoK,KAGAsoK,IAEA9uK,GAAA8uK,e/Vu78CM,SAAU/uK,EAAQC,EAASC,GAEjC,YgWp+8CA,SAAAgvK,KAGA,kBACA,QAAAC,KACA3uK,KAAAwuK,WAoBA,MAlBAG,GAAAxuK,UAAAW,IAAA,SAAAkB,GACAhC,KAAA21C,IAAA3zC,IACAhC,KAAAwuK,QAAApmK,KAAApG,IAGA2sK,EAAAxuK,UAAAw1C,IAAA,SAAA3zC,GACA,WAAAhC,KAAAwuK,QAAA7lK,QAAA3G,IAEAW,OAAAi+F,eAAA+tE,EAAAxuK,UAAA,QACAuS,IAAA,WACA,MAAA1S,MAAAwuK,QAAAnrK,QAEAkqG,YAAA,EACAE,cAAA,IAEAkhE,EAAAxuK,UAAAquE,MAAA,WACAxuE,KAAAwuK,QAAAnrK,OAAA,GAEAsrK,KA1BA,GAAAhvK,GAAAD,EAAA,EA6BAD,GAAAivK,iBACAjvK,EAAAozB,IAAAlzB,EAAA6B,KAAAqxB,KAAA67I,KhW4+8CM,SAAUlvK,EAAQC,EAASC,GAEjC,YiW3g9CA,SAAAkvK,GAAA/yJ,GAEA,OADAg1I,MACA5lJ,EAAA,EAAoBA,EAAA7H,UAAAC,OAAuB4H,IAC3C4lJ,EAAA5lJ,EAAA,GAAA7H,UAAA6H,EAGA,QADA/E,GAAA2qJ,EAAAxtJ,OACA4C,EAAA,EAAmBA,EAAAC,EAASD,IAAA,CAC5B,GAAA1F,GAAAswJ,EAAA5qJ,EACA,QAAAyK,KAAAnQ,GACAA,EAAAmC,eAAAgO,KACAmL,EAAAnL,GAAAnQ,EAAAmQ,IAIA,MAAAmL,GAIA,QAAAgzJ,GAAArtK,GACA,MAAAA,GAAAmB,OAAA0yJ,QAAAuZ,EApBA,GAAAjvK,GAAAD,EAAA,EAiBAD,GAAAmvK,aAKAnvK,EAAAovK,YACApvK,EAAA41J,OAAAwZ,EAAAlvK,EAAA6B,OjWmh9CM,SAAUhC,EAAQC,EAASC,GAEjC,YkW5i9CA,SAAA+gK,GAAAqO,EAAAvnE,GACA,QAAAwnE,KACA,OAAAA,EAAAD,KAAA9pK,MAAA+pK,EAAAxnE,QAAAnkG,WAIA,MAFA2rK,GAAAD,OACAC,EAAAxnE,UACAwnE,EAEAtvK,EAAAghK,OlWmj9CM,SAAUjhK,EAAQC,EAASC,GAEjC,YmW1j9CA,SAAAkB,GAAAwgG,EAAA3gG,EAAAC,GACA,GAAA0gG,EAAA,CACA,GAAAA,YAAAt8F,GAAA9B,WACA,MAAAo+F,EAEA,IAAAA,EAAAr+F,EAAAU,cACA,MAAA29F,GAAAr+F,EAAAU,gBAGA,MAAA29F,IAAA3gG,GAAAC,EAGA,GAAAoE,GAAA9B,WAAAo+F,EAAA3gG,EAAAC,GAFA,GAAAoE,GAAA9B,WAAAF,EAAAS,OAbA,GAAAuB,GAAApF,EAAA,GACAqD,EAAArD,EAAA,IACAoD,EAAApD,EAAA,GAeAD,GAAAmB,gBnWok9CM,SAAUpB,EAAQC,EAASC,IoWtl9CjC,SAAAiK,EAAA24I,IAAA,SAAA34I,EAAAqrB,GACA,YAYA,SAAAqpH,GAAAxrI,GAEA,kBAAAA,KACAA,EAAA,GAAAogB,UAAA,GAAApgB,GAIA,QADA8C,GAAA,GAAAjK,OAAAtI,UAAAC,OAAA,GACA4C,EAAA,EAAqBA,EAAA0P,EAAAtS,OAAiB4C,IACtC0P,EAAA1P,GAAA7C,UAAA6C,EAAA,EAGA,IAAAgoK,IAAkBp7J,WAAA8C,OAGlB,OAFA62J,GAAAD,GAAA0B,EACAe,EAAAzC,GACAA,IAGA,QAAAjuB,GAAA7wH,SACA++I,GAAA/+I,GAGA,QAAAutF,GAAAizD,GACA,GAAAp7J,GAAAo7J,EAAAp7J,SACA8C,EAAAs4J,EAAAt4J,IACA,QAAAA,EAAAtS,QACA,OACAwP,GACA,MACA,QACAA,EAAA8C,EAAA,GACA,MACA,QACA9C,EAAA8C,EAAA,GAAAA,EAAA,GACA,MACA,QACA9C,EAAA8C,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA,MACA,SACA9C,EAAA7N,MAAAgwB,EAAArf,IAKA,QAAAk4J,GAAApgJ,GAGA,GAAAg/I,EAGAnmK,WAAAunK,EAAA,EAAApgJ,OACS,CACT,GAAAwgJ,GAAAzB,EAAA/+I,EACA,IAAAwgJ,EAAA,CACAxB,GAAA,CACA,KACAzxD,EAAAizD,GACiB,QACjB3vB,EAAA7wH,GACAg/I,GAAA,KApEA,IAAA9iK,EAAA00I,aAAA,CAIA,GAIA2wB,GAJAzC,EAAA,EACAC,KACAC,GAAA,EACAltB,EAAA51I,EAAAqJ,SAoJAi8J,EAAAtsK,OAAAusK,gBAAAvsK,OAAAusK,eAAAvlK,EACAslK,QAAA3oK,WAAA2oK,EAAAtlK,EAGU,wBAAAoK,SAAAlT,KAAA8I,EAAA24I,SArFV,WACA0sB,EAAA,SAAAvhJ,GACA60H,EAAA9mC,SAAA,WAA0CqyD,EAAApgJ,SAI1C,WAGA,GAAA9jB,EAAA4jK,cAAA5jK,EAAA6jK,cAAA,CACA,GAAA2B,IAAA,EACAzB,EAAA/jK,EAAA0sJ,SAMA,OALA1sJ,GAAA0sJ,UAAA,WACA8Y,GAAA,GAEAxlK,EAAA4jK,YAAA,QACA5jK,EAAA0sJ,UAAAqX,EACAyB,MAIA,WAKA,GAAArB,GAAA,gBAAA/gK,KAAAyhC,SAAA,IACAu/H,EAAA,SAAA35J,GACAA,EAAA7T,SAAAoJ,GACA,gBAAAyK,GAAAxE,MACA,IAAAwE,EAAAxE,KAAAjH,QAAAmlK,IACAD,GAAAz5J,EAAAxE,KAAApG,MAAAskK,EAAAzqK,SAIAsG,GAAA6L,iBACA7L,EAAA6L,iBAAA,UAAAu4J,GAAA,GAEApkK,EAAAylK,YAAA,YAAArB,GAGAiB,EAAA,SAAAvhJ,GACA9jB,EAAA4jK,YAAAO,EAAArgJ,EAAA,SAmDK9jB,EAAA2jK,eA/CL,WACA,GAAAY,GAAA,GAAAZ,eACAY,GAAAC,MAAA9X,UAAA,SAAAjiJ,GAEAy5J,EADAz5J,EAAAxE,OAIAo/J,EAAA,SAAAvhJ,GACAygJ,EAAAE,MAAAb,YAAA9/I,OA2CK8xH,GAAA,sBAAAA,GAAAjsI,cAAA,UAvCL,WACA,GAAA8nD,GAAAmkF,EAAAlsI,eACA27J,GAAA,SAAAvhJ,GAGA,GAAA4gJ,GAAA9uB,EAAAjsI,cAAA,SACA+6J,GAAAnqF,mBAAA,WACA2pF,EAAApgJ,GACA4gJ,EAAAnqF,mBAAA,KACA9oB,EAAAhhD,YAAAi0J,GACAA,EAAA,MAEAjzG,EAAAthD,YAAAu0J,OAIA,WACAW,EAAA,SAAAvhJ,GACAnnB,WAAAunK,EAAA,EAAApgJ,OA8BAwhJ,EAAA5wB,eACA4wB,EAAA3wB,mBACC,mBAAAv0I,UAAA,KAAAJ,EAAA3J,KAAA2J,EAAAI,QpW0l9C4BlJ,KAAKpB,EAASC,EAAoB,IAAKA,EAAoB,MAG/E,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CAEH,SAAUF,EAAQwrG,EAAqBtrG,GAE7C,YqWrx9CA,SAAA2rH,GAAA8S,EAAAh7B,IAMA,QAAAksE,GAAAluK,GACA,MAAAwB,QAAAxC,UAAA4T,SAAAlT,KAAAM,GAAAwH,QAAA,YAkFA,QAAA2mK,GAAAC,EAAA7tK,GACA,aAAAA,IACA,gBACA,MACA,cACA,MAAAA,EACA,gBACA,MAAAA,GAAA6tK,EACA,eACA,MAAA7tK,GAAA6tK,EAAAj1J,WAAA0a,IA2BA,QAAAw6I,GACArpD,EACAspD,EACAC,OAEA,KAAAD,SAEA,IACAE,GADAjtJ,EAAAgtJ,GAAAE,CAEA,KACAD,EAAAjtJ,EAAAyjG,GAAA,IACG,MAAAl+G,GAEH0nK,KAEA,OAAAp5J,KAAAk5J,GAAA,CACA,GAAA/oE,GAAA+oE,EAAAl5J,EACAo5J,GAAAp5J,GAAA7K,MAAAxD,QAAAw+F,KAAAl9F,QAAAk9F,EAEA,MAAAipE,GAGA,QAAAC,GAAAzpD,GACA,GAAAzZ,KAIA,QAFAyZ,IAAA9zG,OAAA2vC,QAAA,kBAMAmkE,EAAA7zG,MAAA,KAAAlR,QAAA,SAAAyuK,GACA,GAAAC,GAAAD,EAAA7tH,QAAA,WAAA1vC,MAAA,KACAiE,EAAAg8H,GAAAu9B,EAAAz9H,SACAq0D,EAAAopE,EAAAzsK,OAAA,EACAkvI,GAAAu9B,EAAArsJ,KAAA,MACA,SAEAuR,KAAA03E,EAAAn2F,GACAm2F,EAAAn2F,GAAAmwF,EACKh7F,MAAAxD,QAAAwkG,EAAAn2F,IACLm2F,EAAAn2F,GAAAnO,KAAAs+F,GAEAgG,EAAAn2F,IAAAm2F,EAAAn2F,GAAAmwF,KAIAgG,GAnBAA,EAsBA,QAAAqjE,GAAAzkE,GACA,GAAAoB,GAAApB,EAAA3oG,OAAA8rE,KAAA68B,GAAA/4F,IAAA,SAAAgE,GACA,GAAAmwF,GAAA4E,EAAA/0F,EAEA,QAAAye,KAAA0xE,EACA,QAGA,WAAAA,EACA,MAAAspE,IAAAz5J,EAGA,IAAA7K,MAAAxD,QAAAw+F,GAAA,CACA,GAAA/gG,KAWA,OAVA+gG,GAAAtlG,QAAA,SAAA6uK,OACAj7I,KAAAi7I,IAGA,OAAAA,EACAtqK,EAAAyC,KAAA4nK,GAAAz5J,IAEA5Q,EAAAyC,KAAA4nK,GAAAz5J,GAAA,IAAAy5J,GAAAC,OAGAtqK,EAAA8d,KAAA,KAGA,MAAAusJ,IAAAz5J,GAAA,IAAAy5J,GAAAtpE,KACGp1F,OAAA,SAAA3F,GAAuB,MAAAA,GAAAtI,OAAA,IAAuBogB,KAAA,SACjD,OAAAipF,GAAA,IAAAA,EAAA,GAQA,QAAAwjE,GACAC,EACAt/E,EACAu/E,EACAC,GAEA,GAAAC,GAAAD,KAAAzsE,QAAAmsE,eACAR,GACA/8J,KAAAq+E,EAAAr+E,MAAA29J,KAAA39J,KACAmhI,KAAAw8B,KAAAx8B,SACAjkI,KAAAmhF,EAAAnhF,MAAA,IACAylG,KAAAtkB,EAAAskB,MAAA,GACAgR,MAAAt1B,EAAAs1B,UACA7rG,OAAAu2E,EAAAv2E,WACAi2J,SAAAC,EAAA3/E,EAAAy/E,GACAG,QAAAN,EAAAO,EAAAP,MAKA,OAHAC,KACAb,EAAAa,eAAAI,EAAAJ,EAAAE,IAEA3tK,OAAAuiI,OAAAqqC,GAQA,QAAAmB,GAAAP,GAEA,IADA,GAAAzjE,MACAyjE,GACAzjE,EAAAn7C,QAAA4+G,GACAA,IAAAvrK,MAEA,OAAA8nG,GAGA,QAAA8jE,GACAxpD,EACA2pD,GAEA,GAAAjhK,GAAAs3G,EAAAt3G,KACAy2G,EAAAa,EAAAb,UAAwB,KAAAA,SACxB,IAAAhR,GAAA6R,EAAA7R,SAAsB,KAAAA,MAAA,GAEtB,IAAAhiF,GAAAw9I,GAAAZ,CACA,QAAArgK,GAAA,KAAAyjB,EAAAgzF,GAAAhR,EAGA,QAAAy7D,GAAAlkK,EAAApK,GACA,MAAAA,KAAAuuK,GACAnkK,IAAApK,IACGA,IAEAoK,EAAAgD,MAAApN,EAAAoN,KAEHhD,EAAAgD,KAAAsyC,QAAA8uH,GAAA,MAAAxuK,EAAAoN,KAAAsyC,QAAA8uH,GAAA,KACApkK,EAAAyoG,OAAA7yG,EAAA6yG,MACA47D,EAAArkK,EAAAy5G,MAAA7jH,EAAA6jH,UAEGz5G,EAAA8F,OAAAlQ,EAAAkQ,QAEH9F,EAAA8F,OAAAlQ,EAAAkQ,MACA9F,EAAAyoG,OAAA7yG,EAAA6yG,MACA47D,EAAArkK,EAAAy5G,MAAA7jH,EAAA6jH,QACA4qD,EAAArkK,EAAA4N,OAAAhY,EAAAgY,UAOA,QAAAy2J,GAAArkK,EAAApK,OACA,KAAAoK,cACA,KAAApK,SAEA,IAAA0uK,GAAAruK,OAAA8rE,KAAA/hE,GACAukK,EAAAtuK,OAAA8rE,KAAAnsE,EACA,OAAA0uK,GAAA3tK,SAAA4tK,EAAA5tK,QAGA2tK,EAAAhoJ,MAAA,SAAAzS,GACA,GAAA26J,GAAAxkK,EAAA6J,GACA46J,EAAA7uK,EAAAiU,EAEA,uBAAA26J,IAAA,gBAAAC,GACAJ,EAAAG,EAAAC,GAEAxlE,OAAAulE,KAAAvlE,OAAAwlE,KAIA,QAAAC,GAAA95G,EAAAz7C,GACA,MAGA,KAFAy7C,EAAA5nD,KAAAsyC,QAAA8uH,GAAA,KAAAnoK,QACAkT,EAAAnM,KAAAsyC,QAAA8uH,GAAA,SAEAj1J,EAAAs5F,MAAA79C,EAAA69C,OAAAt5F,EAAAs5F,OACAk8D,EAAA/5G,EAAA6uD,MAAAtqG,EAAAsqG,OAIA,QAAAkrD,GAAA/5G,EAAAz7C,GACA,OAAAtF,KAAAsF,GACA,KAAAtF,IAAA+gD,IACA,QAGA,UA8GA,QAAAg6G,GAAArpK,GAEA,KAAAA,EAAAuoB,SAAAvoB,EAAAqoB,QAAAroB,EAAAspK,SAAAtpK,EAAA0oB,UAEA1oB,EAAAupK,sBAEAx8I,KAAA/sB,EAAAmU,QAAA,IAAAnU,EAAAmU,QAAA,CAEA,GAAAnU,EAAAwpK,eAAAxpK,EAAAwpK,cAAAxgK,aAAA,CAEA,iBAAAqoC,KADArxC,EAAAwpK,cAAAxgK,aAAA,WACqC,OAMrC,MAHAhJ,GAAAqzD,gBACArzD,EAAAqzD,kBAEA,GAGA,QAAAo2G,GAAAxkI,GACA,GAAAA,EAEA,OADAY,GACA7nC,EAAA,EAAmBA,EAAAinC,EAAA7pC,OAAqB4C,IAAA,CAExC,GADA6nC,EAAAZ,EAAAjnC,GACA,MAAA6nC,EAAAylE,IACA,MAAAzlE,EAEA,IAAAA,EAAAZ,WAAAY,EAAA4jI,EAAA5jI,EAAAZ,WACA,MAAAY,IAQA,QAAAg2E,GAAAL,GACA,IAAAK,EAAA6tD,UAAA,CACA7tD,EAAA6tD,WAAA,EAEApzB,GAAA96B,CAEA,IAAAvY,GAAA,SAAA3zF,GAA4B,WAAAyd,KAAAzd,GAE5Bq6J,EAAA,SAAA/jE,EAAAgkE,GACA,GAAA5rK,GAAA4nG,EAAAkF,SAAA8G,YACA3O,GAAAjlG,IAAAilG,EAAAjlG,IAAA2J,OAAAs7F,EAAAjlG,IAAA6rK,wBACA7rK,EAAA4nG,EAAAgkE,GAIApuD,GAAAO,OACAxf,aAAA,WACA0G,EAAAlrG,KAAA+yG,SAAAs9D,SACArwK,KAAA+xK,YAAA/xK,KACAA,KAAAgyK,QAAAhyK,KAAA+yG,SAAAs9D,OACArwK,KAAAgyK,QAAA7rJ,KAAAnmB,MACAyjH,EAAAknB,KAAAC,eAAA5qI,KAAA,SAAAA,KAAAgyK,QAAAC,QAAA36G,UAEAt3D,KAAA+xK,YAAA/xK,KAAAk4G,SAAAl4G,KAAAk4G,QAAA65D,aAAA/xK,KAEA4xK,EAAA5xK,YAEAwqI,UAAA,WACAonC,EAAA5xK,SAIA2C,OAAAi+F,eAAA6iB,EAAAtjH,UAAA,WACAuS,IAAA,WAA0B,MAAA1S,MAAA+xK,YAAAC,WAG1BrvK,OAAAi+F,eAAA6iB,EAAAtjH,UAAA,UACAuS,IAAA,WAA0B,MAAA1S,MAAA+xK,YAAAG,UAG1BzuD,EAAA5M,UAAA,cAAAs7D,IACA1uD,EAAA5M,UAAA,cAAAu7D,GAEA,IAAA1gE,GAAA+R,EAAA/hH,OAAAijI,qBAEAjzB,GAAA2gE,iBAAA3gE,EAAA4gE,iBAAA5gE,EAAA6gE,kBAAA7gE,EAAA64B,SASA,QAAAioC,GACAC,EACA76H,EACAznC,GAEA,GAAAuiK,GAAAD,EAAAl3H,OAAA,EACA,UAAAm3H,EACA,MAAAD,EAGA,UAAAC,GAAA,MAAAA,EACA,MAAA96H,GAAA66H,CAGA,IAAA7jF,GAAAh3C,EAAAtlC,MAAA,IAKAnC,IAAAy+E,IAAAvrF,OAAA,IACAurF,EAAAzjF,KAKA,QADAs1B,GAAAgyI,EAAAzwH,QAAA,UAAA1vC,MAAA,KACArM,EAAA,EAAiBA,EAAAw6B,EAAAp9B,OAAqB4C,IAAA,CACtC,GAAA+gC,GAAAvG,EAAAx6B,EACA,QAAA+gC,EACA4nD,EAAAzjF,MACK,MAAA67B,GACL4nD,EAAAxmF,KAAA4+B,GASA,MAJA,KAAA4nD,EAAA,IACAA,EAAAr9B,QAAA,IAGAq9B,EAAAnrE,KAAA,KAGA,QAAAiqF,GAAAh+F,GACA,GAAAylG,GAAA,GACAgR,EAAA,GAEAwsD,EAAAjjK,EAAA/G,QAAA,IACAgqK,IAAA,IACAx9D,EAAAzlG,EAAAlG,MAAAmpK,GACAjjK,IAAAlG,MAAA,EAAAmpK,GAGA,IAAAC,GAAAljK,EAAA/G,QAAA,IAMA,OALAiqK,IAAA,IACAzsD,EAAAz2G,EAAAlG,MAAAopK,EAAA,GACAljK,IAAAlG,MAAA,EAAAopK,KAIAljK,OACAy2G,QACAhR,QAIA,QAAA09D,GAAAnjK,GACA,MAAAA,GAAAsyC,QAAA,aAyCA,QAAAt/B,GAAAopF,EAAAlI,GAQA,IAPA,GAKA8I,GALA+qB,KACAlhH,EAAA,EACA3O,EAAA,EACA8H,EAAA,GACAojK,EAAAlvE,KAAAv0B,WAAA,IAGA,OAAAq9B,EAAAqmE,GAAAj2J,KAAAgvF,KAAA,CACA,GAAA52F,GAAAw3F,EAAA,GACAsmE,EAAAtmE,EAAA,GACAv+F,EAAAu+F,EAAA9kG,KAKA,IAJA8H,GAAAo8F,EAAAtiG,MAAA5B,EAAAuG,GACAvG,EAAAuG,EAAA+G,EAAA7R,OAGA2vK,EACAtjK,GAAAsjK,EAAA,OADA,CAKA,GAAA3xK,GAAAyqG,EAAAlkG,GACA4uD,EAAAk2C,EAAA,GACAl6F,EAAAk6F,EAAA,GACAt3F,EAAAs3F,EAAA,GACAx4F,EAAAw4F,EAAA,GACAumE,EAAAvmE,EAAA,GACAwmE,EAAAxmE,EAAA,EAGAh9F,KACA+nH,EAAArvH,KAAAsH,GACAA,EAAA,GAGA,IAAAyjK,GAAA,MAAA38G,GAAA,MAAAn1D,OAAAm1D,EACAk1F,EAAA,MAAAunB,GAAA,MAAAA,EACA7hI,EAAA,MAAA6hI,GAAA,MAAAA,EACA5jG,EAAAq9B,EAAA,IAAAomE,EACAjuD,EAAAzvG,GAAAlB,CAEAujH,GAAArvH,MACAoK,QAAA+D,IACAigD,UAAA,GACA6Y,YACAj+B,WACAs6G,SACAynB,UACAD,aACAruD,UAAAuuD,EAAAvuD,GAAAquD,EAAA,UAAAG,EAAAhkG,GAAA,SAcA,MATAznE,GAAAkkG,EAAAzoG,SACAqM,GAAAo8F,EAAAwnE,OAAA1rK,IAIA8H,GACA+nH,EAAArvH,KAAAsH,GAGA+nH,EAUA,QAAAwM,GAAAn4B,EAAAlI,GACA,MAAA2vE,GAAA7wJ,EAAAopF,EAAAlI,IASA,QAAA4vE,GAAA1nE,GACA,MAAA8rC,WAAA9rC,GAAA9pD,QAAA,mBAAArvC,GACA,UAAAA,EAAA0oC,WAAA,GAAAtnC,SAAA,IAAA4hE,gBAUA,QAAA89F,GAAA3nE,GACA,MAAA8rC,WAAA9rC,GAAA9pD,QAAA,iBAAArvC,GACA,UAAAA,EAAA0oC,WAAA,GAAAtnC,SAAA,IAAA4hE,gBAOA,QAAA49F,GAAA97C,GAKA,OAHA9gE,GAAA,GAAAjrD,OAAA+rH,EAAAp0H,QAGA4C,EAAA,EAAiBA,EAAAwxH,EAAAp0H,OAAmB4C,IACpC,gBAAAwxH,GAAAxxH,KACA0wD,EAAA1wD,GAAA,GAAAi8C,QAAA,OAAAu1E,EAAAxxH,GAAA4+G,QAAA,MAIA,iBAAAvZ,EAAA8Q,GAMA,OALA1sG,GAAA,GACAE,EAAA07F,MACA1H,EAAAwY,MACA4zD,EAAApsE,EAAA8vE,OAAAF,EAAAG,mBAEA1tK,EAAA,EAAmBA,EAAAwxH,EAAAp0H,OAAmB4C,IAAA,CACtC,GAAAupE,GAAAioD,EAAAxxH,EAEA,oBAAAupE,GAAA,CAMA,GACAxoC,GADAhlC,EAAA4N,EAAA4/D,EAAAh9D,KAGA,UAAAxQ,EAAA,CACA,GAAAwtE,EAAAp+B,SAAA,CAEAo+B,EAAA2jG,UACAzjK,GAAA8/D,EAAAhZ,OAGA,UAEA,SAAA5vD,WAAA,aAAA4oE,EAAAh9D,KAAA,mBAIA,GAAAgnE,GAAAx3E,GAAA,CACA,IAAAwtE,EAAAk8E,OACA,SAAA9kJ,WAAA,aAAA4oE,EAAAh9D,KAAA,kCAAA0gB,KAAAC,UAAAnxB,GAAA,IAGA,QAAAA,EAAAqB,OAAA,CACA,GAAAmsE,EAAAp+B,SACA,QAEA,UAAAxqC,WAAA,aAAA4oE,EAAAh9D,KAAA,qBAIA,OAAAyC,GAAA,EAAuBA,EAAAjT,EAAAqB,OAAkB4R,IAAA,CAGzC,GAFA+xB,EAAAgpI,EAAAhuK,EAAAiT,KAEA0hD,EAAA1wD,GAAAqzC,KAAAtS,GACA,SAAApgC,WAAA,iBAAA4oE,EAAAh9D,KAAA,eAAAg9D,EAAAq1C,QAAA,oBAAA3xF,KAAAC,UAAA6T,GAAA,IAGAt3B,KAAA,IAAAuF,EAAAu6D,EAAAhZ,OAAAgZ,EAAAH,WAAAroC,OApBA,CA4BA,GAFAA,EAAAwoC,EAAA0jG,SAAAO,EAAAzxK,GAAAguK,EAAAhuK,IAEA20D,EAAA1wD,GAAAqzC,KAAAtS,GACA,SAAApgC,WAAA,aAAA4oE,EAAAh9D,KAAA,eAAAg9D,EAAAq1C,QAAA,oBAAA79E,EAAA,IAGAt3B,IAAA8/D,EAAAhZ,OAAAxvB,OArDAt3B,IAAA8/D,EAwDA,MAAA9/D,IAUA,QAAA2jK,GAAAvnE,GACA,MAAAA,GAAA9pD,QAAA,6BAAmC,QASnC,QAAAoxH,GAAAl/J,GACA,MAAAA,GAAA8tC,QAAA,wBAUA,QAAA4xH,GAAA/9I,EAAA44C,GAEA,MADA54C,GAAA44C,OACA54C,EASA,QAAAg+I,GAAAjwE,GACA,MAAAA,GAAAkwE,UAAA,OAUA,QAAAC,GAAArkK,EAAA++D,GAEA,GAAAzzD,GAAAtL,EAAAnP,OAAAq1B,MAAA,YAEA,IAAA5a,EACA,OAAA/U,GAAA,EAAmBA,EAAA+U,EAAA3X,OAAmB4C,IACtCwoE,EAAArmE,MACAoK,KAAAvM,EACAuwD,OAAA,KACA6Y,UAAA,KACAj+B,UAAA,EACAs6G,QAAA,EACAynB,SAAA,EACAD,UAAA,EACAruD,QAAA,MAKA,OAAA+uD,GAAAlkK,EAAA++D,GAWA,QAAAulG,GAAAtkK,EAAA++D,EAAAm1B,GAGA,OAFAksE,MAEA7pK,EAAA,EAAiBA,EAAAyJ,EAAArM,OAAiB4C,IAClC6pK,EAAA1nK,KAAA6rK,EAAAvkK,EAAAzJ,GAAAwoE,EAAAm1B,GAAArjG,OAKA,OAAAqzK,GAFA,GAAA1xH,QAAA,MAAA4tH,EAAArsJ,KAAA,SAAAowJ,EAAAjwE,IAEAn1B,GAWA,QAAAylG,GAAAxkK,EAAA++D,EAAAm1B,GACA,MAAAuwE,GAAAzxJ,EAAAhT,EAAAk0F,GAAAn1B,EAAAm1B,GAWA,QAAAuwE,GAAA18C,EAAAhpD,EAAAm1B,GACApqB,GAAA/K,KACAm1B,EAAiCn1B,GAAAm1B,EACjCn1B,MAGAm1B,OAOA,QALAwwE,GAAAxwE,EAAAwwE,OACApwJ,GAAA,IAAA4/E,EAAA5/E,IACAurJ,EAAA,GAGAtpK,EAAA,EAAiBA,EAAAwxH,EAAAp0H,OAAmB4C,IAAA,CACpC,GAAAupE,GAAAioD,EAAAxxH,EAEA,oBAAAupE,GACA+/F,GAAA8D,EAAA7jG,OACK,CACL,GAAAhZ,GAAA68G,EAAA7jG,EAAAhZ,QACAphD,EAAA,MAAAo6D,EAAAq1C,QAAA,GAEAp2C,GAAArmE,KAAAonE,GAEAA,EAAAk8E,SACAt2I,GAAA,MAAAohD,EAAAphD,EAAA,MAOAA,EAJAo6D,EAAAp+B,SACAo+B,EAAA2jG,QAGA38G,EAAA,IAAAphD,EAAA,KAFA,MAAAohD,EAAA,IAAAphD,EAAA,MAKAohD,EAAA,IAAAphD,EAAA,IAGAm6J,GAAAn6J,GAIA,GAAAi6D,GAAAgkG,EAAAzvE,EAAAv0B,WAAA,KACAglG,EAAA9E,EAAA/lK,OAAA6lE,EAAAhsE,UAAAgsE,CAkBA,OAZA+kG,KACA7E,GAAA8E,EAAA9E,EAAA/lK,MAAA,GAAA6lE,EAAAhsE,QAAAksK,GAAA,MAAAlgG,EAAA,WAIAkgG,GADAvrJ,EACA,IAIAowJ,GAAAC,EAAA,SAAAhlG,EAAA,MAGAukG,EAAA,GAAA1xH,QAAA,IAAAqtH,EAAAsE,EAAAjwE,IAAAn1B,GAeA,QAAAwlG,GAAAvkK,EAAA++D,EAAAm1B,GAQA,MAPApqB,IAAA/K,KACAm1B,EAAiCn1B,GAAAm1B,EACjCn1B,MAGAm1B,QAEAl0F,YAAAwyC,QACA6xH,EAAArkK,EAAkD,GAGlD8pE,GAAA9pE,GACAskK,EAA2C,EAA8B,EAAApwE,GAGzEswE,EAA0C,EAA8B,EAAAtwE,GAYxE,QAAA0wE,GACA5kK,EACA4K,EACAi6J,GAEA,IAIA,OAFAC,GAAA9kK,KACA8kK,GAAA9kK,GAAA9H,GAAAq8H,QAAAv0H,KACA4K,OAAiCo5J,QAAA,IAC9B,MAAAzrK,GAIH,UAMA,QAAAwsK,GACAC,EACAC,EACAC,EACAC,GAGA,GAAAC,GAAAH,MACAI,EAAAH,GAAAjyK,OAAAR,OAAA,MACA6yK,EAAAH,GAAAlyK,OAAAR,OAAA,KAEAuyK,GAAAtzK,QAAA,SAAAmuK,GACA0F,EAAAH,EAAAC,EAAAC,EAAAzF,IAIA,QAAAtpK,GAAA,EAAAkY,EAAA22J,EAAAzxK,OAAsC4C,EAAAkY,EAAOlY,IAC7C,MAAA6uK,EAAA7uK,KACA6uK,EAAA1sK,KAAA0sK,EAAAlsK,OAAA3C,EAAA,OACAkY,IACAlY,IAIA,QACA6uK,WACAC,UACAC,WAIA,QAAAC,GACAH,EACAC,EACAC,EACAzF,EACA3qK,EACAswK,GAEA,GAAAxlK,GAAA6/J,EAAA7/J,KACA8C,EAAA+8J,EAAA/8J,KAUA2iK,EAAAC,EAAA1lK,EAAA9K,GACAywK,EAAA9F,EAAA8F,uBAEA,kBAAA9F,GAAA+F,gBACAD,EAAAvB,UAAAvE,EAAA+F,cAGA,IAAAnF,IACAzgK,KAAAylK,EACAI,MAAAC,EAAAL,EAAAE,GACAtyD,WAAAwsD,EAAAxsD,aAAqCpf,QAAA4rE,EAAA14D,WACrC4+D,aACAjjK,OACA5N,SACAswK,UACAQ,SAAAnG,EAAAmG,SACAxiD,YAAAq8C,EAAAr8C,YACAygB,KAAA47B,EAAA57B,SACA5iC,MAAA,MAAAw+D,EAAAx+D,SAEAw+D,EAAAxsD,WACAwsD,EAAAx+D,OACWpN,QAAA4rE,EAAAx+D,OA2BX,IAxBAw+D,EAAAriI,UAgBAqiI,EAAAriI,SAAA9rC,QAAA,SAAA0sC,GACA,GAAA6nI,GAAAT,EACArC,EAAAqC,EAAA,IAAApnI,EAAA,UACA9Y,EACAigJ,GAAAH,EAAAC,EAAAC,EAAAlnI,EAAAqiI,EAAAwF,SAIA3gJ,KAAAu6I,EAAA1xC,MAAA,EACAnyH,MAAAxD,QAAAqnK,EAAA1xC,OACA0xC,EAAA1xC,OACA0xC,EAAA1xC,QAEAz8H,QAAA,SAAAy8H,GACA,GAAA+3C,IACAlmK,KAAAmuH,EACA3wF,SAAAqiI,EAAAriI,SAEA+nI,GACAH,EACAC,EACAC,EACAY,EACAhxK,EACAurK,EAAAzgK,MAAA,OAKAqlK,EAAA5E,EAAAzgK,QACAolK,EAAA1sK,KAAA+nK,EAAAzgK,MACAqlK,EAAA5E,EAAAzgK,MAAAygK,GAGA39J,IACAwiK,EAAAxiK,KACAwiK,EAAAxiK,GAAA29J,IAWA,QAAAqF,GAAA9lK,EAAA2lK,GACA,GAAAE,GAAA3tK,GAAA8H,KAAA2lK,EAQA,OAAAE,GAGA,QAAAH,GAAA1lK,EAAA9K,GAEA,MADA8K,KAAAsyC,QAAA,UACA,MAAAtyC,EAAA,GAAwBA,EACxB,MAAA9K,EAAuB8K,EACvBmjK,EAAAjuK,EAAA,SAAA8K,GAMA,QAAAmmK,GACAvuC,EACAhwE,EACAnnD,EACAkgK,GAEA,GAAAhvK,GAAA,gBAAAimI,IAAwC53H,KAAA43H,GAAYA,CAEpD,IAAAjmI,EAAAmR,MAAAnR,EAAAy0K,YACA,MAAAz0K,EAIA,KAAAA,EAAAqO,MAAArO,EAAAiZ,QAAAg9C,EAAA,CACAj2D,EAAAg0J,KAAoBh0J,GACpBA,EAAAy0K,aAAA,CACA,IAAAx7J,GAAA+6I,OAAiC/9F,EAAAh9C,QAAAjZ,EAAAiZ,OACjC,IAAAg9C,EAAA9kD,KACAnR,EAAAmR,KAAA8kD,EAAA9kD,KACAnR,EAAAiZ,aACK,IAAAg9C,EAAAm5G,QAAAptK,OAAA,CACL,GAAA0yK,GAAAz+G,EAAAm5G,QAAAn5G,EAAAm5G,QAAAptK,OAAA,GAAAqM,IACArO,GAAAqO,KAAA4kK,EAAAyB,EAAAz7J,EAAA,QAAAg9C,EAAA,MAIA,MAAAj2D,GAGA,GAAA20K,GAAAtoE,EAAArsG,EAAAqO,MAAA,IACAumK,EAAA3+G,KAAA5nD,MAAA,IACAA,EAAAsmK,EAAAtmK,KACA8iK,EAAAwD,EAAAtmK,KAAAumK,EAAA9lK,GAAA9O,EAAA8O,QACA8lK,EAEA9vD,EAAAqpD,EACAwG,EAAA7vD,MACA9kH,EAAA8kH,MACAkqD,KAAAzsE,QAAAgsE,YAGAz6D,EAAA9zG,EAAA8zG,MAAA6gE,EAAA7gE,IAKA,OAJAA,IAAA,MAAAA,EAAA55D,OAAA,KACA45D,EAAA,IAAAA,IAIA2gE,aAAA,EACApmK,OACAy2G,QACAhR,QAIA,QAAAkgD,GAAA3oJ,EAAApK,GACA,OAAAiU,KAAAjU,GACAoK,EAAA6J,GAAAjU,EAAAiU,EAEA,OAAA7J,GAMA,QAAAwpK,GACAxB,EACArE,GAOA,QAAA8F,GAAAzB,GACAD,EAAAC,EAAAI,EAAAC,EAAAC,GAGA,QAAAp/I,GACA0xG,EACA8uC,EACAhG,GAEA,GAAAv/E,GAAAglF,EAAAvuC,EAAA8uC,GAAA,EAAA/F,GACA79J,EAAAq+E,EAAAr+E,IAEA,IAAAA,EAAA,CACA,GAAA29J,GAAA6E,EAAAxiK,EAIA,KAAA29J,EAAoB,MAAAkG,GAAA,KAAAxlF,EACpB,IAAAylF,GAAAnG,EAAAoF,MAAA9mG,KACAn9D,OAAA,SAAAiF,GAAgC,OAAAA,EAAA66B,WAChC7+B,IAAA,SAAAgE,GAA6B,MAAAA,GAAA/D,MAM7B,IAJA,gBAAAq+E,GAAAv2E,SACAu2E,EAAAv2E,WAGA87J,GAAA,gBAAAA,GAAA97J,OACA,OAAA/D,KAAA6/J,GAAA97J,SACA/D,IAAAs6E,GAAAv2E,SAAAg8J,EAAA3tK,QAAA4N,IAAA,IACAs6E,EAAAv2E,OAAA/D,GAAA6/J,EAAA97J,OAAA/D,GAKA,IAAA45J,EAEA,MADAt/E,GAAAnhF,KAAA4kK,EAAAnE,EAAAzgK,KAAAmhF,EAAAv2E,OAAA,gBAAA9H,EAAA,KACA6jK,EAAAlG,EAAAt/E,EAAAu/E,OAEK,IAAAv/E,EAAAnhF,KAAA,CACLmhF,EAAAv2E,SACA,QAAArU,GAAA,EAAqBA,EAAA6uK,EAAAzxK,OAAqB4C,IAAA,CAC1C,GAAAyJ,GAAAolK,EAAA7uK,GACAswK,EAAAxB,EAAArlK,EACA,IAAA8mK,EAAAD,EAAAhB,MAAA1kF,EAAAnhF,KAAAmhF,EAAAv2E,QACA,MAAA+7J,GAAAE,EAAA1lF,EAAAu/E,IAKA,MAAAiG,GAAA,KAAAxlF,GAGA,QAAA6kF,GACAvF,EACAt/E,GAEA,GAAA4lF,GAAAtG,EAAAuF,SACAA,EAAA,kBAAAe,GACAA,EAAAvG,EAAAC,EAAAt/E,EAAA,KAAAw/E,IACAoG,CAMA,IAJA,gBAAAf,KACAA,GAAkBhmK,KAAAgmK,KAGlBA,GAAA,gBAAAA,GAMA,MAAAW,GAAA,KAAAxlF,EAGA,IAAAh7D,GAAA6/I,EACAljK,EAAAqjB,EAAArjB,KACA9C,EAAAmmB,EAAAnmB,KACAy2G,EAAAt1B,EAAAs1B,MACAhR,EAAAtkB,EAAAskB,KACA76F,EAAAu2E,EAAAv2E,MAKA,IAJA6rG,EAAAtwF,EAAAnzB,eAAA,SAAAmzB,EAAAswF,QACAhR,EAAAt/E,EAAAnzB,eAAA,QAAAmzB,EAAAs/E,OACA76F,EAAAub,EAAAnzB,eAAA,UAAAmzB,EAAAvb,SAEA9H,EAAA,CAEAwiK,EAAAxiK,EAIA,OAAAojB,IACAkgJ,aAAA,EACAtjK,OACA2zG,QACAhR,OACA76F,cACO0a,GAAA67D,GACF,GAAAnhF,EAAA,CAEL,GAAAqmK,GAAAW,EAAAhnK,EAAAygK,EAIA,OAAAv6I,IACAkgJ,aAAA,EACApmK,KAJA4kK,EAAAyB,EAAAz7J,EAAA,6BAAAy7J,EAAA,KAKA5vD,QACAhR,YACOngF,GAAA67D,GAKP,MAAAwlF,GAAA,KAAAxlF,GAIA,QAAAgtC,GACAsyC,EACAt/E,EACAqkF,GAEA,GAAAyB,GAAArC,EAAAY,EAAArkF,EAAAv2E,OAAA,4BAAA46J,EAAA,KACA0B,EAAAhhJ,GACAkgJ,aAAA,EACApmK,KAAAinK,GAEA,IAAAC,EAAA,CACA,GAAAnG,GAAAmG,EAAAnG,QACAoG,EAAApG,IAAAptK,OAAA,EAEA,OADAwtF,GAAAv2E,OAAAs8J,EAAAt8J,OACA+7J,EAAAQ,EAAAhmF,GAEA,MAAAwlF,GAAA,KAAAxlF,GAGA,QAAAwlF,GACAlG,EACAt/E,EACAu/E,GAEA,MAAAD,MAAAuF,SACAA,EAAAvF,EAAAC,GAAAv/E,GAEAs/E,KAAA+E,QACAr3C,EAAAsyC,EAAAt/E,EAAAs/E,EAAA+E,SAEAhF,EAAAC,EAAAt/E,EAAAu/E,EAAAC,GAxJA,GAAArpD,GAAAytD,EAAAC,GACAI,EAAA9tD,EAAA8tD,SACAC,EAAA/tD,EAAA+tD,QACAC,EAAAhuD,EAAAguD,OAwJA,QACAp/I,QACAugJ,aAIA,QAAAK,GACAjB,EACA7lK,EACA4K,GAEA,GAAApF,GAAAxF,EAAAkmB,MAAA2/I,EAEA,KAAArgK,EACA,QACG,KAAAoF,EACH,QAGA,QAAArU,GAAA,EAAAC,EAAAgP,EAAA7R,OAAiC4C,EAAAC,IAASD,EAAA,CAC1C,GAAAsQ,GAAAg/J,EAAA9mG,KAAAxoE,EAAA,GACAygG,EAAA,gBAAAxxF,GAAAjP,GAAA6wK,mBAAA5hK,EAAAjP,IAAAiP,EAAAjP,EACAsQ,KACA+D,EAAA/D,EAAA/D,MAAAk0F,GAIA,SAGA,QAAAgwE,GAAAhnK,EAAAygK,GACA,MAAAqC,GAAA9iK,EAAAygK,EAAAvrK,OAAAurK,EAAAvrK,OAAA8K,KAAA,QAQA,QAAAqnK,KACAltK,OAAA2L,iBAAA,oBAAAvN,GACA+uK,IACA/uK,EAAAsD,OAAAtD,EAAAsD,MAAAgL,KACA0gK,GAAAhvK,EAAAsD,MAAAgL,OAKA,QAAA2gK,GACA7G,EACA1wI,EACAD,EACAy3I,GAEA,GAAA9G,EAAA+G,IAAA,CAIA,GAAAC,GAAAhH,EAAAzsE,QAAA0zE,cACAD,IASAhH,EAAA+G,IAAA9tC,UAAA,WACA,GAAA95H,GAAA+nK,IACAC,EAAAH,EAAA13I,EAAAD,EAAAy3I,EAAA3nK,EAAA,KACA,IAAAgoK,EAAA,CAGA,GAAA1wK,GAAA,gBAAA0wK,EACA,IAAA1wK,GAAA,gBAAA0wK,GAAAzrK,SAAA,CACA,GAAA8sG,GAAA7lG,SAAAilD,cAAAu/G,EAAAzrK,SACA,IAAA8sG,EAAA,CACA,GAAA1qG,GAAAqpK,EAAArpK,QAAA,gBAAAqpK,GAAArpK,OAAAqpK,EAAArpK,SACAA,GAAAspK,EAAAtpK,GACAqB,EAAAkoK,EAAA7+D,EAAA1qG,OACOwpK,GAAAH,KACPhoK,EAAAooK,EAAAJ,QAEK1wK,IAAA6wK,EAAAH,KACLhoK,EAAAooK,EAAAJ,GAGAhoK,IACA3F,OAAAguK,SAAAroK,EAAA7D,EAAA6D,EAAAzB,OAKA,QAAAipK,KACA,GAAAzgK,GAAAuhK,IACAvhK,KACAwhK,GAAAxhK,IACA5K,EAAA9B,OAAAmuK,YACAjqK,EAAAlE,OAAAouK,cAKA,QAAAV,KACA,GAAAhhK,GAAAuhK,IACA,IAAAvhK,EACA,MAAAwhK,IAAAxhK,GAIA,QAAAmhK,GAAA7+D,EAAA1qG,GACA,GAAA+pK,GAAAllK,SAAAK,gBACA8kK,EAAAD,EAAApgH,wBACAsgH,EAAAv/D,EAAA/gD,uBACA,QACAnsD,EAAAysK,EAAAjnK,KAAAgnK,EAAAhnK,KAAAhD,EAAAxC,EACAoC,EAAAqqK,EAAAznK,IAAAwnK,EAAAxnK,IAAAxC,EAAAJ,GAIA,QAAA4pK,GAAArsE,GACA,MAAA+sE,IAAA/sE,EAAA3/F,IAAA0sK,GAAA/sE,EAAAv9F,GAGA,QAAA6pK,GAAAtsE,GACA,OACA3/F,EAAA0sK,GAAA/sE,EAAA3/F,GAAA2/F,EAAA3/F,EAAA9B,OAAAmuK,YACAjqK,EAAAsqK,GAAA/sE,EAAAv9F,GAAAu9F,EAAAv9F,EAAAlE,OAAAouK,aAIA,QAAAR,GAAAnsE,GACA,OACA3/F,EAAA0sK,GAAA/sE,EAAA3/F,GAAA2/F,EAAA3/F,EAAA,EACAoC,EAAAsqK,GAAA/sE,EAAAv9F,GAAAu9F,EAAAv9F,EAAA,GAIA,QAAAsqK,IAAA9gK,GACA,sBAAAA,GA2BA,QAAA+gK,MACA,MAAAC,IAAAj0J,MAAAoxD,QAAA,GAGA,QAAAoiG,MACA,MAAAU,IAGA,QAAAvB,IAAA1gK,GACAiiK,GAAAjiK,EAGA,QAAAkiK,IAAAn1F,EAAAthC,GACAg1H,GAGA,IAAA/E,GAAApoK,OAAAooK,OACA,KACAjwH,EACAiwH,EAAAyG,cAA4BniK,IAAAiiK,IAAY,GAAAl1F,IAExCk1F,GAAAF,KACArG,EAAAwG,WAAyBliK,IAAAiiK,IAAY,GAAAl1F,IAElC,MAAAr7E,GACH4B,OAAAgnF,SAAA7uC,EAAA,oBAAAshC,IAIA,QAAAo1F,IAAAp1F,GACAm1F,GAAAn1F,GAAA,GAKA,QAAAq1F,IAAA9jI,EAAAlwC,EAAAs7B,GACA,GAAAnzB,GAAA,SAAAlF,GACAA,GAAAitC,EAAAxxC,OACA48B,IAEA4U,EAAAjtC,GACAjD,EAAAkwC,EAAAjtC,GAAA,WACAkF,EAAAlF,EAAA,KAGAkF,EAAAlF,EAAA,GAIAkF,GAAA,GAKA,QAAA8rK,IAAAnI,GACA,gBAAA9wI,EAAAD,EAAAr+B,GACA,GAAAw3K,IAAA,EACA/2E,EAAA,EACArhG,EAAA,IAEAq4K,IAAArI,EAAA,SAAAnjE,EAAA97F,EAAAokB,EAAArf,GAMA,qBAAA+2F,QAAAt4E,KAAAs4E,EAAAqR,IAAA,CACAk6D,GAAA,EACA/2E,GAEA,IA0BA4K,GA1BA7qG,EAAAsrG,GAAA,SAAA4rE,GACAA,EAAAjjE,YAAAijE,EAAAp1E,UACAo1E,IAAAp1E,SAGA2J,EAAA+I,SAAA,kBAAA0iE,GACAA,EACAx6B,GAAA/hI,OAAAu8J,GACAnjJ,EAAAmtF,WAAAxsG,GAAAwiK,IACAj3E,GACA,GACAzgG,MAIAS,EAAAqrG,GAAA,SAAAyJ,GACA,GAAA7vG,GAAA,qCAAAwP,EAAA,KAAAqgG,CAEAn2G,KACAA,EAAA4uK,EAAAz4D,GACAA,EACA,GAAAh1G,OAAAmF,GACA1F,EAAAZ,KAKA,KACAisG,EAAAY,EAAAzrG,EAAAC,GACS,MAAAmG,GACTnG,EAAAmG,GAEA,GAAAykG,EACA,qBAAAA,GAAArmG,KACAqmG,EAAArmG,KAAAxE,EAAAC,OACW,CAEX,GAAA+zG,GAAAnJ,EAAAmK,SACAhB,IAAA,kBAAAA,GAAAxvG,MACAwvG,EAAAxvG,KAAAxE,EAAAC,OAOA+2K,GAAoBx3K,KAIpB,QAAAy3K,IACArI,EACA9rK,GAEA,MAAAq0K,IAAAvI,EAAAl+J,IAAA,SAAA2C,GACA,MAAAvS,QAAA8rE,KAAAv5D,EAAA6tG,YAAAxwG,IAAA,SAAAgE,GAAyD,MAAA5R,GACzDuQ,EAAA6tG,WAAAxsG,GACArB,EAAAugK,UAAAl/J,GACArB,EAAAqB,QAKA,QAAAyiK,IAAAhtE,GACA,MAAAtgG,OAAAvL,UAAAiH,OAAApC,SAAAgnG,GAOA,QAAAmB,IAAAxoG,GACA,GAAAyoG,IAAA,CACA,mBAEA,IADA,GAAAz3F,MAAAzP,EAAA9C,UAAAC,OACA6C,KAAAyP,EAAAzP,GAAA9C,UAAA8C,EAEA,KAAAknG,EAEA,MADAA,IAAA,EACAzoG,EAAAK,MAAAhF,KAAA2V,IA0KA,QAAAsjK,IAAArhI,GACA,IAAAA,EACA,GAAAo2D,GAAA,CAEA,GAAAkrE,GAAAlmK,SAAAilD,cAAA,OACArgB,GAAAshI,KAAAjoK,aAAA,aAEA2mC,IAAAoK,QAAA,6BAEApK,GAAA,GAQA,OAJA,MAAAA,EAAA2D,OAAA,KACA3D,EAAA,IAAAA,GAGAA,EAAAoK,QAAA,UAGA,QAAAm3H,IACA7hH,EACAj2D,GAEA,GAAA4E,GACA+G,EAAAD,KAAAC,IAAAsqD,EAAAj0D,OAAAhC,EAAAgC,OACA,KAAA4C,EAAA,EAAaA,EAAA+G,GACbsqD,EAAArxD,KAAA5E,EAAA4E,GADsBA,KAKtB,OACAkrI,QAAA9vI,EAAAmI,MAAA,EAAAvD,GACAmzK,UAAA/3K,EAAAmI,MAAAvD,GACAozK,YAAA/hH,EAAA9tD,MAAAvD,IAIA,QAAAqzK,IACAC,EACA/mK,EACAlO,EACAm/B,GAEA,GAAA+1I,GAAAV,GAAAS,EAAA,SAAAjsE,EAAA8/D,EAAAx3I,EAAArf,GACA,GAAAkjK,GAAAC,GAAApsE,EAAA96F,EACA,IAAAinK,EACA,MAAA/tK,OAAAxD,QAAAuxK,GACAA,EAAAlnK,IAAA,SAAAknK,GAAsC,MAAAn1K,GAAAm1K,EAAArM,EAAAx3I,EAAArf,KACtCjS,EAAAm1K,EAAArM,EAAAx3I,EAAArf,IAGA,OAAAyiK,IAAAv1I,EAAA+1I,EAAA/1I,UAAA+1I,GAGA,QAAAE,IACApsE,EACA/2F,GAMA,MAJA,kBAAA+2F,KAEAA,EAAAixC,GAAA/hI,OAAA8wF,IAEAA,EAAA1J,QAAArtF,GAGA,QAAAojK,IAAAN,GACA,MAAAC,IAAAD,EAAA,mBAAAO,IAAA,GAGA,QAAAC,IAAA1oC,GACA,MAAAmoC,IAAAnoC,EAAA,oBAAAyoC,IAGA,QAAAA,IAAAH,EAAArM,GACA,GAAAA,EACA,kBACA,MAAAqM,GAAAz0K,MAAAooK,EAAAhqK,YAKA,QAAA02K,IACAV,EACApwC,EACA+wC,GAEA,MAAAT,IAAAF,EAAA,4BAAAK,EAAAjoK,EAAAokB,EAAArf,GACA,MAAAyjK,IAAAP,EAAA7jJ,EAAArf,EAAAyyH,EAAA+wC,KAIA,QAAAC,IACAP,EACA7jJ,EACArf,EACAyyH,EACA+wC,GAEA,gBAAAp6I,EAAAD,EAAAr+B,GACA,MAAAo4K,GAAA95I,EAAAD,EAAA,SAAAO,GACA5+B,EAAA4+B,GACA,kBAAAA,IACA+oG,EAAA5gI,KAAA,WAMA6xK,GAAAh6I,EAAArK,EAAA6/I,UAAAl/J,EAAAwjK,QAOA,QAAAE,IACAh6I,EACAw1I,EACAl/J,EACAwjK,GAEAtE,EAAAl/J,GACA0pB,EAAAw1I,EAAAl/J,IACGwjK,KACHzzK,WAAA,WACA2zK,GAAAh6I,EAAAw1I,EAAAl/J,EAAAwjK,IACK,IA2EL,QAAAG,IAAAtiI,GACA,GAAAloC,GAAA7F,OAAAgnF,SAAAspF,QAIA,OAHAviI,IAAA,IAAAloC,EAAA/G,QAAAivC,KACAloC,IAAAlG,MAAAouC,EAAAv0C,UAEAqM,GAAA,KAAA7F,OAAAgnF,SAAAupF,OAAAvwK,OAAAgnF,SAAAskB,KAmEA,QAAAklE,IAAAziI,GACA,GAAAi5C,GAAAqpF,GAAAtiI,EACA,YAAA0B,KAAAu3C,GAIA,MAHAhnF,QAAAgnF,SAAA7uC,QACA6wH,EAAAj7H,EAAA,KAAAi5C,KAEA,EAIA,QAAAypF,MACA,GAAA5qK,GAAA6qK,IACA,aAAA7qK,EAAA6rC,OAAA,KAGAi/H,GAAA,IAAA9qK,IACA,GAGA,QAAA6qK,MAGA,GAAAE,GAAA5wK,OAAAgnF,SAAA4pF,KACA7yK,EAAA6yK,EAAA9xK,QAAA,IACA,YAAAf,EAAA,GAAA6yK,EAAAjxK,MAAA5B,EAAA,GAGA,QAAA8yK,IAAAhrK,GACA7F,OAAAgnF,SAAAskB,KAAAzlG,EAGA,QAAA8qK,IAAA9qK,GACA,GAAA+qK,GAAA5wK,OAAAgnF,SAAA4pF,KACAx0K,EAAAw0K,EAAA9xK,QAAA,KACAivC,EAAA3xC,GAAA,EAAAw0K,EAAAjxK,MAAA,EAAAvD,GAAAw0K,CACA5wK,QAAAgnF,SAAA7uC,QAAApK,EAAA,IAAAloC,GAsPA,QAAAirK,IAAA5hK,EAAApU,GAEA,MADAoU,GAAA3Q,KAAAzD,GACA,WACA,GAAAsB,GAAA8S,EAAApQ,QAAAhE,EACAsB,IAAA,GAAiB8S,EAAAnQ,OAAA3C,EAAA,IAIjB,QAAA20K,IAAAhjI,EAAA24H,EAAA5hJ,GACA,GAAAjf,GAAA,SAAAif,EAAA,IAAA4hJ,GACA,OAAA34H,GAAAi7H,EAAAj7H,EAAA,IAAAloC,KAv6EA,GAscA6uI,IAtcA4zB,IACA3/J,KAAA,cACA8xF,YAAA,EACAyM,OACAv+F,MACAC,KAAAk5F,OACAhI,QAAA,YAGAE,OAAA,SAAAryF,EAAAw1G,GACA,GAAAjW,GAAAiW,EAAAjW,MACA7jE,EAAA85E,EAAA95E,SACAtoC,EAAAoiH,EAAApiH,OACAgL,EAAAo3G,EAAAp3G,IAEAA,GAAAirK,YAAA,CAaA,KATA,GAAA58J,GAAArZ,EAAA29G,eACA/vG,EAAAu+F,EAAAv+F,KACA+8J,EAAA3qK,EAAAk2K,OACA9wI,EAAAplC,EAAAm2K,mBAAAn2K,EAAAm2K,qBAIAryI,EAAA,EACAsyI,GAAA,EACAp2K,KAAAmtK,cAAAntK,GACAA,EAAAq/F,QAAAr/F,EAAAq/F,OAAAr0F,KAAAirK,YACAnyI,IAEA9jC,EAAA2zG,YACAyiE,GAAA,GAEAp2K,IAAAszG,OAKA,IAHAtoG,EAAAqrK,gBAAAvyI,EAGAsyI,EACA,MAAA/8J,GAAA+rB,EAAAx3B,GAAA5C,EAAAs9B,EAGA,IAAAujI,GAAAlB,EAAAkB,QAAA/nI,EAEA,KAAA+nI,EAEA,MADAzmI,GAAAx3B,GAAA,KACAyL,GAGA,IAAA44F,GAAA7sE,EAAAx3B,GAAAi+J,EAAA1tD,WAAAvwG,EAwBA,OApBA5C,GAAAkiK,sBAAA,SAAAjkE,EAAAnH,GAEA,GAAApvC,GAAAm5G,EAAAgF,UAAAjjK,IAEAk0F,GAAApvC,IAAAu2C,IACAnH,GAAApvC,IAAAu2C,KAEA4iE,EAAAgF,UAAAjjK,GAAAk0F,KAMK92F,EAAAo0F,OAAAp0F,EAAAo0F,UAA6BqkC,SAAA,SAAA72H,EAAA6hG,GAClCo9D,EAAAgF,UAAAjjK,GAAA6gG,EAAA4R,mBAIAr1G,EAAAmhG,MAAAu+D,EAAAC,EAAAkB,EAAA1/D,OAAA0/D,EAAA1/D,MAAAv+F,IAEAyL,EAAA44F,EAAAjnG,EAAAs9B,KA2BAguI,GAAA,WACAC,GAAA,SAAAxoK,GAA0C,UAAAA,EAAA0oC,WAAA,GAAAtnC,SAAA,KAC1CqnK,GAAA,OAKApL,GAAA,SAAAlkE,GAA6B,MAAA6nE,oBAAA7nE,GAC7B9pD,QAAAk5H,GAAAC,IACAn5H,QAAAo5H,GAAA,MAEA7oC,GAAAukC,mBAuFAhG,GAAA,OA0BAD,GAAAX,EAAA,MACAxgK,KAAA,MAyFA2rK,IAAA1vE,OAAAhpG,QACA24K,IAAA3vE,OAAAjgG,OAEA0mK,IACA5/J,KAAA,cACAu+F,OACApxE,IACAltB,KAAA4oK,GACAhqI,UAAA,GAEAkiE,KACA9gG,KAAAk5F,OACAhI,QAAA,KAEA43E,MAAA5oE,QACAxiG,OAAAwiG,QACA3wD,QAAA2wD,QACAmhB,YAAAnoB,OACA6vE,iBAAA7vE,OACAv3F,OACA3B,KAAA6oK,GACA33E,QAAA,UAGAE,OAAA,SAAA5lF,GACA,GAAAgqH,GAAAjoI,KAEAqwK,EAAArwK,KAAAy7K,QACAnkH,EAAAt3D,KAAA86K,OACA9zD,EAAAqpD,EAAAxuK,QAAA7B,KAAA2/B,GAAA23B,EAAAt3D,KAAAmQ,QACA0gF,EAAAm2B,EAAAn2B,SACA0+E,EAAAvoD,EAAAuoD,MACAkL,EAAAzzD,EAAAyzD,KAEAiB,KACAC,EAAAtL,EAAAzsE,QAAAg4E,gBACAC,EAAAxL,EAAAzsE,QAAAk4E,qBAEAC,EAAA,MAAAJ,EACA,qBACAA,EACAK,EAAA,MAAAH,EACA,2BACAA,EACA/nD,EAAA,MAAA9zH,KAAA8zH,YACAioD,EACA/7K,KAAA8zH,YACA0nD,EAAA,MAAAx7K,KAAAw7K,iBACAQ,EACAh8K,KAAAw7K,iBACAS,EAAAprF,EAAAnhF,KACAwgK,EAAA,KAAAr/E,EAAA,KAAAw/E,GACAd,CAEAmM,GAAAF,GAAA5K,EAAAt5G,EAAA2kH,GACAP,EAAA5nD,GAAA9zH,KAAAu7K,MACAG,EAAAF,GACApK,EAAA95G,EAAA2kH,EAEA,IAAAz+D,GAAA,SAAAv1G,GACAqpK,EAAArpK,KACAggI,EAAAjmF,QACAquH,EAAAruH,QAAA6uC,GAEAw/E,EAAAjoK,KAAAyoF,KAKA/7E,GAAconK,MAAA5K,EACd5lK,OAAAxD,QAAAlI,KAAAoU,OACApU,KAAAoU,MAAAhT,QAAA,SAAA6G,GAAuC6M,EAAA7M,GAAAu1G,IAEvC1oG,EAAA9U,KAAAoU,OAAAopG,CAGA,IAAA5tG,IACA41G,MAAAk2D,EAGA,UAAA17K,KAAAuzG,IACA3jG,EAAAkF,KACAlF,EAAAqlG,OAAoBwlE,YACf,CAEL,GAAA/tK,GAAAglK,EAAA1xK,KAAAm6G,OAAAxW,QACA,IAAAj3F,EAAA,CAEAA,EAAAknG,UAAA,CACA,IAAAp3F,GAAA+hI,GAAA5T,KAAAnuH,QACA9P,EAAAkD,KAAA4M,KAAsC9P,EAAAkD,OACtCkF,MACApI,EAAAkD,KAAAqlG,MAAAz4F,KAA6C9P,EAAAkD,KAAAqlG,QAC7CwlE,WAGA7qK,GAAAkF,KAIA,MAAAmJ,GAAAje,KAAAuzG,IAAA3jG,EAAA5P,KAAAm6G,OAAAxW,WA0FAqK,GAAA,mBAAAnkG,QAyEA2vE,GAAA9tE,MAAAxD,SAAA,SAAA8jG,GACA,wBAAArpG,OAAAxC,UAAA4T,SAAAlT,KAAAmrG,IAMApkG,GAAAqsK,EACAkI,GAAAz5J,EACA05J,GAAAn4C,EACAo4C,GAAA9I,EACA+I,GAAAnI,EAOApB,GAAA,GAAA7wH,SAGA,UAOA,0GACAz+B,KAAA,SAgZA7b,IAAA8a,MAAAy5J,GACAv0K,GAAAq8H,QAAAm4C,GACAx0K,GAAA2rK,iBAAA8I,GACAz0K,GAAAusK,eAAAmI,EAIA,IAAA9H,IAAA7xK,OAAAR,OAAA,MA0bA41K,GAAAp1K,OAAAR,OAAA,MA4GAo6K,GAAAvuE,IAAA,WACA,GAAAwuE,GAAA3yK,OAAAw7H,UAAAC,SAEA,SACA,IAAAk3C,EAAA7zK,QAAA,oBAAA6zK,EAAA7zK,QAAA,iBACA,IAAA6zK,EAAA7zK,QAAA,mBACA,IAAA6zK,EAAA7zK,QAAA,YACA,IAAA6zK,EAAA7zK,QAAA,oBAKAkB,OAAAooK,SAAA,aAAApoK,QAAAooK,YAIAsG,GAAAvqE,IAAAnkG,OAAA6+D,aAAA7+D,OAAA6+D,YAAApkD,IACAza,OAAA6+D,YACArvB,KAEAm/H,GAAAF,KA6JAmE,GAAA,SAAApM,EAAAz4H,GACA53C,KAAAqwK,SACArwK,KAAA43C,KAAAqhI,GAAArhI,GAEA53C,KAAAs3D,QAAAu5G,GACA7wK,KAAA8hG,QAAA,KACA9hG,KAAA8qK,OAAA,EACA9qK,KAAA08K,YACA18K,KAAA28K,iBACA38K,KAAA48K,YAGAH,IAAAt8K,UAAA08K,OAAA,SAAA58I,GACAjgC,KAAAigC,MAGAw8I,GAAAt8K,UAAA28K,QAAA,SAAA78I,EAAA88I,GACA/8K,KAAA8qK,MACA7qI,KAEAjgC,KAAA08K,SAAAt0K,KAAA63B,GACA88I,GACA/8K,KAAA28K,cAAAv0K,KAAA20K,KAKAN,GAAAt8K,UAAA68K,QAAA,SAAAD,GACA/8K,KAAA48K,SAAAx0K,KAAA20K,IAGAN,GAAAt8K,UAAA88K,aAAA,SAAApsF,EAAAqsF,EAAAC,GACA,GAAAl1C,GAAAjoI,KAEAuvK,EAAAvvK,KAAAqwK,OAAAz6I,MAAAi7D,EAAA7wF,KAAAs3D,QACAt3D,MAAAo9K,kBAAA7N,EAAA,WACAtnC,EAAAo1C,YAAA9N,GACA2N,KAAA3N,GACAtnC,EAAAq1C,YAGAr1C,EAAA6iC,QACA7iC,EAAA6iC,OAAA,EACA7iC,EAAAy0C,SAAAt7K,QAAA,SAAA6+B,GAA6CA,EAAAsvI,OAE1C,SAAApuK,GACHg8K,GACAA,EAAAh8K,GAEAA,IAAA8mI,EAAA6iC,QACA7iC,EAAA6iC,OAAA,EACA7iC,EAAA00C,cAAAv7K,QAAA,SAAA6+B,GAAkDA,EAAA9+B,SAKlDs7K,GAAAt8K,UAAAi9K,kBAAA,SAAA7N,EAAA2N,EAAAC,GACA,GAAAl1C,GAAAjoI,KAEAs3D,EAAAt3D,KAAAs3D,QACA5iB,EAAA,SAAAvzC,GACAkuK,EAAAluK,KACA8mI,EAAA20C,SAAAv5K,OACA4kI,EAAA20C,SAAAx7K,QAAA,SAAA6+B,GAA+CA,EAAA9+B,MAE/CkqH,GAAA,6CACApd,QAAAxtG,MAAAU,KAGAg8K,KAAAh8K,GAEA,IACAyvK,EAAArB,EAAAj4G,IAEAi4G,EAAAkB,QAAAptK,SAAAi0D,EAAAm5G,QAAAptK,OAGA,MADArD,MAAAs9K,YACA5oI,GAGA,IAAAsyE,GAAAmyD,GAAAn5K,KAAAs3D,QAAAm5G,QAAAlB,EAAAkB,SACAt/B,EAAAnqB,EAAAmqB,QACAkoC,EAAAryD,EAAAqyD,YACAD,EAAApyD,EAAAoyD,UAEAvkI,KAAAztC,OAEAuyK,GAAAN,GAEAr5K,KAAAqwK,OAAAkN,YAEA1D,GAAA1oC,GAEAioC,EAAA7mK,IAAA,SAAA2C,GAAgC,MAAAA,GAAAg+G,cAEhC0lD,GAAAQ,GAGAp5K,MAAA8hG,QAAAytE,CACA,IAAA/oK,GAAA,SAAAw9F,EAAA3iG,GACA,GAAA4mI,EAAAnmC,UAAAytE,EACA,MAAA76H,IAEA,KACAsvD,EAAAurE,EAAAj4G,EAAA,SAAA33B,IACA,IAAAA,GAAA0vI,EAAA1vI,IAEAsoG,EAAAq1C,WAAA,GACA5oI,EAAA/U,IAEA,gBAAAA,IACA,gBAAAA,KACA,gBAAAA,GAAAjwB,MACA,gBAAAiwB,GAAAntB,OAIAkiC,IACA,gBAAA/U,MAAAqiB,QACAimF,EAAAjmF,QAAAriB,GAEAsoG,EAAA7/H,KAAAu3B,IAIAt+B,EAAAs+B,KAGK,MAAA13B,GACLysC,EAAAzsC,IAIA0wK,IAAA9jI,EAAAruC,EAAA,WACA,GAAAg3K,KAMA7E,IAFAmB,GAAAV,EAAAoE,EAHA,WAA+B,MAAAv1C,GAAA3wE,UAAAi4G,IAI/BnoK,OAAA6gI,EAAAooC,OAAAoN,cACAj3K,EAAA,WACA,GAAAyhI,EAAAnmC,UAAAytE,EACA,MAAA76H,IAEAuzF,GAAAnmC,QAAA,KACAo7E,EAAA3N,GACAtnC,EAAAooC,OAAA+G,KACAnvC,EAAAooC,OAAA+G,IAAA9tC,UAAA,WACAk0C,EAAAp8K,QAAA,SAAA6+B,GAA8CA,aAO9Cw8I,GAAAt8K,UAAAk9K,YAAA,SAAA9N,GACA,GAAAplD,GAAAnqH,KAAAs3D,OACAt3D,MAAAs3D,QAAAi4G,EACAvvK,KAAAigC,IAAAjgC,KAAAigC,GAAAsvI,GACAvvK,KAAAqwK,OAAAqN,WAAAt8K,QAAA,SAAA4iG,GACAA,KAAAurE,EAAAplD,KA0IA,IAAAwzD,IAAA,SAAAC,GACA,QAAAD,GAAAtN,EAAAz4H,GACA,GAAAqwF,GAAAjoI,IAEA49K,GAAA/8K,KAAAb,KAAAqwK,EAAAz4H,EAEA,IAAAimI,GAAAxN,EAAAzsE,QAAA0zE,cAEAuG,IACA9G,IAGAltK,OAAA2L,iBAAA,oBAAAvN,GACA,GAAAqvD,GAAA2wE,EAAA3wE,OACA2wE,GAAAg1C,aAAA/C,GAAAjyC,EAAArwF,MAAA,SAAA23H,GACAsO,GACA3G,EAAA7G,EAAAd,EAAAj4G,GAAA,OAiDA,MA3CAsmH,KAAAD,EAAAhvE,UAAAivE,GACAD,EAAAx9K,UAAAwC,OAAAR,OAAAy7K,KAAAz9K,WACAw9K,EAAAx9K,UAAAqC,YAAAm7K,EAEAA,EAAAx9K,UAAA29K,GAAA,SAAA9rK,GACAnI,OAAAooK,QAAA6L,GAAA9rK,IAGA2rK,EAAAx9K,UAAAiI,KAAA,SAAAyoF,EAAAqsF,EAAAC,GACA,GAAAl1C,GAAAjoI,KAEAgnH,EAAAhnH,KACA+9K,EAAA/2D,EAAA1vD,OACAt3D,MAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAkJ,GAAA5F,EAAA5qC,EAAArwF,KAAA23H,EAAAgB,WACA2G,EAAAjvC,EAAAooC,OAAAd,EAAAwO,GAAA,GACAb,KAAA3N,IACK4N,IAGLQ,EAAAx9K,UAAA6hD,QAAA,SAAA6uC,EAAAqsF,EAAAC,GACA,GAAAl1C,GAAAjoI,KAEAgnH,EAAAhnH,KACA+9K,EAAA/2D,EAAA1vD,OACAt3D,MAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAmJ,GAAA7F,EAAA5qC,EAAArwF,KAAA23H,EAAAgB,WACA2G,EAAAjvC,EAAAooC,OAAAd,EAAAwO,GAAA,GACAb,KAAA3N,IACK4N,IAGLQ,EAAAx9K,UAAAm9K,UAAA,SAAAl1K,GACA,GAAA8xK,GAAAl6K,KAAA43C,QAAA53C,KAAAs3D,QAAAi5G,SAAA,CACA,GAAAj5G,GAAAu7G,EAAA7yK,KAAA43C,KAAA53C,KAAAs3D,QAAAi5G,SACAnoK,GAAAqwK,GAAAnhH,GAAAohH,GAAAphH,KAIAqmH,EAAAx9K,UAAA69K,mBAAA,WACA,MAAA9D,IAAAl6K,KAAA43C,OAGA+lI,GACClB,IAaDwB,GAAA,SAAAL,GACA,QAAAK,GAAA5N,EAAAz4H,EAAA+oE,GACAi9D,EAAA/8K,KAAAb,KAAAqwK,EAAAz4H,GAEA+oE,GAAA05D,GAAAr6K,KAAA43C,OAGA0iI,KAmDA,MAhDAsD,KAAAK,EAAAtvE,UAAAivE,GACAK,EAAA99K,UAAAwC,OAAAR,OAAAy7K,KAAAz9K,WACA89K,EAAA99K,UAAAqC,YAAAy7K,EAIAA,EAAA99K,UAAA+9K,eAAA,WACA,GAAAj2C,GAAAjoI,IAEA6J,QAAA2L,iBAAA,wBACA8kK,MAGAryC,EAAAg1C,aAAA1C,KAAA,SAAAhL,GACAiL,GAAAjL,EAAAgB,eAKA0N,EAAA99K,UAAAiI,KAAA,SAAAyoF,EAAAqsF,EAAAC,GACAn9K,KAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAmL,GAAAnL,EAAAgB,UACA2M,KAAA3N,IACK4N,IAGLc,EAAA99K,UAAA6hD,QAAA,SAAA6uC,EAAAqsF,EAAAC,GACAn9K,KAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAiL,GAAAjL,EAAAgB,UACA2M,KAAA3N,IACK4N,IAGLc,EAAA99K,UAAA29K,GAAA,SAAA9rK,GACAnI,OAAAooK,QAAA6L,GAAA9rK,IAGAisK,EAAA99K,UAAAm9K,UAAA,SAAAl1K,GACA,GAAAkvD,GAAAt3D,KAAAs3D,QAAAi5G,QACAgK,QAAAjjH,IACAlvD,EAAAsyK,GAAApjH,GAAAkjH,GAAAljH,KAIA2mH,EAAA99K,UAAA69K,mBAAA,WACA,MAAAzD,OAGA0D,GACCxB,IA2CD0B,GAAA,SAAAP,GACA,QAAAO,GAAA9N,EAAAz4H,GACAgmI,EAAA/8K,KAAAb,KAAAqwK,EAAAz4H,GACA53C,KAAA4uF,SACA5uF,KAAA4H,OAAA,EAiDA,MA9CAg2K,KAAAO,EAAAxvE,UAAAivE,GACAO,EAAAh+K,UAAAwC,OAAAR,OAAAy7K,KAAAz9K,WACAg+K,EAAAh+K,UAAAqC,YAAA27K,EAEAA,EAAAh+K,UAAAiI,KAAA,SAAAyoF,EAAAqsF,EAAAC,GACA,GAAAl1C,GAAAjoI,IAEAA,MAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAtnC,EAAAr5C,MAAAq5C,EAAAr5C,MAAAplF,MAAA,EAAAy+H,EAAArgI,MAAA,GAAAR,OAAAmoK,GACAtnC,EAAArgI,QACAs1K,KAAA3N,IACK4N,IAGLgB,EAAAh+K,UAAA6hD,QAAA,SAAA6uC,EAAAqsF,EAAAC,GACA,GAAAl1C,GAAAjoI,IAEAA,MAAAi9K,aAAApsF,EAAA,SAAA0+E,GACAtnC,EAAAr5C,MAAAq5C,EAAAr5C,MAAAplF,MAAA,EAAAy+H,EAAArgI,OAAAR,OAAAmoK,GACA2N,KAAA3N,IACK4N,IAGLgB,EAAAh+K,UAAA29K,GAAA,SAAA9rK,GACA,GAAAi2H,GAAAjoI,KAEAo+K,EAAAp+K,KAAA4H,MAAAoK,CACA,MAAAosK,EAAA,GAAAA,GAAAp+K,KAAA4uF,MAAAvrF,QAAA,CAGA,GAAAksK,GAAAvvK,KAAA4uF,MAAAwvF,EACAp+K,MAAAo9K,kBAAA7N,EAAA,WACAtnC,EAAArgI,MAAAw2K,EACAn2C,EAAAo1C,YAAA9N,OAIA4O,EAAAh+K,UAAA69K,mBAAA,WACA,GAAA1mH,GAAAt3D,KAAA4uF,MAAA5uF,KAAA4uF,MAAAvrF,OAAA,EACA,OAAAi0D,KAAAi5G,SAAA,KAGA4N,EAAAh+K,UAAAm9K,UAAA,aAIAa,GACC1B,IAID4B,GAAA,SAAAz6E,OACA,KAAAA,UAEA5jG,KAAAo3K,IAAA,KACAp3K,KAAAs+K,QACAt+K,KAAA4jG,UACA5jG,KAAAu9K,eACAv9K,KAAAy9K,gBACAz9K,KAAA09K,cACA19K,KAAA02D,QAAAw/G,EAAAtyE,EAAA8wE,WAAA10K,KAEA,IAAA2uB,GAAAi1E,EAAAj1E,MAAA,MAUA,QATA3uB,KAAA2gH,SAAA,YAAAhyF,IAAA4tJ,KAAA,IAAA34E,EAAA+c,SACA3gH,KAAA2gH,WACAhyF,EAAA,QAEAq/E,KACAr/E,EAAA,YAEA3uB,KAAA2uB,OAEAA,GACA,cACA3uB,KAAAiyK,QAAA,GAAA0L,IAAA39K,KAAA4jG,EAAAhsD,KACA,MACA,YACA53C,KAAAiyK,QAAA,GAAAgM,IAAAj+K,KAAA4jG,EAAAhsD,KAAA53C,KAAA2gH,SACA,MACA,gBACA3gH,KAAAiyK,QAAA,GAAAkM,IAAAn+K,KAAA4jG,EAAAhsD,QASA2vF,IAA0B6uC,gBAE1BiI,IAAAl+K,UAAAy1B,MAAA,SACA0xG,EACAhwE,EACA84G,GAEA,MAAApwK,MAAA02D,QAAA9gC,MAAA0xG,EAAAhwE,EAAA84G,IAGA7oC,GAAA6uC,aAAA1jK,IAAA,WACA,MAAA1S,MAAAiyK,SAAAjyK,KAAAiyK,QAAA36G,SAGA+mH,GAAAl+K,UAAAgmB,KAAA,SAAAixJ,GACA,GAAAnvC,GAAAjoI,IAWA,IAHAA,KAAAs+K,KAAAl2K,KAAAgvK,IAGAp3K,KAAAo3K,IAAA,CAIAp3K,KAAAo3K,KAEA,IAAAnF,GAAAjyK,KAAAiyK,OAEA,IAAAA,YAAA0L,IACA1L,EAAAgL,aAAAhL,EAAA+L,0BACG,IAAA/L,YAAAgM,IAAA,CACH,GAAAM,GAAA,WACAtM,EAAAiM,iBAEAjM,GAAAgL,aACAhL,EAAA+L,qBACAO,EACAA,GAIAtM,EAAA4K,OAAA,SAAAtN,GACAtnC,EAAAq2C,KAAAl9K,QAAA,SAAAg2K,GACAA,EAAAlF,OAAA3C,QAKA8O,GAAAl+K,UAAAq+K,WAAA,SAAA75K,GACA,MAAAg2K,IAAA36K,KAAAu9K,YAAA54K,IAGA05K,GAAAl+K,UAAAs+K,cAAA,SAAA95K,GACA,MAAAg2K,IAAA36K,KAAAy9K,aAAA94K,IAGA05K,GAAAl+K,UAAAu+K,UAAA,SAAA/5K,GACA,MAAAg2K,IAAA36K,KAAA09K,WAAA/4K,IAGA05K,GAAAl+K,UAAA28K,QAAA,SAAA78I,EAAA88I,GACA/8K,KAAAiyK,QAAA6K,QAAA78I,EAAA88I,IAGAsB,GAAAl+K,UAAA68K,QAAA,SAAAD,GACA/8K,KAAAiyK,QAAA+K,QAAAD,IAGAsB,GAAAl+K,UAAAiI,KAAA,SAAAyoF,EAAAqsF,EAAAC,GACAn9K,KAAAiyK,QAAA7pK,KAAAyoF,EAAAqsF,EAAAC,IAGAkB,GAAAl+K,UAAA6hD,QAAA,SAAA6uC,EAAAqsF,EAAAC,GACAn9K,KAAAiyK,QAAAjwH,QAAA6uC,EAAAqsF,EAAAC,IAGAkB,GAAAl+K,UAAA29K,GAAA,SAAA9rK,GACAhS,KAAAiyK,QAAA6L,GAAA9rK,IAGAqsK,GAAAl+K,UAAAw+K,KAAA,WACA3+K,KAAA89K,IAAA,IAGAO,GAAAl+K,UAAA4qC,QAAA,WACA/qC,KAAA89K,GAAA,IAGAO,GAAAl+K,UAAAy+K,qBAAA,SAAAj/I,GACA,GAAA4vI,GAAA5vI,EACAA,EAAA8wI,QACA9wI,EACA3/B,KAAA6B,QAAA89B,GAAA4vI,MACAvvK,KAAAo2K,YACA,OAAA7G,MAGAnoK,OAAApC,SAAAuqK,EAAAkB,QAAAl+J,IAAA,SAAA2C,GACA,MAAAvS,QAAA8rE,KAAAv5D,EAAA6tG,YAAAxwG,IAAA,SAAAgE,GACA,MAAArB,GAAA6tG,WAAAxsG,YAKA8nK,GAAAl+K,UAAA0B,QAAA,SACA89B,EACA23B,EACAnnD,GAEA,GAAA0gF,GAAAglF,EACAl2I,EACA23B,GAAAt3D,KAAAiyK,QAAA36G,QACAnnD,EACAnQ,MAEAuvK,EAAAvvK,KAAA41B,MAAAi7D,EAAAv5B,GACAi5G,EAAAhB,EAAAa,gBAAAb,EAAAgB,QAGA,QACA1/E,WACA0+E,QACAkL,KAJAG,GADA56K,KAAAiyK,QAAAr6H,KACA24H,EAAAvwK,KAAA2uB,MAMAkwJ,aAAAhuF,EACAwlB,SAAAk5D,IAIA8O,GAAAl+K,UAAAg2K,UAAA,SAAAzB,GACA10K,KAAA02D,QAAAy/G,UAAAzB,GACA10K,KAAAiyK,QAAA36G,UAAAu5G,IACA7wK,KAAAiyK,QAAAgL,aAAAj9K,KAAAiyK,QAAA+L,uBAIAr7K,OAAA6kI,iBAAA62C,GAAAl+K,UAAAonI,IAeA82C,GAAAv6D,UACAu6D,GAAAxrF,QAAA,QAEAmb,IAAAnkG,OAAA45G,KACA55G,OAAA45G,IAAAC,IAAA26D,IAGArzE,EAAA,MrWwy9CM,SAAUxrG,EAAQC,GsW5uiDxBD,EAAAC,QAAA,SAAAqyC,EAAA/4B,GAGA,OAFAw4G,MACAutD,KACA74K,EAAA,EAAiBA,EAAA8S,EAAA1V,OAAiB4C,IAAA,CAClC,GAAAQ,GAAAsS,EAAA9S,GACA6V,EAAArV,EAAA,GACA+pH,EAAA/pH,EAAA,GACAs4K,EAAAt4K,EAAA,GACAu4K,EAAAv4K,EAAA,GACAw4K,GACAnjK,GAAAg2B,EAAA,IAAA7rC,EACAuqH,MACAuuD,QACAC,YAEAF,GAAAhjK,GAGAgjK,EAAAhjK,GAAAg0J,MAAA1nK,KAAA62K,GAFA1tD,EAAAnpH,KAAA02K,EAAAhjK,IAAmCA,KAAAg0J,OAAAmP,KAKnC,MAAA1tD,KtWwviDM,SAAU/xH,EAAQC,GuWhuiDxB,QAAAy/K,GAAAz4K,EAAA04K,GACA,GAAAvtC,GAAAnrI,EAAA,OACA24K,EAAA34K,EAAA,EACA,KAAA24K,EACA,MAAAxtC,EAGA,IAAAutC,GAAA,kBAAAE,MAAA,CACA,GAAAC,GAAAC,EAAAH,EAKA,QAAAxtC,GAAAxqI,OAJAg4K,EAAAvuB,QAAAt+I,IAAA,SAAAhS,GACA,uBAAA6+K,EAAAI,WAAAj/K,EAAA,SAGA6G,QAAAk4K,IAAA77J,KAAA,MAGA,OAAAmuH,GAAAnuH,KAAA,MAIA,QAAA87J,GAAAP,GAKA,yEAHAK,KAAAI,SAAA9L,mBAAAzgJ,KAAAC,UAAA6rJ,MAGA,MArEAx/K,EAAAC,QAAA,SAAA0/K,GACA,GAAApmK,KAwCA,OArCAA,GAAAhF,SAAA,WACA,MAAA/T,MAAAuS,IAAA,SAAA9L,GACA,GAAAmrI,GAAAstC,EAAAz4K,EAAA04K,EACA,OAAA14K,GAAA,GACA,UAAAA,EAAA,OAAmCmrI,EAAA,IAEnCA,IAEGnuH,KAAA,KAIH1K,EAAA9S,EAAA,SAAA8kH,EAAA20D,GACA,gBAAA30D,KACAA,IAAA,KAAAA,EAAA,KAEA,QADA40D,MACA15K,EAAA,EAAgBA,EAAAjG,KAAAqD,OAAiB4C,IAAA,CACjC,GAAA6V,GAAA9b,KAAAiG,GAAA,EACA,iBAAA6V,KACA6jK,EAAA7jK,IAAA,GAEA,IAAA7V,EAAA,EAAYA,EAAA8kH,EAAA1nH,OAAoB4C,IAAA,CAChC,GAAAQ,GAAAskH,EAAA9kH,EAKA,iBAAAQ,GAAA,IAAAk5K,EAAAl5K,EAAA,MACAi5K,IAAAj5K,EAAA,GACAA,EAAA,GAAAi5K,EACKA,IACLj5K,EAAA,OAAAA,EAAA,aAAAi5K,EAAA,KAEA3mK,EAAA3Q,KAAA3B,MAIAsS,IvWqziDM,SAAUvZ,EAAQC,EAASC,GwWlxiDjC,QAAAkgL,GAAAruD,GACA,OAAAtrH,GAAA,EAAiBA,EAAAsrH,EAAAluH,OAAmB4C,IAAA,CACpC,GAAAQ,GAAA8qH,EAAAtrH,GACA45K,EAAAC,EAAAr5K,EAAAqV,GACA,IAAA+jK,EAAA,CACAA,EAAA54D,MACA,QAAAhyG,GAAA,EAAqBA,EAAA4qK,EAAA/P,MAAAzsK,OAA2B4R,IAChD4qK,EAAA/P,MAAA76J,GAAAxO,EAAAqpK,MAAA76J,GAEA,MAAYA,EAAAxO,EAAAqpK,MAAAzsK,OAAuB4R,IACnC4qK,EAAA/P,MAAA1nK,KAAA23K,EAAAt5K,EAAAqpK,MAAA76J,IAEA4qK,GAAA/P,MAAAzsK,OAAAoD,EAAAqpK,MAAAzsK,SACAw8K,EAAA/P,MAAAzsK,OAAAoD,EAAAqpK,MAAAzsK,YAEK,CAEL,OADAysK,MACA76J,EAAA,EAAqBA,EAAAxO,EAAAqpK,MAAAzsK,OAAuB4R,IAC5C66J,EAAA1nK,KAAA23K,EAAAt5K,EAAAqpK,MAAA76J,IAEA6qK,GAAAr5K,EAAAqV,KAA8BA,GAAArV,EAAAqV,GAAAmrG,KAAA,EAAA6oD,WAK9B,QAAAkQ,KACA,GAAAC,GAAAjtK,SAAAM,cAAA,QAGA,OAFA2sK,GAAAxtK,KAAA,WACAytK,EAAApmK,YAAAmmK,GACAA,EAGA,QAAAF,GAAAz0E,GACA,GAAAp1F,GAAArO,EACAo4K,EAAAjtK,SAAAilD,cAAA,2BAAAqzC,EAAAxvF,GAAA,KAEA,IAAAmkK,EAAA,CACA,GAAAE,EAGA,MAAArtK,EAOAmtK,GAAA/uK,WAAAkJ,YAAA6lK,GAIA,GAAAG,EAAA,CAEA,GAAAC,GAAAC,GACAL,GAAAM,MAAAP,KACA9pK,EAAAsqK,EAAAl8K,KAAA,KAAA27K,EAAAI,GAAA,GACAx4K,EAAA24K,EAAAl8K,KAAA,KAAA27K,EAAAI,GAAA,OAGAJ,GAAAD,IACA9pK,EAAAuqK,EAAAn8K,KAAA,KAAA27K,GACAp4K,EAAA,WACAo4K,EAAA/uK,WAAAkJ,YAAA6lK,GAMA,OAFA/pK,GAAAo1F,GAEA,SAAAo1E,GACA,GAAAA,EAAA,CACA,GAAAA,EAAAlwD,MAAAllB,EAAAklB,KACAkwD,EAAA3B,QAAAzzE,EAAAyzE,OACA2B,EAAA1B,YAAA1zE,EAAA0zE,UACA,MAEA9oK,GAAAo1F,EAAAo1E,OAEA74K,MAcA,QAAA24K,GAAAP,EAAAr4K,EAAAC,EAAAyjG,GACA,GAAAklB,GAAA3oH,EAAA,GAAAyjG,EAAAklB,GAEA,IAAAyvD,EAAAU,WACAV,EAAAU,WAAAr1C,QAAAs1C,EAAAh5K,EAAA4oH,OACG,CACH,GAAAxuG,GAAAhP,SAAAyzG,eAAA+J,GACAqwD,EAAAZ,EAAAY,UACAA,GAAAj5K,IAAAq4K,EAAA7lK,YAAAymK,EAAAj5K,IACAi5K,EAAAx9K,OACA48K,EAAAhmK,aAAA+H,EAAA6+J,EAAAj5K,IAEAq4K,EAAAnmK,YAAAkI,IAKA,QAAAy+J,GAAAR,EAAA30E,GACA,GAAAklB,GAAAllB,EAAAklB,IACAuuD,EAAAzzE,EAAAyzE,MACAC,EAAA1zE,EAAA0zE,SAcA,IAZAD,GACAkB,EAAA9oK,aAAA,QAAA4nK,GAGAC,IAGAxuD,GAAA,mBAAAwuD,EAAAnuB,QAAA,SAEArgC,GAAA,uDAAyD6uD,KAAAI,SAAA9L,mBAAAzgJ,KAAAC,UAAA6rJ,MAAA,OAGzDiB,EAAAU,WACAV,EAAAU,WAAAr1C,QAAA9a,MACG,CACH,KAAAyvD,EAAA/lK,YACA+lK,EAAA7lK,YAAA6lK,EAAA/lK,WAEA+lK,GAAAnmK,YAAA9G,SAAAyzG,eAAA+J,KA9MA,GAAAswD,GAAA,mBAAA9tK,SAEA,uBAAA+tK,gBACAD,EACA,SAAAl/K,OACA,0JAKA,IAAAo/K,GAAAthL,EAAA,KAeAogL,KAQAI,EAAAY,IAAA9tK,SAAAktK,MAAAltK,SAAAiuK,qBAAA,YACAV,EAAA,KACAD,EAAA,EACAH,GAAA,EACArtK,EAAA,aAIAstK,EAAA,mBAAA/6C,YAAA,eAAA/rF,KAAA+rF,UAAAC,UAAA1oH,cAEApd,GAAAC,QAAA,SAAAqyC,EAAA/4B,EAAAmoK,GACAf,EAAAe,CAEA,IAAA3vD,GAAAyvD,EAAAlvI,EAAA/4B,EAGA,OAFA6mK,GAAAruD,GAEA,SAAA4vD,GAEA,OADAC,MACAn7K,EAAA,EAAmBA,EAAAsrH,EAAAluH,OAAmB4C,IAAA,CACtC,GAAAQ,GAAA8qH,EAAAtrH,GACA45K,EAAAC,EAAAr5K,EAAAqV,GACA+jK,GAAA54D,OACAm6D,EAAAh5K,KAAAy3K,GAEAsB,GACA5vD,EAAAyvD,EAAAlvI,EAAAqvI,GACAvB,EAAAruD,IAEAA,IAEA,QAAAtrH,GAAA,EAAmBA,EAAAm7K,EAAA/9K,OAAsB4C,IAAA,CACzC,GAAA45K,GAAAuB,EAAAn7K,EACA,QAAA45K,EAAA54D,KAAA,CACA,OAAAhyG,GAAA,EAAuBA,EAAA4qK,EAAA/P,MAAAzsK,OAA2B4R,IAClD4qK,EAAA/P,MAAA76J,WAEA6qK,GAAAD,EAAA/jK,OAwFA,IAAA8kK,GAAA,WACA,GAAAS,KAEA,iBAAAz5K,EAAA05K,GAEA,MADAD,GAAAz5K,GAAA05K,EACAD,EAAA/vK,OAAAqhG,SAAAlvF,KAAA","file":"static/js/vendor.b782ad69b17e217df14e.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nvar toSubscriber_1 = __webpack_require__(369);\nvar observable_1 = __webpack_require__(25);\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log('Adding: ' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log('Sum equals: ' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log('Adding: ' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log('Sum equals: ' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log('completed!') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log('unsubscribed!');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // \"unsubscribed!\" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(30);\nvar Subscription_1 = __webpack_require__(4);\nvar Observer_1 = __webpack_require__(43);\nvar rxSubscriber_1 = __webpack_require__(26);\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer_1.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nvar isArrayLike_1 = __webpack_require__(68);\nvar isPromise_1 = __webpack_require__(70);\nvar isObject_1 = __webpack_require__(69);\nvar Observable_1 = __webpack_require__(0);\nvar iterator_1 = __webpack_require__(19);\nvar InnerSubscriber_1 = __webpack_require__(90);\nvar observable_1 = __webpack_require__(25);\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    else if (isArrayLike_1.isArrayLike(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (result && typeof result[iterator_1.iterator] === 'function') {\n        var iterator = result[iterator_1.iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (result && typeof result[observable_1.observable] === 'function') {\n        var obs = result[observable_1.observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        destination.error(new TypeError(msg));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(11);\nvar isObject_1 = __webpack_require__(69);\nvar isFunction_1 = __webpack_require__(30);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar UnsubscriptionError_1 = __webpack_require__(66);\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar Subscriber_1 = __webpack_require__(1);\nvar Subscription_1 = __webpack_require__(4);\nvar ObjectUnsubscribedError_1 = __webpack_require__(28);\nvar SubjectSubscription_1 = __webpack_require__(44);\nvar rxSubscriber_1 = __webpack_require__(26);\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\nvar _root = __window || __global || __self;\nexports.root = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\n//# sourceMappingURL=root.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(39)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar errorObject_1 = __webpack_require__(6);\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncAction_1 = __webpack_require__(17);\nvar AsyncScheduler_1 = __webpack_require__(18);\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar ScalarObservable_1 = __webpack_require__(32);\nvar EmptyObservable_1 = __webpack_require__(13);\nvar isScheduler_1 = __webpack_require__(12);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following to the console:\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\n     * // x will occur every 1000ms\n     * // if x % 2 is equal to 1 print abc\n     * // if x % 2 is not equal to 1 nothing will be output\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ConnectableObservable_1 = __webpack_require__(45);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    if (typeof selector === 'function') {\n        return this.lift(new MulticastOperator(subjectFactory, selector));\n    }\n    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = this;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org Version 4.10.0. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar version = \"4.10.0\";\n\nvar ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\n\nvar bisector = function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n\nvar pairs = function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n};\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\nvar cross = function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n};\n\nvar descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar number = function(x) {\n  return x === null ? NaN : +x;\n};\n\nvar variance = function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n};\n\nvar deviation = function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n};\n\nvar extent = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n};\n\nvar array = Array.prototype;\n\nvar slice = array.slice;\nvar map = array.map;\n\nvar constant = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar identity = function(x) {\n  return x;\n};\n\nvar sequence = function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n};\n\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n\nvar ticks = function(start, stop, count) {\n  var reverse = stop < start,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  if (reverse) n = start, start = stop, stop = n;\n\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n};\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nvar sturges = function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n};\n\nvar histogram = function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n};\n\nvar threshold = function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n};\n\nvar freedmanDiaconis = function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n};\n\nvar scott = function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n};\n\nvar max = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n};\n\nvar mean = function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n};\n\nvar median = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return threshold(numbers.sort(ascending), 0.5);\n};\n\nvar merge = function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n};\n\nvar min = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n};\n\nvar permute = function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n};\n\nvar scan = function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n};\n\nvar shuffle = function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n};\n\nvar sum = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n};\n\nvar transpose = function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n};\n\nfunction length(d) {\n  return d.length;\n}\n\nvar zip = function() {\n  return transpose(arguments);\n};\n\nvar slice$1 = Array.prototype.slice;\n\nvar identity$1 = function(x) {\n  return x;\n};\n\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon = 1e-6;\n\nfunction translateX(x) {\n  return \"translate(\" + (x + 0.5) + \",0)\";\n}\n\nfunction translateY(y) {\n  return \"translate(0,\" + (y + 0.5) + \")\";\n}\n\nfunction number$1(scale) {\n  return function(d) {\n    return +scale(d);\n  };\n}\n\nfunction center(scale) {\n  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.\n  if (scale.round()) offset = Math.round(offset);\n  return function(d) {\n    return +scale(d) + offset;\n  };\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3,\n      k = orient === top || orient === left ? -1 : 1,\n      x = orient === left || orient === right ? \"x\" : \"y\",\n      transform = orient === top || orient === bottom ? translateX : translateY;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        range = scale.range(),\n        range0 = +range[0] + 0.5,\n        range1 = +range[range.length - 1] + 0.5,\n        position = (scale.bandwidth ? center : number$1)(scale.copy()),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"#000\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"#000\")\n        .attr(x + \"2\", k * tickSizeInner));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"#000\")\n        .attr(x, k * spacing)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute(\"transform\"); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient == right\n            ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H0.5V\" + range1 + \"H\" + k * tickSizeOuter\n            : \"M\" + range0 + \",\" + k * tickSizeOuter + \"V0.5H\" + range1 + \"V\" + k * tickSizeOuter);\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position(d)); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = slice$1.call(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  return axis;\n}\n\nfunction axisTop(scale) {\n  return axis(top, scale);\n}\n\nfunction axisRight(scale) {\n  return axis(right, scale);\n}\n\nfunction axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nfunction axisLeft(scale) {\n  return axis(left, scale);\n}\n\nvar noop = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\nvar namespaces = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nvar namespace = function(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;\n};\n\nfunction creatorInherit(name) {\n  return function() {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n        ? document.createElement(name)\n        : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\nvar creator = function(name) {\n  var fullname = namespace(name);\n  return (fullname.local\n      ? creatorFixed\n      : creatorInherit)(fullname);\n};\n\nvar nextId = 0;\n\nfunction local$1() {\n  return new Local;\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local$1.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id = this._;\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n    return node[id];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nvar matcher = function(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document !== \"undefined\") {\n  var element = document.documentElement;\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector\n        || element.msMatchesSelector\n        || element.mozMatchesSelector\n        || element.oMatchesSelector;\n    matcher = function(selector) {\n      return function() {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\nvar matcher$1 = matcher;\n\nvar filterEvents = {};\n\nexports.event = null;\n\nif (typeof document !== \"undefined\") {\n  var element$1 = document.documentElement;\n  if (!(\"onmouseenter\" in element$1)) {\n    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function(event) {\n    var related = event.relatedTarget;\n    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function(event1) {\n    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n    exports.event = event1;\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      exports.event = event0;\n    }\n  };\n}\n\nfunction parseTypenames$1(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {type: t, name: name};\n  });\n}\n\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;\n  return function(d, i, group) {\n    var on = this.__on, o, listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\n\nvar selection_on = function(typename, value, capture) {\n  var typenames = parseTypenames$1(typename + \"\"), i, n = typenames.length, t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value ? onAdd : onRemove;\n  if (capture == null) capture = false;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n  return this;\n};\n\nfunction customEvent(event1, listener, that, args) {\n  var event0 = exports.event;\n  event1.sourceEvent = exports.event;\n  exports.event = event1;\n  try {\n    return listener.apply(that, args);\n  } finally {\n    exports.event = event0;\n  }\n}\n\nvar sourceEvent = function() {\n  var current = exports.event, source;\n  while (source = current.sourceEvent) current = source;\n  return current;\n};\n\nvar point = function(node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX, point.y = event.clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n};\n\nvar mouse = function(node) {\n  var event = sourceEvent();\n  if (event.changedTouches) event = event.changedTouches[0];\n  return point(node, event);\n};\n\nfunction none() {}\n\nvar selector = function(selector) {\n  return selector == null ? none : function() {\n    return this.querySelector(selector);\n  };\n};\n\nvar selection_select = function(select) {\n  if (typeof select !== \"function\") select = selector(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nfunction empty$1() {\n  return [];\n}\n\nvar selectorAll = function(selector) {\n  return selector == null ? empty$1 : function() {\n    return this.querySelectorAll(selector);\n  };\n};\n\nvar selection_selectAll = function(select) {\n  if (typeof select !== \"function\") select = selectorAll(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        subgroups.push(select.call(node, node.__data__, i, group));\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, parents);\n};\n\nvar selection_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nvar sparse = function(update) {\n  return new Array(update.length);\n};\n\nvar selection_enter = function() {\n  return new Selection(this._enter || this._groups.map(sparse), this._parents);\n};\n\nfunction EnterNode(parent, datum) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum;\n}\n\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },\n  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },\n  querySelector: function(selector) { return this._parent.querySelector(selector); },\n  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }\n};\n\nvar constant$1 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nvar selection_data = function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant$1(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n};\n\nvar selection_exit = function() {\n  return new Selection(this._exit || this._groups.map(sparse), this._parents);\n};\n\nvar selection_merge = function(selection$$1) {\n\n  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Selection(merges, this._parents);\n};\n\nvar selection_order = function() {\n\n  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {\n    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n\n  return this;\n};\n\nvar selection_sort = function(compare) {\n  if (!compare) compare = ascending$1;\n\n  function compareNode(a, b) {\n    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n  }\n\n  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n\n  return new Selection(sortgroups, this._parents).order();\n};\n\nfunction ascending$1(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nvar selection_call = function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n};\n\nvar selection_nodes = function() {\n  var nodes = new Array(this.size()), i = -1;\n  this.each(function() { nodes[++i] = this; });\n  return nodes;\n};\n\nvar selection_node = function() {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n\n  return null;\n};\n\nvar selection_size = function() {\n  var size = 0;\n  this.each(function() { ++size; });\n  return size;\n};\n\nvar selection_empty = function() {\n  return !this.node();\n};\n\nvar selection_each = function(callback) {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) callback.call(node, node.__data__, i, group);\n    }\n  }\n\n  return this;\n};\n\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\n\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\n\nfunction attrFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttribute(name);\n    else this.setAttribute(name, v);\n  };\n}\n\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);\n    else this.setAttributeNS(fullname.space, fullname.local, v);\n  };\n}\n\nvar selection_attr = function(name, value) {\n  var fullname = namespace(name);\n\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local\n        ? node.getAttributeNS(fullname.space, fullname.local)\n        : node.getAttribute(fullname);\n  }\n\n  return this.each((value == null\n      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS : attrFunction)\n      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));\n};\n\nvar defaultView = function(node) {\n  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n      || (node.document && node) // node is a Window\n      || node.defaultView; // node is a Document\n};\n\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\n\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, v, priority);\n  };\n}\n\nvar selection_style = function(name, value, priority) {\n  return arguments.length > 1\n      ? this.each((value == null\n            ? styleRemove : typeof value === \"function\"\n            ? styleFunction\n            : styleConstant)(name, value, priority == null ? \"\" : priority))\n      : styleValue(this.node(), name);\n};\n\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name)\n      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\n\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\n\nfunction propertyFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) delete this[name];\n    else this[name] = v;\n  };\n}\n\nvar selection_property = function(name, value) {\n  return arguments.length > 1\n      ? this.each((value == null\n          ? propertyRemove : typeof value === \"function\"\n          ? propertyFunction\n          : propertyConstant)(name, value))\n      : this.node()[name];\n};\n\nfunction classArray(string) {\n  return string.trim().split(/^|\\s+/);\n}\n\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\n\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\n\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\n\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.add(names[i]);\n}\n\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.remove(names[i]);\n}\n\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\n\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\n\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\n\nvar selection_classed = function(name, value) {\n  var names = classArray(name + \"\");\n\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n) if (!list.contains(names[i])) return false;\n    return true;\n  }\n\n  return this.each((typeof value === \"function\"\n      ? classedFunction : value\n      ? classedTrue\n      : classedFalse)(names, value));\n};\n\nfunction textRemove() {\n  this.textContent = \"\";\n}\n\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.textContent = v == null ? \"\" : v;\n  };\n}\n\nvar selection_text = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? textRemove : (typeof value === \"function\"\n          ? textFunction\n          : textConstant)(value))\n      : this.node().textContent;\n};\n\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\n\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\n\nfunction htmlFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.innerHTML = v == null ? \"\" : v;\n  };\n}\n\nvar selection_html = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? htmlRemove : (typeof value === \"function\"\n          ? htmlFunction\n          : htmlConstant)(value))\n      : this.node().innerHTML;\n};\n\nfunction raise() {\n  if (this.nextSibling) this.parentNode.appendChild(this);\n}\n\nvar selection_raise = function() {\n  return this.each(raise);\n};\n\nfunction lower() {\n  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\n\nvar selection_lower = function() {\n  return this.each(lower);\n};\n\nvar selection_append = function(name) {\n  var create = typeof name === \"function\" ? name : creator(name);\n  return this.select(function() {\n    return this.appendChild(create.apply(this, arguments));\n  });\n};\n\nfunction constantNull() {\n  return null;\n}\n\nvar selection_insert = function(name, before) {\n  var create = typeof name === \"function\" ? name : creator(name),\n      select = before == null ? constantNull : typeof before === \"function\" ? before : selector(before);\n  return this.select(function() {\n    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);\n  });\n};\n\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nvar selection_remove = function() {\n  return this.each(remove);\n};\n\nvar selection_datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.node().__data__;\n};\n\nfunction dispatchEvent(node, type, params) {\n  var window = defaultView(node),\n      event = window.CustomEvent;\n\n  if (typeof event === \"function\") {\n    event = new event(type, params);\n  } else {\n    event = window.document.createEvent(\"Event\");\n    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;\n    else event.initEvent(type, false, false);\n  }\n\n  node.dispatchEvent(event);\n}\n\nfunction dispatchConstant(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params);\n  };\n}\n\nfunction dispatchFunction(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params.apply(this, arguments));\n  };\n}\n\nvar selection_dispatch = function(type, params) {\n  return this.each((typeof params === \"function\"\n      ? dispatchFunction\n      : dispatchConstant)(type, params));\n};\n\nvar root = [null];\n\nfunction Selection(groups, parents) {\n  this._groups = groups;\n  this._parents = parents;\n}\n\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\n\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: selection_select,\n  selectAll: selection_selectAll,\n  filter: selection_filter,\n  data: selection_data,\n  enter: selection_enter,\n  exit: selection_exit,\n  merge: selection_merge,\n  order: selection_order,\n  sort: selection_sort,\n  call: selection_call,\n  nodes: selection_nodes,\n  node: selection_node,\n  size: selection_size,\n  empty: selection_empty,\n  each: selection_each,\n  attr: selection_attr,\n  style: selection_style,\n  property: selection_property,\n  classed: selection_classed,\n  text: selection_text,\n  html: selection_html,\n  raise: selection_raise,\n  lower: selection_lower,\n  append: selection_append,\n  insert: selection_insert,\n  remove: selection_remove,\n  datum: selection_datum,\n  on: selection_on,\n  dispatch: selection_dispatch\n};\n\nvar select = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([[document.querySelector(selector)]], [document.documentElement])\n      : new Selection([[selector]], root);\n};\n\nvar selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])\n      : new Selection([selector == null ? [] : selector], root);\n};\n\nvar touch = function(node, touches, identifier) {\n  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;\n\n  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {\n    if ((touch = touches[i]).identifier === identifier) {\n      return point(node, touch);\n    }\n  }\n\n  return null;\n};\n\nvar touches = function(node, touches) {\n  if (touches == null) touches = sourceEvent().touches;\n\n  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {\n    points[i] = point(node, touches[i]);\n  }\n\n  return points;\n};\n\nfunction nopropagation() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar dragDisable = function(view) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", noevent, true);\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", noevent, true);\n  } else {\n    root.__noselect = root.style.MozUserSelect;\n    root.style.MozUserSelect = \"none\";\n  }\n};\n\nfunction yesdrag(view, noclick) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection$$1.on(\"click.drag\", noevent, true);\n    setTimeout(function() { selection$$1.on(\"click.drag\", null); }, 0);\n  }\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", null);\n  } else {\n    root.style.MozUserSelect = root.__noselect;\n    delete root.__noselect;\n  }\n}\n\nvar constant$2 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {\n  this.target = target;\n  this.type = type;\n  this.subject = subject;\n  this.identifier = id;\n  this.active = active;\n  this.x = x;\n  this.y = y;\n  this.dx = dx;\n  this.dy = dy;\n  this._ = dispatch;\n}\n\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$1() {\n  return !exports.event.button;\n}\n\nfunction defaultContainer() {\n  return this.parentNode;\n}\n\nfunction defaultSubject(d) {\n  return d == null ? {x: exports.event.x, y: exports.event.y} : d;\n}\n\nfunction touchable() {\n  return \"ontouchstart\" in this;\n}\n\nvar drag = function() {\n  var filter = defaultFilter$1,\n      container = defaultContainer,\n      subject = defaultSubject,\n      gestures = {},\n      listeners = dispatch(\"start\", \"drag\", \"end\"),\n      active = 0,\n      mousedownx,\n      mousedowny,\n      mousemoving,\n      touchending,\n      clickDistance2 = 0;\n\n  function drag(selection) {\n    selection\n        .on(\"mousedown.drag\", mousedowned)\n      .filter(touchable)\n        .on(\"touchstart.drag\", touchstarted)\n        .on(\"touchmove.drag\", touchmoved)\n        .on(\"touchend.drag touchcancel.drag\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var gesture = beforestart(\"mouse\", container.apply(this, arguments), mouse, this, arguments);\n    if (!gesture) return;\n    select(exports.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n    dragDisable(exports.event.view);\n    nopropagation();\n    mousemoving = false;\n    mousedownx = exports.event.clientX;\n    mousedowny = exports.event.clientY;\n    gesture(\"start\");\n  }\n\n  function mousemoved() {\n    noevent();\n    if (!mousemoving) {\n      var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\");\n  }\n\n  function mouseupped() {\n    select(exports.event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(exports.event.view, mousemoving);\n    noevent();\n    gestures.mouse(\"end\");\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var touches$$1 = exports.event.changedTouches,\n        c = container.apply(this, arguments),\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {\n        nopropagation();\n        gesture(\"start\");\n      }\n    }\n  }\n\n  function touchmoved() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        noevent();\n        gesture(\"drag\");\n      }\n    }\n  }\n\n  function touchended() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        nopropagation();\n        gesture(\"end\");\n      }\n    }\n  }\n\n  function beforestart(id, container, point, that, args) {\n    var p = point(container, id), s, dx, dy,\n        sublisteners = listeners.copy();\n\n    if (!customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;\n      dx = s.x - p[0] || 0;\n      dy = s.y - p[1] || 0;\n      return true;\n    })) return;\n\n    return function gesture(type) {\n      var p0 = p, n;\n      switch (type) {\n        case \"start\": gestures[id] = gesture, n = active++; break;\n        case \"end\": delete gestures[id], --active; // nobreak\n        case \"drag\": p = point(container, id), n = active; break;\n      }\n      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n    };\n  }\n\n  drag.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$2(!!_), drag) : filter;\n  };\n\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$2(_), drag) : container;\n  };\n\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$2(_), drag) : subject;\n  };\n\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n\n  return drag;\n};\n\nvar define = function(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n};\n\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\n\nfunction Color() {}\n\nvar darker = 0.7;\nvar brighter = 1 / darker;\n\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\";\nvar reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\";\nvar reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\";\nvar reHex3 = /^#([0-9a-f]{3})$/;\nvar reHex6 = /^#([0-9a-f]{6})$/;\nvar reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\");\nvar reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\");\nvar reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\");\nvar reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\");\nvar reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\");\nvar reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\");\n\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\n\ndefine(Color, color, {\n  displayable: function() {\n    return this.rgb().displayable();\n  },\n  toString: function() {\n    return this.rgb() + \"\";\n  }\n});\n\nfunction color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n      : named.hasOwnProperty(format) ? rgbn(named[format])\n      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n      : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb;\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\n\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\n\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Rgb, rgb, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function() {\n    return this;\n  },\n  displayable: function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255)\n        && (0 <= this.opacity && this.opacity <= 1);\n  },\n  toString: function() {\n    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\")\n        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n        + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl;\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\n\nfunction hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hsl, hsl, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  displayable: function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1)\n        && (0 <= this.opacity && this.opacity <= 1);\n  }\n}));\n\n/* From FvD 13.37, CSS Color Module Level 3 */\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60\n      : h < 180 ? m2\n      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n      : m1) * 255;\n}\n\nvar deg2rad = Math.PI / 180;\nvar rad2deg = 180 / Math.PI;\n\nvar Kn = 18;\nvar Xn = 0.950470;\nvar Yn = 1;\nvar Zn = 1.088830;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl) {\n    var h = o.h * deg2rad;\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var b = rgb2xyz(o.r),\n      a = rgb2xyz(o.g),\n      l = rgb2xyz(o.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nfunction lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\n\nfunction Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Lab, lab, extend(Color, {\n  brighter: function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n      this.opacity\n    );\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  var h = Math.atan2(o.b, o.a) * rad2deg;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nfunction hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hcl, hcl, extend(Color, {\n  brighter: function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function() {\n    return labConvert(this).rgb();\n  }\n}));\n\nvar A = -0.14861;\nvar B = +1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = +1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nfunction cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Cubehelix, cubehelix, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh)),\n      this.opacity\n    );\n  }\n}));\n\nfunction basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nvar basis$1 = function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar basisClosed = function(values) {\n  var n = values.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n        v0 = values[(i + n - 1) % n],\n        v1 = values[i % n],\n        v2 = values[(i + 1) % n],\n        v3 = values[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar constant$3 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction linear(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nfunction hue(a, b) {\n  var d = b - a;\n  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);\n}\n\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);\n  };\n}\n\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);\n}\n\nvar interpolateRgb = (function rgbGamma(y) {\n  var color$$1 = gamma(y);\n\n  function rgb$$1(start, end) {\n    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),\n        g = color$$1(start.g, end.g),\n        b = color$$1(start.b, end.b),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb$$1.gamma = rgbGamma;\n\n  return rgb$$1;\n})(1);\n\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length,\n        r = new Array(n),\n        g = new Array(n),\n        b = new Array(n),\n        i, color$$1;\n    for (i = 0; i < n; ++i) {\n      color$$1 = rgb(colors[i]);\n      r[i] = color$$1.r || 0;\n      g[i] = color$$1.g || 0;\n      b[i] = color$$1.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color$$1.opacity = 1;\n    return function(t) {\n      color$$1.r = r(t);\n      color$$1.g = g(t);\n      color$$1.b = b(t);\n      return color$$1 + \"\";\n    };\n  };\n}\n\nvar rgbBasis = rgbSpline(basis$1);\nvar rgbBasisClosed = rgbSpline(basisClosed);\n\nvar array$1 = function(a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(nb),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function(t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nvar date = function(a, b) {\n  var d = new Date;\n  return a = +a, b -= a, function(t) {\n    return d.setTime(a + b * t), d;\n  };\n};\n\nvar reinterpolate = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return a + b * t;\n  };\n};\n\nvar object = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateValue(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n};\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\n\nvar interpolateString = function(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n      am, // current match in a\n      bm, // current match in b\n      bs, // string preceding current number in b, if any\n      i = -1, // index in s\n      s = [], // string constants and placeholders\n      q = []; // number interpolators\n\n  // Coerce inputs to strings.\n  a = a + \"\", b = b + \"\";\n\n  // Interpolate pairs of numbers in a & b.\n  while ((am = reA.exec(a))\n      && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else { // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({i: i, x: reinterpolate(am, bm)});\n    }\n    bi = reB.lastIndex;\n  }\n\n  // Add remains of b.\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  }\n\n  // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return s.length < 2 ? (q[0]\n      ? one(q[0].x)\n      : zero(b))\n      : (b = q.length, function(t) {\n          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n          return s.join(\"\");\n        });\n};\n\nvar interpolateValue = function(a, b) {\n  var t = typeof b, c;\n  return b == null || t === \"boolean\" ? constant$3(b)\n      : (t === \"number\" ? reinterpolate\n      : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)\n      : b instanceof color ? interpolateRgb\n      : b instanceof Date ? date\n      : Array.isArray(b) ? array$1\n      : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object\n      : reinterpolate)(a, b);\n};\n\nvar interpolateRound = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return Math.round(a + b * t);\n  };\n};\n\nvar degrees = 180 / Math.PI;\n\nvar identity$2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\n\nvar decompose = function(a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n};\n\nvar cssNode;\nvar cssRoot;\nvar cssView;\nvar svgNode;\n\nfunction parseCss(value) {\n  if (value === \"none\") return identity$2;\n  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n  cssNode.style.transform = value;\n  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n  cssRoot.removeChild(cssNode);\n  value = value.slice(7, -1).split(\",\");\n  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n}\n\nfunction parseSvg(value) {\n  if (value == null) return identity$2;\n  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;\n  value = value.matrix;\n  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n\n  function pop(s) {\n    return s.length ? s.pop() + \" \" : \"\";\n  }\n\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});\n    } else if (xb || yb) {\n      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path\n      q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: reinterpolate(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"rotate(\" + b + degParen);\n    }\n  }\n\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: reinterpolate(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"skewX(\" + b + degParen);\n    }\n  }\n\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n\n  return function(a, b) {\n    var s = [], // string constants and placeholders\n        q = []; // number interpolators\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null; // gc\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  };\n}\n\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\nvar rho = Math.SQRT2;\nvar rho2 = 2;\nvar rho4 = 4;\nvar epsilon2 = 1e-12;\n\nfunction cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n}\n\n// p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\nvar interpolateZoom = function(p0, p1) {\n  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],\n      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],\n      dx = ux1 - ux0,\n      dy = uy1 - uy0,\n      d2 = dx * dx + dy * dy,\n      i,\n      S;\n\n  // Special case for u0 ≅ u1.\n  if (d2 < epsilon2) {\n    S = Math.log(w1 / w0) / rho;\n    i = function(t) {\n      return [\n        ux0 + t * dx,\n        uy0 + t * dy,\n        w0 * Math.exp(rho * t * S)\n      ];\n    };\n  }\n\n  // General case.\n  else {\n    var d1 = Math.sqrt(d2),\n        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n    S = (r1 - r0) / rho;\n    i = function(t) {\n      var s = t * S,\n          coshr0 = cosh(r0),\n          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n      return [\n        ux0 + u * dx,\n        uy0 + u * dy,\n        w0 * coshr0 / cosh(rho * s + r0)\n      ];\n    };\n  }\n\n  i.duration = S * 1000;\n\n  return i;\n};\n\nfunction hsl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),\n        s = nogamma(start.s, end.s),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.s = s(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hsl$2 = hsl$1(hue);\nvar hslLong = hsl$1(nogamma);\n\nfunction lab$1(start, end) {\n  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),\n      a = nogamma(start.a, end.a),\n      b = nogamma(start.b, end.b),\n      opacity = nogamma(start.opacity, end.opacity);\n  return function(t) {\n    start.l = l(t);\n    start.a = a(t);\n    start.b = b(t);\n    start.opacity = opacity(t);\n    return start + \"\";\n  };\n}\n\nfunction hcl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),\n        c = nogamma(start.c, end.c),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.c = c(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hcl$2 = hcl$1(hue);\nvar hclLong = hcl$1(nogamma);\n\nfunction cubehelix$1(hue$$1) {\n  return (function cubehelixGamma(y) {\n    y = +y;\n\n    function cubehelix$$1(start, end) {\n      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),\n          s = nogamma(start.s, end.s),\n          l = nogamma(start.l, end.l),\n          opacity = nogamma(start.opacity, end.opacity);\n      return function(t) {\n        start.h = h(t);\n        start.s = s(t);\n        start.l = l(Math.pow(t, y));\n        start.opacity = opacity(t);\n        return start + \"\";\n      };\n    }\n\n    cubehelix$$1.gamma = cubehelixGamma;\n\n    return cubehelix$$1;\n  })(1);\n}\n\nvar cubehelix$2 = cubehelix$1(hue);\nvar cubehelixLong = cubehelix$1(nogamma);\n\nvar quantize = function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n};\n\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1000;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nfunction timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow;\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, delay);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\nvar timeout$1 = function(callback, delay, time) {\n  var t = new Timer;\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n};\n\nvar interval$1 = function(callback, delay, time) {\n  var t = new Timer, total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? now() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n};\n\nvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\n\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n\nvar schedule = function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n};\n\nfunction init(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction set$1(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction get$1(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout$1(start);\n\n      // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout$1(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n\nvar interrupt = function(node, name) {\n  var schedules = node.__transition,\n      schedule$$1,\n      active,\n      empty = true,\n      i;\n\n  if (!schedules) return;\n\n  name = name == null ? null : name + \"\";\n\n  for (i in schedules) {\n    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }\n    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;\n    schedule$$1.state = ENDED;\n    schedule$$1.timer.stop();\n    if (active) schedule$$1.on.call(\"interrupt\", node, node.__data__, schedule$$1.index, schedule$$1.group);\n    delete schedules[i];\n  }\n\n  if (empty) delete node.__transition;\n};\n\nvar selection_interrupt = function(name) {\n  return this.each(function() {\n    interrupt(this, name);\n  });\n};\n\nfunction tweenRemove(id, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule$$1 = set$1(this, id),\n        tween = schedule$$1.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    schedule$$1.tween = tween1;\n  };\n}\n\nfunction tweenFunction(id, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    var schedule$$1 = set$1(this, id),\n        tween = schedule$$1.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n) tween1.push(t);\n    }\n\n    schedule$$1.tween = tween1;\n  };\n}\n\nvar transition_tween = function(name, value) {\n  var id = this._id;\n\n  name += \"\";\n\n  if (arguments.length < 2) {\n    var tween = get$1(this.node(), id).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n\n  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n};\n\nfunction tweenValue(transition, name, value) {\n  var id = transition._id;\n\n  transition.each(function() {\n    var schedule$$1 = set$1(this, id);\n    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);\n  });\n\n  return function(node) {\n    return get$1(node, id).value[name];\n  };\n}\n\nvar interpolate = function(a, b) {\n  var c;\n  return (typeof b === \"number\" ? reinterpolate\n      : b instanceof color ? interpolateRgb\n      : (c = color(b)) ? (b = c, interpolateRgb)\n      : interpolateString)(a, b);\n};\n\nfunction attrRemove$1(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS$1(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrConstantNS$1(fullname, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttribute(name);\n    value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction attrFunctionNS$1(fullname, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_attr = function(name, value) {\n  var fullname = namespace(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate;\n  return this.attrTween(name, typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)\n      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + \"\"));\n};\n\nfunction attrTweenNS(fullname, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttributeNS(fullname.space, fullname.local, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nfunction attrTween(name, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttribute(name, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_attrTween = function(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  var fullname = namespace(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n};\n\nfunction delayFunction(id, value) {\n  return function() {\n    init(this, id).delay = +value.apply(this, arguments);\n  };\n}\n\nfunction delayConstant(id, value) {\n  return value = +value, function() {\n    init(this, id).delay = value;\n  };\n}\n\nvar transition_delay = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? delayFunction\n          : delayConstant)(id, value))\n      : get$1(this.node(), id).delay;\n};\n\nfunction durationFunction(id, value) {\n  return function() {\n    set$1(this, id).duration = +value.apply(this, arguments);\n  };\n}\n\nfunction durationConstant(id, value) {\n  return value = +value, function() {\n    set$1(this, id).duration = value;\n  };\n}\n\nvar transition_duration = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? durationFunction\n          : durationConstant)(id, value))\n      : get$1(this.node(), id).duration;\n};\n\nfunction easeConstant(id, value) {\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    set$1(this, id).ease = value;\n  };\n}\n\nvar transition_ease = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each(easeConstant(id, value))\n      : get$1(this.node(), id).ease;\n};\n\nvar transition_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, this._name, this._id);\n};\n\nvar transition_merge = function(transition$$1) {\n  if (transition$$1._id !== this._id) throw new Error;\n\n  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Transition(merges, this._parents, this._name, this._id);\n};\n\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\n\nfunction onFunction(id, name, listener) {\n  var on0, on1, sit = start(name) ? init : set$1;\n  return function() {\n    var schedule$$1 = sit(this, id),\n        on = schedule$$1.on;\n\n    // If this node shared a dispatch with the previous node,\n    // just assign the updated shared dispatch and we’re done!\n    // Otherwise, copy-on-write.\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\n    schedule$$1.on = on1;\n  };\n}\n\nvar transition_on = function(name, listener) {\n  var id = this._id;\n\n  return arguments.length < 2\n      ? get$1(this.node(), id).on.on(name)\n      : this.each(onFunction(id, name, listener));\n};\n\nfunction removeFunction(id) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition) if (+i !== id) return;\n    if (parent) parent.removeChild(this);\n  };\n}\n\nvar transition_remove = function() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n};\n\nvar transition_select = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selector(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, name, id);\n};\n\nvar transition_selectAll = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selectorAll(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {\n          if (child = children[k]) {\n            schedule(child, name, id, k, children, inherit);\n          }\n        }\n        subgroups.push(children);\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, parents, name, id);\n};\n\nvar Selection$1 = selection.prototype.constructor;\n\nvar transition_selection = function() {\n  return new Selection$1(this._groups, this._parents);\n};\n\nfunction styleRemove$1(name, interpolate$$1) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name),\n        value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction styleRemoveEnd(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction styleFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name),\n        value1 = value(this);\n    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_style = function(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate;\n  return value == null ? this\n          .styleTween(name, styleRemove$1(name, i))\n          .on(\"end.style.\" + name, styleRemoveEnd(name))\n      : this.styleTween(name, typeof value === \"function\"\n          ? styleFunction$1(name, i, tweenValue(this, \"style.\" + name, value))\n          : styleConstant$1(name, i, value + \"\"), priority);\n};\n\nfunction styleTween(name, value, priority) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.style.setProperty(name, i(t), priority);\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_styleTween = function(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n};\n\nfunction textConstant$1(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction$1(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\n\nvar transition_text = function(value) {\n  return this.tween(\"text\", typeof value === \"function\"\n      ? textFunction$1(tweenValue(this, \"text\", value))\n      : textConstant$1(value == null ? \"\" : value + \"\"));\n};\n\nvar transition_transition = function() {\n  var name = this._name,\n      id0 = this._id,\n      id1 = newId();\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit = get$1(node, id0);\n        schedule(node, name, id1, i, group, {\n          time: inherit.time + inherit.delay + inherit.duration,\n          delay: 0,\n          duration: inherit.duration,\n          ease: inherit.ease\n        });\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id1);\n};\n\nvar id = 0;\n\nfunction Transition(groups, parents, name, id) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id;\n}\n\nfunction transition(name) {\n  return selection().transition(name);\n}\n\nfunction newId() {\n  return ++id;\n}\n\nvar selection_prototype = selection.prototype;\n\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: transition_select,\n  selectAll: transition_selectAll,\n  filter: transition_filter,\n  merge: transition_merge,\n  selection: transition_selection,\n  transition: transition_transition,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: transition_on,\n  attr: transition_attr,\n  attrTween: transition_attrTween,\n  style: transition_style,\n  styleTween: transition_styleTween,\n  text: transition_text,\n  remove: transition_remove,\n  tween: transition_tween,\n  delay: transition_delay,\n  duration: transition_duration,\n  ease: transition_ease\n};\n\nfunction linear$1(t) {\n  return +t;\n}\n\nfunction quadIn(t) {\n  return t * t;\n}\n\nfunction quadOut(t) {\n  return t * (2 - t);\n}\n\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\n\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\nvar exponent = 3;\n\nvar polyIn = (function custom(e) {\n  e = +e;\n\n  function polyIn(t) {\n    return Math.pow(t, e);\n  }\n\n  polyIn.exponent = custom;\n\n  return polyIn;\n})(exponent);\n\nvar polyOut = (function custom(e) {\n  e = +e;\n\n  function polyOut(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n\n  polyOut.exponent = custom;\n\n  return polyOut;\n})(exponent);\n\nvar polyInOut = (function custom(e) {\n  e = +e;\n\n  function polyInOut(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n\n  polyInOut.exponent = custom;\n\n  return polyInOut;\n})(exponent);\n\nvar pi = Math.PI;\nvar halfPi = pi / 2;\n\nfunction sinIn(t) {\n  return 1 - Math.cos(t * halfPi);\n}\n\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\n\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\nfunction expIn(t) {\n  return Math.pow(2, 10 * t - 10);\n}\n\nfunction expOut(t) {\n  return 1 - Math.pow(2, -10 * t);\n}\n\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n}\n\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\n\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\n\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\n\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\nvar overshoot = 1.70158;\n\nvar backIn = (function custom(s) {\n  s = +s;\n\n  function backIn(t) {\n    return t * t * ((s + 1) * t - s);\n  }\n\n  backIn.overshoot = custom;\n\n  return backIn;\n})(overshoot);\n\nvar backOut = (function custom(s) {\n  s = +s;\n\n  function backOut(t) {\n    return --t * t * ((s + 1) * t + s) + 1;\n  }\n\n  backOut.overshoot = custom;\n\n  return backOut;\n})(overshoot);\n\nvar backInOut = (function custom(s) {\n  s = +s;\n\n  function backInOut(t) {\n    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n  }\n\n  backInOut.overshoot = custom;\n\n  return backInOut;\n})(overshoot);\n\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\n\nvar elasticIn = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticIn(t) {\n    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n  }\n\n  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n  elasticIn.period = function(p) { return custom(a, p); };\n\n  return elasticIn;\n})(amplitude, period);\n\nvar elasticOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticOut.period = function(p) { return custom(a, p); };\n\n  return elasticOut;\n})(amplitude, period);\n\nvar elasticInOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticInOut(t) {\n    return ((t = t * 2 - 1) < 0\n        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n  }\n\n  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticInOut.period = function(p) { return custom(a, p); };\n\n  return elasticInOut;\n})(amplitude, period);\n\nvar defaultTiming = {\n  time: null, // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\n\nfunction inherit(node, id) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id])) {\n    if (!(node = node.parentNode)) {\n      return defaultTiming.time = now(), defaultTiming;\n    }\n  }\n  return timing;\n}\n\nvar selection_transition = function(name) {\n  var id,\n      timing;\n\n  if (name instanceof Transition) {\n    id = name._id, name = name._name;\n  } else {\n    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        schedule(node, name, id, i, group, timing || inherit(node, id));\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id);\n};\n\nselection.prototype.interrupt = selection_interrupt;\nselection.prototype.transition = selection_transition;\n\nvar root$1 = [null];\n\nvar active = function(node, name) {\n  var schedules = node.__transition,\n      schedule$$1,\n      i;\n\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule$$1 = schedules[i]).state > SCHEDULED && schedule$$1.name === name) {\n        return new Transition([[node]], root$1, name, +i);\n      }\n    }\n  }\n\n  return null;\n};\n\nvar constant$4 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar BrushEvent = function(target, type, selection) {\n  this.target = target;\n  this.type = type;\n  this.selection = selection;\n};\n\nfunction nopropagation$1() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$1 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar MODE_DRAG = {name: \"drag\"};\nvar MODE_SPACE = {name: \"space\"};\nvar MODE_HANDLE = {name: \"handle\"};\nvar MODE_CENTER = {name: \"center\"};\n\nvar X = {\n  name: \"x\",\n  handles: [\"e\", \"w\"].map(type),\n  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },\n  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }\n};\n\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },\n  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }\n};\n\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"].map(type),\n  input: function(xy) { return xy; },\n  output: function(xy) { return xy; }\n};\n\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\n\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\n\nvar signsX = {\n  overlay: +1,\n  selection: +1,\n  n: null,\n  e: +1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: +1,\n  se: +1,\n  sw: -1\n};\n\nvar signsY = {\n  overlay: +1,\n  selection: +1,\n  n: -1,\n  e: null,\n  s: +1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: +1,\n  sw: +1\n};\n\nfunction type(t) {\n  return {type: t};\n}\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent() {\n  var svg = this.ownerSVGElement || this;\n  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];\n}\n\n// Like d3.local, but with the name “__brush” rather than auto-generated.\nfunction local$$1(node) {\n  while (!node.__brush) if (!(node = node.parentNode)) return;\n  return node.__brush;\n}\n\nfunction empty(extent) {\n  return extent[0][0] === extent[1][0]\n      || extent[0][1] === extent[1][1];\n}\n\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\n\nfunction brushX() {\n  return brush$1(X);\n}\n\nfunction brushY() {\n  return brush$1(Y);\n}\n\nvar brush = function() {\n  return brush$1(XY);\n};\n\nfunction brush$1(dim) {\n  var extent = defaultExtent,\n      filter = defaultFilter,\n      listeners = dispatch(brush, \"start\", \"brush\", \"end\"),\n      handleSize = 6,\n      touchending;\n\n  function brush(group) {\n    var overlay = group\n        .property(\"__brush\", initialize)\n      .selectAll(\".overlay\")\n      .data([type(\"overlay\")]);\n\n    overlay.enter().append(\"rect\")\n        .attr(\"class\", \"overlay\")\n        .attr(\"pointer-events\", \"all\")\n        .attr(\"cursor\", cursors.overlay)\n      .merge(overlay)\n        .each(function() {\n          var extent = local$$1(this).extent;\n          select(this)\n              .attr(\"x\", extent[0][0])\n              .attr(\"y\", extent[0][1])\n              .attr(\"width\", extent[1][0] - extent[0][0])\n              .attr(\"height\", extent[1][1] - extent[0][1]);\n        });\n\n    group.selectAll(\".selection\")\n      .data([type(\"selection\")])\n      .enter().append(\"rect\")\n        .attr(\"class\", \"selection\")\n        .attr(\"cursor\", cursors.selection)\n        .attr(\"fill\", \"#777\")\n        .attr(\"fill-opacity\", 0.3)\n        .attr(\"stroke\", \"#fff\")\n        .attr(\"shape-rendering\", \"crispEdges\");\n\n    var handle = group.selectAll(\".handle\")\n      .data(dim.handles, function(d) { return d.type; });\n\n    handle.exit().remove();\n\n    handle.enter().append(\"rect\")\n        .attr(\"class\", function(d) { return \"handle handle--\" + d.type; })\n        .attr(\"cursor\", function(d) { return cursors[d.type]; });\n\n    group\n        .each(redraw)\n        .attr(\"fill\", \"none\")\n        .attr(\"pointer-events\", \"all\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n        .on(\"mousedown.brush touchstart.brush\", started);\n  }\n\n  brush.move = function(group, selection) {\n    if (group.selection) {\n      group\n          .on(\"start.brush\", function() { emitter(this, arguments).beforestart().start(); })\n          .on(\"interrupt.brush end.brush\", function() { emitter(this, arguments).end(); })\n          .tween(\"brush\", function() {\n            var that = this,\n                state = that.__brush,\n                emit = emitter(that, arguments),\n                selection0 = state.selection,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(this, arguments) : selection, state.extent),\n                i = interpolateValue(selection0, selection1);\n\n            function tween(t) {\n              state.selection = t === 1 && empty(selection1) ? null : i(t);\n              redraw.call(that);\n              emit.brush();\n            }\n\n            return selection0 && selection1 ? tween : tween(1);\n          });\n    } else {\n      group\n          .each(function() {\n            var that = this,\n                args = arguments,\n                state = that.__brush,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(that, args) : selection, state.extent),\n                emit = emitter(that, args).beforestart();\n\n            interrupt(that);\n            state.selection = selection1 == null || empty(selection1) ? null : selection1;\n            redraw.call(that);\n            emit.start().brush().end();\n          });\n    }\n  };\n\n  function redraw() {\n    var group = select(this),\n        selection = local$$1(this).selection;\n\n    if (selection) {\n      group.selectAll(\".selection\")\n          .style(\"display\", null)\n          .attr(\"x\", selection[0][0])\n          .attr(\"y\", selection[0][1])\n          .attr(\"width\", selection[1][0] - selection[0][0])\n          .attr(\"height\", selection[1][1] - selection[0][1]);\n\n      group.selectAll(\".handle\")\n          .style(\"display\", null)\n          .attr(\"x\", function(d) { return d.type[d.type.length - 1] === \"e\" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })\n          .attr(\"y\", function(d) { return d.type[0] === \"s\" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })\n          .attr(\"width\", function(d) { return d.type === \"n\" || d.type === \"s\" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })\n          .attr(\"height\", function(d) { return d.type === \"e\" || d.type === \"w\" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });\n    }\n\n    else {\n      group.selectAll(\".selection,.handle\")\n          .style(\"display\", \"none\")\n          .attr(\"x\", null)\n          .attr(\"y\", null)\n          .attr(\"width\", null)\n          .attr(\"height\", null);\n    }\n  }\n\n  function emitter(that, args) {\n    return that.__brush.emitter || new Emitter(that, args);\n  }\n\n  function Emitter(that, args) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n  }\n\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1) this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function() {\n      if (this.starting) this.starting = false, this.emit(\"start\");\n      return this;\n    },\n    brush: function() {\n      this.emit(\"brush\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) delete this.state.emitter, this.emit(\"end\");\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function started() {\n    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$1(); }\n    else if (touchending) return;\n    if (!filter.apply(this, arguments)) return;\n\n    var that = this,\n        type = exports.event.target.__data__.type,\n        mode = (exports.event.metaKey ? type = \"overlay\" : type) === \"selection\" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),\n        signX = dim === Y ? null : signsX[type],\n        signY = dim === X ? null : signsY[type],\n        state = local$$1(that),\n        extent = state.extent,\n        selection = state.selection,\n        W = extent[0][0], w0, w1,\n        N = extent[0][1], n0, n1,\n        E = extent[1][0], e0, e1,\n        S = extent[1][1], s0, s1,\n        dx,\n        dy,\n        moving,\n        shifting = signX && signY && exports.event.shiftKey,\n        lockX,\n        lockY,\n        point0 = mouse(that),\n        point = point0,\n        emit = emitter(that, arguments).beforestart();\n\n    if (type === \"overlay\") {\n      state.selection = selection = [\n        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],\n        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]\n      ];\n    } else {\n      w0 = selection[0][0];\n      n0 = selection[0][1];\n      e0 = selection[1][0];\n      s0 = selection[1][1];\n    }\n\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n\n    var group = select(that)\n        .attr(\"pointer-events\", \"none\");\n\n    var overlay = group.selectAll(\".overlay\")\n        .attr(\"cursor\", cursors[type]);\n\n    if (exports.event.touches) {\n      group\n          .on(\"touchmove.brush\", moved, true)\n          .on(\"touchend.brush touchcancel.brush\", ended, true);\n    } else {\n      var view = select(exports.event.view)\n          .on(\"keydown.brush\", keydowned, true)\n          .on(\"keyup.brush\", keyupped, true)\n          .on(\"mousemove.brush\", moved, true)\n          .on(\"mouseup.brush\", ended, true);\n\n      dragDisable(exports.event.view);\n    }\n\n    nopropagation$1();\n    interrupt(that);\n    redraw.call(that);\n    emit.start();\n\n    function moved() {\n      var point1 = mouse(that);\n      if (shifting && !lockX && !lockY) {\n        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;\n        else lockX = true;\n      }\n      point = point1;\n      moving = true;\n      noevent$1();\n      move();\n    }\n\n    function move() {\n      var t;\n\n      dx = point[0] - point0[0];\n      dy = point[1] - point0[1];\n\n      switch (mode) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;\n          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;\n          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));\n          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));\n          break;\n        }\n      }\n\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]);\n      }\n\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]);\n      }\n\n      if (state.selection) selection = state.selection; // May be set by brush.move!\n      if (lockX) w1 = selection[0][0], e1 = selection[1][0];\n      if (lockY) n1 = selection[0][1], s1 = selection[1][1];\n\n      if (selection[0][0] !== w1\n          || selection[0][1] !== n1\n          || selection[1][0] !== e1\n          || selection[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush();\n      }\n    }\n\n    function ended() {\n      nopropagation$1();\n      if (exports.event.touches) {\n        if (exports.event.touches.length) return;\n        if (touchending) clearTimeout(touchending);\n        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n        group.on(\"touchmove.brush touchend.brush touchcancel.brush\", null);\n      } else {\n        yesdrag(exports.event.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!\n      if (empty(selection)) state.selection = null, redraw.call(that);\n      emit.end();\n    }\n\n    function keydowned() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          shifting = signX && signY;\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_HANDLE) {\n            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode = MODE_CENTER;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE; takes priority over ALT\n          if (mode === MODE_HANDLE || mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;\n            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;\n            mode = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$1();\n    }\n\n    function keyupped() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move();\n          }\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n            mode = MODE_HANDLE;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE\n          if (mode === MODE_SPACE) {\n            if (exports.event.altKey) {\n              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode = MODE_CENTER;\n            } else {\n              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n              mode = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type]);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$1();\n    }\n  }\n\n  function initialize() {\n    var state = this.__brush || {selection: null};\n    state.extent = extent.apply(this, arguments);\n    state.dim = dim;\n    return state;\n  }\n\n  brush.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;\n  };\n\n  brush.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$4(!!_), brush) : filter;\n  };\n\n  brush.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush) : handleSize;\n  };\n\n  brush.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush : value;\n  };\n\n  return brush;\n}\n\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi$1 = Math.PI;\nvar halfPi$1 = pi$1 / 2;\nvar tau$1 = pi$1 * 2;\nvar max$1 = Math.max;\n\nfunction compareValue(compare) {\n  return function(a, b) {\n    return compare(\n      a.source.value + a.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\n\nvar chord = function() {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = [],\n        groupIndex = sequence(n),\n        subgroupIndex = [],\n        chords = [],\n        groups = chords.groups = new Array(n),\n        subgroups = new Array(n * n),\n        k,\n        x,\n        x0,\n        dx,\n        i,\n        j;\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(sequence(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) groupIndex.sort(function(a, b) {\n      return sortGroups(groupSums[a], groupSums[b]);\n    });\n\n    // Sort subgroups…\n    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {\n      d.sort(function(a, b) {\n        return sortSubgroups(matrix[i][a], matrix[i][b]);\n      });\n    });\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified?\n    // TODO Allow padding to be specified as percentage?\n    k = max$1(0, tau$1 - padAngle * n) / k;\n    dx = k ? padAngle : tau$1 / n;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[di][j],\n            v = matrix[di][dj],\n            a0 = x,\n            a1 = x += v * k;\n        subgroups[dj * n + di] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups[di] = {\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: groupSums[di]\n      };\n      x += dx;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[j * n + i],\n            target = subgroups[i * n + j];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function(_) {\n    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n};\n\nvar slice$2 = Array.prototype.slice;\n\nvar constant$5 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar pi$2 = Math.PI;\nvar tau$2 = 2 * pi$2;\nvar epsilon$1 = 1e-6;\nvar tauEpsilon = tau$2 - epsilon$1;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon$1)) {}\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon$1) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau$2 + tau$2;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon$1) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi$2)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nfunction defaultSource(d) {\n  return d.source;\n}\n\nfunction defaultTarget(d) {\n  return d.target;\n}\n\nfunction defaultRadius(d) {\n  return d.radius;\n}\n\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\n\nvar ribbon = function() {\n  var source = defaultSource,\n      target = defaultTarget,\n      radius = defaultRadius,\n      startAngle = defaultStartAngle,\n      endAngle = defaultEndAngle,\n      context = null;\n\n  function ribbon() {\n    var buffer,\n        argv = slice$2.call(arguments),\n        s = source.apply(this, argv),\n        t = target.apply(this, argv),\n        sr = +radius.apply(this, (argv[0] = s, argv)),\n        sa0 = startAngle.apply(this, argv) - halfPi$1,\n        sa1 = endAngle.apply(this, argv) - halfPi$1,\n        sx0 = sr * cos(sa0),\n        sy0 = sr * sin(sa0),\n        tr = +radius.apply(this, (argv[0] = t, argv)),\n        ta0 = startAngle.apply(this, argv) - halfPi$1,\n        ta1 = endAngle.apply(this, argv) - halfPi$1;\n\n    if (!context) context = buffer = path();\n\n    context.moveTo(sx0, sy0);\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?\n      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n      context.arc(0, 0, tr, ta0, ta1);\n    }\n    context.quadraticCurveTo(0, 0, sx0, sy0);\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  ribbon.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : radius;\n  };\n\n  ribbon.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : startAngle;\n  };\n\n  ribbon.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : endAngle;\n  };\n\n  ribbon.source = function(_) {\n    return arguments.length ? (source = _, ribbon) : source;\n  };\n\n  ribbon.target = function(_) {\n    return arguments.length ? (target = _, ribbon) : target;\n  };\n\n  ribbon.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;\n  };\n\n  return ribbon;\n};\n\nvar prefix = \"$\";\n\nfunction Map() {}\n\nMap.prototype = map$1.prototype = {\n  constructor: Map,\n  has: function(key) {\n    return (prefix + key) in this;\n  },\n  get: function(key) {\n    return this[prefix + key];\n  },\n  set: function(key, value) {\n    this[prefix + key] = value;\n    return this;\n  },\n  remove: function(key) {\n    var property = prefix + key;\n    return property in this && delete this[property];\n  },\n  clear: function() {\n    for (var property in this) if (property[0] === prefix) delete this[property];\n  },\n  keys: function() {\n    var keys = [];\n    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n    return entries;\n  },\n  size: function() {\n    var size = 0;\n    for (var property in this) if (property[0] === prefix) ++size;\n    return size;\n  },\n  empty: function() {\n    for (var property in this) if (property[0] === prefix) return false;\n    return true;\n  },\n  each: function(f) {\n    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n  }\n};\n\nfunction map$1(object, f) {\n  var map = new Map;\n\n  // Copy constructor.\n  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n  // Index array by numeric index or specified key function.\n  else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n\n    if (f == null) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f(o = object[i], i, object), o);\n  }\n\n  // Convert object to map.\n  else if (object) for (var key in object) map.set(key, object[key]);\n\n  return map;\n}\n\nvar nest = function() {\n  var keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup,\n      nest;\n\n  function apply(array, depth, createResult, setResult) {\n    if (depth >= keys.length) {\n      if (sortValues != null) array.sort(sortValues);\n      return rollup != null ? rollup(array) : array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = map$1(),\n        values,\n        result = createResult();\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n        values.push(value);\n      } else {\n        valuesByKey.set(keyValue, [value]);\n      }\n    }\n\n    valuesByKey.each(function(values, key) {\n      setResult(result, key, apply(values, depth, createResult, setResult));\n    });\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array, sortKey = sortKeys[depth - 1];\n    if (rollup != null && depth >= keys.length) array = map.entries();\n    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n  }\n\n  return nest = {\n    object: function(array) { return apply(array, 0, createObject, setObject); },\n    map: function(array) { return apply(array, 0, createMap, setMap); },\n    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n    key: function(d) { keys.push(d); return nest; },\n    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n    sortValues: function(order) { sortValues = order; return nest; },\n    rollup: function(f) { rollup = f; return nest; }\n  };\n};\n\nfunction createObject() {\n  return {};\n}\n\nfunction setObject(object, key, value) {\n  object[key] = value;\n}\n\nfunction createMap() {\n  return map$1();\n}\n\nfunction setMap(map, key, value) {\n  map.set(key, value);\n}\n\nfunction Set() {}\n\nvar proto = map$1.prototype;\n\nSet.prototype = set$2.prototype = {\n  constructor: Set,\n  has: proto.has,\n  add: function(value) {\n    value += \"\";\n    this[prefix + value] = value;\n    return this;\n  },\n  remove: proto.remove,\n  clear: proto.clear,\n  values: proto.keys,\n  size: proto.size,\n  empty: proto.empty,\n  each: proto.each\n};\n\nfunction set$2(object, f) {\n  var set = new Set;\n\n  // Copy constructor.\n  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n  // Otherwise, assume it’s an array.\n  else if (object) {\n    var i = -1, n = object.length;\n    if (f == null) while (++i < n) set.add(object[i]);\n    else while (++i < n) set.add(f(object[i], i, object));\n  }\n\n  return set;\n}\n\nvar keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\n\nvar values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\n\nvar entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nvar dsv = function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I, c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n};\n\nvar csv = dsv(\",\");\n\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatRows = csv.formatRows;\n\nvar tsv = dsv(\"\\t\");\n\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatRows = tsv.formatRows;\n\nvar center$1 = function(x, y) {\n  var nodes;\n\n  if (x == null) x = 0;\n  if (y == null) y = 0;\n\n  function force() {\n    var i,\n        n = nodes.length,\n        node,\n        sx = 0,\n        sy = 0;\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n\n    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = +_, force) : x;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = +_, force) : y;\n  };\n\n  return force;\n};\n\nvar constant$6 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar jiggle = function() {\n  return (Math.random() - 0.5) * 1e-6;\n};\n\nvar tree_add = function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n};\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nfunction addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n\nvar tree_cover = function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1) {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n        break;\n      }\n      case 2: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n        break;\n      }\n      case 3: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the quadtree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n};\n\nvar tree_data = function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n};\n\nvar tree_extent = function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n};\n\nvar Quad = function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n};\n\nvar tree_find = function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant can’t contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n};\n\nvar tree_remove = function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n};\n\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n\nvar tree_root = function() {\n  return this._root;\n};\n\nvar tree_size = function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n};\n\nvar tree_visit = function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n};\n\nvar tree_visitAfter = function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n};\n\nfunction defaultX(d) {\n  return d[0];\n}\n\nvar tree_x = function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n};\n\nfunction defaultY(d) {\n  return d[1];\n}\n\nvar tree_y = function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n};\n\nfunction quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n\nfunction x(d) {\n  return d.x + d.vx;\n}\n\nfunction y(d) {\n  return d.y + d.vy;\n}\n\nvar collide = function(radius) {\n  var nodes,\n      radii,\n      strength = 1,\n      iterations = 1;\n\n  if (typeof radius !== \"function\") radius = constant$6(radius == null ? 1 : +radius);\n\n  function force() {\n    var i, n = nodes.length,\n        tree,\n        node,\n        xi,\n        yi,\n        ri,\n        ri2;\n\n    for (var k = 0; k < iterations; ++k) {\n      tree = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree.visit(apply);\n      }\n    }\n\n    function apply(quad, x0, y0, x1, y1) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x = xi - data.x - data.vx,\n              y = yi - data.y - data.vy,\n              l = x * x + y * y;\n          if (l < r * r) {\n            if (x === 0) x = jiggle(), l += x * x;\n            if (y === 0) y = jiggle(), l += y * y;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y *= l) * r;\n            data.vx -= x * (r = 1 - r);\n            data.vy -= y * r;\n          }\n        }\n        return;\n      }\n      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n    }\n  }\n\n  function prepare(quad) {\n    if (quad.data) return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n\n  force.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : radius;\n  };\n\n  return force;\n};\n\nfunction index(d) {\n  return d.index;\n}\n\nfunction find(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node) throw new Error(\"missing: \" + nodeId);\n  return node;\n}\n\nvar link = function(links) {\n  var id = index,\n      strength = defaultStrength,\n      strengths,\n      distance = constant$6(30),\n      distances,\n      nodes,\n      count,\n      bias,\n      iterations = 1;\n\n  if (links == null) links = [];\n\n  function defaultStrength(link) {\n    return 1 / Math.min(count[link.source.index], count[link.target.index]);\n  }\n\n  function force(alpha) {\n    for (var k = 0, n = links.length; k < iterations; ++k) {\n      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n        link = links[i], source = link.source, target = link.target;\n        x = target.x + target.vx - source.x - source.vx || jiggle();\n        y = target.y + target.vy - source.y - source.vy || jiggle();\n        l = Math.sqrt(x * x + y * y);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x *= l, y *= l;\n        target.vx -= x * (b = bias[i]);\n        target.vy -= y * b;\n        source.vx += x * (b = 1 - b);\n        source.vy += y * b;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n\n    var i,\n        n = nodes.length,\n        m = links.length,\n        nodeById = map$1(nodes, id),\n        link;\n\n    for (i = 0, count = new Array(n); i < m; ++i) {\n      link = links[i], link.index = i;\n      if (typeof link.source !== \"object\") link.source = find(nodeById, link.source);\n      if (typeof link.target !== \"object\") link.target = find(nodeById, link.target);\n      count[link.source.index] = (count[link.source.index] || 0) + 1;\n      count[link.target.index] = (count[link.target.index] || 0) + 1;\n    }\n\n    for (i = 0, bias = new Array(m); i < m; ++i) {\n      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n    }\n\n    strengths = new Array(m), initializeStrength();\n    distances = new Array(m), initializeDistance();\n  }\n\n  function initializeStrength() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n\n  function initializeDistance() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n\n  force.id = function(_) {\n    return arguments.length ? (id = _, force) : id;\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initializeStrength(), force) : strength;\n  };\n\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant$6(+_), initializeDistance(), force) : distance;\n  };\n\n  return force;\n};\n\nfunction x$1(d) {\n  return d.x;\n}\n\nfunction y$1(d) {\n  return d.y;\n}\n\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nvar simulation = function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = map$1(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i, n = nodes.length, node;\n\n    alpha += (alphaTarget - alpha) * alphaDecay;\n\n    forces.each(function(force) {\n      force(alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (node.fx == null) node.x += node.vx *= velocityDecay;\n      else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= velocityDecay;\n      else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n};\n\nvar manyBody = function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant$6(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = q.value)) {\n          strength += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / strength;\n      quad.y = y / strength;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n};\n\nvar x$2 = function(x) {\n  var strength = constant$6(0.1),\n      nodes,\n      strengths,\n      xz;\n\n  if (typeof x !== \"function\") x = constant$6(x == null ? 0 : +x);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : x;\n  };\n\n  return force;\n};\n\nvar y$2 = function(y) {\n  var strength = constant$6(0.1),\n      nodes,\n      strengths,\n      yz;\n\n  if (typeof y !== \"function\") y = constant$6(y == null ? 0 : +y);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : y;\n  };\n\n  return force;\n};\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nvar formatDecimal = function(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n};\n\nvar exponent$1 = function(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n};\n\nvar formatGroup = function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n};\n\nvar formatNumerals = function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n};\n\nvar formatDefault = function(x, p) {\n  x = x.toPrecision(p);\n\n  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (x[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      case \"e\": break out;\n      default: if (i0 > 0) i0 = 0; break;\n    }\n  }\n\n  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n};\n\nvar prefixExponent;\n\nvar formatPrefixAuto = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n};\n\nvar formatRounded = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n};\n\nvar formatTypes = {\n  \"\": formatDefault,\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\n// [[fill]align][sign][symbol][0][width][,][.precision][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\nfunction formatSpecifier(specifier) {\n  return new FormatSpecifier(specifier);\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nfunction FormatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n  var match,\n      fill = match[1] || \" \",\n      align = match[2] || \">\",\n      sign = match[3] || \"-\",\n      symbol = match[4] || \"\",\n      zero = !!match[5],\n      width = match[6] && +match[6],\n      comma = !!match[7],\n      precision = match[8] && +match[8].slice(1),\n      type = match[9] || \"\";\n\n  // The \"n\" type is an alias for \",g\".\n  if (type === \"n\") comma = true, type = \"g\";\n\n  // Map invalid types to the default format.\n  else if (!formatTypes[type]) type = \"\";\n\n  // If zero fill is specified, padding goes after sign and before digits.\n  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n  this.fill = fill;\n  this.align = align;\n  this.sign = sign;\n  this.symbol = symbol;\n  this.zero = zero;\n  this.width = width;\n  this.comma = comma;\n  this.precision = precision;\n  this.type = type;\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + this.type;\n};\n\nvar identity$3 = function(x) {\n  return x;\n};\n\nvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nvar formatLocale = function(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,\n      currency = locale.currency,\n      decimal = locale.decimal,\n      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,\n      percent = locale.percent || \"%\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        type = specifier.type;\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = !type || /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? (type ? 6 : 12)\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = formatType(Math.abs(value), precision);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n};\n\nvar locale$1;\n\n\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nfunction defaultLocale(definition) {\n  locale$1 = formatLocale(definition);\n  exports.format = locale$1.format;\n  exports.formatPrefix = locale$1.formatPrefix;\n  return locale$1;\n}\n\nvar precisionFixed = function(step) {\n  return Math.max(0, -exponent$1(Math.abs(step)));\n};\n\nvar precisionPrefix = function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));\n};\n\nvar precisionRound = function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;\n};\n\n// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nvar adder = function() {\n  return new Adder;\n};\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add$1(temp, y, this.t);\n    add$1(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add$1(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n\nvar epsilon$2 = 1e-6;\nvar epsilon2$1 = 1e-12;\nvar pi$3 = Math.PI;\nvar halfPi$2 = pi$3 / 2;\nvar quarterPi = pi$3 / 4;\nvar tau$3 = pi$3 * 2;\n\nvar degrees$1 = 180 / pi$3;\nvar radians = pi$3 / 180;\n\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos$1 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\n\nvar log = Math.log;\nvar pow = Math.pow;\nvar sin$1 = Math.sin;\nvar sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);\n}\n\nfunction haversin(x) {\n  return (x = sin$1(x / 2)) * x;\n}\n\nfunction noop$1() {}\n\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nvar geoStream = function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n};\n\nvar areaRingSum = adder();\n\nvar areaSum = adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\n\nvar areaStream = {\n  point: noop$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop$1;\n  },\n  sphere: function() {\n    areaSum.add(tau$3);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnoli’s\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos$1(phi),\n      sinPhi = sin$1(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos$1(adLambda),\n      v = k * sdLambda * sin$1(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nvar area = function(object) {\n  areaSum.reset();\n  geoStream(object, areaStream);\n  return areaSum * 2;\n};\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);\n  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\nvar lambda0$1;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda00$1;\nvar phi00$1;\nvar p0;\nvar deltaSum = adder();\nvar ranges;\nvar range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon$2) phi1 = 90;\n    else if (deltaSum < -epsilon$2) phi0 = -90;\n    range[0] = lambda0$1, range[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign$$1 = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees$1 * sign$$1,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = inflection[1] * degrees$1;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = -inflection[1] * degrees$1;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0$1) {\n        if (lambda < lambda0$1) lambda0$1 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0$1, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00$1 = lambda, phi00$1 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00$1, phi00$1);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);\n  range[0] = lambda0$1, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nvar bounds = function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n  ranges = [];\n  geoStream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0$1 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0$1, phi0], [lambda1, phi1]];\n};\n\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda00$2;\nvar phi00$2;\nvar x0;\nvar y0;\nvar z0; // previous point\n\nvar centroidStream = {\n  sphere: noop$1,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00$2, phi00$2);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00$2 = lambda, phi00$2 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nvar centroid = function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  geoStream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2$1) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2$1) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];\n};\n\nvar constant$7 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar compose = function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n};\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau$3) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos$1(deltaPhi),\n      sinDeltaPhi = sin$1(deltaPhi),\n      cosDeltaGamma = cos$1(deltaGamma),\n      sinDeltaGamma = sin$1(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nvar rotation = function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  };\n\n  return forward;\n};\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos$1(radius),\n      sinRadius = sin$1(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau$3;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;\n}\n\nvar circle = function() {\n  var center = constant$7([0, 0]),\n      radius = constant$7(90),\n      precision = constant$7(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees$1, x[1] *= degrees$1;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant$7([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$7(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant$7(+_), circle) : precision;\n  };\n\n  return circle;\n};\n\nvar clipBuffer = function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop$1,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n};\n\nvar clipLine = function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n};\n\nvar pointEqual = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;\n};\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nvar clipPolygon = function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link$1(subject);\n  link$1(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n};\n\nfunction link$1(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nfunction clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nvar extent$1 = function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n};\n\nvar sum$1 = adder();\n\nvar polygonContains = function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin$1(lambda), -cos$1(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum$1.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin$1(phi0),\n        cosPhi0 = cos$1(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin$1(phi1),\n          cosPhi1 = cos$1(phi1),\n          delta = lambda1 - lambda0,\n          sign$$1 = delta >= 0 ? 1 : -1,\n          absDelta = sign$$1 * delta,\n          antimeridian = absDelta > pi$3,\n          k = sinPhi0 * sinPhi1;\n\n      sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));\n      angle += antimeridian ? delta + sign$$1 * tau$3 : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);\n};\n\nvar lengthSum = adder();\nvar lambda0$2;\nvar sinPhi0$1;\nvar cosPhi0$1;\n\nvar lengthStream = {\n  sphere: noop$1,\n  point: noop$1,\n  lineStart: lengthLineStart,\n  lineEnd: noop$1,\n  polygonStart: noop$1,\n  polygonEnd: noop$1\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop$1;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin$1(phi),\n      cosPhi = cos$1(phi),\n      delta = abs(lambda - lambda0$2),\n      cosDelta = cos$1(delta),\n      sinDelta = sin$1(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n}\n\nvar length$1 = function(object) {\n  lengthSum.reset();\n  geoStream(object, lengthStream);\n  return +lengthSum;\n};\n\nvar coordinates = [null, null];\nvar object$1 = {type: \"LineString\", coordinates: coordinates};\n\nvar distance = function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length$1(object$1);\n};\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon$2;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nvar contains = function(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n};\n\nfunction graticuleX(y0, y1, dy) {\n  var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nfunction graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$2; }).map(x))\n        .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$2; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])\n      .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);\n}\n\nfunction graticule10() {\n  return graticule()();\n}\n\nvar interpolate$1 = function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos$1(y0),\n      sy0 = sin$1(y0),\n      cy1 = cos$1(y1),\n      sy1 = sin$1(y1),\n      kx0 = cy0 * cos$1(x0),\n      ky0 = cy0 * sin$1(x0),\n      kx1 = cy1 * cos$1(x1),\n      ky1 = cy1 * sin$1(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin$1(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin$1(t *= d) / k,\n        A = sin$1(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees$1,\n      atan2(z, sqrt(x * x + y * y)) * degrees$1\n    ];\n  } : function() {\n    return [x0 * degrees$1, y0 * degrees$1];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n};\n\nvar identity$4 = function(x) {\n  return x;\n};\n\nvar areaSum$1 = adder();\nvar areaRingSum$1 = adder();\nvar x00;\nvar y00;\nvar x0$1;\nvar y0$1;\n\nvar areaStream$1 = {\n  point: noop$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: function() {\n    areaStream$1.lineStart = areaRingStart$1;\n    areaStream$1.lineEnd = areaRingEnd$1;\n  },\n  polygonEnd: function() {\n    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;\n    areaSum$1.add(abs(areaRingSum$1));\n    areaRingSum$1.reset();\n  },\n  result: function() {\n    var area = areaSum$1 / 2;\n    areaSum$1.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart$1() {\n  areaStream$1.point = areaPointFirst$1;\n}\n\nfunction areaPointFirst$1(x, y) {\n  areaStream$1.point = areaPoint$1;\n  x00 = x0$1 = x, y00 = y0$1 = y;\n}\n\nfunction areaPoint$1(x, y) {\n  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n  x0$1 = x, y0$1 = y;\n}\n\nfunction areaRingEnd$1() {\n  areaPoint$1(x00, y00);\n}\n\nvar x0$2 = Infinity;\nvar y0$2 = x0$2;\nvar x1 = -x0$2;\nvar y1 = x1;\n\nvar boundsStream$1 = {\n  point: boundsPoint$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: noop$1,\n  polygonEnd: noop$1,\n  result: function() {\n    var bounds = [[x0$2, y0$2], [x1, y1]];\n    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint$1(x, y) {\n  if (x < x0$2) x0$2 = x;\n  if (x > x1) x1 = x;\n  if (y < y0$2) y0$2 = y;\n  if (y > y1) y1 = y;\n}\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0$1 = 0;\nvar Y0$1 = 0;\nvar Z0$1 = 0;\nvar X1$1 = 0;\nvar Y1$1 = 0;\nvar Z1$1 = 0;\nvar X2$1 = 0;\nvar Y2$1 = 0;\nvar Z2$1 = 0;\nvar x00$1;\nvar y00$1;\nvar x0$3;\nvar y0$3;\n\nvar centroidStream$1 = {\n  point: centroidPoint$1,\n  lineStart: centroidLineStart$1,\n  lineEnd: centroidLineEnd$1,\n  polygonStart: function() {\n    centroidStream$1.lineStart = centroidRingStart$1;\n    centroidStream$1.lineEnd = centroidRingEnd$1;\n  },\n  polygonEnd: function() {\n    centroidStream$1.point = centroidPoint$1;\n    centroidStream$1.lineStart = centroidLineStart$1;\n    centroidStream$1.lineEnd = centroidLineEnd$1;\n  },\n  result: function() {\n    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n        : [NaN, NaN];\n    X0$1 = Y0$1 = Z0$1 =\n    X1$1 = Y1$1 = Z1$1 =\n    X2$1 = Y2$1 = Z2$1 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint$1(x, y) {\n  X0$1 += x;\n  Y0$1 += y;\n  ++Z0$1;\n}\n\nfunction centroidLineStart$1() {\n  centroidStream$1.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream$1.point = centroidPointLine;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidLineEnd$1() {\n  centroidStream$1.point = centroidPoint$1;\n}\n\nfunction centroidRingStart$1() {\n  centroidStream$1.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd$1() {\n  centroidPointRing(x00$1, y00$1);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream$1.point = centroidPointRing;\n  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0$3,\n      dy = y - y0$3,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n\n  z = y0$3 * x - x0$3 * y;\n  X2$1 += z * (x0$3 + x);\n  Y2$1 += z * (y0$3 + y);\n  Z2$1 += z * 3;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau$3);\n        break;\n      }\n    }\n  },\n  result: noop$1\n};\n\nvar lengthSum$1 = adder();\nvar lengthRing;\nvar x00$2;\nvar y00$2;\nvar x0$4;\nvar y0$4;\n\nvar lengthStream$1 = {\n  point: noop$1,\n  lineStart: function() {\n    lengthStream$1.point = lengthPointFirst$1;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint$1(x00$2, y00$2);\n    lengthStream$1.point = noop$1;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum$1;\n    lengthSum$1.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst$1(x, y) {\n  lengthStream$1.point = lengthPoint$1;\n  x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n}\n\nfunction lengthPoint$1(x, y) {\n  x0$4 -= x, y0$4 -= y;\n  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n  x0$4 = x, y0$4 = y;\n}\n\nfunction PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle$1(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle$1(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle$1(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n\nvar index$1 = function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      geoStream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    geoStream(object, projectionStream(areaStream$1));\n    return areaStream$1.result();\n  };\n\n  path.measure = function(object) {\n    geoStream(object, projectionStream(lengthStream$1));\n    return lengthStream$1.result();\n  };\n\n  path.bounds = function(object) {\n    geoStream(object, projectionStream(boundsStream$1));\n    return boundsStream$1.result();\n  };\n\n  path.centroid = function(object) {\n    geoStream(object, projectionStream(centroidStream$1));\n    return centroidStream$1.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n};\n\nvar clip = function(pointVisible, clipLine, interpolate, start) {\n  return function(rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n};\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);\n}\n\nvar clipAntimeridian = clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi$3, -halfPi$2]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi$3 : -pi$3,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi$3) < epsilon$2) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi$3) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon$2\n      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)\n          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi$2;\n    stream.point(-pi$3, phi);\n    stream.point(0, phi);\n    stream.point(pi$3, phi);\n    stream.point(pi$3, 0);\n    stream.point(pi$3, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi$3, -phi);\n    stream.point(-pi$3, 0);\n    stream.point(-pi$3, phi);\n  } else if (abs(from[0] - to[0]) > epsilon$2) {\n    var lambda = from[0] < to[0] ? pi$3 : -pi$3;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\nvar clipCircle = function(radius, delta) {\n  var cr = cos$1(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos$1(lambda) * cos$1(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon$2;\n            point1[1] += epsilon$2;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi$3) < epsilon$2,\n        meridian = polar || delta < epsilon$2;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi$3 - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);\n};\n\nvar transform = function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n};\n\nfunction transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n\nfunction fitExtent(projection, extent, object) {\n  var w = extent[1][0] - extent[0][0],\n      h = extent[1][1] - extent[0][1],\n      clip = projection.clipExtent && projection.clipExtent();\n\n  projection\n      .scale(150)\n      .translate([0, 0]);\n\n  if (clip != null) projection.clipExtent(null);\n\n  geoStream(object, projection.stream(boundsStream$1));\n\n  var b = boundsStream$1.result(),\n      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n  if (clip != null) projection.clipExtent(clip);\n\n  return projection\n      .scale(k * 150)\n      .translate([x, y]);\n}\n\nfunction fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nvar maxDepth = 16;\nvar cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)\n\nvar resample = function(project, delta2) {\n  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n};\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample$1(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      dx, dy, lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n      theta = null, preclip = clipAntimeridian, // clip angle\n      x0 = null, y0, x1, y1, postclip = identity$4, // clip extent\n      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    point = projectRotate(point[0] * radians, point[1] * radians);\n    return [point[0] * k + dx, dy - point[1] * k];\n  }\n\n  function invert(point) {\n    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n    return point && [point[0] * degrees$1, point[1] * degrees$1];\n  }\n\n  function projectTransform(x, y) {\n    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  function recenter() {\n    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n    var center = project(lambda, phi);\n    dx = x - center[0] * k;\n    dy = y + center[1] * k;\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n\nfunction conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi$3 / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];\n  };\n\n  return p;\n}\n\nfunction cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos$1(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n\nfunction conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin$1(y)) / n;\n    return [r * sin$1(x *= n), r0 - r * cos$1(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nvar conicEqualArea = function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n};\n\nvar albers = function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n};\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960×500. The projection also works quite well at 960×600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nvar albersUsa = function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n};\n\nfunction azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos$1(x),\n        cy = cos$1(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin$1(x),\n      k * sin$1(y)\n    ];\n  }\n}\n\nfunction azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin$1(c),\n        cc = cos$1(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nvar azimuthalEqualArea = function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n};\n\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin$1(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nvar azimuthalEquidistant = function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n};\n\nfunction mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi$2 + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi$2];\n};\n\nvar mercator = function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau$3);\n};\n\nfunction mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi$3 * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n\nfunction tany(y) {\n  return tan((halfPi$2 + y) / 2);\n}\n\nfunction conicConformalRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }\n    else { if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }\n    var r = f / pow(tany(y), n);\n    return [r * sin$1(n * x), f - r * cos$1(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];\n  };\n\n  return project;\n}\n\nvar conicConformal = function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n};\n\nfunction equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nvar equirectangular = function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n};\n\nfunction conicEquidistantRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon$2) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin$1(nx), g - gy * cos$1(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nvar conicEquidistant = function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n};\n\nfunction gnomonicRaw(x, y) {\n  var cy = cos$1(y), k = cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nvar gnomonic = function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n};\n\nfunction scaleTranslate(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nvar identity$5 = function() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity$4, // scale, translate and reflect\n      x0 = null, y0, x1, y1, clip = identity$4, // clip extent\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform$$1(clip(cacheStream = stream));\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    }\n  };\n};\n\nfunction orthographicRaw(x, y) {\n  return [cos$1(y) * sin$1(x), sin$1(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nvar orthographic = function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon$2);\n};\n\nfunction stereographicRaw(x, y) {\n  var cy = cos$1(y), k = 1 + cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nvar stereographic = function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n};\n\nfunction transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi$2 + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi$2];\n};\n\nvar transverseMercator = function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n};\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\nvar cluster = function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n};\n\nfunction count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nvar node_count = function() {\n  return this.eachAfter(count);\n};\n\nvar node_each = function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n};\n\nvar node_eachBefore = function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n};\n\nvar node_eachAfter = function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n};\n\nvar node_sum = function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n};\n\nvar node_sort = function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n};\n\nvar node_path = function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n};\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n\nvar node_ancestors = function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n};\n\nvar node_descendants = function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n};\n\nvar node_leaves = function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n};\n\nvar node_links = function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n};\n\nfunction hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nfunction computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nfunction Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n\nvar slice$3 = Array.prototype.slice;\n\nfunction shuffle$1(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n\nvar enclose = function(circles) {\n  var i = 0, n = (circles = shuffle$1(slice$3.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n};\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n\nfunction place(a, b, c) {\n  var ax = a.x,\n      ay = a.y,\n      da = b.r + c.r,\n      db = a.r + c.r,\n      dx = b.x - ax,\n      dy = b.y - ay,\n      dc = dx * dx + dy * dy;\n  if (dc) {\n    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),\n        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n    c.x = ax + x * dx + y * dy;\n    c.y = ay + x * dy - y * dx;\n  } else {\n    c.x = ax + db;\n    c.y = ay;\n  }\n}\n\nfunction intersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return dr * dr - 1e-6 > dx * dx + dy * dy;\n}\n\nfunction score(node) {\n  var a = node._,\n      b = node.next._,\n      ab = a.r + b.r,\n      dx = (a.x * b.r + b.x * a.r) / ab,\n      dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction Node$1(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nfunction packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle…\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new Node$1(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // “Closeness” is determined by linear distance along the front-chain.\n    // “Ahead” or “behind” is likewise determined by linear distance.\n    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, c._)) {\n          b = j, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sj += j._.r, j = j.next;\n      } else {\n        if (intersects(k._, c._)) {\n          a = k, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sk += k._.r, k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\nvar siblings = function(circles) {\n  packEnclose(circles);\n  return circles;\n};\n\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\n\nfunction required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n\nfunction constantZero() {\n  return 0;\n}\n\nvar constant$8 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction defaultRadius$1(d) {\n  return Math.sqrt(d.value);\n}\n\nvar index$2 = function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius$1))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === \"function\" ? x : constant$8(+x), pack) : padding;\n  };\n\n  return pack;\n};\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n\nvar roundNode = function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n};\n\nvar treemapDice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n};\n\nvar partition = function() {\n  var dx = 1,\n      dy = 1,\n      padding = 0,\n      round = false;\n\n  function partition(root) {\n    var n = root.height + 1;\n    root.x0 =\n    root.y0 = padding;\n    root.x1 = dx;\n    root.y1 = dy / n;\n    root.eachBefore(positionNode(dy, n));\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(dy, n) {\n    return function(node) {\n      if (node.children) {\n        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n      }\n      var x0 = node.x0,\n          y0 = node.y0,\n          x1 = node.x1 - padding,\n          y1 = node.y1 - padding;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      node.x0 = x0;\n      node.y0 = y0;\n      node.x1 = x1;\n      node.y1 = y1;\n    };\n  }\n\n  partition.round = function(x) {\n    return arguments.length ? (round = !!x, partition) : round;\n  };\n\n  partition.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n  };\n\n  partition.padding = function(x) {\n    return arguments.length ? (padding = +x, partition) : padding;\n  };\n\n  return partition;\n};\n\nvar keyPrefix$1 = \"$\";\nvar preroot = {depth: -1};\nvar ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nvar stratify = function() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = keyPrefix$1 + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += \"\")) {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix$1 + nodeId];\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n};\n\nfunction defaultSeparation$1(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nvar tree = function() {\n  var separation = defaultSeparation$1,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n};\n\nvar treemapSlice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n};\n\nvar phi = (1 + Math.sqrt(5)) / 2;\n\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nvar squarify = (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n\nvar index$3 = function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n};\n\nvar binary = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((x1 - x0) > (y1 - y0)) {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    } else {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    }\n  }\n};\n\nvar sliceDice = function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n};\n\nvar resquarify = (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n\nvar area$1 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nvar centroid$1 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n};\n\n// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nvar cross$1 = function(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nvar hull = function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n};\n\nvar contains$1 = function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n};\n\nvar length$2 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.sqrt(xa * xa + ya * ya);\n  }\n\n  return perimeter;\n};\n\nvar slice$4 = [].slice;\n\nvar noabort = {};\n\nfunction Queue(size) {\n  this._size = size;\n  this._call =\n  this._error = null;\n  this._tasks = [];\n  this._data = [];\n  this._waiting =\n  this._active =\n  this._ended =\n  this._start = 0; // inside a synchronous task callback?\n}\n\nQueue.prototype = queue.prototype = {\n  constructor: Queue,\n  defer: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"defer after await\");\n    if (this._error != null) return this;\n    var t = slice$4.call(arguments, 1);\n    t.push(callback);\n    ++this._waiting, this._tasks.push(t);\n    poke$1(this);\n    return this;\n  },\n  abort: function() {\n    if (this._error == null) abort(this, new Error(\"abort\"));\n    return this;\n  },\n  await: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"multiple await\");\n    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };\n    maybeNotify(this);\n    return this;\n  },\n  awaitAll: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"multiple await\");\n    this._call = callback;\n    maybeNotify(this);\n    return this;\n  }\n};\n\nfunction poke$1(q) {\n  if (!q._start) {\n    try { start$1(q); } // let the current task complete\n    catch (e) {\n      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously\n      else if (!q._data) throw e; // await callback errored synchronously\n    }\n  }\n}\n\nfunction start$1(q) {\n  while (q._start = q._waiting && q._active < q._size) {\n    var i = q._ended + q._active,\n        t = q._tasks[i],\n        j = t.length - 1,\n        c = t[j];\n    t[j] = end(q, i);\n    --q._waiting, ++q._active;\n    t = c.apply(null, t);\n    if (!q._tasks[i]) continue; // task finished synchronously\n    q._tasks[i] = t || noabort;\n  }\n}\n\nfunction end(q, i) {\n  return function(e, r) {\n    if (!q._tasks[i]) return; // ignore multiple callbacks\n    --q._active, ++q._ended;\n    q._tasks[i] = null;\n    if (q._error != null) return; // ignore secondary errors\n    if (e != null) {\n      abort(q, e);\n    } else {\n      q._data[i] = r;\n      if (q._waiting) poke$1(q);\n      else maybeNotify(q);\n    }\n  };\n}\n\nfunction abort(q, e) {\n  var i = q._tasks.length, t;\n  q._error = e; // ignore active callbacks\n  q._data = undefined; // allow gc\n  q._waiting = NaN; // prevent starting\n\n  while (--i >= 0) {\n    if (t = q._tasks[i]) {\n      q._tasks[i] = null;\n      if (t.abort) {\n        try { t.abort(); }\n        catch (e) { /* ignore */ }\n      }\n    }\n  }\n\n  q._active = NaN; // allow notification\n  maybeNotify(q);\n}\n\nfunction maybeNotify(q) {\n  if (!q._active && q._call) {\n    var d = q._data;\n    q._data = undefined; // allow gc\n    q._call(q._error, d);\n  }\n}\n\nfunction queue(concurrency) {\n  if (concurrency == null) concurrency = Infinity;\n  else if (!((concurrency = +concurrency) >= 1)) throw new Error(\"invalid concurrency\");\n  return new Queue(concurrency);\n}\n\nvar defaultSource$1 = function() {\n  return Math.random();\n};\n\nvar uniform = (function sourceRandomUniform(source) {\n  function randomUniform(min, max) {\n    min = min == null ? 0 : +min;\n    max = max == null ? 1 : +max;\n    if (arguments.length === 1) max = min, min = 0;\n    else max -= min;\n    return function() {\n      return source() * max + min;\n    };\n  }\n\n  randomUniform.source = sourceRandomUniform;\n\n  return randomUniform;\n})(defaultSource$1);\n\nvar normal = (function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y;\n\n      // If available, use the second previously-generated uniform random.\n      if (x != null) y = x, x = null;\n\n      // Otherwise, generate a new x and y.\n      else do {\n        x = source() * 2 - 1;\n        y = source() * 2 - 1;\n        r = x * x + y * y;\n      } while (!r || r > 1);\n\n      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n\n  randomNormal.source = sourceRandomNormal;\n\n  return randomNormal;\n})(defaultSource$1);\n\nvar logNormal = (function sourceRandomLogNormal(source) {\n  function randomLogNormal() {\n    var randomNormal = normal.source(source).apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n\n  randomLogNormal.source = sourceRandomLogNormal;\n\n  return randomLogNormal;\n})(defaultSource$1);\n\nvar irwinHall = (function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    return function() {\n      for (var sum = 0, i = 0; i < n; ++i) sum += source();\n      return sum;\n    };\n  }\n\n  randomIrwinHall.source = sourceRandomIrwinHall;\n\n  return randomIrwinHall;\n})(defaultSource$1);\n\nvar bates = (function sourceRandomBates(source) {\n  function randomBates(n) {\n    var randomIrwinHall = irwinHall.source(source)(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n\n  randomBates.source = sourceRandomBates;\n\n  return randomBates;\n})(defaultSource$1);\n\nvar exponential$1 = (function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log(1 - source()) / lambda;\n    };\n  }\n\n  randomExponential.source = sourceRandomExponential;\n\n  return randomExponential;\n})(defaultSource$1);\n\nvar request = function(url, callback) {\n  var request,\n      event = dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n      mimeType,\n      headers = map$1(),\n      xhr = new XMLHttpRequest,\n      user = null,\n      password = null,\n      response,\n      responseType,\n      timeout = 0;\n\n  // If IE does not support CORS, use XDomainRequest.\n  if (typeof XDomainRequest !== \"undefined\"\n      && !(\"withCredentials\" in xhr)\n      && /^(http(s)?:)?\\/\\//.test(url)) xhr = new XDomainRequest;\n\n  \"onload\" in xhr\n      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond\n      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };\n\n  function respond(o) {\n    var status = xhr.status, result;\n    if (!status && hasResponse(xhr)\n        || status >= 200 && status < 300\n        || status === 304) {\n      if (response) {\n        try {\n          result = response.call(request, xhr);\n        } catch (e) {\n          event.call(\"error\", request, e);\n          return;\n        }\n      } else {\n        result = xhr;\n      }\n      event.call(\"load\", request, result);\n    } else {\n      event.call(\"error\", request, o);\n    }\n  }\n\n  xhr.onprogress = function(e) {\n    event.call(\"progress\", request, e);\n  };\n\n  request = {\n    header: function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers.get(name);\n      if (value == null) headers.remove(name);\n      else headers.set(name, value + \"\");\n      return request;\n    },\n\n    // If mimeType is non-null and no Accept header is set, a default is used.\n    mimeType: function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return request;\n    },\n\n    // Specifies what type the response value should take;\n    // for instance, arraybuffer, blob, document, or text.\n    responseType: function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return request;\n    },\n\n    timeout: function(value) {\n      if (!arguments.length) return timeout;\n      timeout = +value;\n      return request;\n    },\n\n    user: function(value) {\n      return arguments.length < 1 ? user : (user = value == null ? null : value + \"\", request);\n    },\n\n    password: function(value) {\n      return arguments.length < 1 ? password : (password = value == null ? null : value + \"\", request);\n    },\n\n    // Specify how to convert the response content to a specific type;\n    // changes the callback value on \"load\" events.\n    response: function(value) {\n      response = value;\n      return request;\n    },\n\n    // Alias for send(\"GET\", …).\n    get: function(data, callback) {\n      return request.send(\"GET\", data, callback);\n    },\n\n    // Alias for send(\"POST\", …).\n    post: function(data, callback) {\n      return request.send(\"POST\", data, callback);\n    },\n\n    // If callback is non-null, it will be used for error and load events.\n    send: function(method, data, callback) {\n      xhr.open(method, url, true, user, password);\n      if (mimeType != null && !headers.has(\"accept\")) headers.set(\"accept\", mimeType + \",*/*\");\n      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });\n      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);\n      if (responseType != null) xhr.responseType = responseType;\n      if (timeout > 0) xhr.timeout = timeout;\n      if (callback == null && typeof data === \"function\") callback = data, data = null;\n      if (callback != null && callback.length === 1) callback = fixCallback(callback);\n      if (callback != null) request.on(\"error\", callback).on(\"load\", function(xhr) { callback(null, xhr); });\n      event.call(\"beforesend\", request, xhr);\n      xhr.send(data == null ? null : data);\n      return request;\n    },\n\n    abort: function() {\n      xhr.abort();\n      return request;\n    },\n\n    on: function() {\n      var value = event.on.apply(event, arguments);\n      return value === event ? request : value;\n    }\n  };\n\n  if (callback != null) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    return request.get(callback);\n  }\n\n  return request;\n};\n\nfunction fixCallback(callback) {\n  return function(error, xhr) {\n    callback(error == null ? xhr : null);\n  };\n}\n\nfunction hasResponse(xhr) {\n  var type = xhr.responseType;\n  return type && type !== \"text\"\n      ? xhr.response // null on error\n      : xhr.responseText; // \"\" on error\n}\n\nvar type$1 = function(defaultMimeType, response) {\n  return function(url, callback) {\n    var r = request(url).mimeType(defaultMimeType).response(response);\n    if (callback != null) {\n      if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n      return r.get(callback);\n    }\n    return r;\n  };\n};\n\nvar html = type$1(\"text/html\", function(xhr) {\n  return document.createRange().createContextualFragment(xhr.responseText);\n});\n\nvar json = type$1(\"application/json\", function(xhr) {\n  return JSON.parse(xhr.responseText);\n});\n\nvar text = type$1(\"text/plain\", function(xhr) {\n  return xhr.responseText;\n});\n\nvar xml = type$1(\"application/xml\", function(xhr) {\n  var xml = xhr.responseXML;\n  if (!xml) throw new Error(\"parse error\");\n  return xml;\n});\n\nvar dsv$1 = function(defaultMimeType, parse) {\n  return function(url, row, callback) {\n    if (arguments.length < 3) callback = row, row = null;\n    var r = request(url).mimeType(defaultMimeType);\n    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };\n    r.row(row);\n    return callback ? r.get(callback) : r;\n  };\n};\n\nfunction responseOf(parse, row) {\n  return function(request$$1) {\n    return parse(request$$1.responseText, row);\n  };\n}\n\nvar csv$1 = dsv$1(\"text/csv\", csvParse);\n\nvar tsv$1 = dsv$1(\"text/tab-separated-values\", tsvParse);\n\nvar array$2 = Array.prototype;\n\nvar map$3 = array$2.map;\nvar slice$5 = array$2.slice;\n\nvar implicit = {name: \"implicit\"};\n\nfunction ordinal(range) {\n  var index = map$1(),\n      domain = [],\n      unknown = implicit;\n\n  range = range == null ? [] : slice$5.call(range);\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = map$1();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return scale;\n}\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point$1() {\n  return pointish(band().paddingInner(1));\n}\n\nvar constant$9 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar number$2 = function(x) {\n  return +x;\n};\n\nvar unit = [0, 1];\n\nfunction deinterpolateLinear(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant$9(b);\n}\n\nfunction deinterpolateClamp(deinterpolate) {\n  return function(a, b) {\n    var d = deinterpolate(a = +a, b = +b);\n    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n  };\n}\n\nfunction reinterpolateClamp(reinterpolate$$1) {\n  return function(a, b) {\n    var r = reinterpolate$$1(a = +a, b = +b);\n    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n  };\n}\n\nfunction bimap(domain, range, deinterpolate, reinterpolate$$1) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate$$1(r1, r0);\n  else d0 = deinterpolate(d0, d1), r0 = reinterpolate$$1(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, deinterpolate, reinterpolate$$1) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = deinterpolate(domain[i], domain[i + 1]);\n    r[i] = reinterpolate$$1(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisectRight(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp());\n}\n\n// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nfunction continuous(deinterpolate, reinterpolate$$1) {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      clamp = false,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);\n  }\n\n  scale.invert = function(y) {\n    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate$$1) : reinterpolate$$1)))(+y);\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$2), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice$5.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  return rescale();\n}\n\nvar tickFormat = function(domain, count, specifier) {\n  var start = domain[0],\n      stop = domain[domain.length - 1],\n      step = tickStep(start, stop, count == null ? 10 : count),\n      precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return exports.formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return exports.format(specifier);\n};\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return tickFormat(domain(), count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear$2() {\n  var scale = continuous(deinterpolateLinear, reinterpolate);\n\n  scale.copy = function() {\n    return copy(scale, linear$2());\n  };\n\n  return linearish(scale);\n}\n\nfunction identity$6() {\n  var domain = [0, 1];\n\n  function scale(x) {\n    return +x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$2), scale) : domain.slice();\n  };\n\n  scale.copy = function() {\n    return identity$6().domain(domain);\n  };\n\n  return linearish(scale);\n}\n\nvar nice = function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n};\n\nfunction deinterpolate(a, b) {\n  return (b = Math.log(b / a))\n      ? function(x) { return Math.log(x / a) / b; }\n      : constant$9(b);\n}\n\nfunction reinterpolate$1(a, b) {\n  return a < 0\n      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction log$1() {\n  var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),\n      domain = scale.domain,\n      base = 10,\n      logs = logp(10),\n      pows = powp(10);\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n    if (typeof specifier !== \"function\") specifier = exports.format(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  scale.copy = function() {\n    return copy(scale, log$1().base(base));\n  };\n\n  return scale;\n}\n\nfunction raise$1(x, exponent) {\n  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n}\n\nfunction pow$1() {\n  var exponent = 1,\n      scale = continuous(deinterpolate, reinterpolate),\n      domain = scale.domain;\n\n  function deinterpolate(a, b) {\n    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))\n        ? function(x) { return (raise$1(x, exponent) - a) / b; }\n        : constant$9(b);\n  }\n\n  function reinterpolate(a, b) {\n    b = raise$1(b, exponent) - (a = raise$1(a, exponent));\n    return function(t) { return raise$1(a + b * t, 1 / exponent); };\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n  };\n\n  scale.copy = function() {\n    return copy(scale, pow$1().exponent(exponent));\n  };\n\n  return linearish(scale);\n}\n\nfunction sqrt$1() {\n  return pow$1().exponent(0.5);\n}\n\nfunction quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [];\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\nfunction quantize$1() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1];\n\n  function scale(x) {\n    if (x <= x) return range[bisectRight(domain, x, 0, n)];\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice$5.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return quantize$1()\n        .domain([x0, x1])\n        .range(range);\n  };\n\n  return linearish(scale);\n}\n\nfunction threshold$1() {\n  var domain = [0.5],\n      range = [0, 1],\n      n = 1;\n\n  function scale(x) {\n    if (x <= x) return range[bisectRight(domain, x, 0, n)];\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return threshold$1()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\nvar t0$1 = new Date;\nvar t1$1 = new Date;\n\nfunction newInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = new Date(+date)), date;\n  }\n\n  interval.floor = interval;\n\n  interval.ceil = function(date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function(date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function(date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function(start, stop, step) {\n    var range = [];\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)\n    return range;\n  };\n\n  interval.filter = function(test) {\n    return newInterval(function(date) {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = function(start, end) {\n      t0$1.setTime(+start), t1$1.setTime(+end);\n      floori(t0$1), floori(t1$1);\n      return Math.floor(count(t0$1, t1$1));\n    };\n\n    interval.every = function(step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? function(d) { return field(d) % step === 0; }\n              : function(d) { return interval.count(0, d) % step === 0; });\n    };\n  }\n\n  return interval;\n}\n\nvar millisecond = newInterval(function() {\n  // noop\n}, function(date, step) {\n  date.setTime(+date + step);\n}, function(start, end) {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = function(k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return newInterval(function(date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function(date, step) {\n    date.setTime(+date + step * k);\n  }, function(start, end) {\n    return (end - start) / k;\n  });\n};\n\nvar milliseconds = millisecond.range;\n\nvar durationSecond$1 = 1e3;\nvar durationMinute$1 = 6e4;\nvar durationHour$1 = 36e5;\nvar durationDay$1 = 864e5;\nvar durationWeek$1 = 6048e5;\n\nvar second = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);\n}, function(date, step) {\n  date.setTime(+date + step * durationSecond$1);\n}, function(start, end) {\n  return (end - start) / durationSecond$1;\n}, function(date) {\n  return date.getUTCSeconds();\n});\n\nvar seconds = second.range;\n\nvar minute = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute$1);\n}, function(start, end) {\n  return (end - start) / durationMinute$1;\n}, function(date) {\n  return date.getMinutes();\n});\n\nvar minutes = minute.range;\n\nvar hour = newInterval(function(date) {\n  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;\n  if (offset < 0) offset += durationHour$1;\n  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour$1);\n}, function(start, end) {\n  return (end - start) / durationHour$1;\n}, function(date) {\n  return date.getHours();\n});\n\nvar hours = hour.range;\n\nvar day = newInterval(function(date) {\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setDate(date.getDate() + step);\n}, function(start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nvar days = day.range;\n\nfunction weekday(i) {\n  return newInterval(function(date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;\n  });\n}\n\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\nvar sundays = sunday.range;\nvar mondays = monday.range;\nvar tuesdays = tuesday.range;\nvar wednesdays = wednesday.range;\nvar thursdays = thursday.range;\nvar fridays = friday.range;\nvar saturdays = saturday.range;\n\nvar month = newInterval(function(date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function(start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function(date) {\n  return date.getMonth();\n});\n\nvar months = month.range;\n\nvar year = newInterval(function(date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function(start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function(date) {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\nyear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nvar years = year.range;\n\nvar utcMinute = newInterval(function(date) {\n  date.setUTCSeconds(0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute$1);\n}, function(start, end) {\n  return (end - start) / durationMinute$1;\n}, function(date) {\n  return date.getUTCMinutes();\n});\n\nvar utcMinutes = utcMinute.range;\n\nvar utcHour = newInterval(function(date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour$1);\n}, function(start, end) {\n  return (end - start) / durationHour$1;\n}, function(date) {\n  return date.getUTCHours();\n});\n\nvar utcHours = utcHour.range;\n\nvar utcDay = newInterval(function(date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function(start, end) {\n  return (end - start) / durationDay$1;\n}, function(date) {\n  return date.getUTCDate() - 1;\n});\n\nvar utcDays = utcDay.range;\n\nfunction utcWeekday(i) {\n  return newInterval(function(date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function(start, end) {\n    return (end - start) / durationWeek$1;\n  });\n}\n\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\n\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\nvar utcMonth = newInterval(function(date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function(start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function(date) {\n  return date.getUTCMonth();\n});\n\nvar utcMonths = utcMonth.range;\n\nvar utcYear = newInterval(function(date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function(start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function(date) {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nvar utcYears = utcYear.range;\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newYear(y) {\n  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n}\n\nfunction formatLocale$1(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"S\": formatSeconds,\n    \"U\": formatWeekNumberSunday,\n    \"w\": formatWeekdayNumber,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"S\": formatUTCSeconds,\n    \"U\": formatUTCWeekNumberSunday,\n    \"w\": formatUTCWeekdayNumber,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"S\": parseSeconds,\n    \"U\": parseWeekNumberSunday,\n    \"w\": parseWeekdayNumber,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, newDate) {\n    return function(string) {\n      var d = newYear(1900),\n          i = parseSpecifier(d, specifier, string += \"\", 0);\n      if (i != string.length) return null;\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n        var day$$1 = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return newDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", localDate);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier, utcDate);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  var map = {}, i = -1, n = names.length;\n  while (++i < n) map[names[i].toLowerCase()] = i;\n  return map;\n}\n\nfunction parseWeekdayNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + day.count(year(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(sunday.count(year(d), d), p, 2);\n}\n\nfunction formatWeekdayNumber(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(monday.count(year(d), d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCWeekdayNumber(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nvar locale$2;\n\n\n\n\n\ndefaultLocale$1({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nfunction defaultLocale$1(definition) {\n  locale$2 = formatLocale$1(definition);\n  exports.timeFormat = locale$2.format;\n  exports.timeParse = locale$2.parse;\n  exports.utcFormat = locale$2.utcFormat;\n  exports.utcParse = locale$2.utcParse;\n  return locale$2;\n}\n\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : exports.utcFormat(isoSpecifier);\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : exports.utcParse(isoSpecifier);\n\nvar durationSecond = 1000;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\nfunction date$1(t) {\n  return new Date(t);\n}\n\nfunction number$3(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {\n  var scale = continuous(deinterpolateLinear, reinterpolate),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second$$1,  1,      durationSecond],\n    [second$$1,  5,  5 * durationSecond],\n    [second$$1, 15, 15 * durationSecond],\n    [second$$1, 30, 30 * durationSecond],\n    [minute$$1,  1,      durationMinute],\n    [minute$$1,  5,  5 * durationMinute],\n    [minute$$1, 15, 15 * durationMinute],\n    [minute$$1, 30, 30 * durationMinute],\n    [  hour$$1,  1,      durationHour  ],\n    [  hour$$1,  3,  3 * durationHour  ],\n    [  hour$$1,  6,  6 * durationHour  ],\n    [  hour$$1, 12, 12 * durationHour  ],\n    [   day$$1,  1,      durationDay   ],\n    [   day$$1,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month$$1,  1,      durationMonth ],\n    [ month$$1,  3,  3 * durationMonth ],\n    [  year$$1,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date$$1) {\n    return (second$$1(date$$1) < date$$1 ? formatMillisecond\n        : minute$$1(date$$1) < date$$1 ? formatSecond\n        : hour$$1(date$$1) < date$$1 ? formatMinute\n        : day$$1(date$$1) < date$$1 ? formatHour\n        : month$$1(date$$1) < date$$1 ? (week(date$$1) < date$$1 ? formatDay : formatWeek)\n        : year$$1(date$$1) < date$$1 ? formatMonth\n        : formatYear)(date$$1);\n  }\n\n  function tickInterval(interval$$1, start, stop, step) {\n    if (interval$$1 == null) interval$$1 = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval$$1 === \"number\") {\n      var target = Math.abs(stop - start) / interval$$1,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval$$1);\n        interval$$1 = year$$1;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval$$1 = i[0];\n      } else {\n        step = tickStep(start, stop, interval$$1);\n        interval$$1 = millisecond$$1;\n      }\n    }\n\n    return step == null ? interval$$1 : interval$$1.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map$3.call(_, number$3)) : domain().map(date$1);\n  };\n\n  scale.ticks = function(interval$$1, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval$$1, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval$$1, step) {\n    var d = domain();\n    return (interval$$1 = tickInterval(interval$$1, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval$$1))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));\n  };\n\n  return scale;\n}\n\nvar time = function() {\n  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n};\n\nvar utcTime = function() {\n  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n};\n\nvar colors = function(s) {\n  return s.match(/.{6}/g).map(function(x) {\n    return \"#\" + x;\n  });\n};\n\nvar category10 = colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\nvar category20b = colors(\"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6\");\n\nvar category20c = colors(\"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9\");\n\nvar category20 = colors(\"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5\");\n\nvar cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar rainbow = cubehelix();\n\nvar rainbow$1 = function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  rainbow.h = 360 * t - 100;\n  rainbow.s = 1.5 - 1.5 * ts;\n  rainbow.l = 0.8 - 0.9 * ts;\n  return rainbow + \"\";\n};\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\nvar viridis = ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\nvar magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\nvar inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\nvar plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\nfunction sequential(interpolator) {\n  var x0 = 0,\n      x1 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = (x - x0) / (x1 - x0);\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequential(interpolator).domain([x0, x1]).clamp(clamp);\n  };\n\n  return linearish(scale);\n}\n\nvar constant$10 = function(x) {\n  return function constant() {\n    return x;\n  };\n};\n\nvar abs$1 = Math.abs;\nvar atan2$1 = Math.atan2;\nvar cos$2 = Math.cos;\nvar max$2 = Math.max;\nvar min$1 = Math.min;\nvar sin$2 = Math.sin;\nvar sqrt$2 = Math.sqrt;\n\nvar epsilon$3 = 1e-12;\nvar pi$4 = Math.PI;\nvar halfPi$3 = pi$4 / 2;\nvar tau$4 = 2 * pi$4;\n\nfunction acos$1(x) {\n  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);\n}\n\nfunction asin$1(x) {\n  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);\n}\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nvar arc = function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant$10(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi$3,\n        a1 = endAngle.apply(this, arguments) - halfPi$3,\n        da = abs$1(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon$3)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau$4 - epsilon$3) {\n      context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon$3) {\n        context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon$3) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),\n          rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon$3) {\n        var p0 = asin$1(rp / r0 * sin$2(ap)),\n            p1 = asin$1(rp / r1 * sin$2(ap));\n        if ((da0 -= p0 * 2) > epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos$2(a01),\n          y01 = r1 * sin$2(a01),\n          x10 = r0 * cos$2(a10),\n          y10 = r0 * sin$2(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon$3) {\n        var x11 = r1 * cos$2(a11),\n            y11 = r1 * sin$2(a11),\n            x00 = r0 * cos$2(a00),\n            y00 = r0 * sin$2(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi$4) {\n          var oc = da0 > epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),\n              lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min$1(rc, (r0 - lc) / (kc - 1));\n          rc1 = min$1(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon$3)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon$3) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon$3) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;\n    return [cos$2(a) * r, sin$2(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n};\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nvar curveLinear = function(context) {\n  return new Linear(context);\n};\n\nfunction x$3(p) {\n  return p[0];\n}\n\nfunction y$3(p) {\n  return p[1];\n}\n\nvar line = function() {\n  var x = x$3,\n      y = y$3,\n      defined = constant$10(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$10(+_), line) : x;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$10(+_), line) : y;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$10(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n};\n\nvar area$2 = function() {\n  var x0 = x$3,\n      x1 = null,\n      y0 = constant$10(0),\n      y1 = y$3,\n      defined = constant$10(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$10(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$10(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$10(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$10(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$10(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n};\n\nvar descending$1 = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar identity$7 = function(d) {\n  return d;\n};\n\nvar pie = function() {\n  var value = identity$7,\n      sortValues = descending$1,\n      sort = null,\n      startAngle = constant$10(0),\n      endAngle = constant$10(tau$4),\n      padAngle = constant$10(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$10(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : padAngle;\n  };\n\n  return pie;\n};\n\nvar curveRadialLinear = curveRadial(curveLinear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nfunction curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n\nfunction lineRadial(l) {\n  var c = l.curve;\n\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n\n  l.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return l;\n}\n\nvar lineRadial$1 = function() {\n  return lineRadial(line().curve(curveRadialLinear));\n};\n\nvar areaRadial = function() {\n  var a = area$2().curve(curveRadialLinear),\n      c = a.curve,\n      x0 = a.lineX0,\n      x1 = a.lineX1,\n      y0 = a.lineY0,\n      y1 = a.lineY1;\n\n  a.angle = a.x, delete a.x;\n  a.startAngle = a.x0, delete a.x0;\n  a.endAngle = a.x1, delete a.x1;\n  a.radius = a.y, delete a.y;\n  a.innerRadius = a.y0, delete a.y0;\n  a.outerRadius = a.y1, delete a.y1;\n  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;\n  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;\n  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;\n  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;\n\n  a.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return a;\n};\n\nvar pointRadial = function(x, y) {\n  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n};\n\nvar slice$6 = Array.prototype.slice;\n\nfunction linkSource(d) {\n  return d.source;\n}\n\nfunction linkTarget(d) {\n  return d.target;\n}\n\nfunction link$2(curve) {\n  var source = linkSource,\n      target = linkTarget,\n      x = x$3,\n      y = y$3,\n      context = null;\n\n  function link() {\n    var buffer, argv = slice$6.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n    if (!context) context = buffer = path();\n    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  link.source = function(_) {\n    return arguments.length ? (source = _, link) : source;\n  };\n\n  link.target = function(_) {\n    return arguments.length ? (target = _, link) : target;\n  };\n\n  link.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$10(+_), link) : x;\n  };\n\n  link.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$10(+_), link) : y;\n  };\n\n  link.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), link) : context;\n  };\n\n  return link;\n}\n\nfunction curveHorizontal(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n}\n\nfunction curveVertical(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n}\n\nfunction curveRadial$1(context, x0, y0, x1, y1) {\n  var p0 = pointRadial(x0, y0),\n      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),\n      p2 = pointRadial(x1, y0),\n      p3 = pointRadial(x1, y1);\n  context.moveTo(p0[0], p0[1]);\n  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\nfunction linkHorizontal() {\n  return link$2(curveHorizontal);\n}\n\nfunction linkVertical() {\n  return link$2(curveVertical);\n}\n\nfunction linkRadial() {\n  var l = link$2(curveRadial$1);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\nvar circle$2 = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / pi$4);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau$4);\n  }\n};\n\nvar cross$2 = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\nvar tan30 = Math.sqrt(1 / 3);\nvar tan30_2 = tan30 * 2;\n\nvar diamond = {\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n\nvar ka = 0.89081309152928522810;\nvar kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);\nvar kx = Math.sin(tau$4 / 10) * kr;\nvar ky = -Math.cos(tau$4 / 10) * kr;\n\nvar star = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = tau$4 * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n\nvar square = {\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n};\n\nvar sqrt3 = Math.sqrt(3);\n\nvar triangle = {\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n\nvar c = -0.5;\nvar s = Math.sqrt(3) / 2;\nvar k = 1 / Math.sqrt(12);\nvar a = (k / 2 + 1) * 3;\n\nvar wye = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n};\n\nvar symbols = [\n  circle$2,\n  cross$2,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\nvar symbol = function() {\n  var type = constant$10(circle$2),\n      size = constant$10(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant$10(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant$10(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n};\n\nvar noop$2 = function() {};\n\nfunction point$2(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point$2(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basis$2 = function(context) {\n  return new Basis(context);\n};\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisClosed$1 = function(context) {\n  return new BasisClosed(context);\n};\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisOpen = function(context) {\n  return new BasisOpen(context);\n};\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nvar bundle = (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n\nfunction point$3(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point$3(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinal = (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalClosed = (function custom(tension) {\n\n  function cardinal$$1(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal$$1.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal$$1;\n})(0);\n\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalOpen = (function custom(tension) {\n\n  function cardinal$$1(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal$$1.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal$$1;\n})(0);\n\nfunction point$4(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon$3) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon$3) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRom = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomClosed = (function custom(alpha) {\n\n  function catmullRom$$1(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom$$1.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom$$1;\n})(0.5);\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomOpen = (function custom(alpha) {\n\n  function catmullRom$$1(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom$$1.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom$$1;\n})(0.5);\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nvar linearClosed = function(context) {\n  return new LinearClosed(context);\n};\n\nfunction sign$1(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point$5(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n};\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\nfunction Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nvar natural = function(context) {\n  return new Natural(context);\n};\n\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nvar step = function(context) {\n  return new Step(context, 0.5);\n};\n\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\n\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\nvar none$1 = function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n};\n\nvar none$2 = function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n};\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nvar stack = function() {\n  var keys = constant$10([]),\n      order = none$2,\n      offset = none$1,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant$10(slice$6.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$10(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? none$2 : typeof _ === \"function\" ? _ : constant$10(slice$6.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;\n  };\n\n  return stack;\n};\n\nvar expand = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  none$1(series, order);\n};\n\nvar diverging = function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n};\n\nvar silhouette = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  none$1(series, order);\n};\n\nvar wiggle = function(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  none$1(series, order);\n};\n\nvar ascending$2 = function(series) {\n  var sums = series.map(sum$2);\n  return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });\n};\n\nfunction sum$2(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n\nvar descending$2 = function(series) {\n  return ascending$2(series).reverse();\n};\n\nvar insideOut = function(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(sum$2),\n      order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n};\n\nvar reverse = function(series) {\n  return none$2(series).reverse();\n};\n\nvar constant$11 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction x$4(d) {\n  return d[0];\n}\n\nfunction y$4(d) {\n  return d[1];\n}\n\nfunction RedBlackTree() {\n  this._ = null; // root node\n}\n\nfunction RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\nfunction createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nfunction createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nfunction setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// Liang–Barsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nfunction clipEdges(x0, y0, x1, y1) {\n  var i = edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {\n      delete edges[i];\n    }\n  }\n}\n\nfunction createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nfunction sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1]\n              : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0]\n              : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n\nvar circlePool = [];\n\nvar firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nfunction attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2$2) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nfunction detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nfunction removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon$4\n      && Math.abs(y - lArc.circle.cy) < epsilon$4) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon$4\n      && Math.abs(y - rArc.circle.cy) < epsilon$4) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon$4) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon$4) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon$4) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon$4) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n\nvar epsilon$4 = 1e-6;\nvar epsilon2$2 = 1e-12;\nvar beaches;\nvar cells;\nvar circles;\nvar edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nfunction Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n};\n\nvar voronoi = function() {\n  var x = x$4,\n      y = y$4,\n      extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function(d, i) {\n      var s = [Math.round(x(d, i, data) / epsilon$4) * epsilon$4, Math.round(y(d, i, data) / epsilon$4) * epsilon$4];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function(data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function(data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function(data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$11(+_), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$11(+_), voronoi) : y;\n  };\n\n  voronoi.extent = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n};\n\nvar constant$12 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction ZoomEvent(target, type, transform) {\n  this.target = target;\n  this.type = type;\n  this.transform = transform;\n}\n\nfunction Transform(k, x, y) {\n  this.k = k;\n  this.x = x;\n  this.y = y;\n}\n\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k) {\n    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n  },\n  translate: function(x, y) {\n    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n  },\n  apply: function(point) {\n    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n  },\n  applyX: function(x) {\n    return x * this.k + this.x;\n  },\n  applyY: function(y) {\n    return y * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x) {\n    return (x - this.x) / this.k;\n  },\n  invertY: function(y) {\n    return (y - this.y) / this.k;\n  },\n  rescaleX: function(x) {\n    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n  },\n  rescaleY: function(y) {\n    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\n\nvar identity$8 = new Transform(1, 0, 0);\n\ntransform$1.prototype = Transform.prototype;\n\nfunction transform$1(node) {\n  return node.__zoom || identity$8;\n}\n\nfunction nopropagation$2() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$2 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$2() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent$1() {\n  var e = this, w, h;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    w = e.width.baseVal.value;\n    h = e.height.baseVal.value;\n  } else {\n    w = e.clientWidth;\n    h = e.clientHeight;\n  }\n  return [[0, 0], [w, h]];\n}\n\nfunction defaultTransform() {\n  return this.__zoom || identity$8;\n}\n\nfunction defaultWheelDelta() {\n  return -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500;\n}\n\nfunction touchable$1() {\n  return \"ontouchstart\" in this;\n}\n\nvar zoom = function() {\n  var filter = defaultFilter$2,\n      extent = defaultExtent$1,\n      wheelDelta = defaultWheelDelta,\n      k0 = 0,\n      k1 = Infinity,\n      x0 = -k1,\n      x1 = k1,\n      y0 = x0,\n      y1 = x1,\n      duration = 250,\n      interpolate = interpolateZoom,\n      gestures = [],\n      listeners = dispatch(\"start\", \"zoom\", \"end\"),\n      touchstarting,\n      touchending,\n      touchDelay = 500,\n      wheelDelay = 150,\n      clickDistance2 = 0;\n\n  function zoom(selection$$1) {\n    selection$$1\n        .property(\"__zoom\", defaultTransform)\n        .on(\"wheel.zoom\", wheeled)\n        .on(\"mousedown.zoom\", mousedowned)\n        .on(\"dblclick.zoom\", dblclicked)\n      .filter(touchable$1)\n        .on(\"touchstart.zoom\", touchstarted)\n        .on(\"touchmove.zoom\", touchmoved)\n        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  zoom.transform = function(collection, transform$$1) {\n    var selection$$1 = collection.selection ? collection.selection() : collection;\n    selection$$1.property(\"__zoom\", defaultTransform);\n    if (collection !== selection$$1) {\n      schedule(collection, transform$$1);\n    } else {\n      selection$$1.interrupt().each(function() {\n        gesture(this, arguments)\n            .start()\n            .zoom(null, typeof transform$$1 === \"function\" ? transform$$1.apply(this, arguments) : transform$$1)\n            .end();\n      });\n    }\n  };\n\n  zoom.scaleBy = function(selection$$1, k) {\n    zoom.scaleTo(selection$$1, function() {\n      var k0 = this.__zoom.k,\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return k0 * k1;\n    });\n  };\n\n  zoom.scaleTo = function(selection$$1, k) {\n    zoom.transform(selection$$1, function() {\n      var e = extent.apply(this, arguments),\n          t0 = this.__zoom,\n          p0 = centroid(e),\n          p1 = t0.invert(p0),\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return constrain(translate(scale(t0, k1), p0, p1), e);\n    });\n  };\n\n  zoom.translateBy = function(selection$$1, x, y) {\n    zoom.transform(selection$$1, function() {\n      return constrain(this.__zoom.translate(\n        typeof x === \"function\" ? x.apply(this, arguments) : x,\n        typeof y === \"function\" ? y.apply(this, arguments) : y\n      ), extent.apply(this, arguments));\n    });\n  };\n\n  zoom.translateTo = function(selection$$1, x, y) {\n    zoom.transform(selection$$1, function() {\n      var e = extent.apply(this, arguments),\n          t = this.__zoom,\n          p = centroid(e);\n      return constrain(identity$8.translate(p[0], p[1]).scale(t.k).translate(\n        typeof x === \"function\" ? -x.apply(this, arguments) : -x,\n        typeof y === \"function\" ? -y.apply(this, arguments) : -y\n      ), e);\n    });\n  };\n\n  function scale(transform$$1, k) {\n    k = Math.max(k0, Math.min(k1, k));\n    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);\n  }\n\n  function translate(transform$$1, p0, p1) {\n    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;\n    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);\n  }\n\n  function constrain(transform$$1, extent) {\n    var dx0 = transform$$1.invertX(extent[0][0]) - x0,\n        dx1 = transform$$1.invertX(extent[1][0]) - x1,\n        dy0 = transform$$1.invertY(extent[0][1]) - y0,\n        dy1 = transform$$1.invertY(extent[1][1]) - y1;\n    return transform$$1.translate(\n      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n    );\n  }\n\n  function centroid(extent) {\n    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n  }\n\n  function schedule(transition$$1, transform$$1, center) {\n    transition$$1\n        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n        .tween(\"zoom\", function() {\n          var that = this,\n              args = arguments,\n              g = gesture(that, args),\n              e = extent.apply(that, args),\n              p = center || centroid(e),\n              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n              a = that.__zoom,\n              b = typeof transform$$1 === \"function\" ? transform$$1.apply(that, args) : transform$$1,\n              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n          return function(t) {\n            if (t === 1) t = b; // Avoid rounding error on end.\n            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n            g.zoom(null, t);\n          };\n        });\n  }\n\n  function gesture(that, args) {\n    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n      if ((g = gestures[i]).that === that) {\n        return g;\n      }\n    }\n    return new Gesture(that, args);\n  }\n\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.index = -1;\n    this.active = 0;\n    this.extent = extent.apply(that, args);\n  }\n\n  Gesture.prototype = {\n    start: function() {\n      if (++this.active === 1) {\n        this.index = gestures.push(this) - 1;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform$$1) {\n      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform$$1.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform$$1.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform$$1.invert(this.touch1[0]);\n      this.that.__zoom = transform$$1;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        gestures.splice(this.index, 1);\n        this.index = -1;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function wheeled() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        t = this.__zoom,\n        k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),\n        p = mouse(this);\n\n    // If the mouse is in the same location as before, reuse it.\n    // If there were recent wheel events, reset the wheel idle timeout.\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    }\n\n    // If this wheel event won’t trigger a transform change, ignore it.\n    else if (t.k === k) return;\n\n    // Otherwise, capture the mouse point and location at the start.\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt(this);\n      g.start();\n    }\n\n    noevent$2();\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));\n\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        v = select(exports.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n        p = mouse(this),\n        x0 = exports.event.clientX,\n        y0 = exports.event.clientY;\n\n    dragDisable(exports.event.view);\n    nopropagation$2();\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt(this);\n    g.start();\n\n    function mousemoved() {\n      noevent$2();\n      if (!g.moved) {\n        var dx = exports.event.clientX - x0, dy = exports.event.clientY - y0;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));\n    }\n\n    function mouseupped() {\n      v.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(exports.event.view, g.moved);\n      noevent$2();\n      g.end();\n    }\n  }\n\n  function dblclicked() {\n    if (!filter.apply(this, arguments)) return;\n    var t0 = this.__zoom,\n        p0 = mouse(this),\n        p1 = t0.invert(p0),\n        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),\n        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));\n\n    noevent$2();\n    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);\n    else select(this).call(zoom.transform, t1);\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        started,\n        n = touches$$1.length, i, t, p;\n\n    nopropagation$2();\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0) g.touch0 = p, started = true;\n      else if (!g.touch1) g.touch1 = p;\n    }\n\n    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\n    if (touchstarting) {\n      touchstarting = clearTimeout(touchstarting);\n      if (!g.touch1) {\n        g.end();\n        p = select(this).on(\"dblclick.zoom\");\n        if (p) p.apply(this, arguments);\n        return;\n      }\n    }\n\n    if (started) {\n      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n      interrupt(this);\n      g.start();\n    }\n  }\n\n  function touchmoved() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t, p, l;\n\n    noevent$2();\n    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p0 = g.touch0[0], l0 = g.touch0[1],\n          p1 = g.touch1[0], l1 = g.touch1[1],\n          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale(t, Math.sqrt(dp / dl));\n      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    }\n    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n    else return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent));\n  }\n\n  function touchended() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t;\n\n    nopropagation$2();\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i];\n      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else g.end();\n  }\n\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant$12(+_), zoom) : wheelDelta;\n  };\n\n  zoom.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$12(!!_), zoom) : filter;\n  };\n\n  zoom.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$12([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n  };\n\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];\n  };\n\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];\n  };\n\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n\n  return zoom;\n};\n\nexports.version = version;\nexports.bisect = bisectRight;\nexports.bisectRight = bisectRight;\nexports.bisectLeft = bisectLeft;\nexports.ascending = ascending;\nexports.bisector = bisector;\nexports.cross = cross;\nexports.descending = descending;\nexports.deviation = deviation;\nexports.extent = extent;\nexports.histogram = histogram;\nexports.thresholdFreedmanDiaconis = freedmanDiaconis;\nexports.thresholdScott = scott;\nexports.thresholdSturges = sturges;\nexports.max = max;\nexports.mean = mean;\nexports.median = median;\nexports.merge = merge;\nexports.min = min;\nexports.pairs = pairs;\nexports.permute = permute;\nexports.quantile = threshold;\nexports.range = sequence;\nexports.scan = scan;\nexports.shuffle = shuffle;\nexports.sum = sum;\nexports.ticks = ticks;\nexports.tickIncrement = tickIncrement;\nexports.tickStep = tickStep;\nexports.transpose = transpose;\nexports.variance = variance;\nexports.zip = zip;\nexports.axisTop = axisTop;\nexports.axisRight = axisRight;\nexports.axisBottom = axisBottom;\nexports.axisLeft = axisLeft;\nexports.brush = brush;\nexports.brushX = brushX;\nexports.brushY = brushY;\nexports.brushSelection = brushSelection;\nexports.chord = chord;\nexports.ribbon = ribbon;\nexports.nest = nest;\nexports.set = set$2;\nexports.map = map$1;\nexports.keys = keys;\nexports.values = values;\nexports.entries = entries;\nexports.color = color;\nexports.rgb = rgb;\nexports.hsl = hsl;\nexports.lab = lab;\nexports.hcl = hcl;\nexports.cubehelix = cubehelix;\nexports.dispatch = dispatch;\nexports.drag = drag;\nexports.dragDisable = dragDisable;\nexports.dragEnable = yesdrag;\nexports.dsvFormat = dsv;\nexports.csvParse = csvParse;\nexports.csvParseRows = csvParseRows;\nexports.csvFormat = csvFormat;\nexports.csvFormatRows = csvFormatRows;\nexports.tsvParse = tsvParse;\nexports.tsvParseRows = tsvParseRows;\nexports.tsvFormat = tsvFormat;\nexports.tsvFormatRows = tsvFormatRows;\nexports.easeLinear = linear$1;\nexports.easeQuad = quadInOut;\nexports.easeQuadIn = quadIn;\nexports.easeQuadOut = quadOut;\nexports.easeQuadInOut = quadInOut;\nexports.easeCubic = cubicInOut;\nexports.easeCubicIn = cubicIn;\nexports.easeCubicOut = cubicOut;\nexports.easeCubicInOut = cubicInOut;\nexports.easePoly = polyInOut;\nexports.easePolyIn = polyIn;\nexports.easePolyOut = polyOut;\nexports.easePolyInOut = polyInOut;\nexports.easeSin = sinInOut;\nexports.easeSinIn = sinIn;\nexports.easeSinOut = sinOut;\nexports.easeSinInOut = sinInOut;\nexports.easeExp = expInOut;\nexports.easeExpIn = expIn;\nexports.easeExpOut = expOut;\nexports.easeExpInOut = expInOut;\nexports.easeCircle = circleInOut;\nexports.easeCircleIn = circleIn;\nexports.easeCircleOut = circleOut;\nexports.easeCircleInOut = circleInOut;\nexports.easeBounce = bounceOut;\nexports.easeBounceIn = bounceIn;\nexports.easeBounceOut = bounceOut;\nexports.easeBounceInOut = bounceInOut;\nexports.easeBack = backInOut;\nexports.easeBackIn = backIn;\nexports.easeBackOut = backOut;\nexports.easeBackInOut = backInOut;\nexports.easeElastic = elasticOut;\nexports.easeElasticIn = elasticIn;\nexports.easeElasticOut = elasticOut;\nexports.easeElasticInOut = elasticInOut;\nexports.forceCenter = center$1;\nexports.forceCollide = collide;\nexports.forceLink = link;\nexports.forceManyBody = manyBody;\nexports.forceSimulation = simulation;\nexports.forceX = x$2;\nexports.forceY = y$2;\nexports.formatDefaultLocale = defaultLocale;\nexports.formatLocale = formatLocale;\nexports.formatSpecifier = formatSpecifier;\nexports.precisionFixed = precisionFixed;\nexports.precisionPrefix = precisionPrefix;\nexports.precisionRound = precisionRound;\nexports.geoArea = area;\nexports.geoBounds = bounds;\nexports.geoCentroid = centroid;\nexports.geoCircle = circle;\nexports.geoClipExtent = extent$1;\nexports.geoContains = contains;\nexports.geoDistance = distance;\nexports.geoGraticule = graticule;\nexports.geoGraticule10 = graticule10;\nexports.geoInterpolate = interpolate$1;\nexports.geoLength = length$1;\nexports.geoPath = index$1;\nexports.geoAlbers = albers;\nexports.geoAlbersUsa = albersUsa;\nexports.geoAzimuthalEqualArea = azimuthalEqualArea;\nexports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\nexports.geoAzimuthalEquidistant = azimuthalEquidistant;\nexports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\nexports.geoConicConformal = conicConformal;\nexports.geoConicConformalRaw = conicConformalRaw;\nexports.geoConicEqualArea = conicEqualArea;\nexports.geoConicEqualAreaRaw = conicEqualAreaRaw;\nexports.geoConicEquidistant = conicEquidistant;\nexports.geoConicEquidistantRaw = conicEquidistantRaw;\nexports.geoEquirectangular = equirectangular;\nexports.geoEquirectangularRaw = equirectangularRaw;\nexports.geoGnomonic = gnomonic;\nexports.geoGnomonicRaw = gnomonicRaw;\nexports.geoIdentity = identity$5;\nexports.geoProjection = projection;\nexports.geoProjectionMutator = projectionMutator;\nexports.geoMercator = mercator;\nexports.geoMercatorRaw = mercatorRaw;\nexports.geoOrthographic = orthographic;\nexports.geoOrthographicRaw = orthographicRaw;\nexports.geoStereographic = stereographic;\nexports.geoStereographicRaw = stereographicRaw;\nexports.geoTransverseMercator = transverseMercator;\nexports.geoTransverseMercatorRaw = transverseMercatorRaw;\nexports.geoRotation = rotation;\nexports.geoStream = geoStream;\nexports.geoTransform = transform;\nexports.cluster = cluster;\nexports.hierarchy = hierarchy;\nexports.pack = index$2;\nexports.packSiblings = siblings;\nexports.packEnclose = enclose;\nexports.partition = partition;\nexports.stratify = stratify;\nexports.tree = tree;\nexports.treemap = index$3;\nexports.treemapBinary = binary;\nexports.treemapDice = treemapDice;\nexports.treemapSlice = treemapSlice;\nexports.treemapSliceDice = sliceDice;\nexports.treemapSquarify = squarify;\nexports.treemapResquarify = resquarify;\nexports.interpolate = interpolateValue;\nexports.interpolateArray = array$1;\nexports.interpolateBasis = basis$1;\nexports.interpolateBasisClosed = basisClosed;\nexports.interpolateDate = date;\nexports.interpolateNumber = reinterpolate;\nexports.interpolateObject = object;\nexports.interpolateRound = interpolateRound;\nexports.interpolateString = interpolateString;\nexports.interpolateTransformCss = interpolateTransformCss;\nexports.interpolateTransformSvg = interpolateTransformSvg;\nexports.interpolateZoom = interpolateZoom;\nexports.interpolateRgb = interpolateRgb;\nexports.interpolateRgbBasis = rgbBasis;\nexports.interpolateRgbBasisClosed = rgbBasisClosed;\nexports.interpolateHsl = hsl$2;\nexports.interpolateHslLong = hslLong;\nexports.interpolateLab = lab$1;\nexports.interpolateHcl = hcl$2;\nexports.interpolateHclLong = hclLong;\nexports.interpolateCubehelix = cubehelix$2;\nexports.interpolateCubehelixLong = cubehelixLong;\nexports.quantize = quantize;\nexports.path = path;\nexports.polygonArea = area$1;\nexports.polygonCentroid = centroid$1;\nexports.polygonHull = hull;\nexports.polygonContains = contains$1;\nexports.polygonLength = length$2;\nexports.quadtree = quadtree;\nexports.queue = queue;\nexports.randomUniform = uniform;\nexports.randomNormal = normal;\nexports.randomLogNormal = logNormal;\nexports.randomBates = bates;\nexports.randomIrwinHall = irwinHall;\nexports.randomExponential = exponential$1;\nexports.request = request;\nexports.html = html;\nexports.json = json;\nexports.text = text;\nexports.xml = xml;\nexports.csv = csv$1;\nexports.tsv = tsv$1;\nexports.scaleBand = band;\nexports.scalePoint = point$1;\nexports.scaleIdentity = identity$6;\nexports.scaleLinear = linear$2;\nexports.scaleLog = log$1;\nexports.scaleOrdinal = ordinal;\nexports.scaleImplicit = implicit;\nexports.scalePow = pow$1;\nexports.scaleSqrt = sqrt$1;\nexports.scaleQuantile = quantile;\nexports.scaleQuantize = quantize$1;\nexports.scaleThreshold = threshold$1;\nexports.scaleTime = time;\nexports.scaleUtc = utcTime;\nexports.schemeCategory10 = category10;\nexports.schemeCategory20b = category20b;\nexports.schemeCategory20c = category20c;\nexports.schemeCategory20 = category20;\nexports.interpolateCubehelixDefault = cubehelix$3;\nexports.interpolateRainbow = rainbow$1;\nexports.interpolateWarm = warm;\nexports.interpolateCool = cool;\nexports.interpolateViridis = viridis;\nexports.interpolateMagma = magma;\nexports.interpolateInferno = inferno;\nexports.interpolatePlasma = plasma;\nexports.scaleSequential = sequential;\nexports.creator = creator;\nexports.local = local$1;\nexports.matcher = matcher$1;\nexports.mouse = mouse;\nexports.namespace = namespace;\nexports.namespaces = namespaces;\nexports.select = select;\nexports.selectAll = selectAll;\nexports.selection = selection;\nexports.selector = selector;\nexports.selectorAll = selectorAll;\nexports.style = styleValue;\nexports.touch = touch;\nexports.touches = touches;\nexports.window = defaultView;\nexports.customEvent = customEvent;\nexports.arc = arc;\nexports.area = area$2;\nexports.line = line;\nexports.pie = pie;\nexports.areaRadial = areaRadial;\nexports.radialArea = areaRadial;\nexports.lineRadial = lineRadial$1;\nexports.radialLine = lineRadial$1;\nexports.pointRadial = pointRadial;\nexports.linkHorizontal = linkHorizontal;\nexports.linkVertical = linkVertical;\nexports.linkRadial = linkRadial;\nexports.symbol = symbol;\nexports.symbols = symbols;\nexports.symbolCircle = circle$2;\nexports.symbolCross = cross$2;\nexports.symbolDiamond = diamond;\nexports.symbolSquare = square;\nexports.symbolStar = star;\nexports.symbolTriangle = triangle;\nexports.symbolWye = wye;\nexports.curveBasisClosed = basisClosed$1;\nexports.curveBasisOpen = basisOpen;\nexports.curveBasis = basis$2;\nexports.curveBundle = bundle;\nexports.curveCardinalClosed = cardinalClosed;\nexports.curveCardinalOpen = cardinalOpen;\nexports.curveCardinal = cardinal;\nexports.curveCatmullRomClosed = catmullRomClosed;\nexports.curveCatmullRomOpen = catmullRomOpen;\nexports.curveCatmullRom = catmullRom;\nexports.curveLinearClosed = linearClosed;\nexports.curveLinear = curveLinear;\nexports.curveMonotoneX = monotoneX;\nexports.curveMonotoneY = monotoneY;\nexports.curveNatural = natural;\nexports.curveStep = step;\nexports.curveStepAfter = stepAfter;\nexports.curveStepBefore = stepBefore;\nexports.stack = stack;\nexports.stackOffsetExpand = expand;\nexports.stackOffsetDiverging = diverging;\nexports.stackOffsetNone = none$1;\nexports.stackOffsetSilhouette = silhouette;\nexports.stackOffsetWiggle = wiggle;\nexports.stackOrderAscending = ascending$2;\nexports.stackOrderDescending = descending$2;\nexports.stackOrderInsideOut = insideOut;\nexports.stackOrderNone = none$2;\nexports.stackOrderReverse = reverse;\nexports.timeInterval = newInterval;\nexports.timeMillisecond = millisecond;\nexports.timeMilliseconds = milliseconds;\nexports.utcMillisecond = millisecond;\nexports.utcMilliseconds = milliseconds;\nexports.timeSecond = second;\nexports.timeSeconds = seconds;\nexports.utcSecond = second;\nexports.utcSeconds = seconds;\nexports.timeMinute = minute;\nexports.timeMinutes = minutes;\nexports.timeHour = hour;\nexports.timeHours = hours;\nexports.timeDay = day;\nexports.timeDays = days;\nexports.timeWeek = sunday;\nexports.timeWeeks = sundays;\nexports.timeSunday = sunday;\nexports.timeSundays = sundays;\nexports.timeMonday = monday;\nexports.timeMondays = mondays;\nexports.timeTuesday = tuesday;\nexports.timeTuesdays = tuesdays;\nexports.timeWednesday = wednesday;\nexports.timeWednesdays = wednesdays;\nexports.timeThursday = thursday;\nexports.timeThursdays = thursdays;\nexports.timeFriday = friday;\nexports.timeFridays = fridays;\nexports.timeSaturday = saturday;\nexports.timeSaturdays = saturdays;\nexports.timeMonth = month;\nexports.timeMonths = months;\nexports.timeYear = year;\nexports.timeYears = years;\nexports.utcMinute = utcMinute;\nexports.utcMinutes = utcMinutes;\nexports.utcHour = utcHour;\nexports.utcHours = utcHours;\nexports.utcDay = utcDay;\nexports.utcDays = utcDays;\nexports.utcWeek = utcSunday;\nexports.utcWeeks = utcSundays;\nexports.utcSunday = utcSunday;\nexports.utcSundays = utcSundays;\nexports.utcMonday = utcMonday;\nexports.utcMondays = utcMondays;\nexports.utcTuesday = utcTuesday;\nexports.utcTuesdays = utcTuesdays;\nexports.utcWednesday = utcWednesday;\nexports.utcWednesdays = utcWednesdays;\nexports.utcThursday = utcThursday;\nexports.utcThursdays = utcThursdays;\nexports.utcFriday = utcFriday;\nexports.utcFridays = utcFridays;\nexports.utcSaturday = utcSaturday;\nexports.utcSaturdays = utcSaturdays;\nexports.utcMonth = utcMonth;\nexports.utcMonths = utcMonths;\nexports.utcYear = utcYear;\nexports.utcYears = utcYears;\nexports.timeFormatDefaultLocale = defaultLocale$1;\nexports.timeFormatLocale = formatLocale$1;\nexports.isoFormat = formatIso;\nexports.isoParse = parseIso;\nexports.now = now;\nexports.timer = timer;\nexports.timerFlush = timerFlush;\nexports.timeout = timeout$1;\nexports.interval = interval$1;\nexports.transition = transition;\nexports.active = active;\nexports.interrupt = interrupt;\nexports.voronoi = voronoi;\nexports.zoom = zoom;\nexports.zoomTransform = transform$1;\nexports.zoomIdentity = identity$8;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(7);\nvar Action_1 = __webpack_require__(350);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(91);\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.iterator = symbolIteratorPonyfill(root_1.root);\n/**\n * @deprecated use iterator instead\n */\nexports.$$iterator = exports.iterator;\n//# sourceMappingURL=iterator.js.map\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(4);\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar queue_1 = __webpack_require__(62);\nvar Subscription_1 = __webpack_require__(4);\nvar observeOn_1 = __webpack_require__(36);\nvar ObjectUnsubscribedError_1 = __webpack_require__(28);\nvar SubjectSubscription_1 = __webpack_require__(44);\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\nexports.$$observable = exports.observable;\n//# sourceMappingURL=observable.js.map\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\nexports.$$rxSubscriber = exports.rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(11);\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(10);\nvar isArray_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    observables.unshift(this);\n    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar isScheduler_1 = __webpack_require__(12);\nvar ArrayObservable_1 = __webpack_require__(10);\nvar mergeAll_1 = __webpack_require__(24);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n}\nexports.concat = concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concatStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var scheduler = null;\n    var args = observables;\n    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n        scheduler = args.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatStatic = concatStatic;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Notification_1 = __webpack_require__(16);\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n        this.hasValue = false;\n        this.acc = seed;\n        if (!this.hasSeed) {\n            this.index++;\n        }\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value, this.index++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(10);\nvar isArray_1 = __webpack_require__(11);\nvar Subscriber_1 = __webpack_require__(1);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar iterator_1 = __webpack_require__(19);\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zipProto() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));\n}\nexports.zipProto = zipProto;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* tslint:disable:no-unused-variable */\n// Subject imported before Observable to bypass circular dependency issue since\n// Subject extends Observable and Observable references Subject in it's\n// definition\nvar Subject_1 = __webpack_require__(5);\nexports.Subject = Subject_1.Subject;\nexports.AnonymousSubject = Subject_1.AnonymousSubject;\n/* tslint:enable:no-unused-variable */\nvar Observable_1 = __webpack_require__(0);\nexports.Observable = Observable_1.Observable;\n// statics\n/* tslint:disable:no-use-before-declare */\n__webpack_require__(92);\n__webpack_require__(93);\n__webpack_require__(94);\n__webpack_require__(95);\n__webpack_require__(96);\n__webpack_require__(99);\n__webpack_require__(100);\n__webpack_require__(101);\n__webpack_require__(102);\n__webpack_require__(103);\n__webpack_require__(104);\n__webpack_require__(105);\n__webpack_require__(106);\n__webpack_require__(107);\n__webpack_require__(108);\n__webpack_require__(113);\n__webpack_require__(109);\n__webpack_require__(110);\n__webpack_require__(111);\n__webpack_require__(112);\n__webpack_require__(114);\n__webpack_require__(117);\n__webpack_require__(115);\n__webpack_require__(116);\n__webpack_require__(118);\n//dom\n__webpack_require__(97);\n__webpack_require__(98);\n//operators\n__webpack_require__(121);\n__webpack_require__(122);\n__webpack_require__(123);\n__webpack_require__(124);\n__webpack_require__(125);\n__webpack_require__(126);\n__webpack_require__(127);\n__webpack_require__(128);\n__webpack_require__(129);\n__webpack_require__(130);\n__webpack_require__(131);\n__webpack_require__(132);\n__webpack_require__(133);\n__webpack_require__(139);\n__webpack_require__(134);\n__webpack_require__(135);\n__webpack_require__(136);\n__webpack_require__(137);\n__webpack_require__(138);\n__webpack_require__(140);\n__webpack_require__(141);\n__webpack_require__(142);\n__webpack_require__(143);\n__webpack_require__(146);\n__webpack_require__(147);\n__webpack_require__(148);\n__webpack_require__(144);\n__webpack_require__(149);\n__webpack_require__(150);\n__webpack_require__(151);\n__webpack_require__(152);\n__webpack_require__(153);\n__webpack_require__(154);\n__webpack_require__(155);\n__webpack_require__(156);\n__webpack_require__(119);\n__webpack_require__(120);\n__webpack_require__(157);\n__webpack_require__(158);\n__webpack_require__(145);\n__webpack_require__(159);\n__webpack_require__(160);\n__webpack_require__(161);\n__webpack_require__(162);\n__webpack_require__(163);\n__webpack_require__(164);\n__webpack_require__(165);\n__webpack_require__(166);\n__webpack_require__(167);\n__webpack_require__(168);\n__webpack_require__(169);\n__webpack_require__(170);\n__webpack_require__(171);\n__webpack_require__(172);\n__webpack_require__(173);\n__webpack_require__(174);\n__webpack_require__(175);\n__webpack_require__(176);\n__webpack_require__(178);\n__webpack_require__(177);\n__webpack_require__(179);\n__webpack_require__(180);\n__webpack_require__(181);\n__webpack_require__(182);\n__webpack_require__(183);\n__webpack_require__(184);\n__webpack_require__(185);\n__webpack_require__(186);\n__webpack_require__(187);\n__webpack_require__(188);\n__webpack_require__(189);\n__webpack_require__(190);\n__webpack_require__(191);\n__webpack_require__(192);\n__webpack_require__(193);\n__webpack_require__(194);\n__webpack_require__(195);\n__webpack_require__(196);\n__webpack_require__(197);\n__webpack_require__(198);\n__webpack_require__(199);\n__webpack_require__(200);\n__webpack_require__(201);\n__webpack_require__(202);\n__webpack_require__(203);\n__webpack_require__(204);\n__webpack_require__(205);\n__webpack_require__(206);\n__webpack_require__(207);\n__webpack_require__(208);\n__webpack_require__(209);\n__webpack_require__(210);\n__webpack_require__(211);\n__webpack_require__(212);\n__webpack_require__(213);\n__webpack_require__(214);\n__webpack_require__(215);\n__webpack_require__(216);\n__webpack_require__(217);\n__webpack_require__(218);\n__webpack_require__(219);\n__webpack_require__(220);\n/* tslint:disable:no-unused-variable */\nvar Subscription_1 = __webpack_require__(4);\nexports.Subscription = Subscription_1.Subscription;\nvar Subscriber_1 = __webpack_require__(1);\nexports.Subscriber = Subscriber_1.Subscriber;\nvar AsyncSubject_1 = __webpack_require__(22);\nexports.AsyncSubject = AsyncSubject_1.AsyncSubject;\nvar ReplaySubject_1 = __webpack_require__(23);\nexports.ReplaySubject = ReplaySubject_1.ReplaySubject;\nvar BehaviorSubject_1 = __webpack_require__(42);\nexports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\nvar ConnectableObservable_1 = __webpack_require__(45);\nexports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\nvar Notification_1 = __webpack_require__(16);\nexports.Notification = Notification_1.Notification;\nvar EmptyError_1 = __webpack_require__(27);\nexports.EmptyError = EmptyError_1.EmptyError;\nvar ArgumentOutOfRangeError_1 = __webpack_require__(20);\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\nvar ObjectUnsubscribedError_1 = __webpack_require__(28);\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\nvar TimeoutError_1 = __webpack_require__(65);\nexports.TimeoutError = TimeoutError_1.TimeoutError;\nvar UnsubscriptionError_1 = __webpack_require__(66);\nexports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\nvar timeInterval_1 = __webpack_require__(58);\nexports.TimeInterval = timeInterval_1.TimeInterval;\nvar timestamp_1 = __webpack_require__(59);\nexports.Timestamp = timestamp_1.Timestamp;\nvar TestScheduler_1 = __webpack_require__(360);\nexports.TestScheduler = TestScheduler_1.TestScheduler;\nvar VirtualTimeScheduler_1 = __webpack_require__(60);\nexports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\nvar AjaxObservable_1 = __webpack_require__(48);\nexports.AjaxResponse = AjaxObservable_1.AjaxResponse;\nexports.AjaxError = AjaxObservable_1.AjaxError;\nexports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\nvar asap_1 = __webpack_require__(61);\nvar async_1 = __webpack_require__(9);\nvar queue_1 = __webpack_require__(62);\nvar animationFrame_1 = __webpack_require__(357);\nvar rxSubscriber_1 = __webpack_require__(26);\nvar iterator_1 = __webpack_require__(19);\nvar observable_1 = __webpack_require__(25);\n/* tslint:enable:no-unused-variable */\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {Scheduler} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n * fastest transport mechanism available, either Node.js' `process.nextTick()`\n * or Web Worker MessageChannel or setTimeout or others. Use this for\n * asynchronous conversions.\n * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting\n */\nvar Scheduler = {\n    asap: asap_1.asap,\n    queue: queue_1.queue,\n    animationFrame: animationFrame_1.animationFrame,\n    async: async_1.async\n};\nexports.Scheduler = Scheduler;\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\nvar Symbol = {\n    rxSubscriber: rxSubscriber_1.rxSubscriber,\n    observable: observable_1.observable,\n    iterator: iterator_1.iterator\n};\nexports.Symbol = Symbol;\n//# sourceMappingURL=Rx.js.map\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.4.2\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefix has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listensers hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n  vm.$listeners = listeners;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  \"production\" !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (false) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  \"production\" !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  \"production\" !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (false) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n  if (false) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.2';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (modelRs.exp) + \", \" + (modelRs.idx) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (false) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (false\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (false) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el, state) || 'void 0'\n      : genElement(el, state)) + \"}}\"\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (false) {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(39)))\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar ObjectUnsubscribedError_1 = __webpack_require__(28);\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(4);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar Observable_1 = __webpack_require__(0);\nvar Subscriber_1 = __webpack_require__(1);\nvar Subscription_1 = __webpack_require__(4);\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n        this._isComplete = false;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return this.lift(new RefCountOperator(this));\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(11);\nvar isArrayLike_1 = __webpack_require__(68);\nvar isPromise_1 = __webpack_require__(70);\nvar PromiseObservable_1 = __webpack_require__(47);\nvar IteratorObservable_1 = __webpack_require__(232);\nvar ArrayObservable_1 = __webpack_require__(10);\nvar ArrayLikeObservable_1 = __webpack_require__(221);\nvar iterator_1 = __webpack_require__(19);\nvar Observable_1 = __webpack_require__(0);\nvar observeOn_1 = __webpack_require__(36);\nvar observable_1 = __webpack_require__(25);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike_1.isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(7);\nvar Observable_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {PromiseLike<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(7);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar Observable_1 = __webpack_require__(0);\nvar Subscriber_1 = __webpack_require__(1);\nvar map_1 = __webpack_require__(35);\nfunction getCORSRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else if (!!root_1.root.XDomainRequest) {\n        return new root_1.root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else {\n        var progId = void 0;\n        try {\n            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (var i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root_1.root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root_1.root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nfunction ajaxGet(url, headers) {\n    if (headers === void 0) { headers = null; }\n    return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n}\nexports.ajaxGet = ajaxGet;\n;\nfunction ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n}\nexports.ajaxPost = ajaxPost;\n;\nfunction ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n}\nexports.ajaxDelete = ajaxDelete;\n;\nfunction ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n}\nexports.ajaxPut = ajaxPut;\n;\nfunction ajaxPatch(url, body, headers) {\n    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });\n}\nexports.ajaxPatch = ajaxPatch;\n;\nfunction ajaxGetJSON(url, headers) {\n    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })\n        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));\n}\nexports.ajaxGetJSON = ajaxGetJSON;\n;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar AjaxObservable = (function (_super) {\n    __extends(AjaxObservable, _super);\n    function AjaxObservable(urlOrRequest) {\n        _super.call(this);\n        var request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n            },\n            crossDomain: false,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (var prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    AjaxObservable.prototype._subscribe = function (subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    };\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * @example\n     * source = Rx.Observable.ajax('/products');\n     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n    */\n    AjaxObservable.create = (function () {\n        var create = function (urlOrRequest) {\n            return new AjaxObservable(urlOrRequest);\n        };\n        create.get = ajaxGet;\n        create.post = ajaxPost;\n        create.delete = ajaxDelete;\n        create.put = ajaxPut;\n        create.patch = ajaxPatch;\n        create.getJSON = ajaxGetJSON;\n        return create;\n    })();\n    return AjaxObservable;\n}(Observable_1.Observable));\nexports.AjaxObservable = AjaxObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AjaxSubscriber = (function (_super) {\n    __extends(AjaxSubscriber, _super);\n    function AjaxSubscriber(destination, request) {\n        _super.call(this, destination);\n        this.request = request;\n        this.done = false;\n        var headers = request.headers = request.headers || {};\n        // force CORS if requested\n        if (!request.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        // ensure content type is set\n        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        // properly serialize body\n        request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n        this.send();\n    }\n    AjaxSubscriber.prototype.next = function (e) {\n        this.done = true;\n        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n        var response = new AjaxResponse(e, xhr, request);\n        destination.next(response);\n    };\n    AjaxSubscriber.prototype.send = function () {\n        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n        var createXHR = request.createXHR;\n        var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n        if (xhr === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            this.xhr = xhr;\n            // set up the events before open XHR\n            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n            // You need to add the event listeners before calling open() on the request.\n            // Otherwise the progress events will not fire.\n            this.setupEvents(xhr, request);\n            // open XHR\n            var result = void 0;\n            if (user) {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n            }\n            else {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n            }\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n            // timeout, responseType and withCredentials can be set once the XHR is open\n            if (async) {\n                xhr.timeout = request.timeout;\n                xhr.responseType = request.responseType;\n            }\n            if ('withCredentials' in xhr) {\n                xhr.withCredentials = !!request.withCredentials;\n            }\n            // set headers\n            this.setHeaders(xhr, headers);\n            // finally send the request\n            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n        }\n        return xhr;\n    };\n    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            var splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(function (key) { return (encodeURI(key) + \"=\" + encodeURI(body[key])); }).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    };\n    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n        for (var key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    };\n    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n        var progressSubscriber = request.progressSubscriber;\n        function xhrTimeout(e) {\n            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n        }\n        ;\n        xhr.ontimeout = xhrTimeout;\n        xhrTimeout.request = request;\n        xhrTimeout.subscriber = this;\n        xhrTimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr) {\n            if (progressSubscriber) {\n                var xhrProgress_1;\n                xhrProgress_1 = function (e) {\n                    var progressSubscriber = xhrProgress_1.progressSubscriber;\n                    progressSubscriber.next(e);\n                };\n                if (root_1.root.XDomainRequest) {\n                    xhr.onprogress = xhrProgress_1;\n                }\n                else {\n                    xhr.upload.onprogress = xhrProgress_1;\n                }\n                xhrProgress_1.progressSubscriber = progressSubscriber;\n            }\n            var xhrError_1;\n            xhrError_1 = function (e) {\n                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxError('ajax error', this, request));\n            };\n            xhr.onerror = xhrError_1;\n            xhrError_1.request = request;\n            xhrError_1.subscriber = this;\n            xhrError_1.progressSubscriber = progressSubscriber;\n        }\n        function xhrReadyStateChange(e) {\n            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (this.readyState === 4) {\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                var status_1 = this.status === 1223 ? 204 : this.status;\n                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                // fix status code when it is 0 (0 status is undocumented).\n                // Occurs when accessing file resources or on Android 4.1 stock browser\n                // while retrieving files from application cache.\n                if (status_1 === 0) {\n                    status_1 = response ? 200 : 0;\n                }\n                if (200 <= status_1 && status_1 < 300) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                }\n            }\n        }\n        ;\n        xhr.onreadystatechange = xhrReadyStateChange;\n        xhrReadyStateChange.subscriber = this;\n        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n        xhrReadyStateChange.request = request;\n    };\n    AjaxSubscriber.prototype.unsubscribe = function () {\n        var _a = this, done = _a.done, xhr = _a.xhr;\n        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n            xhr.abort();\n        }\n        _super.prototype.unsubscribe.call(this);\n    };\n    return AjaxSubscriber;\n}(Subscriber_1.Subscriber));\nexports.AjaxSubscriber = AjaxSubscriber;\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nvar AjaxResponse = (function () {\n    function AjaxResponse(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        switch (this.responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    this.response = JSON.parse(xhr.responseText || 'null');\n                }\n                break;\n            case 'xml':\n                this.response = xhr.responseXML;\n                break;\n            case 'text':\n            default:\n                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n                break;\n        }\n    }\n    return AjaxResponse;\n}());\nexports.AjaxResponse = AjaxResponse;\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nvar AjaxError = (function (_super) {\n    __extends(AjaxError, _super);\n    function AjaxError(message, xhr, request) {\n        _super.call(this, message);\n        this.message = message;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n    }\n    return AjaxError;\n}(Error));\nexports.AjaxError = AjaxError;\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nvar AjaxTimeoutError = (function (_super) {\n    __extends(AjaxTimeoutError, _super);\n    function AjaxTimeoutError(xhr, request) {\n        _super.call(this, 'ajax timeout', xhr, request);\n    }\n    return AjaxTimeoutError;\n}(AjaxError));\nexports.AjaxTimeoutError = AjaxTimeoutError;\n//# sourceMappingURL=AjaxObservable.js.map\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nvar DistinctUntilChangedOperator = (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return this.lift(new FindValueOperator(predicate, this, false, thisArg));\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar ArrayObservable_1 = __webpack_require__(10);\nvar mergeAll_1 = __webpack_require__(24);\nvar isScheduler_1 = __webpack_require__(12);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));\n}\nexports.merge = merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nfunction mergeStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var concurrent = Number.POSITIVE_INFINITY;\n    var scheduler = null;\n    var last = observables[observables.length - 1];\n    if (isScheduler_1.isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));\n}\nexports.mergeStatic = mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = __webpack_require__(46);\nvar isArray_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return this.lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(11);\nvar ArrayObservable_1 = __webpack_require__(10);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));\n}\nexports.race = race;\nfunction raceStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.raceStatic = raceStatic;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\nexports.defaultThrottleConfig = {\n    leading: true,\n    trailing: false\n};\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nfunction throttle(durationSelector, config) {\n    if (config === void 0) { config = exports.defaultThrottleConfig; }\n    return this.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n}\nexports.throttle = throttle;\nvar ThrottleOperator = (function () {\n    function ThrottleOperator(durationSelector, leading, trailing) {\n        this.durationSelector = durationSelector;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n    };\n    return ThrottleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleSubscriber = (function (_super) {\n    __extends(ThrottleSubscriber, _super);\n    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.durationSelector = durationSelector;\n        this._leading = _leading;\n        this._trailing = _trailing;\n        this._hasTrailingValue = false;\n    }\n    ThrottleSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this._trailing) {\n                this._hasTrailingValue = true;\n                this._trailingValue = value;\n            }\n        }\n        else {\n            var duration = this.tryDurationSelector(value);\n            if (duration) {\n                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n            }\n            if (this._leading) {\n                this.destination.next(value);\n                if (this._trailing) {\n                    this._hasTrailingValue = true;\n                    this._trailingValue = value;\n                }\n            }\n        }\n    };\n    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n        try {\n            return this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return null;\n        }\n    };\n    ThrottleSubscriber.prototype._unsubscribe = function () {\n        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n    };\n    ThrottleSubscriber.prototype._sendTrailing = function () {\n        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;\n        if (throttled && _trailing && _hasTrailingValue) {\n            destination.next(_trailingValue);\n            this._trailingValue = null;\n            this._hasTrailingValue = false;\n        }\n    };\n    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._sendTrailing();\n        this._unsubscribe();\n    };\n    ThrottleSubscriber.prototype.notifyComplete = function () {\n        this._sendTrailing();\n        this._unsubscribe();\n    };\n    return ThrottleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=throttle.js.map\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(9);\n/**\n * @param scheduler\n * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timeInterval\n * @owner Observable\n */\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimeIntervalOperator(scheduler));\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(9);\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\nvar TimestampOperator = (function () {\n    function TimestampOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimestampOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));\n    };\n    return TimestampOperator;\n}());\nvar TimestampSubscriber = (function (_super) {\n    __extends(TimestampSubscriber, _super);\n    function TimestampSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n    }\n    TimestampSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        this.destination.next(new Timestamp(value, now));\n    };\n    return TimestampSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(17);\nvar AsyncScheduler_1 = __webpack_require__(18);\nvar VirtualTimeScheduler = (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        var _this = this;\n        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }\n        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }\n        _super.call(this, SchedulerAction, function () { return _this.frame; });\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar VirtualAction = (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) { index = scheduler.index += 1; }\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.active = true;\n        this.index = scheduler.index = index;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (!this.id) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.active = false;\n        // If an action is rescheduled, we save allocations by mutating its state,\n        // pushing it to the end of the scheduler queue, and recycling the action.\n        // But since the VirtualTimeScheduler is used for testing, VirtualActions\n        // must be immutable so they can be inspected later.\n        var action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction_1.AsyncAction));\nexports.VirtualAction = VirtualAction;\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsapAction_1 = __webpack_require__(353);\nvar AsapScheduler_1 = __webpack_require__(354);\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * @example <caption>Compare async and asap scheduler</caption>\n *\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n *\n * @static true\n * @name asap\n * @owner Scheduler\n */\nexports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n//# sourceMappingURL=asap.js.map\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar QueueAction_1 = __webpack_require__(355);\nvar QueueScheduler_1 = __webpack_require__(356);\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar SubscriptionLog = (function () {\n    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }\n        this.subscribedFrame = subscribedFrame;\n        this.unsubscribedFrame = unsubscribedFrame;\n    }\n    return SubscriptionLog;\n}());\nexports.SubscriptionLog = SubscriptionLog;\n//# sourceMappingURL=SubscriptionLog.js.map\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar SubscriptionLog_1 = __webpack_require__(63);\nvar SubscriptionLoggable = (function () {\n    function SubscriptionLoggable() {\n        this.subscriptions = [];\n    }\n    SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n        return this.subscriptions.length - 1;\n    };\n    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n        var subscriptionLogs = this.subscriptions;\n        var oldSubscriptionLog = subscriptionLogs[index];\n        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n    };\n    return SubscriptionLoggable;\n}());\nexports.SubscriptionLoggable = SubscriptionLoggable;\n//# sourceMappingURL=SubscriptionLoggable.js.map\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction applyMixins(derivedCtor, baseCtors) {\n    for (var i = 0, len = baseCtors.length; i < len; i++) {\n        var baseCtor = baseCtors[i];\n        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n            var name_1 = propertyKeys[j];\n            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n        }\n    }\n}\nexports.applyMixins = applyMixins;\n//# sourceMappingURL=applyMixins.js.map\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(370);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n/***/ }),\n/* 73 */,\n/* 74 */,\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.VueRx = factory());\n}(this, (function () { 'use strict';\n\nvar Rx$1;\nvar Vue$1;\nvar warn = function () {};\n\nfunction install (_Vue, _Rx) {\n  Rx$1 = _Rx;\n  Vue$1 = _Vue;\n  warn = Vue$1.util.warn || warn;\n}\n\nfunction hasRx (vm) {\n  if (!Rx$1) {\n    warn(\n      '$watchAsObservable requires Rx to be present globally or ' +\n      'be passed to Vue.use() as the second argument.',\n      vm\n    );\n    return false\n  }\n  return true\n}\n\nfunction isObservable (ob) {\n  return ob && typeof ob.subscribe === 'function'\n}\n\nfunction isSubject (subject) {\n  return subject && (\n    typeof subject.next === 'function' ||\n    typeof subject.onNext === 'function'\n  )\n}\n\nfunction unsub (handle) {\n  if (!handle) { return }\n  if (handle.dispose) {\n    handle.dispose();\n  } else if (handle.unsubscribe) {\n    handle.unsubscribe();\n  }\n}\n\nfunction getDisposable (target) {\n  if (Rx$1.Subscription) { // Rx5\n    return new Rx$1.Subscription(target)\n  } else { // Rx4\n    return Rx$1.Disposable.create(target)\n  }\n}\n\nfunction defineReactive (vm, key, val) {\n  if (key in vm) {\n    vm[key] = val;\n  } else {\n    Vue$1.util.defineReactive(vm, key, val);\n  }\n}\n\nfunction getKey (binding) {\n  return [binding.arg].concat(Object.keys(binding.modifiers)).join(':')\n}\n\nvar rxMixin = {\n  created: function created () {\n    var vm = this;\n    var domStreams = vm.$options.domStreams;\n    if (domStreams) {\n      if (!Rx$1.Subject) {\n        warn('Rx.Subject is required to use the \"domStreams\" option.');\n      } else {\n        domStreams.forEach(function (key) {\n          vm[key] = new Rx$1.Subject();\n        });\n      }\n    }\n\n    var observableMethods = vm.$options.observableMethods;\n    if (observableMethods) {\n      if (Array.isArray(observableMethods)) {\n        observableMethods.forEach(function (methodName) {\n          vm[ methodName + '$' ] = vm.$createObservableMethod(methodName);\n        });\n      } else {\n        Object.keys(observableMethods).forEach(function (methodName) {\n          vm[observableMethods[methodName]] = vm.$createObservableMethod(methodName);\n        });\n      }\n    }\n\n    var obs = vm.$options.subscriptions;\n    if (typeof obs === 'function') {\n      obs = obs.call(vm);\n    }\n    if (obs) {\n      vm.$observables = {};\n      vm._obSubscriptions = [];\n      Object.keys(obs).forEach(function (key) {\n        defineReactive(vm, key, undefined);\n        var ob = vm.$observables[key] = obs[key];\n        if (!isObservable(ob)) {\n          warn(\n            'Invalid Observable found in subscriptions option with key \"' + key + '\".',\n            vm\n          );\n          return\n        }\n        vm._obSubscriptions.push(obs[key].subscribe(function (value) {\n          vm[key] = value;\n        }));\n      });\n    }\n  },\n\n  beforeDestroy: function beforeDestroy () {\n    if (this._obSubscriptions) {\n      this._obSubscriptions.forEach(unsub);\n    }\n  }\n};\n\nvar streamDirective = {\n  // Example ./example/counter_dir.html\n  bind: function bind (el, binding, vnode) {\n    if (!hasRx()) {\n      return\n    }\n\n    var handle = binding.value;\n    var event = binding.arg;\n    var streamName = binding.expression;\n    var modifiers = binding.modifiers;\n\n    if (isSubject(handle)) {\n      handle = { subject: handle };\n    } else if (!handle || !isSubject(handle.subject)) {\n      warn(\n        'Invalid Subject found in directive with key \"' + streamName + '\".' +\n        streamName + ' should be an instance of Rx.Subject or have the ' +\n        'type { subject: Rx.Subject, data: any }.',\n        vnode.context\n      );\n      return\n    }\n\n    var subject = handle.subject;\n    var next = (subject.next || subject.onNext).bind(subject);\n\n    if (!modifiers.native && vnode.componentInstance) {\n      handle.subscription = vnode.componentInstance.$eventToObservable(event).subscribe(function (e) {\n        next({\n          event: e,\n          data: handle.data\n        });\n      });\n    } else {\n      if (!Rx$1.Observable.fromEvent) {\n        warn(\n          \"No 'fromEvent' method on Observable class. \" +\n          \"v-stream directive requires Rx.Observable.fromEvent method. \" +\n          \"Try import 'rxjs/add/observable/fromEvent' for \" + streamName,\n          vnode.context\n        );\n        return\n      }\n      var fromEventArgs = handle.options ? [el, event, handle.options] : [el, event];\n      handle.subscription = (ref = Rx$1.Observable).fromEvent.apply(ref, fromEventArgs).subscribe(function (e) {\n        next({\n          event: e,\n          data: handle.data\n        });\n      })\n\n      // store handle on element with a unique key for identifying\n      // multiple v-stream directives on the same node\n      ;(el._rxHandles || (el._rxHandles = {}))[getKey(binding)] = handle;\n    }\n    var ref;\n  },\n\n  update: function update (el, binding) {\n    var handle = binding.value;\n    var _handle = el._rxHandles && el._rxHandles[getKey(binding)];\n    if (_handle && handle && isSubject(handle.subject)) {\n      _handle.data = handle.data;\n    }\n  },\n\n  unbind: function unbind (el, binding) {\n    var key = getKey(binding);\n    var handle = el._rxHandles && el._rxHandles[key];\n    if (handle) {\n      unsub(handle.subscription);\n      el._rxHandles[key] = null;\n    }\n  }\n};\n\nfunction watchAsObservable (expOrFn, options) {\n  if (!hasRx()) {\n    return\n  }\n\n  var vm = this;\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    var _unwatch;\n    var watch = function () {\n      _unwatch = vm.$watch(expOrFn, function (newValue, oldValue) {\n        observer.next({ oldValue: oldValue, newValue: newValue });\n      }, options);\n    };\n\n    // if $watchAsObservable is called inside the subscriptions function,\n    // because data hasn't been observed yet, the watcher will not work.\n    // in that case, wait until created hook to watch.\n    if (vm._data) {\n      watch();\n    } else {\n      vm.$once('hook:created', watch);\n    }\n\n    // Returns function which disconnects the $watch expression\n    return getDisposable(function () {\n      _unwatch && _unwatch();\n    })\n  });\n\n  return obs$\n}\n\nfunction fromDOMEvent (selector, event) {\n  if (!hasRx()) {\n    return\n  }\n  if (typeof window === 'undefined') {\n    return Rx$1.Observable.create(function () {})\n  }\n\n  var vm = this;\n  var doc = document.documentElement;\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    function listener (e) {\n      if (!vm.$el) { return }\n      if (selector === null && vm.$el === e.target) { return observer.next(e) }\n      var els = vm.$el.querySelectorAll(selector);\n      var el = e.target;\n      for (var i = 0, len = els.length; i < len; i++) {\n        if (els[i] === el) { return observer.next(e) }\n      }\n    }\n    doc.addEventListener(event, listener);\n    // Returns function which disconnects the $watch expression\n    return getDisposable(function () {\n      doc.removeEventListener(event, listener);\n    })\n  });\n\n  return obs$\n}\n\nfunction subscribeTo (observable, next, error, complete) {\n  var obs$ = observable.subscribe(next, error, complete);(this._obSubscriptions || (this._obSubscriptions = [])).push(obs$);\n  return obs$\n}\n\n/**\n * @see {@link https://vuejs.org/v2/api/#vm-on}\n * @param {String||Array} evtName Event name\n * @return {Observable} Event stream\n */\nfunction eventToObservable (evtName) {\n  if (!hasRx()) {\n    return\n  }\n  var vm = this;\n  var evtNames = Array.isArray(evtName) ? evtName : [evtName];\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    var eventPairs = evtNames.map(function (name) {\n      var callback = function (msg) { return observer.next({ name: name, msg: msg }); };\n      vm.$on(name, callback);\n      return { name: name, callback: callback }\n    });\n    return function () {\n      // Only remove the specific callback\n      eventPairs.forEach(function (pair) { return vm.$off(pair.name, pair.callback); });\n    }\n  });\n\n  return obs$\n}\n\n/**\n * @name Vue.prototype.$createObservableMethod\n * @description Creates an observable from a given function name.\n * @param {String} methodName Function name\n * @param {Boolean} [passContext] Append the call context at the end of emit data?\n * @return {Observable} Hot stream\n */\nfunction createObservableMethod (methodName, passContext) {\n  if (!hasRx()) {\n    return\n  }\n  var vm = this;\n\n  if (!Rx$1.Observable.prototype.share) {\n    warn(\n      \"No 'share' operator. \" +\n      \"$createObservableMethod returns a shared hot observable. \" +\n      \"Try import 'rxjs/add/operator/share' for creating \" + methodName,\n      vm\n    );\n    return\n  }\n\n  if (vm[methodName] !== undefined) {\n    warn(\n      'Potential bug: ' +\n      \"Method \" + methodName + \" already defined on vm and has been overwritten by $createObservableMethod.\" +\n      String(vm[methodName]),\n      vm\n    );\n  }\n\n  var creator = function (observer) {\n    vm[methodName] = function () {\n      var args = Array.from(arguments);\n      if (passContext) {\n        args.push(this);\n        observer.next(args);\n      } else {\n        if (args.length <= 1) {\n          observer.next(args[0]);\n        } else {\n          observer.next(args);\n        }\n      }\n    };\n    return function () {\n      delete vm[methodName];\n    }\n  };\n\n  // Must be a hot stream otherwise function context may overwrite over and over again\n  return Rx$1.Observable.create(creator).share()\n}\n\n/* global Vue, Rx */\n\nfunction VueRx (Vue$$1, Rx$$1) {\n  install(Vue$$1, Rx$$1);\n  Vue$$1.mixin(rxMixin);\n  Vue$$1.directive('stream', streamDirective);\n  Vue$$1.prototype.$watchAsObservable = watchAsObservable;\n  Vue$$1.prototype.$fromDOMEvent = fromDOMEvent;\n  Vue$$1.prototype.$subscribeTo = subscribeTo;\n  Vue$$1.prototype.$eventToObservable = eventToObservable;\n  Vue$$1.prototype.$createObservableMethod = createObservableMethod;\n}\n\n// auto install\nif (typeof Vue !== 'undefined' && typeof Rx !== 'undefined') {\n  Vue.use(VueRx, Rx);\n}\n\nreturn VueRx;\n\n})));\n\n\n/***/ }),\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bindCallback_1 = __webpack_require__(239);\nObservable_1.Observable.bindCallback = bindCallback_1.bindCallback;\n//# sourceMappingURL=bindCallback.js.map\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bindNodeCallback_1 = __webpack_require__(240);\nObservable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar combineLatest_1 = __webpack_require__(241);\nObservable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar concat_1 = __webpack_require__(242);\nObservable_1.Observable.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar defer_1 = __webpack_require__(243);\nObservable_1.Observable.defer = defer_1.defer;\n//# sourceMappingURL=defer.js.map\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar ajax_1 = __webpack_require__(245);\nObservable_1.Observable.ajax = ajax_1.ajax;\n//# sourceMappingURL=ajax.js.map\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar webSocket_1 = __webpack_require__(246);\nObservable_1.Observable.webSocket = webSocket_1.webSocket;\n//# sourceMappingURL=webSocket.js.map\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar empty_1 = __webpack_require__(247);\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar forkJoin_1 = __webpack_require__(248);\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar from_1 = __webpack_require__(249);\nObservable_1.Observable.from = from_1.from;\n//# sourceMappingURL=from.js.map\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar fromEvent_1 = __webpack_require__(250);\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar fromEventPattern_1 = __webpack_require__(251);\nObservable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;\n//# sourceMappingURL=fromEventPattern.js.map\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar fromPromise_1 = __webpack_require__(252);\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar generate_1 = __webpack_require__(253);\nObservable_1.Observable.generate = generate_1.generate;\n//# sourceMappingURL=generate.js.map\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar if_1 = __webpack_require__(254);\nObservable_1.Observable.if = if_1._if;\n//# sourceMappingURL=if.js.map\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar interval_1 = __webpack_require__(255);\nObservable_1.Observable.interval = interval_1.interval;\n//# sourceMappingURL=interval.js.map\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar merge_1 = __webpack_require__(256);\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar never_1 = __webpack_require__(257);\nObservable_1.Observable.never = never_1.never;\n//# sourceMappingURL=never.js.map\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar of_1 = __webpack_require__(258);\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar onErrorResumeNext_1 = __webpack_require__(259);\nObservable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar pairs_1 = __webpack_require__(260);\nObservable_1.Observable.pairs = pairs_1.pairs;\n//# sourceMappingURL=pairs.js.map\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar race_1 = __webpack_require__(261);\nObservable_1.Observable.race = race_1.race;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar range_1 = __webpack_require__(262);\nObservable_1.Observable.range = range_1.range;\n//# sourceMappingURL=range.js.map\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar throw_1 = __webpack_require__(263);\nObservable_1.Observable.throw = throw_1._throw;\n//# sourceMappingURL=throw.js.map\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar timer_1 = __webpack_require__(264);\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar using_1 = __webpack_require__(265);\nObservable_1.Observable.using = using_1.using;\n//# sourceMappingURL=using.js.map\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar zip_1 = __webpack_require__(266);\nObservable_1.Observable.zip = zip_1.zip;\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar audit_1 = __webpack_require__(267);\nObservable_1.Observable.prototype.audit = audit_1.audit;\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar auditTime_1 = __webpack_require__(268);\nObservable_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar buffer_1 = __webpack_require__(269);\nObservable_1.Observable.prototype.buffer = buffer_1.buffer;\n//# sourceMappingURL=buffer.js.map\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bufferCount_1 = __webpack_require__(270);\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bufferTime_1 = __webpack_require__(271);\nObservable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n//# sourceMappingURL=bufferTime.js.map\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bufferToggle_1 = __webpack_require__(272);\nObservable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n//# sourceMappingURL=bufferToggle.js.map\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar bufferWhen_1 = __webpack_require__(273);\nObservable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n//# sourceMappingURL=bufferWhen.js.map\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar catch_1 = __webpack_require__(274);\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar combineAll_1 = __webpack_require__(275);\nObservable_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar combineLatest_1 = __webpack_require__(33);\nObservable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar concat_1 = __webpack_require__(34);\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar concatAll_1 = __webpack_require__(276);\nObservable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar concatMap_1 = __webpack_require__(277);\nObservable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar concatMapTo_1 = __webpack_require__(278);\nObservable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar count_1 = __webpack_require__(279);\nObservable_1.Observable.prototype.count = count_1.count;\n//# sourceMappingURL=count.js.map\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar debounce_1 = __webpack_require__(280);\nObservable_1.Observable.prototype.debounce = debounce_1.debounce;\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar debounceTime_1 = __webpack_require__(281);\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar defaultIfEmpty_1 = __webpack_require__(282);\nObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar delay_1 = __webpack_require__(283);\nObservable_1.Observable.prototype.delay = delay_1.delay;\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar delayWhen_1 = __webpack_require__(284);\nObservable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n//# sourceMappingURL=delayWhen.js.map\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar dematerialize_1 = __webpack_require__(285);\nObservable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n//# sourceMappingURL=dematerialize.js.map\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar distinct_1 = __webpack_require__(286);\nObservable_1.Observable.prototype.distinct = distinct_1.distinct;\n//# sourceMappingURL=distinct.js.map\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar distinctUntilChanged_1 = __webpack_require__(49);\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar distinctUntilKeyChanged_1 = __webpack_require__(287);\nObservable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar do_1 = __webpack_require__(288);\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar elementAt_1 = __webpack_require__(289);\nObservable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n//# sourceMappingURL=elementAt.js.map\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar every_1 = __webpack_require__(290);\nObservable_1.Observable.prototype.every = every_1.every;\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar exhaust_1 = __webpack_require__(291);\nObservable_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n//# sourceMappingURL=exhaust.js.map\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar exhaustMap_1 = __webpack_require__(292);\nObservable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar expand_1 = __webpack_require__(293);\nObservable_1.Observable.prototype.expand = expand_1.expand;\n//# sourceMappingURL=expand.js.map\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar filter_1 = __webpack_require__(50);\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar finally_1 = __webpack_require__(294);\nObservable_1.Observable.prototype.finally = finally_1._finally;\nObservable_1.Observable.prototype._finally = finally_1._finally;\n//# sourceMappingURL=finally.js.map\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar find_1 = __webpack_require__(51);\nObservable_1.Observable.prototype.find = find_1.find;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar findIndex_1 = __webpack_require__(295);\nObservable_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar first_1 = __webpack_require__(296);\nObservable_1.Observable.prototype.first = first_1.first;\n//# sourceMappingURL=first.js.map\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar groupBy_1 = __webpack_require__(297);\nObservable_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n//# sourceMappingURL=groupBy.js.map\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar ignoreElements_1 = __webpack_require__(298);\nObservable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n//# sourceMappingURL=ignoreElements.js.map\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar isEmpty_1 = __webpack_require__(299);\nObservable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n//# sourceMappingURL=isEmpty.js.map\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar last_1 = __webpack_require__(300);\nObservable_1.Observable.prototype.last = last_1.last;\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar let_1 = __webpack_require__(301);\nObservable_1.Observable.prototype.let = let_1.letProto;\nObservable_1.Observable.prototype.letBind = let_1.letProto;\n//# sourceMappingURL=let.js.map\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar map_1 = __webpack_require__(35);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar mapTo_1 = __webpack_require__(302);\nObservable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar materialize_1 = __webpack_require__(303);\nObservable_1.Observable.prototype.materialize = materialize_1.materialize;\n//# sourceMappingURL=materialize.js.map\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar max_1 = __webpack_require__(304);\nObservable_1.Observable.prototype.max = max_1.max;\n//# sourceMappingURL=max.js.map\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar merge_1 = __webpack_require__(52);\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar mergeAll_1 = __webpack_require__(24);\nObservable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar mergeMap_1 = __webpack_require__(53);\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar mergeMapTo_1 = __webpack_require__(54);\nObservable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nObservable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar mergeScan_1 = __webpack_require__(305);\nObservable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n//# sourceMappingURL=mergeScan.js.map\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar min_1 = __webpack_require__(306);\nObservable_1.Observable.prototype.min = min_1.min;\n//# sourceMappingURL=min.js.map\n\n/***/ }),\n/* 169 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar multicast_1 = __webpack_require__(14);\nObservable_1.Observable.prototype.multicast = multicast_1.multicast;\n//# sourceMappingURL=multicast.js.map\n\n/***/ }),\n/* 170 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar observeOn_1 = __webpack_require__(36);\nObservable_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n//# sourceMappingURL=observeOn.js.map\n\n/***/ }),\n/* 171 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar onErrorResumeNext_1 = __webpack_require__(55);\nObservable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n/* 172 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar pairwise_1 = __webpack_require__(307);\nObservable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n/***/ }),\n/* 173 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar partition_1 = __webpack_require__(308);\nObservable_1.Observable.prototype.partition = partition_1.partition;\n//# sourceMappingURL=partition.js.map\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar pluck_1 = __webpack_require__(309);\nObservable_1.Observable.prototype.pluck = pluck_1.pluck;\n//# sourceMappingURL=pluck.js.map\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar publish_1 = __webpack_require__(310);\nObservable_1.Observable.prototype.publish = publish_1.publish;\n//# sourceMappingURL=publish.js.map\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar publishBehavior_1 = __webpack_require__(311);\nObservable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar publishLast_1 = __webpack_require__(312);\nObservable_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar publishReplay_1 = __webpack_require__(313);\nObservable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar race_1 = __webpack_require__(56);\nObservable_1.Observable.prototype.race = race_1.race;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar reduce_1 = __webpack_require__(37);\nObservable_1.Observable.prototype.reduce = reduce_1.reduce;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar repeat_1 = __webpack_require__(314);\nObservable_1.Observable.prototype.repeat = repeat_1.repeat;\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar repeatWhen_1 = __webpack_require__(315);\nObservable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n//# sourceMappingURL=repeatWhen.js.map\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar retry_1 = __webpack_require__(316);\nObservable_1.Observable.prototype.retry = retry_1.retry;\n//# sourceMappingURL=retry.js.map\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar retryWhen_1 = __webpack_require__(317);\nObservable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar sample_1 = __webpack_require__(318);\nObservable_1.Observable.prototype.sample = sample_1.sample;\n//# sourceMappingURL=sample.js.map\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar sampleTime_1 = __webpack_require__(319);\nObservable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n//# sourceMappingURL=sampleTime.js.map\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar scan_1 = __webpack_require__(320);\nObservable_1.Observable.prototype.scan = scan_1.scan;\n//# sourceMappingURL=scan.js.map\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar sequenceEqual_1 = __webpack_require__(321);\nObservable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n//# sourceMappingURL=sequenceEqual.js.map\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar share_1 = __webpack_require__(322);\nObservable_1.Observable.prototype.share = share_1.share;\n//# sourceMappingURL=share.js.map\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar shareReplay_1 = __webpack_require__(323);\nObservable_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;\n//# sourceMappingURL=shareReplay.js.map\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar single_1 = __webpack_require__(324);\nObservable_1.Observable.prototype.single = single_1.single;\n//# sourceMappingURL=single.js.map\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar skip_1 = __webpack_require__(325);\nObservable_1.Observable.prototype.skip = skip_1.skip;\n//# sourceMappingURL=skip.js.map\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar skipLast_1 = __webpack_require__(326);\nObservable_1.Observable.prototype.skipLast = skipLast_1.skipLast;\n//# sourceMappingURL=skipLast.js.map\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar skipUntil_1 = __webpack_require__(327);\nObservable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar skipWhile_1 = __webpack_require__(328);\nObservable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar startWith_1 = __webpack_require__(329);\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar subscribeOn_1 = __webpack_require__(330);\nObservable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n//# sourceMappingURL=subscribeOn.js.map\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar switch_1 = __webpack_require__(331);\nObservable_1.Observable.prototype.switch = switch_1._switch;\nObservable_1.Observable.prototype._switch = switch_1._switch;\n//# sourceMappingURL=switch.js.map\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar switchMap_1 = __webpack_require__(332);\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar switchMapTo_1 = __webpack_require__(333);\nObservable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar take_1 = __webpack_require__(334);\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar takeLast_1 = __webpack_require__(335);\nObservable_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n//# sourceMappingURL=takeLast.js.map\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar takeUntil_1 = __webpack_require__(336);\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar takeWhile_1 = __webpack_require__(337);\nObservable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n//# sourceMappingURL=takeWhile.js.map\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar throttle_1 = __webpack_require__(57);\nObservable_1.Observable.prototype.throttle = throttle_1.throttle;\n//# sourceMappingURL=throttle.js.map\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar throttleTime_1 = __webpack_require__(338);\nObservable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n//# sourceMappingURL=throttleTime.js.map\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar timeInterval_1 = __webpack_require__(58);\nObservable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n//# sourceMappingURL=timeInterval.js.map\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar timeout_1 = __webpack_require__(339);\nObservable_1.Observable.prototype.timeout = timeout_1.timeout;\n//# sourceMappingURL=timeout.js.map\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar timeoutWith_1 = __webpack_require__(340);\nObservable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n//# sourceMappingURL=timeoutWith.js.map\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar timestamp_1 = __webpack_require__(59);\nObservable_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n//# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar toArray_1 = __webpack_require__(341);\nObservable_1.Observable.prototype.toArray = toArray_1.toArray;\n//# sourceMappingURL=toArray.js.map\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar toPromise_1 = __webpack_require__(342);\nObservable_1.Observable.prototype.toPromise = toPromise_1.toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar window_1 = __webpack_require__(343);\nObservable_1.Observable.prototype.window = window_1.window;\n//# sourceMappingURL=window.js.map\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar windowCount_1 = __webpack_require__(344);\nObservable_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n//# sourceMappingURL=windowCount.js.map\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar windowTime_1 = __webpack_require__(345);\nObservable_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n//# sourceMappingURL=windowTime.js.map\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar windowToggle_1 = __webpack_require__(346);\nObservable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n//# sourceMappingURL=windowToggle.js.map\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar windowWhen_1 = __webpack_require__(347);\nObservable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n//# sourceMappingURL=windowWhen.js.map\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar withLatestFrom_1 = __webpack_require__(348);\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar zip_1 = __webpack_require__(38);\nObservable_1.Observable.prototype.zip = zip_1.zipProto;\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(0);\nvar zipAll_1 = __webpack_require__(349);\nObservable_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar ScalarObservable_1 = __webpack_require__(32);\nvar EmptyObservable_1 = __webpack_require__(13);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar AsyncSubject_1 = __webpack_require__(22);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = (function (_super) {\n    __extends(BoundCallbackObservable, _super);\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a callback API to a function that returns an Observable.\n     *\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n     * it will return a function `g` that when called as `g(x)` will output an\n     * Observable.</span>\n     *\n     * `bindCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done.\n     *\n     * The output of `bindCallback` is a function that takes the same parameters\n     * as `func`, except the last one (the callback). When the output function\n     * is called with arguments, it will return an Observable. If `func` function\n     * calls its callback with one argument, the Observable will emit that value.\n     * If on the other hand callback is called with multiple values, resulting\n     * Observable will emit an array with these arguments.\n     *\n     * It is very important to remember, that input function `func` is not called\n     * when output function is, but rather when Observable returned by output\n     * function is subscribed. This means if `func` makes AJAX request, that request\n     * will be made every time someone subscribes to resulting Observable, but not before.\n     *\n     * Optionally, selector function can be passed to `bindObservable`. That function\n     * takes the same arguments as callback, and returns value\n     * that will be emitted by Observable instead of callback parameters themselves.\n     * Even though by default multiple arguments passed to callback appear in the stream as array,\n     * selector function will be called with arguments directly, just as callback would.\n     * This means you can imagine default selector (when one is not provided explicitly)\n     * as function that aggregates all its arguments into array, or simply returns first argument,\n     * if there is only one.\n     *\n     * Last optional parameter - {@link Scheduler} - can be used to control when call\n     * to `func` happens after someone subscribes to Observable, as well as when results\n     * passed to callback will be emitted. By default subscription to Observable calls `func`\n     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,\n     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler\n     * and call `subscribe` on output Observable, all function calls that are currently executing,\n     * will end before `func` is invoked.\n     *\n     * When it comes to emitting results passed to callback, by default they are emitted\n     * immediately after `func` invokes callback. In particular, if callback is called synchronously,\n     * then subscription to resulting Observable will call `next` function synchronously as well.\n     * If you want to defer that call, using `Scheduler.async` will, again, do the job.\n     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`\n     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n     *\n     * Note that Observable created by output function will always emit only one value\n     * and then complete right after. Even if `func` calls callback multiple times, values from\n     * second and following calls will never appear in the stream. If you need to\n     * listen for multiple calls, you probably want to use {@link fromEvent} or\n     * {@link fromEventPattern} instead.\n     *\n     * If `func` depends on some context (`this` property), that context will be set\n     * to the same context that output function has at call time. In particular, if `func`\n     * is called as method of some object, in order to preserve proper behaviour,\n     * it is recommended to set context of output function to that object as well,\n     * provided `func` is not already bound.\n     *\n     * If input function calls its callback in \"node style\" (i.e. first argument to callback is\n     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}\n     * provides convenient error handling and probably is a better choice.\n     * `bindCallback` will treat such functions without any difference and error parameter\n     * (whether passed or not) will always be interpreted as regular callback argument.\n     *\n     *\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n     * var result = getJSONAsObservable('/my/url');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Receive array of arguments passed to callback</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 5\n     *   console.log(b); // 'some string'\n     *   console.log(c); // {someProperty: 'someValue'}\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n     * boundSomeFunction().subscribe(values => {\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n     * });\n     *\n     *\n     * @example <caption>Use bindCallback with selector function</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 'a'\n     *   console.log(b); // 'b'\n     *   console.log(c); // 'c'\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n     * boundSomeFunction().subscribe(value => {\n     *   console.log(value) // 'abc'\n     * });\n     *\n     *\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\n     * function iCallMyCallbackSynchronously(cb) {\n     *   cb();\n     * }\n     *\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n     *\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\n     * console.log('This happened...');\n     *\n     * // Logs:\n     * // I was sync!\n     * // This happened...\n     * // I was async!\n     *\n     *\n     * @example <caption>Use bindCallback on object method</caption>\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n     * .subscribe(subscriber);\n     *\n     *\n     * @see {@link bindNodeCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps those to a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the callback would deliver.\n     * @static true\n     * @name bindCallback\n     * @owner Observable\n     */\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    BoundCallbackObservable.dispatch = function (state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i - 0] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                subject.error(errorObject_1.errorObject.e);\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    };\n    return BoundCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundCallbackObservable.js.map\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar AsyncSubject_1 = __webpack_require__(22);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundNodeCallbackObservable = (function (_super) {\n    __extends(BoundNodeCallbackObservable, _super);\n    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a Node.js-style callback API to a function that returns an\n     * Observable.\n     *\n     * <span class=\"informal\">It's just like {@link bindCallback}, but the\n     * callback is expected to be of type `callback(error, result)`.</span>\n     *\n     * `bindNodeCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done. The callback function is expected to follow Node.js conventions,\n     * where the first argument to the callback is an error object, signaling\n     * whether call was successful. If that object is passed to callback, it means\n     * something went wrong.\n     *\n     * The output of `bindNodeCallback` is a function that takes the same\n     * parameters as `func`, except the last one (the callback). When the output\n     * function is called with arguments, it will return an Observable.\n     * If `func` calls its callback with error parameter present, Observable will\n     * error with that value as well. If error parameter is not passed, Observable will emit\n     * second parameter. If there are more parameters (third and so on),\n     * Observable will emit an array with all arguments, except first error argument.\n     *\n     * Optionally `bindNodeCallback` accepts selector function, which allows you to\n     * make resulting Observable emit value computed by selector, instead of regular\n     * callback arguments. It works similarly to {@link bindCallback} selector, but\n     * Node.js-style error argument will never be passed to that function.\n     *\n     * Note that `func` will not be called at the same time output function is,\n     * but rather whenever resulting Observable is subscribed. By default call to\n     * `func` will happen synchronously after subscription, but that can be changed\n     * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n     * can also control when values from callback will be emitted by Observable.\n     * To find out more, check out documentation for {@link bindCallback}, where\n     * Scheduler works exactly the same.\n     *\n     * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n     * of returned function, when it is called.\n     *\n     * After Observable emits value, it will complete immediately. This means\n     * even if `func` calls callback again, values from second and consecutive\n     * calls will never appear on the stream. If you need to handle functions\n     * that call callbacks multiple times, check out {@link fromEvent} or\n     * {@link fromEventPattern} instead.\n     *\n     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n     * \"Node.js-style\" callbacks are just a convention, so if you write for\n     * browsers or any other environment and API you use implements that callback style,\n     * `bindNodeCallback` can be safely used on that API functions as well.\n     *\n     * Remember that Error object passed to callback does not have to be an instance\n     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n     * Error parameter of callback function is interpreted as \"present\", when value\n     * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n     * string or boolean `true`. In all of these cases resulting Observable would error\n     * with that value. This means usually regular style callbacks will fail very often when\n     * `bindNodeCallback` is used. If your Observable errors much more often then you\n     * would expect, check if callback really is called in Node.js-style and, if not,\n     * switch to {@link bindCallback} instead.\n     *\n     * Note that even if error parameter is technically present in callback, but its value\n     * is falsy, it still won't appear in array emitted by Observable or in selector function.\n     *\n     *\n     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n     * import * as fs from 'fs';\n     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n     * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Use on function calling callback with multiple arguments</caption>\n     * someFunction((err, a, b) => {\n     *   console.log(err); // null\n     *   console.log(a); // 5\n     *   console.log(b); // \"some string\"\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n     * boundSomeFunction()\n     * .subscribe(value => {\n     *   console.log(value); // [5, \"some string\"]\n     * });\n     *\n     *\n     * @example <caption>Use with selector function</caption>\n     * someFunction((err, a, b) => {\n     *   console.log(err); // undefined\n     *   console.log(a); // \"abc\"\n     *   console.log(b); // \"DEF\"\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n     * boundSomeFunction()\n     * .subscribe(value => {\n     *   console.log(value); // \"abcDEF\"\n     * });\n     *\n     *\n     * @example <caption>Use on function calling callback in regular style</caption>\n     * someFunction(a => {\n     *   console.log(a); // 5\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n     * boundSomeFunction()\n     * .subscribe(\n     *   value => {}             // never gets called\n     *   err => console.log(err) // 5\n     *);\n     *\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a Node.js-style callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps those to a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the Node.js callback would\n     * deliver.\n     * @static true\n     * @name bindNodeCallback\n     * @owner Observable\n     */\n    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    var err = innerArgs.shift();\n                    if (err) {\n                        subject.error(err);\n                    }\n                    else if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    return BoundNodeCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\nfunction dispatch(state) {\n    var self = this;\n    var source = state.source, subscriber = state.subscriber, context = state.context;\n    // XXX: cast to `any` to access to the private field in `source`.\n    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;\n    var subject = source.subject;\n    if (!subject) {\n        subject = source.subject = new AsyncSubject_1.AsyncSubject();\n        var handler = function handlerFn() {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i - 0] = arguments[_i];\n            }\n            var source = handlerFn.source;\n            var selector = source.selector, subject = source.subject;\n            var err = innerArgs.shift();\n            if (err) {\n                self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n            }\n            else if (selector) {\n                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                if (result_2 === errorObject_1.errorObject) {\n                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                }\n                else {\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                }\n            }\n            else {\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n            }\n        };\n        // use named function to pass values in without closure\n        handler.source = source;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n        if (result === errorObject_1.errorObject) {\n            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n        }\n    }\n    self.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundNodeCallbackObservable.js.map\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar DeferObservable = (function (_super) {\n    __extends(DeferObservable, _super);\n    function DeferObservable(observableFactory) {\n        _super.call(this);\n        this.observableFactory = observableFactory;\n    }\n    /**\n     * Creates an Observable that, on subscribe, calls an Observable factory to\n     * make an Observable for each new Observer.\n     *\n     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n     * is subscribed.\n     * </span>\n     *\n     * <img src=\"./img/defer.png\" width=\"100%\">\n     *\n     * `defer` allows you to create the Observable only when the Observer\n     * subscribes, and create a fresh Observable for each Observer. It waits until\n     * an Observer subscribes to it, and then it generates an Observable,\n     * typically with an Observable factory function. It does this afresh for each\n     * subscriber, so although each subscriber may think it is subscribing to the\n     * same Observable, in fact each subscriber gets its own individual\n     * Observable.\n     *\n     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n     * var clicksOrInterval = Rx.Observable.defer(function () {\n     *   if (Math.random() > 0.5) {\n     *     return Rx.Observable.fromEvent(document, 'click');\n     *   } else {\n     *     return Rx.Observable.interval(1000);\n     *   }\n     * });\n     * clicksOrInterval.subscribe(x => console.log(x));\n     *\n     * // Results in the following behavior:\n     * // If the result of Math.random() is greater than 0.5 it will listen\n     * // for clicks anywhere on the \"document\"; when document is clicked it\n     * // will log a MouseEvent object to the console. If the result is less\n     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n     *\n     * @see {@link create}\n     *\n     * @param {function(): SubscribableOrPromise} observableFactory The Observable\n     * factory function to invoke for each Observer that subscribes to the output\n     * Observable. May also return a Promise, which will be converted on the fly\n     * to an Observable.\n     * @return {Observable} An Observable whose Observers' subscriptions trigger\n     * an invocation of the given Observable factory function.\n     * @static true\n     * @name defer\n     * @owner Observable\n     */\n    DeferObservable.create = function (observableFactory) {\n        return new DeferObservable(observableFactory);\n    };\n    DeferObservable.prototype._subscribe = function (subscriber) {\n        return new DeferSubscriber(subscriber, this.observableFactory);\n    };\n    return DeferObservable;\n}(Observable_1.Observable));\nexports.DeferObservable = DeferObservable;\nvar DeferSubscriber = (function (_super) {\n    __extends(DeferSubscriber, _super);\n    function DeferSubscriber(destination, factory) {\n        _super.call(this, destination);\n        this.factory = factory;\n        this.tryDefer();\n    }\n    DeferSubscriber.prototype.tryDefer = function () {\n        try {\n            this._callFactory();\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    DeferSubscriber.prototype._callFactory = function () {\n        var result = this.factory();\n        if (result) {\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=DeferObservable.js.map\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ErrorObservable = (function (_super) {\n    __extends(ErrorObservable, _super);\n    function ErrorObservable(error, scheduler) {\n        _super.call(this);\n        this.error = error;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits an error notification.\n     *\n     * <span class=\"informal\">Just emits 'error', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/throw.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the error notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then emit an error.</caption>\n     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x === 13 ?\n     *     Rx.Observable.throw('Thirteens are bad') :\n     *     Rx.Observable.of('a', 'b', 'c')\n     * );\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     *\n     * @param {any} error The particular Error to pass to the error notification.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the error notification.\n     * @return {Observable} An error Observable: emits only the error notification\n     * using the given error argument.\n     * @static true\n     * @name throw\n     * @owner Observable\n     */\n    ErrorObservable.create = function (error, scheduler) {\n        return new ErrorObservable(error, scheduler);\n    };\n    ErrorObservable.dispatch = function (arg) {\n        var error = arg.error, subscriber = arg.subscriber;\n        subscriber.error(error);\n    };\n    ErrorObservable.prototype._subscribe = function (subscriber) {\n        var error = this.error;\n        var scheduler = this.scheduler;\n        subscriber.syncErrorThrowable = true;\n        if (scheduler) {\n            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                error: error, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.error(error);\n        }\n    };\n    return ErrorObservable;\n}(Observable_1.Observable));\nexports.ErrorObservable = ErrorObservable;\n//# sourceMappingURL=ErrorObservable.js.map\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar EmptyObservable_1 = __webpack_require__(13);\nvar isArray_1 = __webpack_require__(11);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * @param sources\n     * @return {any}\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar tryCatch_1 = __webpack_require__(8);\nvar isFunction_1 = __webpack_require__(30);\nvar errorObject_1 = __webpack_require__(6);\nvar Subscription_1 = __webpack_require__(4);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console everytime a click\n     * // occurs on the document.\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(30);\nvar Observable_1 = __webpack_require__(0);\nvar Subscription_1 = __webpack_require__(4);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventPatternObservable = (function (_super) {\n    __extends(FromEventPatternObservable, _super);\n    function FromEventPatternObservable(addHandler, removeHandler, selector) {\n        _super.call(this);\n        this.addHandler = addHandler;\n        this.removeHandler = removeHandler;\n        this.selector = selector;\n    }\n    /**\n     * Creates an Observable from an API based on addHandler/removeHandler\n     * functions.\n     *\n     * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n     * Observable.</span>\n     *\n     * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n     *\n     * Creates an Observable by using the `addHandler` and `removeHandler`\n     * functions to add and remove the handlers, with an optional selector\n     * function to project the event arguments to a result. The `addHandler` is\n     * called when the output Observable is subscribed, and `removeHandler` is\n     * called when the Subscription is unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * function addClickHandler(handler) {\n     *   document.addEventListener('click', handler);\n     * }\n     *\n     * function removeClickHandler(handler) {\n     *   document.removeEventListener('click', handler);\n     * }\n     *\n     * var clicks = Rx.Observable.fromEventPattern(\n     *   addClickHandler,\n     *   removeClickHandler\n     * );\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEvent}\n     *\n     * @param {function(handler: Function): any} addHandler A function that takes\n     * a `handler` function as argument and attaches it somehow to the actual\n     * source of events.\n     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n     * takes a `handler` function as argument and removes it in case it was\n     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n     * removeHandler function will forward it.\n     * @param {function(...args: any): T} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEventPattern\n     * @owner Observable\n     */\n    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n        return new FromEventPatternObservable(addHandler, removeHandler, selector);\n    };\n    FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var removeHandler = this.removeHandler;\n        var handler = !!this.selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            _this._callSelector(subscriber, args);\n        } : function (e) { subscriber.next(e); };\n        var retValue = this._callAddHandler(handler, subscriber);\n        if (!isFunction_1.isFunction(removeHandler)) {\n            return;\n        }\n        subscriber.add(new Subscription_1.Subscription(function () {\n            //TODO: determine whether or not to forward to error handler\n            removeHandler(handler, retValue);\n        }));\n    };\n    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n        try {\n            var result = this.selector.apply(this, args);\n            subscriber.next(result);\n        }\n        catch (e) {\n            subscriber.error(e);\n        }\n    };\n    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n        try {\n            return this.addHandler(handler) || null;\n        }\n        catch (e) {\n            errorSubscriber.error(e);\n        }\n    };\n    return FromEventPatternObservable;\n}(Observable_1.Observable));\nexports.FromEventPatternObservable = FromEventPatternObservable;\n//# sourceMappingURL=FromEventPatternObservable.js.map\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar isScheduler_1 = __webpack_require__(12);\nvar selfSelector = function (value) { return value; };\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar GenerateObservable = (function (_super) {\n    __extends(GenerateObservable, _super);\n    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n        _super.call(this);\n        this.initialState = initialState;\n        this.condition = condition;\n        this.iterate = iterate;\n        this.resultSelector = resultSelector;\n        this.scheduler = scheduler;\n    }\n    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n        if (arguments.length == 1) {\n            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n        }\n        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n        }\n        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n    };\n    GenerateObservable.prototype._subscribe = function (subscriber) {\n        var state = this.initialState;\n        if (this.scheduler) {\n            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n                subscriber: subscriber,\n                iterate: this.iterate,\n                condition: this.condition,\n                resultSelector: this.resultSelector,\n                state: state });\n        }\n        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\n        do {\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            var value = void 0;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        } while (true);\n    };\n    GenerateObservable.dispatch = function (state) {\n        var subscriber = state.subscriber, condition = state.condition;\n        if (subscriber.closed) {\n            return;\n        }\n        if (state.needIterate) {\n            try {\n                state.state = state.iterate(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        }\n        else {\n            state.needIterate = true;\n        }\n        if (condition) {\n            var conditionResult = void 0;\n            try {\n                conditionResult = condition(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            if (!conditionResult) {\n                subscriber.complete();\n                return;\n            }\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        var value;\n        try {\n            value = state.resultSelector(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return;\n        }\n        if (subscriber.closed) {\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        return this.schedule(state);\n    };\n    return GenerateObservable;\n}(Observable_1.Observable));\nexports.GenerateObservable = GenerateObservable;\n//# sourceMappingURL=GenerateObservable.js.map\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IfObservable = (function (_super) {\n    __extends(IfObservable, _super);\n    function IfObservable(condition, thenSource, elseSource) {\n        _super.call(this);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n    }\n    IfObservable.create = function (condition, thenSource, elseSource) {\n        return new IfObservable(condition, thenSource, elseSource);\n    };\n    IfObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n    };\n    return IfObservable;\n}(Observable_1.Observable));\nexports.IfObservable = IfObservable;\nvar IfSubscriber = (function (_super) {\n    __extends(IfSubscriber, _super);\n    function IfSubscriber(destination, condition, thenSource, elseSource) {\n        _super.call(this, destination);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n        this.tryIf();\n    }\n    IfSubscriber.prototype.tryIf = function () {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        var result;\n        try {\n            result = condition();\n            var source = result ? thenSource : elseSource;\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n            else {\n                this._complete();\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return IfSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=IfObservable.js.map\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(31);\nvar Observable_1 = __webpack_require__(0);\nvar async_1 = __webpack_require__(9);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IntervalObservable = (function (_super) {\n    __extends(IntervalObservable, _super);\n    function IntervalObservable(period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        _super.call(this);\n        this.period = period;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\n            this.period = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = async_1.async;\n        }\n    }\n    /**\n     * Creates an Observable that emits sequential numbers every specified\n     * interval of time, on a specified IScheduler.\n     *\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\n     * </span>\n     *\n     * <img src=\"./img/interval.png\" width=\"100%\">\n     *\n     * `interval` returns an Observable that emits an infinite sequence of\n     * ascending integers, with a constant interval of time of your choosing\n     * between those emissions. The first emission is not sent immediately, but\n     * only after the first period has passed. By default, this operator uses the\n     * `async` IScheduler to provide a notion of time, but you may pass any\n     * IScheduler to it.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n     * var numbers = Rx.Observable.interval(1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link delay}\n     *\n     * @param {number} [period=0] The interval size in milliseconds (by default)\n     * or the time unit determined by the scheduler's clock.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a sequential number each time\n     * interval.\n     * @static true\n     * @name interval\n     * @owner Observable\n     */\n    IntervalObservable.create = function (period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return new IntervalObservable(period, scheduler);\n    };\n    IntervalObservable.dispatch = function (state) {\n        var index = state.index, subscriber = state.subscriber, period = state.period;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index += 1;\n        this.schedule(state, period);\n    };\n    IntervalObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var period = this.period;\n        var scheduler = this.scheduler;\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n            index: index, subscriber: subscriber, period: period\n        }));\n    };\n    return IntervalObservable;\n}(Observable_1.Observable));\nexports.IntervalObservable = IntervalObservable;\n//# sourceMappingURL=IntervalObservable.js.map\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(7);\nvar Observable_1 = __webpack_require__(0);\nvar iterator_1 = __webpack_require__(19);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n/***/ }),\n/* 233 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar noop_1 = __webpack_require__(71);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar NeverObservable = (function (_super) {\n    __extends(NeverObservable, _super);\n    function NeverObservable() {\n        _super.call(this);\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer.\n     *\n     * <span class=\"informal\">An Observable that never emits anything.</span>\n     *\n     * <img src=\"./img/never.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that emits\n     * neither values nor errors nor the completion notification. It can be used\n     * for testing purposes or for composing with other Observables. Please note\n     * that by never emitting a complete notification, this Observable keeps the\n     * subscription from being disposed automatically. Subscriptions need to be\n     * manually disposed.\n     *\n     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n     * function info() {\n     *   console.log('Will not be called');\n     * }\n     * var result = Rx.Observable.never().startWith(7);\n     * result.subscribe(x => console.log(x), info, info);\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @return {Observable} A \"never\" Observable: never emits anything.\n     * @static true\n     * @name never\n     * @owner Observable\n     */\n    NeverObservable.create = function () {\n        return new NeverObservable();\n    };\n    NeverObservable.prototype._subscribe = function (subscriber) {\n        noop_1.noop();\n    };\n    return NeverObservable;\n}(Observable_1.Observable));\nexports.NeverObservable = NeverObservable;\n//# sourceMappingURL=NeverObservable.js.map\n\n/***/ }),\n/* 234 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nfunction dispatch(state) {\n    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;\n    if (index === length) {\n        subscriber.complete();\n        return;\n    }\n    var key = keys[index];\n    subscriber.next([key, obj[key]]);\n    state.index = index + 1;\n    this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PairsObservable = (function (_super) {\n    __extends(PairsObservable, _super);\n    function PairsObservable(obj, scheduler) {\n        _super.call(this);\n        this.obj = obj;\n        this.scheduler = scheduler;\n        this.keys = Object.keys(obj);\n    }\n    /**\n     * Convert an object into an observable sequence of [key, value] pairs\n     * using an optional IScheduler to enumerate the object.\n     *\n     * @example <caption>Converts a javascript object to an Observable</caption>\n     * var obj = {\n     *   foo: 42,\n     *   bar: 56,\n     *   baz: 78\n     * };\n     *\n     * var source = Rx.Observable.pairs(obj);\n     *\n     * var subscription = source.subscribe(\n     *   function (x) {\n     *     console.log('Next: %s', x);\n     *   },\n     *   function (err) {\n     *     console.log('Error: %s', err);\n     *   },\n     *   function () {\n     *     console.log('Completed');\n     *   });\n     *\n     * @param {Object} obj The object to inspect and turn into an\n     * Observable sequence.\n     * @param {Scheduler} [scheduler] An optional IScheduler to run the\n     * enumeration of the input sequence on.\n     * @returns {(Observable<Array<string | T>>)} An observable sequence of\n     * [key, value] pairs from the object.\n     */\n    PairsObservable.create = function (obj, scheduler) {\n        return new PairsObservable(obj, scheduler);\n    };\n    PairsObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, keys = _a.keys, scheduler = _a.scheduler;\n        var length = keys.length;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber\n            });\n        }\n        else {\n            for (var idx = 0; idx < length; idx++) {\n                var key = keys[idx];\n                subscriber.next([key, this.obj[key]]);\n            }\n            subscriber.complete();\n        }\n    };\n    return PairsObservable;\n}(Observable_1.Observable));\nexports.PairsObservable = PairsObservable;\n//# sourceMappingURL=PairsObservable.js.map\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar RangeObservable = (function (_super) {\n    __extends(RangeObservable, _super);\n    function RangeObservable(start, count, scheduler) {\n        _super.call(this);\n        this.start = start;\n        this._count = count;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits a sequence of numbers within a specified\n     * range.\n     *\n     * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n     *\n     * <img src=\"./img/range.png\" width=\"100%\">\n     *\n     * `range` operator emits a range of sequential integers, in order, where you\n     * select the `start` of the range and its `length`. By default, uses no\n     * IScheduler and just delivers the notifications synchronously, but may use\n     * an optional IScheduler to regulate those deliveries.\n     *\n     * @example <caption>Emits the numbers 1 to 10</caption>\n     * var numbers = Rx.Observable.range(1, 10);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link interval}\n     *\n     * @param {number} [start=0] The value of the first integer in the sequence.\n     * @param {number} [count=0] The number of sequential integers to generate.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the notifications.\n     * @return {Observable} An Observable of numbers that emits a finite range of\n     * sequential integers.\n     * @static true\n     * @name range\n     * @owner Observable\n     */\n    RangeObservable.create = function (start, count, scheduler) {\n        if (start === void 0) { start = 0; }\n        if (count === void 0) { count = 0; }\n        return new RangeObservable(start, count, scheduler);\n    };\n    RangeObservable.dispatch = function (state) {\n        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(start);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        state.start = start + 1;\n        this.schedule(state);\n    };\n    RangeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var start = this.start;\n        var count = this._count;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(RangeObservable.dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(start++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return RangeObservable;\n}(Observable_1.Observable));\nexports.RangeObservable = RangeObservable;\n//# sourceMappingURL=RangeObservable.js.map\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar asap_1 = __webpack_require__(61);\nvar isNumeric_1 = __webpack_require__(31);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar SubscribeOnObservable = (function (_super) {\n    __extends(SubscribeOnObservable, _super);\n    function SubscribeOnObservable(source, delayTime, scheduler) {\n        if (delayTime === void 0) { delayTime = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        _super.call(this);\n        this.source = source;\n        this.delayTime = delayTime;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n            this.delayTime = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = asap_1.asap;\n        }\n    }\n    SubscribeOnObservable.create = function (source, delay, scheduler) {\n        if (delay === void 0) { delay = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        return new SubscribeOnObservable(source, delay, scheduler);\n    };\n    SubscribeOnObservable.dispatch = function (arg) {\n        var source = arg.source, subscriber = arg.subscriber;\n        return this.add(source.subscribe(subscriber));\n    };\n    SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n        var delay = this.delayTime;\n        var source = this.source;\n        var scheduler = this.scheduler;\n        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n            source: source, subscriber: subscriber\n        });\n    };\n    return SubscribeOnObservable;\n}(Observable_1.Observable));\nexports.SubscribeOnObservable = SubscribeOnObservable;\n//# sourceMappingURL=SubscribeOnObservable.js.map\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(31);\nvar Observable_1 = __webpack_require__(0);\nvar async_1 = __webpack_require__(9);\nvar isScheduler_1 = __webpack_require__(12);\nvar isDate_1 = __webpack_require__(29);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar UsingObservable = (function (_super) {\n    __extends(UsingObservable, _super);\n    function UsingObservable(resourceFactory, observableFactory) {\n        _super.call(this);\n        this.resourceFactory = resourceFactory;\n        this.observableFactory = observableFactory;\n    }\n    UsingObservable.create = function (resourceFactory, observableFactory) {\n        return new UsingObservable(resourceFactory, observableFactory);\n    };\n    UsingObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;\n        var resource;\n        try {\n            resource = resourceFactory();\n            return new UsingSubscriber(subscriber, resource, observableFactory);\n        }\n        catch (err) {\n            subscriber.error(err);\n        }\n    };\n    return UsingObservable;\n}(Observable_1.Observable));\nexports.UsingObservable = UsingObservable;\nvar UsingSubscriber = (function (_super) {\n    __extends(UsingSubscriber, _super);\n    function UsingSubscriber(destination, resource, observableFactory) {\n        _super.call(this, destination);\n        this.resource = resource;\n        this.observableFactory = observableFactory;\n        destination.add(resource);\n        this.tryUse();\n    }\n    UsingSubscriber.prototype.tryUse = function () {\n        try {\n            var source = this.observableFactory.call(this, this.resource);\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return UsingSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=UsingObservable.js.map\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar BoundCallbackObservable_1 = __webpack_require__(222);\nexports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n//# sourceMappingURL=bindCallback.js.map\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar BoundNodeCallbackObservable_1 = __webpack_require__(223);\nexports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(12);\nvar isArray_1 = __webpack_require__(11);\nvar ArrayObservable_1 = __webpack_require__(10);\nvar combineLatest_1 = __webpack_require__(33);\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n *\n * @example <caption>Combine two timer Observables</caption>\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n *\n *\n * @example <caption>Combine an array of Observables</caption>\n * const observables = [1, 5, 10].map(\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n * );\n * const combined = Rx.Observable.combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n *\n *\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @static true\n * @name combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    var scheduler = null;\n    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(34);\nexports.concat = concat_1.concatStatic;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar DeferObservable_1 = __webpack_require__(224);\nexports.defer = DeferObservable_1.DeferObservable.create;\n//# sourceMappingURL=defer.js.map\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar Subscriber_1 = __webpack_require__(1);\nvar Observable_1 = __webpack_require__(0);\nvar Subscription_1 = __webpack_require__(4);\nvar root_1 = __webpack_require__(7);\nvar ReplaySubject_1 = __webpack_require__(23);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar assign_1 = __webpack_require__(367);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        if (urlConfigOrSource instanceof Observable_1.Observable) {\n            _super.call(this, destination, urlConfigOrSource);\n        }\n        else {\n            _super.call(this);\n            this.WebSocketCtor = root_1.root.WebSocket;\n            this._output = new Subject_1.Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                this.url = urlConfigOrSource;\n            }\n            else {\n                // WARNING: config object could override important members here.\n                assign_1.assign(this, urlConfigOrSource);\n            }\n            if (!this.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    }\n    WebSocketSubject.prototype.resultSelector = function (e) {\n        return JSON.parse(e.data);\n    };\n    /**\n     * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n     *\n     * @example <caption>Wraps browser WebSocket</caption>\n     *\n     * let socket$ = Observable.webSocket('ws://localhost:8081');\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n     *\n     * import { w3cwebsocket } from 'websocket';\n     *\n     * let socket$ = Observable.webSocket({\n     *   url: 'ws://localhost:8081',\n     *   WebSocketCtor: w3cwebsocket\n     * });\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n     * @return {WebSocketSubject}\n     * @static true\n     * @name webSocket\n     * @owner Observable\n     */\n    WebSocketSubject.create = function (urlConfigOrSource) {\n        return new WebSocketSubject(urlConfigOrSource);\n    };\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this, this.destination);\n        sock.operator = operator;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this.socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n        this._output = new Subject_1.Subject();\n    };\n    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable_1.Observable(function (observer) {\n            var result = tryCatch_1.tryCatch(subMsg)();\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                self.next(result);\n            }\n            var subscription = self.subscribe(function (x) {\n                var result = tryCatch_1.tryCatch(messageFilter)(x);\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else if (result) {\n                    observer.next(x);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                var result = tryCatch_1.tryCatch(unsubMsg)();\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var WebSocketCtor = this.WebSocketCtor;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = this.protocol ?\n                new WebSocketCtor(this.url, this.protocol) :\n                new WebSocketCtor(this.url);\n            this.socket = socket;\n            if (this.binaryType) {\n                this.socket.binaryType = this.binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription_1.Subscription(function () {\n            _this.socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var openObserver = _this.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                        'and an optional reason: { code: number, reason: string }'));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                observer.next(result);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this.socket) {\n            this._connectSocket();\n        }\n        var subscription = new Subscription_1.Subscription();\n        subscription.add(this._output.subscribe(subscriber));\n        subscription.add(function () {\n            var socket = _this.socket;\n            if (_this._output.observers.length === 0) {\n                if (socket && socket.readyState === 1) {\n                    socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscription;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _a = this, source = _a.source, socket = _a.socket;\n        if (socket && socket.readyState === 1) {\n            socket.close();\n            this._resetState();\n        }\n        _super.prototype.unsubscribe.call(this);\n        if (!source) {\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    };\n    return WebSocketSubject;\n}(Subject_1.AnonymousSubject));\nexports.WebSocketSubject = WebSocketSubject;\n//# sourceMappingURL=WebSocketSubject.js.map\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AjaxObservable_1 = __webpack_require__(48);\nexports.ajax = AjaxObservable_1.AjaxObservable.create;\n//# sourceMappingURL=ajax.js.map\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar WebSocketSubject_1 = __webpack_require__(244);\nexports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n//# sourceMappingURL=webSocket.js.map\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar EmptyObservable_1 = __webpack_require__(13);\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ForkJoinObservable_1 = __webpack_require__(226);\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromObservable_1 = __webpack_require__(46);\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(227);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventPatternObservable_1 = __webpack_require__(228);\nexports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n//# sourceMappingURL=fromEventPattern.js.map\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar PromiseObservable_1 = __webpack_require__(47);\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar GenerateObservable_1 = __webpack_require__(229);\nexports.generate = GenerateObservable_1.GenerateObservable.create;\n//# sourceMappingURL=generate.js.map\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IfObservable_1 = __webpack_require__(230);\nexports._if = IfObservable_1.IfObservable.create;\n//# sourceMappingURL=if.js.map\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IntervalObservable_1 = __webpack_require__(231);\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n//# sourceMappingURL=interval.js.map\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(52);\nexports.merge = merge_1.mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar NeverObservable_1 = __webpack_require__(233);\nexports.never = NeverObservable_1.NeverObservable.create;\n//# sourceMappingURL=never.js.map\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(10);\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar onErrorResumeNext_1 = __webpack_require__(55);\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar PairsObservable_1 = __webpack_require__(234);\nexports.pairs = PairsObservable_1.PairsObservable.create;\n//# sourceMappingURL=pairs.js.map\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar race_1 = __webpack_require__(56);\nexports.race = race_1.raceStatic;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar RangeObservable_1 = __webpack_require__(235);\nexports.range = RangeObservable_1.RangeObservable.create;\n//# sourceMappingURL=range.js.map\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ErrorObservable_1 = __webpack_require__(225);\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n//# sourceMappingURL=throw.js.map\n\n/***/ }),\n/* 264 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(237);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n/* 265 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar UsingObservable_1 = __webpack_require__(238);\nexports.using = UsingObservable_1.UsingObservable.create;\n//# sourceMappingURL=using.js.map\n\n/***/ }),\n/* 266 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar zip_1 = __webpack_require__(38);\nexports.zip = zip_1.zipStatic;\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n/* 267 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return this.lift(new AuditOperator(durationSelector));\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n/* 268 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(9);\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new AuditTimeOperator(duration, scheduler));\n}\nexports.auditTime = auditTime;\nvar AuditTimeOperator = (function () {\n    function AuditTimeOperator(duration, scheduler) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n    }\n    AuditTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));\n    };\n    return AuditTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditTimeSubscriber = (function (_super) {\n    __extends(AuditTimeSubscriber, _super);\n    function AuditTimeSubscriber(destination, duration, scheduler) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n    }\n    AuditTimeSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));\n        }\n    };\n    AuditTimeSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    return AuditTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n/* 269 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return this.lift(new BufferOperator(closingNotifier));\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n/***/ }),\n/* 270 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n/* 271 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(9);\nvar Subscriber_1 = __webpack_require__(1);\nvar isScheduler_1 = __webpack_require__(12);\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n/***/ }),\n/* 272 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(4);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return this.lift(new BufferToggleOperator(openings, closingSelector));\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n/***/ }),\n/* 273 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(4);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return this.lift(new BufferWhenOperator(closingSelector));\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n/***/ }),\n/* 274 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n/***/ }),\n/* 275 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar combineLatest_1 = __webpack_require__(33);\n/**\n * Converts a higher-order Observable into a first-order Observable by waiting\n * for the outer Observable to complete, then applying {@link combineLatest}.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n * {@link combineLatest} when the Observable-of-Observables completes.</span>\n *\n * <img src=\"./img/combineAll.png\" width=\"100%\">\n *\n * Takes an Observable of Observables, and collects all Observables from it.\n * Once the outer Observable completes, it subscribes to all collected\n * Observables and combines their values using the {@link combineLatest}\n * strategy, such that:\n * - Every time an inner Observable emits, the output Observable emits.\n * - When the returned observable emits, it emits all of the latest values by:\n *   - If a `project` function is provided, it is called with each recent value\n *     from each inner Observable in whatever order they arrived, and the result\n *     of the `project` function is what is emitted by the output Observable.\n *   - If there is no `project` function, an array of all of the most recent\n *     values is emitted by the output Observable.\n *\n * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev =>\n *   Rx.Observable.interval(Math.random()*2000).take(3)\n * ).take(2);\n * var result = higherOrder.combineAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function} [project] An optional function to map the most recent\n * values from each inner Observable into a new result. Takes each of the most\n * recent values from each collected inner Observable as arguments, in order.\n * @return {Observable} An Observable of projected results or arrays of recent\n * values.\n * @method combineAll\n * @owner Observable\n */\nfunction combineAll(project) {\n    return this.lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/***/ }),\n/* 276 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeAll_1 = __webpack_require__(24);\n/* tslint:enable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n/***/ }),\n/* 277 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeMap_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n/***/ }),\n/* 278 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar mergeMapTo_1 = __webpack_require__(54);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/***/ }),\n/* 279 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return this.lift(new CountOperator(predicate, this));\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n/***/ }),\n/* 280 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return this.lift(new DebounceOperator(durationSelector));\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n/* 281 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(9);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n/* 282 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return this.lift(new DefaultIfEmptyOperator(defaultValue));\n}\nexports.defaultIfEmpty = defaultIfEmpty;\nvar DefaultIfEmptyOperator = (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DefaultIfEmptySubscriber = (function (_super) {\n    __extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        _super.call(this, destination);\n        this.defaultValue = defaultValue;\n        this.isEmpty = true;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n/***/ }),\n/* 283 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(9);\nvar isDate_1 = __webpack_require__(29);\nvar Subscriber_1 = __webpack_require__(1);\nvar Notification_1 = __webpack_require__(16);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return this.lift(new DelayOperator(delayFor, scheduler));\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n/* 284 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Observable_1 = __webpack_require__(0);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return new SubscriptionDelayObservable(this, subscriptionDelay)\n            .lift(new DelayWhenOperator(delayDurationSelector));\n    }\n    return this.lift(new DelayWhenOperator(delayDurationSelector));\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n/***/ }),\n/* 285 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return this.lift(new DeMaterializeOperator());\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n/***/ }),\n/* 286 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar Set_1 = __webpack_require__(366);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return this.lift(new DistinctOperator(keySelector, flushes));\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n/***/ }),\n/* 287 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar distinctUntilChanged_1 = __webpack_require__(49);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {\n        if (compare) {\n            return compare(x[key], y[key]);\n        }\n        return x[key] === y[key];\n    });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/***/ }),\n/* 288 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\nexports._do = _do;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n/* 289 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(20);\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return this.lift(new ElementAtOperator(index, defaultValue));\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n/***/ }),\n/* 290 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n/* 291 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return this.lift(new SwitchFirstOperator());\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n/***/ }),\n/* 292 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return this.lift(new SwitchFirstMapOperator(project, resultSelector));\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n/***/ }),\n/* 293 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return this.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n/***/ }),\n/* 294 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Subscription_1 = __webpack_require__(4);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return this.lift(new FinallyOperator(callback));\n}\nexports._finally = _finally;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finally.js.map\n\n/***/ }),\n/* 295 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar find_1 = __webpack_require__(51);\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/***/ }),\n/* 296 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyError_1 = __webpack_require__(27);\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n        this._emitted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        if (!this._emitted) {\n            this._emitted = true;\n            destination.next(value);\n            destination.complete();\n            this.hasCompleted = true;\n        }\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n/***/ }),\n/* 297 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Subscription_1 = __webpack_require__(4);\nvar Observable_1 = __webpack_require__(0);\nvar Subject_1 = __webpack_require__(5);\nvar Map_1 = __webpack_require__(364);\nvar FastMap_1 = __webpack_require__(362);\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n/***/ }),\n/* 298 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar noop_1 = __webpack_require__(71);\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return this.lift(new IgnoreElementsOperator());\n}\nexports.ignoreElements = ignoreElements;\n;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n/***/ }),\n/* 299 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n *\n * <img src=\"./img/isEmpty.png\" width=\"100%\">\n *\n * @return {Observable} An Observable that emits a Boolean.\n * @method isEmpty\n * @owner Observable\n */\nfunction isEmpty() {\n    return this.lift(new IsEmptyOperator());\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n/***/ }),\n/* 300 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyError_1 = __webpack_require__(27);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n/* 301 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\nfunction letProto(func) {\n    return func(this);\n}\nexports.letProto = letProto;\n//# sourceMappingURL=let.js.map\n\n/***/ }),\n/* 302 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return this.lift(new MapToOperator(value));\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n/***/ }),\n/* 303 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Notification_1 = __webpack_require__(16);\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return this.lift(new MaterializeOperator());\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n/***/ }),\n/* 304 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(37);\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(max));\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n/***/ }),\n/* 305 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar subscribeToResult_1 = __webpack_require__(3);\nvar OuterSubscriber_1 = __webpack_require__(2);\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n/***/ }),\n/* 306 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(37);\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(min));\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n/***/ }),\n/* 307 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return this.lift(new PairwiseOperator());\n}\nexports.pairwise = pairwise;\nvar PairwiseOperator = (function () {\n    function PairwiseOperator() {\n    }\n    PairwiseOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    };\n    return PairwiseOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar PairwiseSubscriber = (function (_super) {\n    __extends(PairwiseSubscriber, _super);\n    function PairwiseSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasPrev = false;\n    }\n    PairwiseSubscriber.prototype._next = function (value) {\n        if (this.hasPrev) {\n            this.destination.next([this.prev, value]);\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n    };\n    return PairwiseSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=pairwise.js.map\n\n/***/ }),\n/* 308 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar not_1 = __webpack_require__(368);\nvar filter_1 = __webpack_require__(50);\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return [\n        filter_1.filter.call(this, predicate, thisArg),\n        filter_1.filter.call(this, not_1.not(predicate, thisArg))\n    ];\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n/***/ }),\n/* 309 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar map_1 = __webpack_require__(35);\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return map_1.map.call(this, plucker(properties, length));\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n/***/ }),\n/* 310 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Subject_1 = __webpack_require__(5);\nvar multicast_1 = __webpack_require__(14);\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast.call(this, new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n/***/ }),\n/* 311 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar BehaviorSubject_1 = __webpack_require__(42);\nvar multicast_1 = __webpack_require__(14);\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/***/ }),\n/* 312 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncSubject_1 = __webpack_require__(22);\nvar multicast_1 = __webpack_require__(14);\n/**\n * @return {ConnectableObservable<T>}\n * @method publishLast\n * @owner Observable\n */\nfunction publishLast() {\n    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/***/ }),\n/* 313 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ReplaySubject_1 = __webpack_require__(23);\nvar multicast_1 = __webpack_require__(14);\n/**\n * @param bufferSize\n * @param windowTime\n * @param scheduler\n * @return {ConnectableObservable<T>}\n * @method publishReplay\n * @owner Observable\n */\nfunction publishReplay(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/***/ }),\n/* 314 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyObservable_1 = __webpack_require__(13);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else if (count < 0) {\n        return this.lift(new RepeatOperator(-1, this));\n    }\n    else {\n        return this.lift(new RepeatOperator(count - 1, this));\n    }\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n/* 315 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return this.lift(new RepeatWhenOperator(notifier));\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            else if (this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n/***/ }),\n/* 316 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return this.lift(new RetryOperator(count, this));\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n/***/ }),\n/* 317 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return this.lift(new RetryWhenOperator(notifier, this));\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n/***/ }),\n/* 318 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return this.lift(new SampleOperator(notifier));\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n/***/ }),\n/* 319 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(9);\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new SampleTimeOperator(period, scheduler));\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n/***/ }),\n/* 320 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ScanOperator(accumulator, seed, hasSeed));\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n/***/ }),\n/* 321 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return this.lift(new SequenceEqualOperator(compareTo, comparor));\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n/***/ }),\n/* 322 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar multicast_1 = __webpack_require__(14);\nvar Subject_1 = __webpack_require__(5);\nfunction shareSubjectFactory() {\n    return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .publish().refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n/***/ }),\n/* 323 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar multicast_1 = __webpack_require__(14);\nvar ReplaySubject_1 = __webpack_require__(23);\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    var subject;\n    var connectable = multicast_1.multicast.call(this, function shareReplaySubjectFactory() {\n        if (this._isComplete) {\n            return subject;\n        }\n        else {\n            return (subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));\n        }\n    });\n    return connectable.refCount();\n}\nexports.shareReplay = shareReplay;\n;\n//# sourceMappingURL=shareReplay.js.map\n\n/***/ }),\n/* 324 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar EmptyError_1 = __webpack_require__(27);\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return this.lift(new SingleOperator(predicate, this));\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n/***/ }),\n/* 325 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return this.lift(new SkipOperator(count));\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n/***/ }),\n/* 326 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(20);\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return this.lift(new SkipLastOperator(count));\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n/***/ }),\n/* 327 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return this.lift(new SkipUntilOperator(notifier));\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n/***/ }),\n/* 328 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return this.lift(new SkipWhileOperator(predicate));\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n/***/ }),\n/* 329 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(10);\nvar ScalarObservable_1 = __webpack_require__(32);\nvar EmptyObservable_1 = __webpack_require__(13);\nvar concat_1 = __webpack_require__(34);\nvar isScheduler_1 = __webpack_require__(12);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n        array.pop();\n    }\n    else {\n        scheduler = null;\n    }\n    var len = array.length;\n    if (len === 1) {\n        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n    }\n    else if (len > 1) {\n        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n    }\n    else {\n        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n    }\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n/* 330 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar SubscribeOnObservable_1 = __webpack_require__(236);\n/**\n * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n .\n * @method subscribeOn\n * @owner Observable\n */\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new SubscribeOnOperator(scheduler, delay));\n}\nexports.subscribeOn = subscribeOn;\nvar SubscribeOnOperator = (function () {\n    function SubscribeOnOperator(scheduler, delay) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    SubscribeOnOperator.prototype.call = function (subscriber, source) {\n        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n    };\n    return SubscribeOnOperator;\n}());\n//# sourceMappingURL=subscribeOn.js.map\n\n/***/ }),\n/* 331 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nfunction _switch() {\n    return this.lift(new SwitchOperator());\n}\nexports._switch = _switch;\nvar SwitchOperator = (function () {\n    function SwitchOperator() {\n    }\n    SwitchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchSubscriber(subscriber));\n    };\n    return SwitchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchSubscriber = (function (_super) {\n    __extends(SwitchSubscriber, _super);\n    function SwitchSubscriber(destination) {\n        _super.call(this, destination);\n        this.active = 0;\n        this.hasCompleted = false;\n    }\n    SwitchSubscriber.prototype._next = function (value) {\n        this.unsubscribeInner();\n        this.active++;\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));\n    };\n    SwitchSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    SwitchSubscriber.prototype.unsubscribeInner = function () {\n        this.active = this.active > 0 ? this.active - 1 : 0;\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n            this.remove(innerSubscription);\n        }\n    };\n    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    SwitchSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchSubscriber.prototype.notifyComplete = function () {\n        this.unsubscribeInner();\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return SwitchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switch.js.map\n\n/***/ }),\n/* 332 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n/***/ }),\n/* 333 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n/***/ }),\n/* 334 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(20);\nvar EmptyObservable_1 = __webpack_require__(13);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeOperator(count));\n    }\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n/* 335 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(20);\nvar EmptyObservable_1 = __webpack_require__(13);\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeLastOperator(count));\n    }\n}\nexports.takeLast = takeLast;\nvar TakeLastOperator = (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeLastSubscriber = (function (_super) {\n    __extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.ring = new Array();\n        this.count = 0;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeLast.js.map\n\n/***/ }),\n/* 336 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return this.lift(new TakeUntilOperator(notifier));\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n/* 337 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return this.lift(new TakeWhileOperator(predicate));\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n/***/ }),\n/* 338 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(9);\nvar throttle_1 = __webpack_require__(57);\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return this.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n/***/ }),\n/* 339 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(9);\nvar isDate_1 = __webpack_require__(29);\nvar Subscriber_1 = __webpack_require__(1);\nvar TimeoutError_1 = __webpack_require__(65);\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n/***/ }),\n/* 340 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(9);\nvar isDate_1 = __webpack_require__(29);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * @param due\n * @param withObservable\n * @param scheduler\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n/***/ }),\n/* 341 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\n/**\n * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n * @method toArray\n * @owner Observable\n */\nfunction toArray() {\n    return this.lift(new ToArrayOperator());\n}\nexports.toArray = toArray;\nvar ToArrayOperator = (function () {\n    function ToArrayOperator() {\n    }\n    ToArrayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ToArraySubscriber(subscriber));\n    };\n    return ToArrayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ToArraySubscriber = (function (_super) {\n    __extends(ToArraySubscriber, _super);\n    function ToArraySubscriber(destination) {\n        _super.call(this, destination);\n        this.array = [];\n    }\n    ToArraySubscriber.prototype._next = function (x) {\n        this.array.push(x);\n    };\n    ToArraySubscriber.prototype._complete = function () {\n        this.destination.next(this.array);\n        this.destination.complete();\n    };\n    return ToArraySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=toArray.js.map\n\n/***/ }),\n/* 342 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\n/* tslint:enable:max-line-length */\n/**\n * Converts an Observable sequence to a ES2015 compliant promise.\n *\n * @example\n * // Using normal ES2015\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise();\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * // Rejected Promise\n * // Using normal ES2015\n * let source = Rx.Observable\n *   .throw(new Error('woops'))\n *   .toPromise();\n *\n * source\n *   .then((value) => console.log('Value: %s', value))\n *   .catch((err) => console.log('Error: %s', err));\n * // => Error: Error: woops\n *\n * // Setting via the config\n * Rx.config.Promise = RSVP.Promise;\n *\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise();\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * // Setting via the method\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise(RSVP.Promise);\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * @param {PromiseConstructor} [PromiseCtor] The constructor of the promise. If not provided,\n * it will look for a constructor first in Rx.config.Promise then fall back to\n * the native Promise constructor if available.\n * @return {Promise<T>} An ES2015 compatible promise with the last value from\n * the observable sequence.\n * @method toPromise\n * @owner Observable\n */\nfunction toPromise(PromiseCtor) {\n    var _this = this;\n    if (!PromiseCtor) {\n        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n            PromiseCtor = root_1.root.Rx.config.Promise;\n        }\n        else if (root_1.root.Promise) {\n            PromiseCtor = root_1.root.Promise;\n        }\n    }\n    if (!PromiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return new PromiseCtor(function (resolve, reject) {\n        var value;\n        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n    });\n}\nexports.toPromise = toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n/***/ }),\n/* 343 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return this.lift(new WindowOperator(windowBoundaries));\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n/***/ }),\n/* 344 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(1);\nvar Subject_1 = __webpack_require__(5);\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n/***/ }),\n/* 345 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar async_1 = __webpack_require__(9);\nvar Subscriber_1 = __webpack_require__(1);\nvar isNumeric_1 = __webpack_require__(31);\nvar isScheduler_1 = __webpack_require__(12);\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n/***/ }),\n/* 346 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(4);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return this.lift(new WindowToggleOperator(openings, closingSelector));\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n/***/ }),\n/* 347 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar tryCatch_1 = __webpack_require__(8);\nvar errorObject_1 = __webpack_require__(6);\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return this.lift(new WindowOperator(closingSelector));\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n/***/ }),\n/* 348 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(2);\nvar subscribeToResult_1 = __webpack_require__(3);\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ }),\n/* 349 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar zip_1 = __webpack_require__(38);\n/**\n * @param project\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method zipAll\n * @owner Observable\n */\nfunction zipAll(project) {\n    return this.lift(new zip_1.ZipOperator(project));\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/***/ }),\n/* 350 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(4);\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n/***/ }),\n/* 351 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(17);\nvar AnimationFrame_1 = __webpack_require__(361);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If an animation frame has already been requested, don't request another\n        // one. If an animation frame hasn't been requested yet, request one. Return\n        // the current animation frame request id.\n        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested animation frame and\n        // set the scheduled flag to undefined so the next AnimationFrameAction will\n        // request its own.\n        if (scheduler.actions.length === 0) {\n            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction_1.AsyncAction));\nexports.AnimationFrameAction = AnimationFrameAction;\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n/***/ }),\n/* 352 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(18);\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        _super.apply(this, arguments);\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AnimationFrameScheduler = AnimationFrameScheduler;\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n/***/ }),\n/* 353 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Immediate_1 = __webpack_require__(363);\nvar AsyncAction_1 = __webpack_require__(17);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If a microtask has already been scheduled, don't schedule another\n        // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n        // the current scheduled microtask id.\n        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested microtask and\n        // set the scheduled flag to undefined so the next AsapAction will schedule\n        // its own.\n        if (scheduler.actions.length === 0) {\n            Immediate_1.Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction_1.AsyncAction));\nexports.AsapAction = AsapAction;\n//# sourceMappingURL=AsapAction.js.map\n\n/***/ }),\n/* 354 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(18);\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        _super.apply(this, arguments);\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AsapScheduler = AsapScheduler;\n//# sourceMappingURL=AsapScheduler.js.map\n\n/***/ }),\n/* 355 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(17);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n/***/ }),\n/* 356 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(18);\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n/***/ }),\n/* 357 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AnimationFrameAction_1 = __webpack_require__(351);\nvar AnimationFrameScheduler_1 = __webpack_require__(352);\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * @example <caption>Schedule div height animation</caption>\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n *\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\nexports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n//# sourceMappingURL=animationFrame.js.map\n\n/***/ }),\n/* 358 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar Subscription_1 = __webpack_require__(4);\nvar SubscriptionLoggable_1 = __webpack_require__(64);\nvar applyMixins_1 = __webpack_require__(67);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ColdObservable = (function (_super) {\n    __extends(ColdObservable, _super);\n    function ColdObservable(messages, scheduler) {\n        _super.call(this, function (subscriber) {\n            var observable = this;\n            var index = observable.logSubscribedFrame();\n            subscriber.add(new Subscription_1.Subscription(function () {\n                observable.logUnsubscribedFrame(index);\n            }));\n            observable.scheduleMessages(subscriber);\n            return subscriber;\n        });\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    ColdObservable.prototype.scheduleMessages = function (subscriber) {\n        var messagesLength = this.messages.length;\n        for (var i = 0; i < messagesLength; i++) {\n            var message = this.messages[i];\n            subscriber.add(this.scheduler.schedule(function (_a) {\n                var message = _a.message, subscriber = _a.subscriber;\n                message.notification.observe(subscriber);\n            }, message.frame, { message: message, subscriber: subscriber }));\n        }\n    };\n    return ColdObservable;\n}(Observable_1.Observable));\nexports.ColdObservable = ColdObservable;\napplyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=ColdObservable.js.map\n\n/***/ }),\n/* 359 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(5);\nvar Subscription_1 = __webpack_require__(4);\nvar SubscriptionLoggable_1 = __webpack_require__(64);\nvar applyMixins_1 = __webpack_require__(67);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar HotObservable = (function (_super) {\n    __extends(HotObservable, _super);\n    function HotObservable(messages, scheduler) {\n        _super.call(this);\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    HotObservable.prototype._subscribe = function (subscriber) {\n        var subject = this;\n        var index = subject.logSubscribedFrame();\n        subscriber.add(new Subscription_1.Subscription(function () {\n            subject.logUnsubscribedFrame(index);\n        }));\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    HotObservable.prototype.setup = function () {\n        var subject = this;\n        var messagesLength = subject.messages.length;\n        /* tslint:disable:no-var-keyword */\n        for (var i = 0; i < messagesLength; i++) {\n            (function () {\n                var message = subject.messages[i];\n                /* tslint:enable */\n                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);\n            })();\n        }\n    };\n    return HotObservable;\n}(Subject_1.Subject));\nexports.HotObservable = HotObservable;\napplyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=HotObservable.js.map\n\n/***/ }),\n/* 360 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(0);\nvar Notification_1 = __webpack_require__(16);\nvar ColdObservable_1 = __webpack_require__(358);\nvar HotObservable_1 = __webpack_require__(359);\nvar SubscriptionLog_1 = __webpack_require__(63);\nvar VirtualTimeScheduler_1 = __webpack_require__(60);\nvar defaultMaxFrame = 750;\nvar TestScheduler = (function (_super) {\n    __extends(TestScheduler, _super);\n    function TestScheduler(assertDeepEqual) {\n        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n    }\n    TestScheduler.prototype.createTime = function (marbles) {\n        var indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    };\n    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var cold = new ColdObservable_1.ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    };\n    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var subject = new HotObservable_1.HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    };\n    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n        var _this = this;\n        var messages = [];\n        observable.subscribe(function (value) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });\n        }, function (err) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });\n        }, function () {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });\n        });\n        return messages;\n    };\n    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n        var _this = this;\n        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }\n        var actual = [];\n        var flushTest = { actual: actual, ready: false };\n        var unsubscriptionFrame = TestScheduler\n            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n        var subscription;\n        this.schedule(function () {\n            subscription = observable.subscribe(function (x) {\n                var value = x;\n                // Support Observable-of-Observables\n                if (x instanceof Observable_1.Observable) {\n                    value = _this.materializeInnerObservable(value, _this.frame);\n                }\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n            }, function (err) {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n            }, function () {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n            });\n        }, 0);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n            }\n        };\n    };\n    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n        var flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles) {\n                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(function (marbles) {\n                    return TestScheduler.parseMarblesAsSubscriptions(marbles);\n                });\n            }\n        };\n    };\n    TestScheduler.prototype.flush = function () {\n        var hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        _super.prototype.flush.call(this);\n        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });\n        while (readyFlushTests.length > 0) {\n            var test = readyFlushTests.shift();\n            this.assertDeepEqual(test.actual, test.expected);\n        }\n    };\n    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        var len = marbles.length;\n        var groupStart = -1;\n        var subscriptionFrame = Number.POSITIVE_INFINITY;\n        var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    };\n    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        var len = marbles.length;\n        var testMessages = [];\n        var subIndex = marbles.indexOf('^');\n        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        var getValue = typeof values !== 'object' ?\n            function (x) { return x; } :\n            function (x) {\n                // Support Observable-of-Observables\n                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        var groupStart = -1;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor + frameOffset;\n            var notification = void 0;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '|':\n                    notification = Notification_1.Notification.createComplete();\n                    break;\n                case '^':\n                    break;\n                case '#':\n                    notification = Notification_1.Notification.createError(errorValue || 'error');\n                    break;\n                default:\n                    notification = Notification_1.Notification.createNext(getValue(c));\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });\n            }\n        }\n        return testMessages;\n    };\n    return TestScheduler;\n}(VirtualTimeScheduler_1.VirtualTimeScheduler));\nexports.TestScheduler = TestScheduler;\n//# sourceMappingURL=TestScheduler.js.map\n\n/***/ }),\n/* 361 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nvar RequestAnimationFrameDefinition = (function () {\n    function RequestAnimationFrameDefinition(root) {\n        if (root.requestAnimationFrame) {\n            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n        }\n        else if (root.mozRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n        }\n        else if (root.webkitRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n        }\n        else if (root.msRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n        }\n        else if (root.oRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n        }\n        else {\n            this.cancelAnimationFrame = root.clearTimeout.bind(root);\n            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };\n        }\n    }\n    return RequestAnimationFrameDefinition;\n}());\nexports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\nexports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);\n//# sourceMappingURL=AnimationFrame.js.map\n\n/***/ }),\n/* 362 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n/***/ }),\n/* 363 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\n\nvar root_1 = __webpack_require__(7);\nvar ImmediateDefinition = (function () {\n    function ImmediateDefinition(root) {\n        this.root = root;\n        if (root.setImmediate && typeof root.setImmediate === 'function') {\n            this.setImmediate = root.setImmediate.bind(root);\n            this.clearImmediate = root.clearImmediate.bind(root);\n        }\n        else {\n            this.nextHandle = 1;\n            this.tasksByHandle = {};\n            this.currentlyRunningATask = false;\n            // Don't get fooled by e.g. browserify environments.\n            if (this.canUseProcessNextTick()) {\n                // For Node.js before 0.9\n                this.setImmediate = this.createProcessNextTickSetImmediate();\n            }\n            else if (this.canUsePostMessage()) {\n                // For non-IE10 modern browsers\n                this.setImmediate = this.createPostMessageSetImmediate();\n            }\n            else if (this.canUseMessageChannel()) {\n                // For web workers, where supported\n                this.setImmediate = this.createMessageChannelSetImmediate();\n            }\n            else if (this.canUseReadyStateChange()) {\n                // For IE 6–8\n                this.setImmediate = this.createReadyStateChangeSetImmediate();\n            }\n            else {\n                // For older browsers\n                this.setImmediate = this.createSetTimeoutSetImmediate();\n            }\n            var ci = function clearImmediate(handle) {\n                delete clearImmediate.instance.tasksByHandle[handle];\n            };\n            ci.instance = this;\n            this.clearImmediate = ci;\n        }\n    }\n    ImmediateDefinition.prototype.identify = function (o) {\n        return this.root.Object.prototype.toString.call(o);\n    };\n    ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n        return this.identify(this.root.process) === '[object process]';\n    };\n    ImmediateDefinition.prototype.canUseMessageChannel = function () {\n        return Boolean(this.root.MessageChannel);\n    };\n    ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n        var document = this.root.document;\n        return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n    };\n    ImmediateDefinition.prototype.canUsePostMessage = function () {\n        var root = this.root;\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `root.postMessage` means something completely different and can't be used for this purpose.\n        if (root.postMessage && !root.importScripts) {\n            var postMessageIsAsynchronous_1 = true;\n            var oldOnMessage = root.onmessage;\n            root.onmessage = function () {\n                postMessageIsAsynchronous_1 = false;\n            };\n            root.postMessage('', '*');\n            root.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous_1;\n        }\n        return false;\n    };\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var fn = function result() {\n            var _a = result, handler = _a.handler, args = _a.args;\n            if (typeof handler === 'function') {\n                handler.apply(undefined, args);\n            }\n            else {\n                (new Function('' + handler))();\n            }\n        };\n        fn.handler = handler;\n        fn.args = args;\n        return fn;\n    };\n    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n        return this.nextHandle++;\n    };\n    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        var root = this.root;\n        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n        var onGlobalMessage = function globalMessageHandler(event) {\n            var instance = globalMessageHandler.instance;\n            if (event.source === root &&\n                typeof event.data === 'string' &&\n                event.data.indexOf(messagePrefix) === 0) {\n                instance.runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n        onGlobalMessage.instance = this;\n        root.addEventListener('message', onGlobalMessage, false);\n        var fn = function setImmediate() {\n            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.postMessage(messagePrefix + handle, '*');\n            return handle;\n        };\n        fn.instance = this;\n        fn.messagePrefix = messagePrefix;\n        return fn;\n    };\n    ImmediateDefinition.prototype.runIfPresent = function (handle) {\n        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (this.currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // 'too much recursion' error.\n            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n        }\n        else {\n            var task = this.tasksByHandle[handle];\n            if (task) {\n                this.currentlyRunningATask = true;\n                try {\n                    task();\n                }\n                finally {\n                    this.clearImmediate(handle);\n                    this.currentlyRunningATask = false;\n                }\n            }\n        }\n    };\n    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n        var _this = this;\n        var channel = new this.root.MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            _this.runIfPresent(handle);\n        };\n        var fn = function setImmediate() {\n            var _a = setImmediate, channel = _a.channel, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n        fn.channel = channel;\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var root = instance.root;\n            var doc = root.document;\n            var html = doc.documentElement;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement('script');\n            script.onreadystatechange = function () {\n                instance.runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    return ImmediateDefinition;\n}());\nexports.ImmediateDefinition = ImmediateDefinition;\nexports.Immediate = new ImmediateDefinition(root_1.root);\n//# sourceMappingURL=Immediate.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(72).clearImmediate, __webpack_require__(72).setImmediate))\n\n/***/ }),\n/* 364 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nvar MapPolyfill_1 = __webpack_require__(365);\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n/***/ }),\n/* 365 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n/***/ }),\n/* 366 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n/***/ }),\n/* 367 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(7);\nfunction assignImpl(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    var len = sources.length;\n    for (var i = 0; i < len; i++) {\n        var source = sources[i];\n        for (var k in source) {\n            if (source.hasOwnProperty(k)) {\n                target[k] = source[k];\n            }\n        }\n    }\n    return target;\n}\nexports.assignImpl = assignImpl;\n;\nfunction getAssign(root) {\n    return root.Object.assign || assignImpl;\n}\nexports.getAssign = getAssign;\nexports.assign = getAssign(root_1.root);\n//# sourceMappingURL=assign.js.map\n\n/***/ }),\n/* 368 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n/***/ }),\n/* 369 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Subscriber_1 = __webpack_require__(1);\nvar rxSubscriber_1 = __webpack_require__(26);\nvar Observer_1 = __webpack_require__(43);\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n/***/ }),\n/* 370 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(39), __webpack_require__(89)))\n\n/***/ }),\n/* 371 */,\n/* 372 */,\n/* 373 */,\n/* 374 */,\n/* 375 */,\n/* 376 */,\n/* 377 */,\n/* 378 */,\n/* 379 */,\n/* 380 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n  * vue-router v2.7.0\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (false) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nfunction isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n      ) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also regiseter instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      if (false) {\n        warn(\n          false,\n          \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n          \"expecting an object, function or boolean.\"\n        );\n      }\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery,\n  _parseQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n    \"production\" !== 'production' && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    var val = extraQuery[key];\n    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;\n  }\n  return parsedQuery\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom,\n  router\n) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (\n  ref,\n  _stringifyQuery\n) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal)\n    }\n    return String(aVal) === String(bVal)\n  })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null\n            ? 'router-link-active'\n            : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null\n            ? 'router-link-exact-active'\n            : globalExactActiveClass;\n    var activeClass = this.activeClass == null\n            ? activeClassFallback\n            : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null\n            ? exactActiveClassFallback\n            : this.exactActiveClass;\n    var compareTarget = location.path\n      ? createRoute(null, location, null, router)\n      : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact\n      ? classes[exactActiveClass]\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function (v) { return v !== undefined; };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed () {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this._routerRoot._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this._routerRoot._route }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (index$1(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (index$1(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (false) {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (false) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var normalizedPath = normalizePath(path, parent);\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (false) {\n      if (route.name && !route.redirect && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (false) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction compileRouteRegex (path, pathToRegexpOptions) {\n  var regex = index(path, [], pathToRegexpOptions);\n  if (false) {\n    var keys = {};\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\"));\n      keys[key.name] = true;\n    });\n  }\n  return regex\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\n/*  */\n\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append,\n  router\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (false) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : basePath;\n\n  var query = resolveQuery(\n    parsedPath.query,\n    next.query,\n    router && router.options.parseQuery\n  );\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\n\nfunction createMatcher (\n  routes,\n  router\n) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (false) {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      if (!record) { return _createRoute(null, location) }\n      var paramNames = record.regex.keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location, null, router))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (false) {\n        warn(\n          false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n        );\n      }\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (false) {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      if (false) {\n        warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      }\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  regex,\n  path,\n  params\n) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (false) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n        offset = normalizeOffset(offset);\n        position = getElementPosition(el, offset);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction normalizeOffset (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents (matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (resolvedDef.__esModule && resolvedDef.default) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n          \"production\" !== 'production' && warn(false, msg);\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) { next(); }\n  }\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (called) { return }\n    called = true;\n    return fn.apply(this, args)\n  }\n}\n\n/*  */\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError (errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function (err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' && (\n            typeof to.path === 'string' ||\n            typeof to.name === 'string'\n          ))\n        ) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  window.location.replace((base + \"#\" + path));\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (false) {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  \"production\" !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  return registerHook(this.beforeHooks, fn)\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n  return registerHook(this.resolveHooks, fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  return registerHook(this.afterHooks, fn)\n};\n\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError (errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? to.matched\n      ? to\n      : this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(\n    to,\n    current || this.history.current,\n    append,\n    this\n  );\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction registerHook (list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) { list.splice(i, 1); }\n  }\n}\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.7.0';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (VueRouter);\n\n\n/***/ }),\n/* 381 */\n/***/ (function(module, exports) {\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n/***/ }),\n/* 382 */\n/***/ (function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n/***/ }),\n/* 383 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(381)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ })\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/vendor.b782ad69b17e217df14e.js","\"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar observable_1 = require('./symbol/observable');\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log('Adding: ' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log('Sum equals: ' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log('Adding: ' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log('Sum equals: ' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log('completed!') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log('unsubscribed!');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // \"unsubscribed!\" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observable.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer_1.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscriber.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/OuterSubscriber.js\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nvar isArrayLike_1 = require('./isArrayLike');\nvar isPromise_1 = require('./isPromise');\nvar isObject_1 = require('./isObject');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    else if (isArrayLike_1.isArrayLike(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (result && typeof result[iterator_1.iterator] === 'function') {\n        var iterator = result[iterator_1.iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (result && typeof result[observable_1.observable] === 'function') {\n        var obs = result[observable_1.observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        destination.error(new TypeError(msg));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/subscribeToResult.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscription.js\n// module id = 4\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('./Observable');\nvar Subscriber_1 = require('./Subscriber');\nvar Subscription_1 = require('./Subscription');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subject.js\n// module id = 5\n// module chunks = 0","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/errorObject.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\nvar _root = __window || __global || __self;\nexports.root = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/root.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/tryCatch.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/async.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ArrayObservable.js\n// module id = 10\n// module chunks = 0","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isArray.js\n// module id = 11\n// module chunks = 0","\"use strict\";\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isScheduler.js\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following to the console:\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\n     * // x will occur every 1000ms\n     * // if x % 2 is equal to 1 print abc\n     * // if x % 2 is not equal to 1 nothing will be output\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/EmptyObservable.js\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar ConnectableObservable_1 = require('../observable/ConnectableObservable');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    if (typeof selector === 'function') {\n        return this.lift(new MulticastOperator(subjectFactory, selector));\n    }\n    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = this;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/multicast.js\n// module id = 14\n// module chunks = 0","// https://d3js.org Version 4.10.0. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar version = \"4.10.0\";\n\nvar ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\n\nvar bisector = function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n\nvar pairs = function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n};\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\nvar cross = function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n};\n\nvar descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar number = function(x) {\n  return x === null ? NaN : +x;\n};\n\nvar variance = function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n};\n\nvar deviation = function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n};\n\nvar extent = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n};\n\nvar array = Array.prototype;\n\nvar slice = array.slice;\nvar map = array.map;\n\nvar constant = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar identity = function(x) {\n  return x;\n};\n\nvar sequence = function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n};\n\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n\nvar ticks = function(start, stop, count) {\n  var reverse = stop < start,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  if (reverse) n = start, start = stop, stop = n;\n\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n};\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nvar sturges = function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n};\n\nvar histogram = function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n};\n\nvar threshold = function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n};\n\nvar freedmanDiaconis = function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n};\n\nvar scott = function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n};\n\nvar max = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n};\n\nvar mean = function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n};\n\nvar median = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return threshold(numbers.sort(ascending), 0.5);\n};\n\nvar merge = function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n};\n\nvar min = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n};\n\nvar permute = function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n};\n\nvar scan = function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n};\n\nvar shuffle = function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n};\n\nvar sum = function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n};\n\nvar transpose = function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n};\n\nfunction length(d) {\n  return d.length;\n}\n\nvar zip = function() {\n  return transpose(arguments);\n};\n\nvar slice$1 = Array.prototype.slice;\n\nvar identity$1 = function(x) {\n  return x;\n};\n\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon = 1e-6;\n\nfunction translateX(x) {\n  return \"translate(\" + (x + 0.5) + \",0)\";\n}\n\nfunction translateY(y) {\n  return \"translate(0,\" + (y + 0.5) + \")\";\n}\n\nfunction number$1(scale) {\n  return function(d) {\n    return +scale(d);\n  };\n}\n\nfunction center(scale) {\n  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.\n  if (scale.round()) offset = Math.round(offset);\n  return function(d) {\n    return +scale(d) + offset;\n  };\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3,\n      k = orient === top || orient === left ? -1 : 1,\n      x = orient === left || orient === right ? \"x\" : \"y\",\n      transform = orient === top || orient === bottom ? translateX : translateY;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        range = scale.range(),\n        range0 = +range[0] + 0.5,\n        range1 = +range[range.length - 1] + 0.5,\n        position = (scale.bandwidth ? center : number$1)(scale.copy()),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"#000\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"#000\")\n        .attr(x + \"2\", k * tickSizeInner));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"#000\")\n        .attr(x, k * spacing)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute(\"transform\"); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon)\n          .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient == right\n            ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H0.5V\" + range1 + \"H\" + k * tickSizeOuter\n            : \"M\" + range0 + \",\" + k * tickSizeOuter + \"V0.5H\" + range1 + \"V\" + k * tickSizeOuter);\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position(d)); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = slice$1.call(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  return axis;\n}\n\nfunction axisTop(scale) {\n  return axis(top, scale);\n}\n\nfunction axisRight(scale) {\n  return axis(right, scale);\n}\n\nfunction axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nfunction axisLeft(scale) {\n  return axis(left, scale);\n}\n\nvar noop = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\nvar namespaces = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nvar namespace = function(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;\n};\n\nfunction creatorInherit(name) {\n  return function() {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n        ? document.createElement(name)\n        : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\nvar creator = function(name) {\n  var fullname = namespace(name);\n  return (fullname.local\n      ? creatorFixed\n      : creatorInherit)(fullname);\n};\n\nvar nextId = 0;\n\nfunction local$1() {\n  return new Local;\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local$1.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id = this._;\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n    return node[id];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nvar matcher = function(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document !== \"undefined\") {\n  var element = document.documentElement;\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector\n        || element.msMatchesSelector\n        || element.mozMatchesSelector\n        || element.oMatchesSelector;\n    matcher = function(selector) {\n      return function() {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\nvar matcher$1 = matcher;\n\nvar filterEvents = {};\n\nexports.event = null;\n\nif (typeof document !== \"undefined\") {\n  var element$1 = document.documentElement;\n  if (!(\"onmouseenter\" in element$1)) {\n    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function(event) {\n    var related = event.relatedTarget;\n    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function(event1) {\n    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n    exports.event = event1;\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      exports.event = event0;\n    }\n  };\n}\n\nfunction parseTypenames$1(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {type: t, name: name};\n  });\n}\n\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;\n  return function(d, i, group) {\n    var on = this.__on, o, listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\n\nvar selection_on = function(typename, value, capture) {\n  var typenames = parseTypenames$1(typename + \"\"), i, n = typenames.length, t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value ? onAdd : onRemove;\n  if (capture == null) capture = false;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n  return this;\n};\n\nfunction customEvent(event1, listener, that, args) {\n  var event0 = exports.event;\n  event1.sourceEvent = exports.event;\n  exports.event = event1;\n  try {\n    return listener.apply(that, args);\n  } finally {\n    exports.event = event0;\n  }\n}\n\nvar sourceEvent = function() {\n  var current = exports.event, source;\n  while (source = current.sourceEvent) current = source;\n  return current;\n};\n\nvar point = function(node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX, point.y = event.clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n};\n\nvar mouse = function(node) {\n  var event = sourceEvent();\n  if (event.changedTouches) event = event.changedTouches[0];\n  return point(node, event);\n};\n\nfunction none() {}\n\nvar selector = function(selector) {\n  return selector == null ? none : function() {\n    return this.querySelector(selector);\n  };\n};\n\nvar selection_select = function(select) {\n  if (typeof select !== \"function\") select = selector(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nfunction empty$1() {\n  return [];\n}\n\nvar selectorAll = function(selector) {\n  return selector == null ? empty$1 : function() {\n    return this.querySelectorAll(selector);\n  };\n};\n\nvar selection_selectAll = function(select) {\n  if (typeof select !== \"function\") select = selectorAll(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        subgroups.push(select.call(node, node.__data__, i, group));\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, parents);\n};\n\nvar selection_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nvar sparse = function(update) {\n  return new Array(update.length);\n};\n\nvar selection_enter = function() {\n  return new Selection(this._enter || this._groups.map(sparse), this._parents);\n};\n\nfunction EnterNode(parent, datum) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum;\n}\n\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },\n  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },\n  querySelector: function(selector) { return this._parent.querySelector(selector); },\n  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }\n};\n\nvar constant$1 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nvar selection_data = function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant$1(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n};\n\nvar selection_exit = function() {\n  return new Selection(this._exit || this._groups.map(sparse), this._parents);\n};\n\nvar selection_merge = function(selection$$1) {\n\n  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Selection(merges, this._parents);\n};\n\nvar selection_order = function() {\n\n  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {\n    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n\n  return this;\n};\n\nvar selection_sort = function(compare) {\n  if (!compare) compare = ascending$1;\n\n  function compareNode(a, b) {\n    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n  }\n\n  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n\n  return new Selection(sortgroups, this._parents).order();\n};\n\nfunction ascending$1(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nvar selection_call = function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n};\n\nvar selection_nodes = function() {\n  var nodes = new Array(this.size()), i = -1;\n  this.each(function() { nodes[++i] = this; });\n  return nodes;\n};\n\nvar selection_node = function() {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n\n  return null;\n};\n\nvar selection_size = function() {\n  var size = 0;\n  this.each(function() { ++size; });\n  return size;\n};\n\nvar selection_empty = function() {\n  return !this.node();\n};\n\nvar selection_each = function(callback) {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) callback.call(node, node.__data__, i, group);\n    }\n  }\n\n  return this;\n};\n\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\n\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\n\nfunction attrFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttribute(name);\n    else this.setAttribute(name, v);\n  };\n}\n\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);\n    else this.setAttributeNS(fullname.space, fullname.local, v);\n  };\n}\n\nvar selection_attr = function(name, value) {\n  var fullname = namespace(name);\n\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local\n        ? node.getAttributeNS(fullname.space, fullname.local)\n        : node.getAttribute(fullname);\n  }\n\n  return this.each((value == null\n      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS : attrFunction)\n      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));\n};\n\nvar defaultView = function(node) {\n  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n      || (node.document && node) // node is a Window\n      || node.defaultView; // node is a Document\n};\n\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\n\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, v, priority);\n  };\n}\n\nvar selection_style = function(name, value, priority) {\n  return arguments.length > 1\n      ? this.each((value == null\n            ? styleRemove : typeof value === \"function\"\n            ? styleFunction\n            : styleConstant)(name, value, priority == null ? \"\" : priority))\n      : styleValue(this.node(), name);\n};\n\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name)\n      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\n\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\n\nfunction propertyFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) delete this[name];\n    else this[name] = v;\n  };\n}\n\nvar selection_property = function(name, value) {\n  return arguments.length > 1\n      ? this.each((value == null\n          ? propertyRemove : typeof value === \"function\"\n          ? propertyFunction\n          : propertyConstant)(name, value))\n      : this.node()[name];\n};\n\nfunction classArray(string) {\n  return string.trim().split(/^|\\s+/);\n}\n\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\n\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\n\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\n\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.add(names[i]);\n}\n\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.remove(names[i]);\n}\n\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\n\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\n\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\n\nvar selection_classed = function(name, value) {\n  var names = classArray(name + \"\");\n\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n) if (!list.contains(names[i])) return false;\n    return true;\n  }\n\n  return this.each((typeof value === \"function\"\n      ? classedFunction : value\n      ? classedTrue\n      : classedFalse)(names, value));\n};\n\nfunction textRemove() {\n  this.textContent = \"\";\n}\n\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.textContent = v == null ? \"\" : v;\n  };\n}\n\nvar selection_text = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? textRemove : (typeof value === \"function\"\n          ? textFunction\n          : textConstant)(value))\n      : this.node().textContent;\n};\n\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\n\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\n\nfunction htmlFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.innerHTML = v == null ? \"\" : v;\n  };\n}\n\nvar selection_html = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? htmlRemove : (typeof value === \"function\"\n          ? htmlFunction\n          : htmlConstant)(value))\n      : this.node().innerHTML;\n};\n\nfunction raise() {\n  if (this.nextSibling) this.parentNode.appendChild(this);\n}\n\nvar selection_raise = function() {\n  return this.each(raise);\n};\n\nfunction lower() {\n  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\n\nvar selection_lower = function() {\n  return this.each(lower);\n};\n\nvar selection_append = function(name) {\n  var create = typeof name === \"function\" ? name : creator(name);\n  return this.select(function() {\n    return this.appendChild(create.apply(this, arguments));\n  });\n};\n\nfunction constantNull() {\n  return null;\n}\n\nvar selection_insert = function(name, before) {\n  var create = typeof name === \"function\" ? name : creator(name),\n      select = before == null ? constantNull : typeof before === \"function\" ? before : selector(before);\n  return this.select(function() {\n    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);\n  });\n};\n\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nvar selection_remove = function() {\n  return this.each(remove);\n};\n\nvar selection_datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.node().__data__;\n};\n\nfunction dispatchEvent(node, type, params) {\n  var window = defaultView(node),\n      event = window.CustomEvent;\n\n  if (typeof event === \"function\") {\n    event = new event(type, params);\n  } else {\n    event = window.document.createEvent(\"Event\");\n    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;\n    else event.initEvent(type, false, false);\n  }\n\n  node.dispatchEvent(event);\n}\n\nfunction dispatchConstant(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params);\n  };\n}\n\nfunction dispatchFunction(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params.apply(this, arguments));\n  };\n}\n\nvar selection_dispatch = function(type, params) {\n  return this.each((typeof params === \"function\"\n      ? dispatchFunction\n      : dispatchConstant)(type, params));\n};\n\nvar root = [null];\n\nfunction Selection(groups, parents) {\n  this._groups = groups;\n  this._parents = parents;\n}\n\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\n\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: selection_select,\n  selectAll: selection_selectAll,\n  filter: selection_filter,\n  data: selection_data,\n  enter: selection_enter,\n  exit: selection_exit,\n  merge: selection_merge,\n  order: selection_order,\n  sort: selection_sort,\n  call: selection_call,\n  nodes: selection_nodes,\n  node: selection_node,\n  size: selection_size,\n  empty: selection_empty,\n  each: selection_each,\n  attr: selection_attr,\n  style: selection_style,\n  property: selection_property,\n  classed: selection_classed,\n  text: selection_text,\n  html: selection_html,\n  raise: selection_raise,\n  lower: selection_lower,\n  append: selection_append,\n  insert: selection_insert,\n  remove: selection_remove,\n  datum: selection_datum,\n  on: selection_on,\n  dispatch: selection_dispatch\n};\n\nvar select = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([[document.querySelector(selector)]], [document.documentElement])\n      : new Selection([[selector]], root);\n};\n\nvar selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])\n      : new Selection([selector == null ? [] : selector], root);\n};\n\nvar touch = function(node, touches, identifier) {\n  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;\n\n  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {\n    if ((touch = touches[i]).identifier === identifier) {\n      return point(node, touch);\n    }\n  }\n\n  return null;\n};\n\nvar touches = function(node, touches) {\n  if (touches == null) touches = sourceEvent().touches;\n\n  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {\n    points[i] = point(node, touches[i]);\n  }\n\n  return points;\n};\n\nfunction nopropagation() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar dragDisable = function(view) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", noevent, true);\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", noevent, true);\n  } else {\n    root.__noselect = root.style.MozUserSelect;\n    root.style.MozUserSelect = \"none\";\n  }\n};\n\nfunction yesdrag(view, noclick) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection$$1.on(\"click.drag\", noevent, true);\n    setTimeout(function() { selection$$1.on(\"click.drag\", null); }, 0);\n  }\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", null);\n  } else {\n    root.style.MozUserSelect = root.__noselect;\n    delete root.__noselect;\n  }\n}\n\nvar constant$2 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {\n  this.target = target;\n  this.type = type;\n  this.subject = subject;\n  this.identifier = id;\n  this.active = active;\n  this.x = x;\n  this.y = y;\n  this.dx = dx;\n  this.dy = dy;\n  this._ = dispatch;\n}\n\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$1() {\n  return !exports.event.button;\n}\n\nfunction defaultContainer() {\n  return this.parentNode;\n}\n\nfunction defaultSubject(d) {\n  return d == null ? {x: exports.event.x, y: exports.event.y} : d;\n}\n\nfunction touchable() {\n  return \"ontouchstart\" in this;\n}\n\nvar drag = function() {\n  var filter = defaultFilter$1,\n      container = defaultContainer,\n      subject = defaultSubject,\n      gestures = {},\n      listeners = dispatch(\"start\", \"drag\", \"end\"),\n      active = 0,\n      mousedownx,\n      mousedowny,\n      mousemoving,\n      touchending,\n      clickDistance2 = 0;\n\n  function drag(selection) {\n    selection\n        .on(\"mousedown.drag\", mousedowned)\n      .filter(touchable)\n        .on(\"touchstart.drag\", touchstarted)\n        .on(\"touchmove.drag\", touchmoved)\n        .on(\"touchend.drag touchcancel.drag\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var gesture = beforestart(\"mouse\", container.apply(this, arguments), mouse, this, arguments);\n    if (!gesture) return;\n    select(exports.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n    dragDisable(exports.event.view);\n    nopropagation();\n    mousemoving = false;\n    mousedownx = exports.event.clientX;\n    mousedowny = exports.event.clientY;\n    gesture(\"start\");\n  }\n\n  function mousemoved() {\n    noevent();\n    if (!mousemoving) {\n      var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\");\n  }\n\n  function mouseupped() {\n    select(exports.event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(exports.event.view, mousemoving);\n    noevent();\n    gestures.mouse(\"end\");\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var touches$$1 = exports.event.changedTouches,\n        c = container.apply(this, arguments),\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {\n        nopropagation();\n        gesture(\"start\");\n      }\n    }\n  }\n\n  function touchmoved() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        noevent();\n        gesture(\"drag\");\n      }\n    }\n  }\n\n  function touchended() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        nopropagation();\n        gesture(\"end\");\n      }\n    }\n  }\n\n  function beforestart(id, container, point, that, args) {\n    var p = point(container, id), s, dx, dy,\n        sublisteners = listeners.copy();\n\n    if (!customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;\n      dx = s.x - p[0] || 0;\n      dy = s.y - p[1] || 0;\n      return true;\n    })) return;\n\n    return function gesture(type) {\n      var p0 = p, n;\n      switch (type) {\n        case \"start\": gestures[id] = gesture, n = active++; break;\n        case \"end\": delete gestures[id], --active; // nobreak\n        case \"drag\": p = point(container, id), n = active; break;\n      }\n      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n    };\n  }\n\n  drag.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$2(!!_), drag) : filter;\n  };\n\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$2(_), drag) : container;\n  };\n\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$2(_), drag) : subject;\n  };\n\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n\n  return drag;\n};\n\nvar define = function(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n};\n\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\n\nfunction Color() {}\n\nvar darker = 0.7;\nvar brighter = 1 / darker;\n\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\";\nvar reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\";\nvar reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\";\nvar reHex3 = /^#([0-9a-f]{3})$/;\nvar reHex6 = /^#([0-9a-f]{6})$/;\nvar reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\");\nvar reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\");\nvar reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\");\nvar reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\");\nvar reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\");\nvar reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\");\n\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\n\ndefine(Color, color, {\n  displayable: function() {\n    return this.rgb().displayable();\n  },\n  toString: function() {\n    return this.rgb() + \"\";\n  }\n});\n\nfunction color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n      : named.hasOwnProperty(format) ? rgbn(named[format])\n      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n      : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb;\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\n\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\n\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Rgb, rgb, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function() {\n    return this;\n  },\n  displayable: function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255)\n        && (0 <= this.opacity && this.opacity <= 1);\n  },\n  toString: function() {\n    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\")\n        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n        + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl;\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\n\nfunction hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hsl, hsl, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  displayable: function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1)\n        && (0 <= this.opacity && this.opacity <= 1);\n  }\n}));\n\n/* From FvD 13.37, CSS Color Module Level 3 */\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60\n      : h < 180 ? m2\n      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n      : m1) * 255;\n}\n\nvar deg2rad = Math.PI / 180;\nvar rad2deg = 180 / Math.PI;\n\nvar Kn = 18;\nvar Xn = 0.950470;\nvar Yn = 1;\nvar Zn = 1.088830;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl) {\n    var h = o.h * deg2rad;\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var b = rgb2xyz(o.r),\n      a = rgb2xyz(o.g),\n      l = rgb2xyz(o.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nfunction lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\n\nfunction Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Lab, lab, extend(Color, {\n  brighter: function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n      this.opacity\n    );\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  var h = Math.atan2(o.b, o.a) * rad2deg;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nfunction hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hcl, hcl, extend(Color, {\n  brighter: function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function() {\n    return labConvert(this).rgb();\n  }\n}));\n\nvar A = -0.14861;\nvar B = +1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = +1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nfunction cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Cubehelix, cubehelix, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh)),\n      this.opacity\n    );\n  }\n}));\n\nfunction basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nvar basis$1 = function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar basisClosed = function(values) {\n  var n = values.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n        v0 = values[(i + n - 1) % n],\n        v1 = values[i % n],\n        v2 = values[(i + 1) % n],\n        v3 = values[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar constant$3 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction linear(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nfunction hue(a, b) {\n  var d = b - a;\n  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);\n}\n\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);\n  };\n}\n\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);\n}\n\nvar interpolateRgb = (function rgbGamma(y) {\n  var color$$1 = gamma(y);\n\n  function rgb$$1(start, end) {\n    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),\n        g = color$$1(start.g, end.g),\n        b = color$$1(start.b, end.b),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb$$1.gamma = rgbGamma;\n\n  return rgb$$1;\n})(1);\n\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length,\n        r = new Array(n),\n        g = new Array(n),\n        b = new Array(n),\n        i, color$$1;\n    for (i = 0; i < n; ++i) {\n      color$$1 = rgb(colors[i]);\n      r[i] = color$$1.r || 0;\n      g[i] = color$$1.g || 0;\n      b[i] = color$$1.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color$$1.opacity = 1;\n    return function(t) {\n      color$$1.r = r(t);\n      color$$1.g = g(t);\n      color$$1.b = b(t);\n      return color$$1 + \"\";\n    };\n  };\n}\n\nvar rgbBasis = rgbSpline(basis$1);\nvar rgbBasisClosed = rgbSpline(basisClosed);\n\nvar array$1 = function(a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(nb),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function(t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nvar date = function(a, b) {\n  var d = new Date;\n  return a = +a, b -= a, function(t) {\n    return d.setTime(a + b * t), d;\n  };\n};\n\nvar reinterpolate = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return a + b * t;\n  };\n};\n\nvar object = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateValue(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n};\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\n\nvar interpolateString = function(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n      am, // current match in a\n      bm, // current match in b\n      bs, // string preceding current number in b, if any\n      i = -1, // index in s\n      s = [], // string constants and placeholders\n      q = []; // number interpolators\n\n  // Coerce inputs to strings.\n  a = a + \"\", b = b + \"\";\n\n  // Interpolate pairs of numbers in a & b.\n  while ((am = reA.exec(a))\n      && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else { // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({i: i, x: reinterpolate(am, bm)});\n    }\n    bi = reB.lastIndex;\n  }\n\n  // Add remains of b.\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  }\n\n  // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return s.length < 2 ? (q[0]\n      ? one(q[0].x)\n      : zero(b))\n      : (b = q.length, function(t) {\n          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n          return s.join(\"\");\n        });\n};\n\nvar interpolateValue = function(a, b) {\n  var t = typeof b, c;\n  return b == null || t === \"boolean\" ? constant$3(b)\n      : (t === \"number\" ? reinterpolate\n      : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)\n      : b instanceof color ? interpolateRgb\n      : b instanceof Date ? date\n      : Array.isArray(b) ? array$1\n      : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object\n      : reinterpolate)(a, b);\n};\n\nvar interpolateRound = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return Math.round(a + b * t);\n  };\n};\n\nvar degrees = 180 / Math.PI;\n\nvar identity$2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\n\nvar decompose = function(a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n};\n\nvar cssNode;\nvar cssRoot;\nvar cssView;\nvar svgNode;\n\nfunction parseCss(value) {\n  if (value === \"none\") return identity$2;\n  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n  cssNode.style.transform = value;\n  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n  cssRoot.removeChild(cssNode);\n  value = value.slice(7, -1).split(\",\");\n  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n}\n\nfunction parseSvg(value) {\n  if (value == null) return identity$2;\n  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;\n  value = value.matrix;\n  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n\n  function pop(s) {\n    return s.length ? s.pop() + \" \" : \"\";\n  }\n\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});\n    } else if (xb || yb) {\n      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path\n      q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: reinterpolate(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"rotate(\" + b + degParen);\n    }\n  }\n\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: reinterpolate(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"skewX(\" + b + degParen);\n    }\n  }\n\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n\n  return function(a, b) {\n    var s = [], // string constants and placeholders\n        q = []; // number interpolators\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null; // gc\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  };\n}\n\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\nvar rho = Math.SQRT2;\nvar rho2 = 2;\nvar rho4 = 4;\nvar epsilon2 = 1e-12;\n\nfunction cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n}\n\n// p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\nvar interpolateZoom = function(p0, p1) {\n  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],\n      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],\n      dx = ux1 - ux0,\n      dy = uy1 - uy0,\n      d2 = dx * dx + dy * dy,\n      i,\n      S;\n\n  // Special case for u0 ≅ u1.\n  if (d2 < epsilon2) {\n    S = Math.log(w1 / w0) / rho;\n    i = function(t) {\n      return [\n        ux0 + t * dx,\n        uy0 + t * dy,\n        w0 * Math.exp(rho * t * S)\n      ];\n    };\n  }\n\n  // General case.\n  else {\n    var d1 = Math.sqrt(d2),\n        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n    S = (r1 - r0) / rho;\n    i = function(t) {\n      var s = t * S,\n          coshr0 = cosh(r0),\n          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n      return [\n        ux0 + u * dx,\n        uy0 + u * dy,\n        w0 * coshr0 / cosh(rho * s + r0)\n      ];\n    };\n  }\n\n  i.duration = S * 1000;\n\n  return i;\n};\n\nfunction hsl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),\n        s = nogamma(start.s, end.s),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.s = s(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hsl$2 = hsl$1(hue);\nvar hslLong = hsl$1(nogamma);\n\nfunction lab$1(start, end) {\n  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),\n      a = nogamma(start.a, end.a),\n      b = nogamma(start.b, end.b),\n      opacity = nogamma(start.opacity, end.opacity);\n  return function(t) {\n    start.l = l(t);\n    start.a = a(t);\n    start.b = b(t);\n    start.opacity = opacity(t);\n    return start + \"\";\n  };\n}\n\nfunction hcl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),\n        c = nogamma(start.c, end.c),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.c = c(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hcl$2 = hcl$1(hue);\nvar hclLong = hcl$1(nogamma);\n\nfunction cubehelix$1(hue$$1) {\n  return (function cubehelixGamma(y) {\n    y = +y;\n\n    function cubehelix$$1(start, end) {\n      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),\n          s = nogamma(start.s, end.s),\n          l = nogamma(start.l, end.l),\n          opacity = nogamma(start.opacity, end.opacity);\n      return function(t) {\n        start.h = h(t);\n        start.s = s(t);\n        start.l = l(Math.pow(t, y));\n        start.opacity = opacity(t);\n        return start + \"\";\n      };\n    }\n\n    cubehelix$$1.gamma = cubehelixGamma;\n\n    return cubehelix$$1;\n  })(1);\n}\n\nvar cubehelix$2 = cubehelix$1(hue);\nvar cubehelixLong = cubehelix$1(nogamma);\n\nvar quantize = function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n};\n\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1000;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nfunction timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow;\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, delay);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\nvar timeout$1 = function(callback, delay, time) {\n  var t = new Timer;\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n};\n\nvar interval$1 = function(callback, delay, time) {\n  var t = new Timer, total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? now() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n};\n\nvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\n\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n\nvar schedule = function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n};\n\nfunction init(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction set$1(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction get$1(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout$1(start);\n\n      // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout$1(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n\nvar interrupt = function(node, name) {\n  var schedules = node.__transition,\n      schedule$$1,\n      active,\n      empty = true,\n      i;\n\n  if (!schedules) return;\n\n  name = name == null ? null : name + \"\";\n\n  for (i in schedules) {\n    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }\n    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;\n    schedule$$1.state = ENDED;\n    schedule$$1.timer.stop();\n    if (active) schedule$$1.on.call(\"interrupt\", node, node.__data__, schedule$$1.index, schedule$$1.group);\n    delete schedules[i];\n  }\n\n  if (empty) delete node.__transition;\n};\n\nvar selection_interrupt = function(name) {\n  return this.each(function() {\n    interrupt(this, name);\n  });\n};\n\nfunction tweenRemove(id, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule$$1 = set$1(this, id),\n        tween = schedule$$1.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    schedule$$1.tween = tween1;\n  };\n}\n\nfunction tweenFunction(id, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    var schedule$$1 = set$1(this, id),\n        tween = schedule$$1.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n) tween1.push(t);\n    }\n\n    schedule$$1.tween = tween1;\n  };\n}\n\nvar transition_tween = function(name, value) {\n  var id = this._id;\n\n  name += \"\";\n\n  if (arguments.length < 2) {\n    var tween = get$1(this.node(), id).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n\n  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n};\n\nfunction tweenValue(transition, name, value) {\n  var id = transition._id;\n\n  transition.each(function() {\n    var schedule$$1 = set$1(this, id);\n    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);\n  });\n\n  return function(node) {\n    return get$1(node, id).value[name];\n  };\n}\n\nvar interpolate = function(a, b) {\n  var c;\n  return (typeof b === \"number\" ? reinterpolate\n      : b instanceof color ? interpolateRgb\n      : (c = color(b)) ? (b = c, interpolateRgb)\n      : interpolateString)(a, b);\n};\n\nfunction attrRemove$1(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS$1(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrConstantNS$1(fullname, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttribute(name);\n    value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction attrFunctionNS$1(fullname, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_attr = function(name, value) {\n  var fullname = namespace(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate;\n  return this.attrTween(name, typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)\n      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + \"\"));\n};\n\nfunction attrTweenNS(fullname, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttributeNS(fullname.space, fullname.local, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nfunction attrTween(name, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttribute(name, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_attrTween = function(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  var fullname = namespace(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n};\n\nfunction delayFunction(id, value) {\n  return function() {\n    init(this, id).delay = +value.apply(this, arguments);\n  };\n}\n\nfunction delayConstant(id, value) {\n  return value = +value, function() {\n    init(this, id).delay = value;\n  };\n}\n\nvar transition_delay = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? delayFunction\n          : delayConstant)(id, value))\n      : get$1(this.node(), id).delay;\n};\n\nfunction durationFunction(id, value) {\n  return function() {\n    set$1(this, id).duration = +value.apply(this, arguments);\n  };\n}\n\nfunction durationConstant(id, value) {\n  return value = +value, function() {\n    set$1(this, id).duration = value;\n  };\n}\n\nvar transition_duration = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? durationFunction\n          : durationConstant)(id, value))\n      : get$1(this.node(), id).duration;\n};\n\nfunction easeConstant(id, value) {\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    set$1(this, id).ease = value;\n  };\n}\n\nvar transition_ease = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each(easeConstant(id, value))\n      : get$1(this.node(), id).ease;\n};\n\nvar transition_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, this._name, this._id);\n};\n\nvar transition_merge = function(transition$$1) {\n  if (transition$$1._id !== this._id) throw new Error;\n\n  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Transition(merges, this._parents, this._name, this._id);\n};\n\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\n\nfunction onFunction(id, name, listener) {\n  var on0, on1, sit = start(name) ? init : set$1;\n  return function() {\n    var schedule$$1 = sit(this, id),\n        on = schedule$$1.on;\n\n    // If this node shared a dispatch with the previous node,\n    // just assign the updated shared dispatch and we’re done!\n    // Otherwise, copy-on-write.\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\n    schedule$$1.on = on1;\n  };\n}\n\nvar transition_on = function(name, listener) {\n  var id = this._id;\n\n  return arguments.length < 2\n      ? get$1(this.node(), id).on.on(name)\n      : this.each(onFunction(id, name, listener));\n};\n\nfunction removeFunction(id) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition) if (+i !== id) return;\n    if (parent) parent.removeChild(this);\n  };\n}\n\nvar transition_remove = function() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n};\n\nvar transition_select = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selector(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, name, id);\n};\n\nvar transition_selectAll = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selectorAll(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {\n          if (child = children[k]) {\n            schedule(child, name, id, k, children, inherit);\n          }\n        }\n        subgroups.push(children);\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, parents, name, id);\n};\n\nvar Selection$1 = selection.prototype.constructor;\n\nvar transition_selection = function() {\n  return new Selection$1(this._groups, this._parents);\n};\n\nfunction styleRemove$1(name, interpolate$$1) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name),\n        value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction styleRemoveEnd(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction styleFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0 = styleValue(this, name),\n        value1 = value(this);\n    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_style = function(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate;\n  return value == null ? this\n          .styleTween(name, styleRemove$1(name, i))\n          .on(\"end.style.\" + name, styleRemoveEnd(name))\n      : this.styleTween(name, typeof value === \"function\"\n          ? styleFunction$1(name, i, tweenValue(this, \"style.\" + name, value))\n          : styleConstant$1(name, i, value + \"\"), priority);\n};\n\nfunction styleTween(name, value, priority) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.style.setProperty(name, i(t), priority);\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_styleTween = function(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n};\n\nfunction textConstant$1(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction$1(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\n\nvar transition_text = function(value) {\n  return this.tween(\"text\", typeof value === \"function\"\n      ? textFunction$1(tweenValue(this, \"text\", value))\n      : textConstant$1(value == null ? \"\" : value + \"\"));\n};\n\nvar transition_transition = function() {\n  var name = this._name,\n      id0 = this._id,\n      id1 = newId();\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit = get$1(node, id0);\n        schedule(node, name, id1, i, group, {\n          time: inherit.time + inherit.delay + inherit.duration,\n          delay: 0,\n          duration: inherit.duration,\n          ease: inherit.ease\n        });\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id1);\n};\n\nvar id = 0;\n\nfunction Transition(groups, parents, name, id) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id;\n}\n\nfunction transition(name) {\n  return selection().transition(name);\n}\n\nfunction newId() {\n  return ++id;\n}\n\nvar selection_prototype = selection.prototype;\n\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: transition_select,\n  selectAll: transition_selectAll,\n  filter: transition_filter,\n  merge: transition_merge,\n  selection: transition_selection,\n  transition: transition_transition,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: transition_on,\n  attr: transition_attr,\n  attrTween: transition_attrTween,\n  style: transition_style,\n  styleTween: transition_styleTween,\n  text: transition_text,\n  remove: transition_remove,\n  tween: transition_tween,\n  delay: transition_delay,\n  duration: transition_duration,\n  ease: transition_ease\n};\n\nfunction linear$1(t) {\n  return +t;\n}\n\nfunction quadIn(t) {\n  return t * t;\n}\n\nfunction quadOut(t) {\n  return t * (2 - t);\n}\n\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\n\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\nvar exponent = 3;\n\nvar polyIn = (function custom(e) {\n  e = +e;\n\n  function polyIn(t) {\n    return Math.pow(t, e);\n  }\n\n  polyIn.exponent = custom;\n\n  return polyIn;\n})(exponent);\n\nvar polyOut = (function custom(e) {\n  e = +e;\n\n  function polyOut(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n\n  polyOut.exponent = custom;\n\n  return polyOut;\n})(exponent);\n\nvar polyInOut = (function custom(e) {\n  e = +e;\n\n  function polyInOut(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n\n  polyInOut.exponent = custom;\n\n  return polyInOut;\n})(exponent);\n\nvar pi = Math.PI;\nvar halfPi = pi / 2;\n\nfunction sinIn(t) {\n  return 1 - Math.cos(t * halfPi);\n}\n\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\n\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\nfunction expIn(t) {\n  return Math.pow(2, 10 * t - 10);\n}\n\nfunction expOut(t) {\n  return 1 - Math.pow(2, -10 * t);\n}\n\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n}\n\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\n\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\n\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\n\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\nvar overshoot = 1.70158;\n\nvar backIn = (function custom(s) {\n  s = +s;\n\n  function backIn(t) {\n    return t * t * ((s + 1) * t - s);\n  }\n\n  backIn.overshoot = custom;\n\n  return backIn;\n})(overshoot);\n\nvar backOut = (function custom(s) {\n  s = +s;\n\n  function backOut(t) {\n    return --t * t * ((s + 1) * t + s) + 1;\n  }\n\n  backOut.overshoot = custom;\n\n  return backOut;\n})(overshoot);\n\nvar backInOut = (function custom(s) {\n  s = +s;\n\n  function backInOut(t) {\n    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n  }\n\n  backInOut.overshoot = custom;\n\n  return backInOut;\n})(overshoot);\n\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\n\nvar elasticIn = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticIn(t) {\n    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n  }\n\n  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n  elasticIn.period = function(p) { return custom(a, p); };\n\n  return elasticIn;\n})(amplitude, period);\n\nvar elasticOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticOut.period = function(p) { return custom(a, p); };\n\n  return elasticOut;\n})(amplitude, period);\n\nvar elasticInOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticInOut(t) {\n    return ((t = t * 2 - 1) < 0\n        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n  }\n\n  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticInOut.period = function(p) { return custom(a, p); };\n\n  return elasticInOut;\n})(amplitude, period);\n\nvar defaultTiming = {\n  time: null, // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\n\nfunction inherit(node, id) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id])) {\n    if (!(node = node.parentNode)) {\n      return defaultTiming.time = now(), defaultTiming;\n    }\n  }\n  return timing;\n}\n\nvar selection_transition = function(name) {\n  var id,\n      timing;\n\n  if (name instanceof Transition) {\n    id = name._id, name = name._name;\n  } else {\n    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        schedule(node, name, id, i, group, timing || inherit(node, id));\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id);\n};\n\nselection.prototype.interrupt = selection_interrupt;\nselection.prototype.transition = selection_transition;\n\nvar root$1 = [null];\n\nvar active = function(node, name) {\n  var schedules = node.__transition,\n      schedule$$1,\n      i;\n\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule$$1 = schedules[i]).state > SCHEDULED && schedule$$1.name === name) {\n        return new Transition([[node]], root$1, name, +i);\n      }\n    }\n  }\n\n  return null;\n};\n\nvar constant$4 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar BrushEvent = function(target, type, selection) {\n  this.target = target;\n  this.type = type;\n  this.selection = selection;\n};\n\nfunction nopropagation$1() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$1 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar MODE_DRAG = {name: \"drag\"};\nvar MODE_SPACE = {name: \"space\"};\nvar MODE_HANDLE = {name: \"handle\"};\nvar MODE_CENTER = {name: \"center\"};\n\nvar X = {\n  name: \"x\",\n  handles: [\"e\", \"w\"].map(type),\n  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },\n  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }\n};\n\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type),\n  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },\n  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }\n};\n\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"].map(type),\n  input: function(xy) { return xy; },\n  output: function(xy) { return xy; }\n};\n\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\n\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\n\nvar signsX = {\n  overlay: +1,\n  selection: +1,\n  n: null,\n  e: +1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: +1,\n  se: +1,\n  sw: -1\n};\n\nvar signsY = {\n  overlay: +1,\n  selection: +1,\n  n: -1,\n  e: null,\n  s: +1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: +1,\n  sw: +1\n};\n\nfunction type(t) {\n  return {type: t};\n}\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent() {\n  var svg = this.ownerSVGElement || this;\n  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];\n}\n\n// Like d3.local, but with the name “__brush” rather than auto-generated.\nfunction local$$1(node) {\n  while (!node.__brush) if (!(node = node.parentNode)) return;\n  return node.__brush;\n}\n\nfunction empty(extent) {\n  return extent[0][0] === extent[1][0]\n      || extent[0][1] === extent[1][1];\n}\n\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\n\nfunction brushX() {\n  return brush$1(X);\n}\n\nfunction brushY() {\n  return brush$1(Y);\n}\n\nvar brush = function() {\n  return brush$1(XY);\n};\n\nfunction brush$1(dim) {\n  var extent = defaultExtent,\n      filter = defaultFilter,\n      listeners = dispatch(brush, \"start\", \"brush\", \"end\"),\n      handleSize = 6,\n      touchending;\n\n  function brush(group) {\n    var overlay = group\n        .property(\"__brush\", initialize)\n      .selectAll(\".overlay\")\n      .data([type(\"overlay\")]);\n\n    overlay.enter().append(\"rect\")\n        .attr(\"class\", \"overlay\")\n        .attr(\"pointer-events\", \"all\")\n        .attr(\"cursor\", cursors.overlay)\n      .merge(overlay)\n        .each(function() {\n          var extent = local$$1(this).extent;\n          select(this)\n              .attr(\"x\", extent[0][0])\n              .attr(\"y\", extent[0][1])\n              .attr(\"width\", extent[1][0] - extent[0][0])\n              .attr(\"height\", extent[1][1] - extent[0][1]);\n        });\n\n    group.selectAll(\".selection\")\n      .data([type(\"selection\")])\n      .enter().append(\"rect\")\n        .attr(\"class\", \"selection\")\n        .attr(\"cursor\", cursors.selection)\n        .attr(\"fill\", \"#777\")\n        .attr(\"fill-opacity\", 0.3)\n        .attr(\"stroke\", \"#fff\")\n        .attr(\"shape-rendering\", \"crispEdges\");\n\n    var handle = group.selectAll(\".handle\")\n      .data(dim.handles, function(d) { return d.type; });\n\n    handle.exit().remove();\n\n    handle.enter().append(\"rect\")\n        .attr(\"class\", function(d) { return \"handle handle--\" + d.type; })\n        .attr(\"cursor\", function(d) { return cursors[d.type]; });\n\n    group\n        .each(redraw)\n        .attr(\"fill\", \"none\")\n        .attr(\"pointer-events\", \"all\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n        .on(\"mousedown.brush touchstart.brush\", started);\n  }\n\n  brush.move = function(group, selection) {\n    if (group.selection) {\n      group\n          .on(\"start.brush\", function() { emitter(this, arguments).beforestart().start(); })\n          .on(\"interrupt.brush end.brush\", function() { emitter(this, arguments).end(); })\n          .tween(\"brush\", function() {\n            var that = this,\n                state = that.__brush,\n                emit = emitter(that, arguments),\n                selection0 = state.selection,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(this, arguments) : selection, state.extent),\n                i = interpolateValue(selection0, selection1);\n\n            function tween(t) {\n              state.selection = t === 1 && empty(selection1) ? null : i(t);\n              redraw.call(that);\n              emit.brush();\n            }\n\n            return selection0 && selection1 ? tween : tween(1);\n          });\n    } else {\n      group\n          .each(function() {\n            var that = this,\n                args = arguments,\n                state = that.__brush,\n                selection1 = dim.input(typeof selection === \"function\" ? selection.apply(that, args) : selection, state.extent),\n                emit = emitter(that, args).beforestart();\n\n            interrupt(that);\n            state.selection = selection1 == null || empty(selection1) ? null : selection1;\n            redraw.call(that);\n            emit.start().brush().end();\n          });\n    }\n  };\n\n  function redraw() {\n    var group = select(this),\n        selection = local$$1(this).selection;\n\n    if (selection) {\n      group.selectAll(\".selection\")\n          .style(\"display\", null)\n          .attr(\"x\", selection[0][0])\n          .attr(\"y\", selection[0][1])\n          .attr(\"width\", selection[1][0] - selection[0][0])\n          .attr(\"height\", selection[1][1] - selection[0][1]);\n\n      group.selectAll(\".handle\")\n          .style(\"display\", null)\n          .attr(\"x\", function(d) { return d.type[d.type.length - 1] === \"e\" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })\n          .attr(\"y\", function(d) { return d.type[0] === \"s\" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })\n          .attr(\"width\", function(d) { return d.type === \"n\" || d.type === \"s\" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })\n          .attr(\"height\", function(d) { return d.type === \"e\" || d.type === \"w\" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });\n    }\n\n    else {\n      group.selectAll(\".selection,.handle\")\n          .style(\"display\", \"none\")\n          .attr(\"x\", null)\n          .attr(\"y\", null)\n          .attr(\"width\", null)\n          .attr(\"height\", null);\n    }\n  }\n\n  function emitter(that, args) {\n    return that.__brush.emitter || new Emitter(that, args);\n  }\n\n  function Emitter(that, args) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n  }\n\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1) this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function() {\n      if (this.starting) this.starting = false, this.emit(\"start\");\n      return this;\n    },\n    brush: function() {\n      this.emit(\"brush\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) delete this.state.emitter, this.emit(\"end\");\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function started() {\n    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$1(); }\n    else if (touchending) return;\n    if (!filter.apply(this, arguments)) return;\n\n    var that = this,\n        type = exports.event.target.__data__.type,\n        mode = (exports.event.metaKey ? type = \"overlay\" : type) === \"selection\" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),\n        signX = dim === Y ? null : signsX[type],\n        signY = dim === X ? null : signsY[type],\n        state = local$$1(that),\n        extent = state.extent,\n        selection = state.selection,\n        W = extent[0][0], w0, w1,\n        N = extent[0][1], n0, n1,\n        E = extent[1][0], e0, e1,\n        S = extent[1][1], s0, s1,\n        dx,\n        dy,\n        moving,\n        shifting = signX && signY && exports.event.shiftKey,\n        lockX,\n        lockY,\n        point0 = mouse(that),\n        point = point0,\n        emit = emitter(that, arguments).beforestart();\n\n    if (type === \"overlay\") {\n      state.selection = selection = [\n        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],\n        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]\n      ];\n    } else {\n      w0 = selection[0][0];\n      n0 = selection[0][1];\n      e0 = selection[1][0];\n      s0 = selection[1][1];\n    }\n\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n\n    var group = select(that)\n        .attr(\"pointer-events\", \"none\");\n\n    var overlay = group.selectAll(\".overlay\")\n        .attr(\"cursor\", cursors[type]);\n\n    if (exports.event.touches) {\n      group\n          .on(\"touchmove.brush\", moved, true)\n          .on(\"touchend.brush touchcancel.brush\", ended, true);\n    } else {\n      var view = select(exports.event.view)\n          .on(\"keydown.brush\", keydowned, true)\n          .on(\"keyup.brush\", keyupped, true)\n          .on(\"mousemove.brush\", moved, true)\n          .on(\"mouseup.brush\", ended, true);\n\n      dragDisable(exports.event.view);\n    }\n\n    nopropagation$1();\n    interrupt(that);\n    redraw.call(that);\n    emit.start();\n\n    function moved() {\n      var point1 = mouse(that);\n      if (shifting && !lockX && !lockY) {\n        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;\n        else lockX = true;\n      }\n      point = point1;\n      moving = true;\n      noevent$1();\n      move();\n    }\n\n    function move() {\n      var t;\n\n      dx = point[0] - point0[0];\n      dy = point[1] - point0[1];\n\n      switch (mode) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;\n          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;\n          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));\n          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));\n          break;\n        }\n      }\n\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]);\n      }\n\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]);\n      }\n\n      if (state.selection) selection = state.selection; // May be set by brush.move!\n      if (lockX) w1 = selection[0][0], e1 = selection[1][0];\n      if (lockY) n1 = selection[0][1], s1 = selection[1][1];\n\n      if (selection[0][0] !== w1\n          || selection[0][1] !== n1\n          || selection[1][0] !== e1\n          || selection[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush();\n      }\n    }\n\n    function ended() {\n      nopropagation$1();\n      if (exports.event.touches) {\n        if (exports.event.touches.length) return;\n        if (touchending) clearTimeout(touchending);\n        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n        group.on(\"touchmove.brush touchend.brush touchcancel.brush\", null);\n      } else {\n        yesdrag(exports.event.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!\n      if (empty(selection)) state.selection = null, redraw.call(that);\n      emit.end();\n    }\n\n    function keydowned() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          shifting = signX && signY;\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_HANDLE) {\n            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode = MODE_CENTER;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE; takes priority over ALT\n          if (mode === MODE_HANDLE || mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;\n            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;\n            mode = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$1();\n    }\n\n    function keyupped() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move();\n          }\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n            mode = MODE_HANDLE;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE\n          if (mode === MODE_SPACE) {\n            if (exports.event.altKey) {\n              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode = MODE_CENTER;\n            } else {\n              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n              mode = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type]);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$1();\n    }\n  }\n\n  function initialize() {\n    var state = this.__brush || {selection: null};\n    state.extent = extent.apply(this, arguments);\n    state.dim = dim;\n    return state;\n  }\n\n  brush.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;\n  };\n\n  brush.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$4(!!_), brush) : filter;\n  };\n\n  brush.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush) : handleSize;\n  };\n\n  brush.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush : value;\n  };\n\n  return brush;\n}\n\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi$1 = Math.PI;\nvar halfPi$1 = pi$1 / 2;\nvar tau$1 = pi$1 * 2;\nvar max$1 = Math.max;\n\nfunction compareValue(compare) {\n  return function(a, b) {\n    return compare(\n      a.source.value + a.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\n\nvar chord = function() {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = [],\n        groupIndex = sequence(n),\n        subgroupIndex = [],\n        chords = [],\n        groups = chords.groups = new Array(n),\n        subgroups = new Array(n * n),\n        k,\n        x,\n        x0,\n        dx,\n        i,\n        j;\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(sequence(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) groupIndex.sort(function(a, b) {\n      return sortGroups(groupSums[a], groupSums[b]);\n    });\n\n    // Sort subgroups…\n    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {\n      d.sort(function(a, b) {\n        return sortSubgroups(matrix[i][a], matrix[i][b]);\n      });\n    });\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified?\n    // TODO Allow padding to be specified as percentage?\n    k = max$1(0, tau$1 - padAngle * n) / k;\n    dx = k ? padAngle : tau$1 / n;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[di][j],\n            v = matrix[di][dj],\n            a0 = x,\n            a1 = x += v * k;\n        subgroups[dj * n + di] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups[di] = {\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: groupSums[di]\n      };\n      x += dx;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[j * n + i],\n            target = subgroups[i * n + j];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function(_) {\n    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n};\n\nvar slice$2 = Array.prototype.slice;\n\nvar constant$5 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar pi$2 = Math.PI;\nvar tau$2 = 2 * pi$2;\nvar epsilon$1 = 1e-6;\nvar tauEpsilon = tau$2 - epsilon$1;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon$1)) {}\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon$1) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau$2 + tau$2;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon$1) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi$2)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nfunction defaultSource(d) {\n  return d.source;\n}\n\nfunction defaultTarget(d) {\n  return d.target;\n}\n\nfunction defaultRadius(d) {\n  return d.radius;\n}\n\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\n\nvar ribbon = function() {\n  var source = defaultSource,\n      target = defaultTarget,\n      radius = defaultRadius,\n      startAngle = defaultStartAngle,\n      endAngle = defaultEndAngle,\n      context = null;\n\n  function ribbon() {\n    var buffer,\n        argv = slice$2.call(arguments),\n        s = source.apply(this, argv),\n        t = target.apply(this, argv),\n        sr = +radius.apply(this, (argv[0] = s, argv)),\n        sa0 = startAngle.apply(this, argv) - halfPi$1,\n        sa1 = endAngle.apply(this, argv) - halfPi$1,\n        sx0 = sr * cos(sa0),\n        sy0 = sr * sin(sa0),\n        tr = +radius.apply(this, (argv[0] = t, argv)),\n        ta0 = startAngle.apply(this, argv) - halfPi$1,\n        ta1 = endAngle.apply(this, argv) - halfPi$1;\n\n    if (!context) context = buffer = path();\n\n    context.moveTo(sx0, sy0);\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?\n      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n      context.arc(0, 0, tr, ta0, ta1);\n    }\n    context.quadraticCurveTo(0, 0, sx0, sy0);\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  ribbon.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : radius;\n  };\n\n  ribbon.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : startAngle;\n  };\n\n  ribbon.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : endAngle;\n  };\n\n  ribbon.source = function(_) {\n    return arguments.length ? (source = _, ribbon) : source;\n  };\n\n  ribbon.target = function(_) {\n    return arguments.length ? (target = _, ribbon) : target;\n  };\n\n  ribbon.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;\n  };\n\n  return ribbon;\n};\n\nvar prefix = \"$\";\n\nfunction Map() {}\n\nMap.prototype = map$1.prototype = {\n  constructor: Map,\n  has: function(key) {\n    return (prefix + key) in this;\n  },\n  get: function(key) {\n    return this[prefix + key];\n  },\n  set: function(key, value) {\n    this[prefix + key] = value;\n    return this;\n  },\n  remove: function(key) {\n    var property = prefix + key;\n    return property in this && delete this[property];\n  },\n  clear: function() {\n    for (var property in this) if (property[0] === prefix) delete this[property];\n  },\n  keys: function() {\n    var keys = [];\n    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n    return entries;\n  },\n  size: function() {\n    var size = 0;\n    for (var property in this) if (property[0] === prefix) ++size;\n    return size;\n  },\n  empty: function() {\n    for (var property in this) if (property[0] === prefix) return false;\n    return true;\n  },\n  each: function(f) {\n    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n  }\n};\n\nfunction map$1(object, f) {\n  var map = new Map;\n\n  // Copy constructor.\n  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n  // Index array by numeric index or specified key function.\n  else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n\n    if (f == null) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f(o = object[i], i, object), o);\n  }\n\n  // Convert object to map.\n  else if (object) for (var key in object) map.set(key, object[key]);\n\n  return map;\n}\n\nvar nest = function() {\n  var keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup,\n      nest;\n\n  function apply(array, depth, createResult, setResult) {\n    if (depth >= keys.length) {\n      if (sortValues != null) array.sort(sortValues);\n      return rollup != null ? rollup(array) : array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = map$1(),\n        values,\n        result = createResult();\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n        values.push(value);\n      } else {\n        valuesByKey.set(keyValue, [value]);\n      }\n    }\n\n    valuesByKey.each(function(values, key) {\n      setResult(result, key, apply(values, depth, createResult, setResult));\n    });\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array, sortKey = sortKeys[depth - 1];\n    if (rollup != null && depth >= keys.length) array = map.entries();\n    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n  }\n\n  return nest = {\n    object: function(array) { return apply(array, 0, createObject, setObject); },\n    map: function(array) { return apply(array, 0, createMap, setMap); },\n    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n    key: function(d) { keys.push(d); return nest; },\n    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n    sortValues: function(order) { sortValues = order; return nest; },\n    rollup: function(f) { rollup = f; return nest; }\n  };\n};\n\nfunction createObject() {\n  return {};\n}\n\nfunction setObject(object, key, value) {\n  object[key] = value;\n}\n\nfunction createMap() {\n  return map$1();\n}\n\nfunction setMap(map, key, value) {\n  map.set(key, value);\n}\n\nfunction Set() {}\n\nvar proto = map$1.prototype;\n\nSet.prototype = set$2.prototype = {\n  constructor: Set,\n  has: proto.has,\n  add: function(value) {\n    value += \"\";\n    this[prefix + value] = value;\n    return this;\n  },\n  remove: proto.remove,\n  clear: proto.clear,\n  values: proto.keys,\n  size: proto.size,\n  empty: proto.empty,\n  each: proto.each\n};\n\nfunction set$2(object, f) {\n  var set = new Set;\n\n  // Copy constructor.\n  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n  // Otherwise, assume it’s an array.\n  else if (object) {\n    var i = -1, n = object.length;\n    if (f == null) while (++i < n) set.add(object[i]);\n    else while (++i < n) set.add(f(object[i], i, object));\n  }\n\n  return set;\n}\n\nvar keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\n\nvar values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\n\nvar entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nvar dsv = function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I, c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n};\n\nvar csv = dsv(\",\");\n\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatRows = csv.formatRows;\n\nvar tsv = dsv(\"\\t\");\n\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatRows = tsv.formatRows;\n\nvar center$1 = function(x, y) {\n  var nodes;\n\n  if (x == null) x = 0;\n  if (y == null) y = 0;\n\n  function force() {\n    var i,\n        n = nodes.length,\n        node,\n        sx = 0,\n        sy = 0;\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n\n    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = +_, force) : x;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = +_, force) : y;\n  };\n\n  return force;\n};\n\nvar constant$6 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar jiggle = function() {\n  return (Math.random() - 0.5) * 1e-6;\n};\n\nvar tree_add = function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n};\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nfunction addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n\nvar tree_cover = function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1) {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n        break;\n      }\n      case 2: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n        break;\n      }\n      case 3: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the quadtree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n};\n\nvar tree_data = function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n};\n\nvar tree_extent = function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n};\n\nvar Quad = function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n};\n\nvar tree_find = function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant can’t contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n};\n\nvar tree_remove = function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n};\n\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n\nvar tree_root = function() {\n  return this._root;\n};\n\nvar tree_size = function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n};\n\nvar tree_visit = function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n};\n\nvar tree_visitAfter = function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n};\n\nfunction defaultX(d) {\n  return d[0];\n}\n\nvar tree_x = function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n};\n\nfunction defaultY(d) {\n  return d[1];\n}\n\nvar tree_y = function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n};\n\nfunction quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n\nfunction x(d) {\n  return d.x + d.vx;\n}\n\nfunction y(d) {\n  return d.y + d.vy;\n}\n\nvar collide = function(radius) {\n  var nodes,\n      radii,\n      strength = 1,\n      iterations = 1;\n\n  if (typeof radius !== \"function\") radius = constant$6(radius == null ? 1 : +radius);\n\n  function force() {\n    var i, n = nodes.length,\n        tree,\n        node,\n        xi,\n        yi,\n        ri,\n        ri2;\n\n    for (var k = 0; k < iterations; ++k) {\n      tree = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree.visit(apply);\n      }\n    }\n\n    function apply(quad, x0, y0, x1, y1) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x = xi - data.x - data.vx,\n              y = yi - data.y - data.vy,\n              l = x * x + y * y;\n          if (l < r * r) {\n            if (x === 0) x = jiggle(), l += x * x;\n            if (y === 0) y = jiggle(), l += y * y;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y *= l) * r;\n            data.vx -= x * (r = 1 - r);\n            data.vy -= y * r;\n          }\n        }\n        return;\n      }\n      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n    }\n  }\n\n  function prepare(quad) {\n    if (quad.data) return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n\n  force.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : radius;\n  };\n\n  return force;\n};\n\nfunction index(d) {\n  return d.index;\n}\n\nfunction find(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node) throw new Error(\"missing: \" + nodeId);\n  return node;\n}\n\nvar link = function(links) {\n  var id = index,\n      strength = defaultStrength,\n      strengths,\n      distance = constant$6(30),\n      distances,\n      nodes,\n      count,\n      bias,\n      iterations = 1;\n\n  if (links == null) links = [];\n\n  function defaultStrength(link) {\n    return 1 / Math.min(count[link.source.index], count[link.target.index]);\n  }\n\n  function force(alpha) {\n    for (var k = 0, n = links.length; k < iterations; ++k) {\n      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n        link = links[i], source = link.source, target = link.target;\n        x = target.x + target.vx - source.x - source.vx || jiggle();\n        y = target.y + target.vy - source.y - source.vy || jiggle();\n        l = Math.sqrt(x * x + y * y);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x *= l, y *= l;\n        target.vx -= x * (b = bias[i]);\n        target.vy -= y * b;\n        source.vx += x * (b = 1 - b);\n        source.vy += y * b;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n\n    var i,\n        n = nodes.length,\n        m = links.length,\n        nodeById = map$1(nodes, id),\n        link;\n\n    for (i = 0, count = new Array(n); i < m; ++i) {\n      link = links[i], link.index = i;\n      if (typeof link.source !== \"object\") link.source = find(nodeById, link.source);\n      if (typeof link.target !== \"object\") link.target = find(nodeById, link.target);\n      count[link.source.index] = (count[link.source.index] || 0) + 1;\n      count[link.target.index] = (count[link.target.index] || 0) + 1;\n    }\n\n    for (i = 0, bias = new Array(m); i < m; ++i) {\n      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n    }\n\n    strengths = new Array(m), initializeStrength();\n    distances = new Array(m), initializeDistance();\n  }\n\n  function initializeStrength() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n\n  function initializeDistance() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n\n  force.id = function(_) {\n    return arguments.length ? (id = _, force) : id;\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initializeStrength(), force) : strength;\n  };\n\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant$6(+_), initializeDistance(), force) : distance;\n  };\n\n  return force;\n};\n\nfunction x$1(d) {\n  return d.x;\n}\n\nfunction y$1(d) {\n  return d.y;\n}\n\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nvar simulation = function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = map$1(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i, n = nodes.length, node;\n\n    alpha += (alphaTarget - alpha) * alphaDecay;\n\n    forces.each(function(force) {\n      force(alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (node.fx == null) node.x += node.vx *= velocityDecay;\n      else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= velocityDecay;\n      else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n};\n\nvar manyBody = function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant$6(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = q.value)) {\n          strength += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / strength;\n      quad.y = y / strength;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n};\n\nvar x$2 = function(x) {\n  var strength = constant$6(0.1),\n      nodes,\n      strengths,\n      xz;\n\n  if (typeof x !== \"function\") x = constant$6(x == null ? 0 : +x);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : x;\n  };\n\n  return force;\n};\n\nvar y$2 = function(y) {\n  var strength = constant$6(0.1),\n      nodes,\n      strengths,\n      yz;\n\n  if (typeof y !== \"function\") y = constant$6(y == null ? 0 : +y);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : y;\n  };\n\n  return force;\n};\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nvar formatDecimal = function(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n};\n\nvar exponent$1 = function(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n};\n\nvar formatGroup = function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n};\n\nvar formatNumerals = function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n};\n\nvar formatDefault = function(x, p) {\n  x = x.toPrecision(p);\n\n  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (x[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      case \"e\": break out;\n      default: if (i0 > 0) i0 = 0; break;\n    }\n  }\n\n  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n};\n\nvar prefixExponent;\n\nvar formatPrefixAuto = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n};\n\nvar formatRounded = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n};\n\nvar formatTypes = {\n  \"\": formatDefault,\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\n// [[fill]align][sign][symbol][0][width][,][.precision][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\nfunction formatSpecifier(specifier) {\n  return new FormatSpecifier(specifier);\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nfunction FormatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n  var match,\n      fill = match[1] || \" \",\n      align = match[2] || \">\",\n      sign = match[3] || \"-\",\n      symbol = match[4] || \"\",\n      zero = !!match[5],\n      width = match[6] && +match[6],\n      comma = !!match[7],\n      precision = match[8] && +match[8].slice(1),\n      type = match[9] || \"\";\n\n  // The \"n\" type is an alias for \",g\".\n  if (type === \"n\") comma = true, type = \"g\";\n\n  // Map invalid types to the default format.\n  else if (!formatTypes[type]) type = \"\";\n\n  // If zero fill is specified, padding goes after sign and before digits.\n  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n  this.fill = fill;\n  this.align = align;\n  this.sign = sign;\n  this.symbol = symbol;\n  this.zero = zero;\n  this.width = width;\n  this.comma = comma;\n  this.precision = precision;\n  this.type = type;\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + this.type;\n};\n\nvar identity$3 = function(x) {\n  return x;\n};\n\nvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nvar formatLocale = function(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,\n      currency = locale.currency,\n      decimal = locale.decimal,\n      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,\n      percent = locale.percent || \"%\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        type = specifier.type;\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = !type || /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? (type ? 6 : 12)\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = formatType(Math.abs(value), precision);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n};\n\nvar locale$1;\n\n\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nfunction defaultLocale(definition) {\n  locale$1 = formatLocale(definition);\n  exports.format = locale$1.format;\n  exports.formatPrefix = locale$1.formatPrefix;\n  return locale$1;\n}\n\nvar precisionFixed = function(step) {\n  return Math.max(0, -exponent$1(Math.abs(step)));\n};\n\nvar precisionPrefix = function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));\n};\n\nvar precisionRound = function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;\n};\n\n// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nvar adder = function() {\n  return new Adder;\n};\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add$1(temp, y, this.t);\n    add$1(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add$1(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n\nvar epsilon$2 = 1e-6;\nvar epsilon2$1 = 1e-12;\nvar pi$3 = Math.PI;\nvar halfPi$2 = pi$3 / 2;\nvar quarterPi = pi$3 / 4;\nvar tau$3 = pi$3 * 2;\n\nvar degrees$1 = 180 / pi$3;\nvar radians = pi$3 / 180;\n\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos$1 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\n\nvar log = Math.log;\nvar pow = Math.pow;\nvar sin$1 = Math.sin;\nvar sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nvar sqrt = Math.sqrt;\nvar tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);\n}\n\nfunction haversin(x) {\n  return (x = sin$1(x / 2)) * x;\n}\n\nfunction noop$1() {}\n\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nvar geoStream = function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n};\n\nvar areaRingSum = adder();\n\nvar areaSum = adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\n\nvar areaStream = {\n  point: noop$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop$1;\n  },\n  sphere: function() {\n    areaSum.add(tau$3);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnoli’s\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos$1(phi),\n      sinPhi = sin$1(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos$1(adLambda),\n      v = k * sdLambda * sin$1(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nvar area = function(object) {\n  areaSum.reset();\n  geoStream(object, areaStream);\n  return areaSum * 2;\n};\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);\n  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\nvar lambda0$1;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda00$1;\nvar phi00$1;\nvar p0;\nvar deltaSum = adder();\nvar ranges;\nvar range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon$2) phi1 = 90;\n    else if (deltaSum < -epsilon$2) phi0 = -90;\n    range[0] = lambda0$1, range[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign$$1 = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees$1 * sign$$1,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = inflection[1] * degrees$1;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = -inflection[1] * degrees$1;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0$1) {\n        if (lambda < lambda0$1) lambda0$1 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0$1, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00$1 = lambda, phi00$1 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00$1, phi00$1);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);\n  range[0] = lambda0$1, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nvar bounds = function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n  ranges = [];\n  geoStream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0$1 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0$1, phi0], [lambda1, phi1]];\n};\n\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda00$2;\nvar phi00$2;\nvar x0;\nvar y0;\nvar z0; // previous point\n\nvar centroidStream = {\n  sphere: noop$1,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00$2, phi00$2);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00$2 = lambda, phi00$2 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nvar centroid = function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  geoStream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2$1) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2$1) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];\n};\n\nvar constant$7 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar compose = function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n};\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau$3) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos$1(deltaPhi),\n      sinDeltaPhi = sin$1(deltaPhi),\n      cosDeltaGamma = cos$1(deltaGamma),\n      sinDeltaGamma = sin$1(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nvar rotation = function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  };\n\n  return forward;\n};\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos$1(radius),\n      sinRadius = sin$1(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau$3;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;\n}\n\nvar circle = function() {\n  var center = constant$7([0, 0]),\n      radius = constant$7(90),\n      precision = constant$7(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees$1, x[1] *= degrees$1;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant$7([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$7(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant$7(+_), circle) : precision;\n  };\n\n  return circle;\n};\n\nvar clipBuffer = function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop$1,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n};\n\nvar clipLine = function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n};\n\nvar pointEqual = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;\n};\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nvar clipPolygon = function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link$1(subject);\n  link$1(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n};\n\nfunction link$1(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nfunction clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nvar extent$1 = function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n};\n\nvar sum$1 = adder();\n\nvar polygonContains = function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin$1(lambda), -cos$1(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum$1.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin$1(phi0),\n        cosPhi0 = cos$1(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin$1(phi1),\n          cosPhi1 = cos$1(phi1),\n          delta = lambda1 - lambda0,\n          sign$$1 = delta >= 0 ? 1 : -1,\n          absDelta = sign$$1 * delta,\n          antimeridian = absDelta > pi$3,\n          k = sinPhi0 * sinPhi1;\n\n      sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));\n      angle += antimeridian ? delta + sign$$1 * tau$3 : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);\n};\n\nvar lengthSum = adder();\nvar lambda0$2;\nvar sinPhi0$1;\nvar cosPhi0$1;\n\nvar lengthStream = {\n  sphere: noop$1,\n  point: noop$1,\n  lineStart: lengthLineStart,\n  lineEnd: noop$1,\n  polygonStart: noop$1,\n  polygonEnd: noop$1\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop$1;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin$1(phi),\n      cosPhi = cos$1(phi),\n      delta = abs(lambda - lambda0$2),\n      cosDelta = cos$1(delta),\n      sinDelta = sin$1(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n}\n\nvar length$1 = function(object) {\n  lengthSum.reset();\n  geoStream(object, lengthStream);\n  return +lengthSum;\n};\n\nvar coordinates = [null, null];\nvar object$1 = {type: \"LineString\", coordinates: coordinates};\n\nvar distance = function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length$1(object$1);\n};\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon$2;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nvar contains = function(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n};\n\nfunction graticuleX(y0, y1, dy) {\n  var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nfunction graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$2; }).map(x))\n        .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$2; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])\n      .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);\n}\n\nfunction graticule10() {\n  return graticule()();\n}\n\nvar interpolate$1 = function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos$1(y0),\n      sy0 = sin$1(y0),\n      cy1 = cos$1(y1),\n      sy1 = sin$1(y1),\n      kx0 = cy0 * cos$1(x0),\n      ky0 = cy0 * sin$1(x0),\n      kx1 = cy1 * cos$1(x1),\n      ky1 = cy1 * sin$1(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin$1(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin$1(t *= d) / k,\n        A = sin$1(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees$1,\n      atan2(z, sqrt(x * x + y * y)) * degrees$1\n    ];\n  } : function() {\n    return [x0 * degrees$1, y0 * degrees$1];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n};\n\nvar identity$4 = function(x) {\n  return x;\n};\n\nvar areaSum$1 = adder();\nvar areaRingSum$1 = adder();\nvar x00;\nvar y00;\nvar x0$1;\nvar y0$1;\n\nvar areaStream$1 = {\n  point: noop$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: function() {\n    areaStream$1.lineStart = areaRingStart$1;\n    areaStream$1.lineEnd = areaRingEnd$1;\n  },\n  polygonEnd: function() {\n    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;\n    areaSum$1.add(abs(areaRingSum$1));\n    areaRingSum$1.reset();\n  },\n  result: function() {\n    var area = areaSum$1 / 2;\n    areaSum$1.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart$1() {\n  areaStream$1.point = areaPointFirst$1;\n}\n\nfunction areaPointFirst$1(x, y) {\n  areaStream$1.point = areaPoint$1;\n  x00 = x0$1 = x, y00 = y0$1 = y;\n}\n\nfunction areaPoint$1(x, y) {\n  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n  x0$1 = x, y0$1 = y;\n}\n\nfunction areaRingEnd$1() {\n  areaPoint$1(x00, y00);\n}\n\nvar x0$2 = Infinity;\nvar y0$2 = x0$2;\nvar x1 = -x0$2;\nvar y1 = x1;\n\nvar boundsStream$1 = {\n  point: boundsPoint$1,\n  lineStart: noop$1,\n  lineEnd: noop$1,\n  polygonStart: noop$1,\n  polygonEnd: noop$1,\n  result: function() {\n    var bounds = [[x0$2, y0$2], [x1, y1]];\n    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint$1(x, y) {\n  if (x < x0$2) x0$2 = x;\n  if (x > x1) x1 = x;\n  if (y < y0$2) y0$2 = y;\n  if (y > y1) y1 = y;\n}\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0$1 = 0;\nvar Y0$1 = 0;\nvar Z0$1 = 0;\nvar X1$1 = 0;\nvar Y1$1 = 0;\nvar Z1$1 = 0;\nvar X2$1 = 0;\nvar Y2$1 = 0;\nvar Z2$1 = 0;\nvar x00$1;\nvar y00$1;\nvar x0$3;\nvar y0$3;\n\nvar centroidStream$1 = {\n  point: centroidPoint$1,\n  lineStart: centroidLineStart$1,\n  lineEnd: centroidLineEnd$1,\n  polygonStart: function() {\n    centroidStream$1.lineStart = centroidRingStart$1;\n    centroidStream$1.lineEnd = centroidRingEnd$1;\n  },\n  polygonEnd: function() {\n    centroidStream$1.point = centroidPoint$1;\n    centroidStream$1.lineStart = centroidLineStart$1;\n    centroidStream$1.lineEnd = centroidLineEnd$1;\n  },\n  result: function() {\n    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n        : [NaN, NaN];\n    X0$1 = Y0$1 = Z0$1 =\n    X1$1 = Y1$1 = Z1$1 =\n    X2$1 = Y2$1 = Z2$1 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint$1(x, y) {\n  X0$1 += x;\n  Y0$1 += y;\n  ++Z0$1;\n}\n\nfunction centroidLineStart$1() {\n  centroidStream$1.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream$1.point = centroidPointLine;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidLineEnd$1() {\n  centroidStream$1.point = centroidPoint$1;\n}\n\nfunction centroidRingStart$1() {\n  centroidStream$1.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd$1() {\n  centroidPointRing(x00$1, y00$1);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream$1.point = centroidPointRing;\n  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0$3,\n      dy = y - y0$3,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n\n  z = y0$3 * x - x0$3 * y;\n  X2$1 += z * (x0$3 + x);\n  Y2$1 += z * (y0$3 + y);\n  Z2$1 += z * 3;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau$3);\n        break;\n      }\n    }\n  },\n  result: noop$1\n};\n\nvar lengthSum$1 = adder();\nvar lengthRing;\nvar x00$2;\nvar y00$2;\nvar x0$4;\nvar y0$4;\n\nvar lengthStream$1 = {\n  point: noop$1,\n  lineStart: function() {\n    lengthStream$1.point = lengthPointFirst$1;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint$1(x00$2, y00$2);\n    lengthStream$1.point = noop$1;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum$1;\n    lengthSum$1.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst$1(x, y) {\n  lengthStream$1.point = lengthPoint$1;\n  x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n}\n\nfunction lengthPoint$1(x, y) {\n  x0$4 -= x, y0$4 -= y;\n  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n  x0$4 = x, y0$4 = y;\n}\n\nfunction PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle$1(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle$1(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle$1(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n\nvar index$1 = function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      geoStream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    geoStream(object, projectionStream(areaStream$1));\n    return areaStream$1.result();\n  };\n\n  path.measure = function(object) {\n    geoStream(object, projectionStream(lengthStream$1));\n    return lengthStream$1.result();\n  };\n\n  path.bounds = function(object) {\n    geoStream(object, projectionStream(boundsStream$1));\n    return boundsStream$1.result();\n  };\n\n  path.centroid = function(object) {\n    geoStream(object, projectionStream(centroidStream$1));\n    return centroidStream$1.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n};\n\nvar clip = function(pointVisible, clipLine, interpolate, start) {\n  return function(rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n};\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);\n}\n\nvar clipAntimeridian = clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi$3, -halfPi$2]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi$3 : -pi$3,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi$3) < epsilon$2) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi$3) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon$2\n      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)\n          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi$2;\n    stream.point(-pi$3, phi);\n    stream.point(0, phi);\n    stream.point(pi$3, phi);\n    stream.point(pi$3, 0);\n    stream.point(pi$3, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi$3, -phi);\n    stream.point(-pi$3, 0);\n    stream.point(-pi$3, phi);\n  } else if (abs(from[0] - to[0]) > epsilon$2) {\n    var lambda = from[0] < to[0] ? pi$3 : -pi$3;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\nvar clipCircle = function(radius, delta) {\n  var cr = cos$1(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos$1(lambda) * cos$1(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon$2;\n            point1[1] += epsilon$2;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi$3) < epsilon$2,\n        meridian = polar || delta < epsilon$2;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi$3 - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);\n};\n\nvar transform = function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n};\n\nfunction transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n\nfunction fitExtent(projection, extent, object) {\n  var w = extent[1][0] - extent[0][0],\n      h = extent[1][1] - extent[0][1],\n      clip = projection.clipExtent && projection.clipExtent();\n\n  projection\n      .scale(150)\n      .translate([0, 0]);\n\n  if (clip != null) projection.clipExtent(null);\n\n  geoStream(object, projection.stream(boundsStream$1));\n\n  var b = boundsStream$1.result(),\n      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n  if (clip != null) projection.clipExtent(clip);\n\n  return projection\n      .scale(k * 150)\n      .translate([x, y]);\n}\n\nfunction fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nvar maxDepth = 16;\nvar cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)\n\nvar resample = function(project, delta2) {\n  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n};\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample$1(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      dx, dy, lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n      theta = null, preclip = clipAntimeridian, // clip angle\n      x0 = null, y0, x1, y1, postclip = identity$4, // clip extent\n      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    point = projectRotate(point[0] * radians, point[1] * radians);\n    return [point[0] * k + dx, dy - point[1] * k];\n  }\n\n  function invert(point) {\n    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n    return point && [point[0] * degrees$1, point[1] * degrees$1];\n  }\n\n  function projectTransform(x, y) {\n    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  function recenter() {\n    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n    var center = project(lambda, phi);\n    dx = x - center[0] * k;\n    dy = y + center[1] * k;\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n\nfunction conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi$3 / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];\n  };\n\n  return p;\n}\n\nfunction cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos$1(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n\nfunction conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin$1(y)) / n;\n    return [r * sin$1(x *= n), r0 - r * cos$1(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nvar conicEqualArea = function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n};\n\nvar albers = function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n};\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960×500. The projection also works quite well at 960×600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nvar albersUsa = function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n};\n\nfunction azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos$1(x),\n        cy = cos$1(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin$1(x),\n      k * sin$1(y)\n    ];\n  }\n}\n\nfunction azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin$1(c),\n        cc = cos$1(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nvar azimuthalEqualArea = function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n};\n\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin$1(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nvar azimuthalEquidistant = function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n};\n\nfunction mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi$2 + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi$2];\n};\n\nvar mercator = function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau$3);\n};\n\nfunction mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi$3 * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n\nfunction tany(y) {\n  return tan((halfPi$2 + y) / 2);\n}\n\nfunction conicConformalRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }\n    else { if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }\n    var r = f / pow(tany(y), n);\n    return [r * sin$1(n * x), f - r * cos$1(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];\n  };\n\n  return project;\n}\n\nvar conicConformal = function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n};\n\nfunction equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nvar equirectangular = function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n};\n\nfunction conicEquidistantRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon$2) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin$1(nx), g - gy * cos$1(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nvar conicEquidistant = function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n};\n\nfunction gnomonicRaw(x, y) {\n  var cy = cos$1(y), k = cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nvar gnomonic = function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n};\n\nfunction scaleTranslate(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nvar identity$5 = function() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity$4, // scale, translate and reflect\n      x0 = null, y0, x1, y1, clip = identity$4, // clip extent\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform$$1(clip(cacheStream = stream));\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform$$1 = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    }\n  };\n};\n\nfunction orthographicRaw(x, y) {\n  return [cos$1(y) * sin$1(x), sin$1(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nvar orthographic = function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon$2);\n};\n\nfunction stereographicRaw(x, y) {\n  var cy = cos$1(y), k = 1 + cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nvar stereographic = function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n};\n\nfunction transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi$2 + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi$2];\n};\n\nvar transverseMercator = function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n};\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\nvar cluster = function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n};\n\nfunction count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nvar node_count = function() {\n  return this.eachAfter(count);\n};\n\nvar node_each = function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n};\n\nvar node_eachBefore = function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n};\n\nvar node_eachAfter = function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n};\n\nvar node_sum = function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n};\n\nvar node_sort = function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n};\n\nvar node_path = function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n};\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n\nvar node_ancestors = function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n};\n\nvar node_descendants = function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n};\n\nvar node_leaves = function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n};\n\nvar node_links = function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n};\n\nfunction hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nfunction computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nfunction Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n\nvar slice$3 = Array.prototype.slice;\n\nfunction shuffle$1(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n\nvar enclose = function(circles) {\n  var i = 0, n = (circles = shuffle$1(slice$3.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n};\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n\nfunction place(a, b, c) {\n  var ax = a.x,\n      ay = a.y,\n      da = b.r + c.r,\n      db = a.r + c.r,\n      dx = b.x - ax,\n      dy = b.y - ay,\n      dc = dx * dx + dy * dy;\n  if (dc) {\n    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),\n        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n    c.x = ax + x * dx + y * dy;\n    c.y = ay + x * dy - y * dx;\n  } else {\n    c.x = ax + db;\n    c.y = ay;\n  }\n}\n\nfunction intersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return dr * dr - 1e-6 > dx * dx + dy * dy;\n}\n\nfunction score(node) {\n  var a = node._,\n      b = node.next._,\n      ab = a.r + b.r,\n      dx = (a.x * b.r + b.x * a.r) / ab,\n      dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction Node$1(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nfunction packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle…\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new Node$1(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // “Closeness” is determined by linear distance along the front-chain.\n    // “Ahead” or “behind” is likewise determined by linear distance.\n    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, c._)) {\n          b = j, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sj += j._.r, j = j.next;\n      } else {\n        if (intersects(k._, c._)) {\n          a = k, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sk += k._.r, k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\nvar siblings = function(circles) {\n  packEnclose(circles);\n  return circles;\n};\n\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\n\nfunction required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n\nfunction constantZero() {\n  return 0;\n}\n\nvar constant$8 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction defaultRadius$1(d) {\n  return Math.sqrt(d.value);\n}\n\nvar index$2 = function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius$1))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === \"function\" ? x : constant$8(+x), pack) : padding;\n  };\n\n  return pack;\n};\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n\nvar roundNode = function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n};\n\nvar treemapDice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n};\n\nvar partition = function() {\n  var dx = 1,\n      dy = 1,\n      padding = 0,\n      round = false;\n\n  function partition(root) {\n    var n = root.height + 1;\n    root.x0 =\n    root.y0 = padding;\n    root.x1 = dx;\n    root.y1 = dy / n;\n    root.eachBefore(positionNode(dy, n));\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(dy, n) {\n    return function(node) {\n      if (node.children) {\n        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n      }\n      var x0 = node.x0,\n          y0 = node.y0,\n          x1 = node.x1 - padding,\n          y1 = node.y1 - padding;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      node.x0 = x0;\n      node.y0 = y0;\n      node.x1 = x1;\n      node.y1 = y1;\n    };\n  }\n\n  partition.round = function(x) {\n    return arguments.length ? (round = !!x, partition) : round;\n  };\n\n  partition.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n  };\n\n  partition.padding = function(x) {\n    return arguments.length ? (padding = +x, partition) : padding;\n  };\n\n  return partition;\n};\n\nvar keyPrefix$1 = \"$\";\nvar preroot = {depth: -1};\nvar ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nvar stratify = function() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = keyPrefix$1 + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += \"\")) {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix$1 + nodeId];\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n};\n\nfunction defaultSeparation$1(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nvar tree = function() {\n  var separation = defaultSeparation$1,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n};\n\nvar treemapSlice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n};\n\nvar phi = (1 + Math.sqrt(5)) / 2;\n\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nvar squarify = (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n\nvar index$3 = function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n};\n\nvar binary = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((x1 - x0) > (y1 - y0)) {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    } else {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    }\n  }\n};\n\nvar sliceDice = function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n};\n\nvar resquarify = (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n\nvar area$1 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nvar centroid$1 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n};\n\n// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nvar cross$1 = function(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nvar hull = function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n};\n\nvar contains$1 = function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n};\n\nvar length$2 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.sqrt(xa * xa + ya * ya);\n  }\n\n  return perimeter;\n};\n\nvar slice$4 = [].slice;\n\nvar noabort = {};\n\nfunction Queue(size) {\n  this._size = size;\n  this._call =\n  this._error = null;\n  this._tasks = [];\n  this._data = [];\n  this._waiting =\n  this._active =\n  this._ended =\n  this._start = 0; // inside a synchronous task callback?\n}\n\nQueue.prototype = queue.prototype = {\n  constructor: Queue,\n  defer: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"defer after await\");\n    if (this._error != null) return this;\n    var t = slice$4.call(arguments, 1);\n    t.push(callback);\n    ++this._waiting, this._tasks.push(t);\n    poke$1(this);\n    return this;\n  },\n  abort: function() {\n    if (this._error == null) abort(this, new Error(\"abort\"));\n    return this;\n  },\n  await: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"multiple await\");\n    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };\n    maybeNotify(this);\n    return this;\n  },\n  awaitAll: function(callback) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback\");\n    if (this._call) throw new Error(\"multiple await\");\n    this._call = callback;\n    maybeNotify(this);\n    return this;\n  }\n};\n\nfunction poke$1(q) {\n  if (!q._start) {\n    try { start$1(q); } // let the current task complete\n    catch (e) {\n      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously\n      else if (!q._data) throw e; // await callback errored synchronously\n    }\n  }\n}\n\nfunction start$1(q) {\n  while (q._start = q._waiting && q._active < q._size) {\n    var i = q._ended + q._active,\n        t = q._tasks[i],\n        j = t.length - 1,\n        c = t[j];\n    t[j] = end(q, i);\n    --q._waiting, ++q._active;\n    t = c.apply(null, t);\n    if (!q._tasks[i]) continue; // task finished synchronously\n    q._tasks[i] = t || noabort;\n  }\n}\n\nfunction end(q, i) {\n  return function(e, r) {\n    if (!q._tasks[i]) return; // ignore multiple callbacks\n    --q._active, ++q._ended;\n    q._tasks[i] = null;\n    if (q._error != null) return; // ignore secondary errors\n    if (e != null) {\n      abort(q, e);\n    } else {\n      q._data[i] = r;\n      if (q._waiting) poke$1(q);\n      else maybeNotify(q);\n    }\n  };\n}\n\nfunction abort(q, e) {\n  var i = q._tasks.length, t;\n  q._error = e; // ignore active callbacks\n  q._data = undefined; // allow gc\n  q._waiting = NaN; // prevent starting\n\n  while (--i >= 0) {\n    if (t = q._tasks[i]) {\n      q._tasks[i] = null;\n      if (t.abort) {\n        try { t.abort(); }\n        catch (e) { /* ignore */ }\n      }\n    }\n  }\n\n  q._active = NaN; // allow notification\n  maybeNotify(q);\n}\n\nfunction maybeNotify(q) {\n  if (!q._active && q._call) {\n    var d = q._data;\n    q._data = undefined; // allow gc\n    q._call(q._error, d);\n  }\n}\n\nfunction queue(concurrency) {\n  if (concurrency == null) concurrency = Infinity;\n  else if (!((concurrency = +concurrency) >= 1)) throw new Error(\"invalid concurrency\");\n  return new Queue(concurrency);\n}\n\nvar defaultSource$1 = function() {\n  return Math.random();\n};\n\nvar uniform = (function sourceRandomUniform(source) {\n  function randomUniform(min, max) {\n    min = min == null ? 0 : +min;\n    max = max == null ? 1 : +max;\n    if (arguments.length === 1) max = min, min = 0;\n    else max -= min;\n    return function() {\n      return source() * max + min;\n    };\n  }\n\n  randomUniform.source = sourceRandomUniform;\n\n  return randomUniform;\n})(defaultSource$1);\n\nvar normal = (function sourceRandomNormal(source) {\n  function randomNormal(mu, sigma) {\n    var x, r;\n    mu = mu == null ? 0 : +mu;\n    sigma = sigma == null ? 1 : +sigma;\n    return function() {\n      var y;\n\n      // If available, use the second previously-generated uniform random.\n      if (x != null) y = x, x = null;\n\n      // Otherwise, generate a new x and y.\n      else do {\n        x = source() * 2 - 1;\n        y = source() * 2 - 1;\n        r = x * x + y * y;\n      } while (!r || r > 1);\n\n      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n    };\n  }\n\n  randomNormal.source = sourceRandomNormal;\n\n  return randomNormal;\n})(defaultSource$1);\n\nvar logNormal = (function sourceRandomLogNormal(source) {\n  function randomLogNormal() {\n    var randomNormal = normal.source(source).apply(this, arguments);\n    return function() {\n      return Math.exp(randomNormal());\n    };\n  }\n\n  randomLogNormal.source = sourceRandomLogNormal;\n\n  return randomLogNormal;\n})(defaultSource$1);\n\nvar irwinHall = (function sourceRandomIrwinHall(source) {\n  function randomIrwinHall(n) {\n    return function() {\n      for (var sum = 0, i = 0; i < n; ++i) sum += source();\n      return sum;\n    };\n  }\n\n  randomIrwinHall.source = sourceRandomIrwinHall;\n\n  return randomIrwinHall;\n})(defaultSource$1);\n\nvar bates = (function sourceRandomBates(source) {\n  function randomBates(n) {\n    var randomIrwinHall = irwinHall.source(source)(n);\n    return function() {\n      return randomIrwinHall() / n;\n    };\n  }\n\n  randomBates.source = sourceRandomBates;\n\n  return randomBates;\n})(defaultSource$1);\n\nvar exponential$1 = (function sourceRandomExponential(source) {\n  function randomExponential(lambda) {\n    return function() {\n      return -Math.log(1 - source()) / lambda;\n    };\n  }\n\n  randomExponential.source = sourceRandomExponential;\n\n  return randomExponential;\n})(defaultSource$1);\n\nvar request = function(url, callback) {\n  var request,\n      event = dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n      mimeType,\n      headers = map$1(),\n      xhr = new XMLHttpRequest,\n      user = null,\n      password = null,\n      response,\n      responseType,\n      timeout = 0;\n\n  // If IE does not support CORS, use XDomainRequest.\n  if (typeof XDomainRequest !== \"undefined\"\n      && !(\"withCredentials\" in xhr)\n      && /^(http(s)?:)?\\/\\//.test(url)) xhr = new XDomainRequest;\n\n  \"onload\" in xhr\n      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond\n      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };\n\n  function respond(o) {\n    var status = xhr.status, result;\n    if (!status && hasResponse(xhr)\n        || status >= 200 && status < 300\n        || status === 304) {\n      if (response) {\n        try {\n          result = response.call(request, xhr);\n        } catch (e) {\n          event.call(\"error\", request, e);\n          return;\n        }\n      } else {\n        result = xhr;\n      }\n      event.call(\"load\", request, result);\n    } else {\n      event.call(\"error\", request, o);\n    }\n  }\n\n  xhr.onprogress = function(e) {\n    event.call(\"progress\", request, e);\n  };\n\n  request = {\n    header: function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers.get(name);\n      if (value == null) headers.remove(name);\n      else headers.set(name, value + \"\");\n      return request;\n    },\n\n    // If mimeType is non-null and no Accept header is set, a default is used.\n    mimeType: function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return request;\n    },\n\n    // Specifies what type the response value should take;\n    // for instance, arraybuffer, blob, document, or text.\n    responseType: function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return request;\n    },\n\n    timeout: function(value) {\n      if (!arguments.length) return timeout;\n      timeout = +value;\n      return request;\n    },\n\n    user: function(value) {\n      return arguments.length < 1 ? user : (user = value == null ? null : value + \"\", request);\n    },\n\n    password: function(value) {\n      return arguments.length < 1 ? password : (password = value == null ? null : value + \"\", request);\n    },\n\n    // Specify how to convert the response content to a specific type;\n    // changes the callback value on \"load\" events.\n    response: function(value) {\n      response = value;\n      return request;\n    },\n\n    // Alias for send(\"GET\", …).\n    get: function(data, callback) {\n      return request.send(\"GET\", data, callback);\n    },\n\n    // Alias for send(\"POST\", …).\n    post: function(data, callback) {\n      return request.send(\"POST\", data, callback);\n    },\n\n    // If callback is non-null, it will be used for error and load events.\n    send: function(method, data, callback) {\n      xhr.open(method, url, true, user, password);\n      if (mimeType != null && !headers.has(\"accept\")) headers.set(\"accept\", mimeType + \",*/*\");\n      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });\n      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);\n      if (responseType != null) xhr.responseType = responseType;\n      if (timeout > 0) xhr.timeout = timeout;\n      if (callback == null && typeof data === \"function\") callback = data, data = null;\n      if (callback != null && callback.length === 1) callback = fixCallback(callback);\n      if (callback != null) request.on(\"error\", callback).on(\"load\", function(xhr) { callback(null, xhr); });\n      event.call(\"beforesend\", request, xhr);\n      xhr.send(data == null ? null : data);\n      return request;\n    },\n\n    abort: function() {\n      xhr.abort();\n      return request;\n    },\n\n    on: function() {\n      var value = event.on.apply(event, arguments);\n      return value === event ? request : value;\n    }\n  };\n\n  if (callback != null) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    return request.get(callback);\n  }\n\n  return request;\n};\n\nfunction fixCallback(callback) {\n  return function(error, xhr) {\n    callback(error == null ? xhr : null);\n  };\n}\n\nfunction hasResponse(xhr) {\n  var type = xhr.responseType;\n  return type && type !== \"text\"\n      ? xhr.response // null on error\n      : xhr.responseText; // \"\" on error\n}\n\nvar type$1 = function(defaultMimeType, response) {\n  return function(url, callback) {\n    var r = request(url).mimeType(defaultMimeType).response(response);\n    if (callback != null) {\n      if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n      return r.get(callback);\n    }\n    return r;\n  };\n};\n\nvar html = type$1(\"text/html\", function(xhr) {\n  return document.createRange().createContextualFragment(xhr.responseText);\n});\n\nvar json = type$1(\"application/json\", function(xhr) {\n  return JSON.parse(xhr.responseText);\n});\n\nvar text = type$1(\"text/plain\", function(xhr) {\n  return xhr.responseText;\n});\n\nvar xml = type$1(\"application/xml\", function(xhr) {\n  var xml = xhr.responseXML;\n  if (!xml) throw new Error(\"parse error\");\n  return xml;\n});\n\nvar dsv$1 = function(defaultMimeType, parse) {\n  return function(url, row, callback) {\n    if (arguments.length < 3) callback = row, row = null;\n    var r = request(url).mimeType(defaultMimeType);\n    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };\n    r.row(row);\n    return callback ? r.get(callback) : r;\n  };\n};\n\nfunction responseOf(parse, row) {\n  return function(request$$1) {\n    return parse(request$$1.responseText, row);\n  };\n}\n\nvar csv$1 = dsv$1(\"text/csv\", csvParse);\n\nvar tsv$1 = dsv$1(\"text/tab-separated-values\", tsvParse);\n\nvar array$2 = Array.prototype;\n\nvar map$3 = array$2.map;\nvar slice$5 = array$2.slice;\n\nvar implicit = {name: \"implicit\"};\n\nfunction ordinal(range) {\n  var index = map$1(),\n      domain = [],\n      unknown = implicit;\n\n  range = range == null ? [] : slice$5.call(range);\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = map$1();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return scale;\n}\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point$1() {\n  return pointish(band().paddingInner(1));\n}\n\nvar constant$9 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar number$2 = function(x) {\n  return +x;\n};\n\nvar unit = [0, 1];\n\nfunction deinterpolateLinear(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant$9(b);\n}\n\nfunction deinterpolateClamp(deinterpolate) {\n  return function(a, b) {\n    var d = deinterpolate(a = +a, b = +b);\n    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n  };\n}\n\nfunction reinterpolateClamp(reinterpolate$$1) {\n  return function(a, b) {\n    var r = reinterpolate$$1(a = +a, b = +b);\n    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n  };\n}\n\nfunction bimap(domain, range, deinterpolate, reinterpolate$$1) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate$$1(r1, r0);\n  else d0 = deinterpolate(d0, d1), r0 = reinterpolate$$1(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, deinterpolate, reinterpolate$$1) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = deinterpolate(domain[i], domain[i + 1]);\n    r[i] = reinterpolate$$1(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisectRight(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp());\n}\n\n// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nfunction continuous(deinterpolate, reinterpolate$$1) {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      clamp = false,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);\n  }\n\n  scale.invert = function(y) {\n    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate$$1) : reinterpolate$$1)))(+y);\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$2), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice$5.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  return rescale();\n}\n\nvar tickFormat = function(domain, count, specifier) {\n  var start = domain[0],\n      stop = domain[domain.length - 1],\n      step = tickStep(start, stop, count == null ? 10 : count),\n      precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return exports.formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return exports.format(specifier);\n};\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return tickFormat(domain(), count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear$2() {\n  var scale = continuous(deinterpolateLinear, reinterpolate);\n\n  scale.copy = function() {\n    return copy(scale, linear$2());\n  };\n\n  return linearish(scale);\n}\n\nfunction identity$6() {\n  var domain = [0, 1];\n\n  function scale(x) {\n    return +x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$2), scale) : domain.slice();\n  };\n\n  scale.copy = function() {\n    return identity$6().domain(domain);\n  };\n\n  return linearish(scale);\n}\n\nvar nice = function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n};\n\nfunction deinterpolate(a, b) {\n  return (b = Math.log(b / a))\n      ? function(x) { return Math.log(x / a) / b; }\n      : constant$9(b);\n}\n\nfunction reinterpolate$1(a, b) {\n  return a < 0\n      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction log$1() {\n  var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),\n      domain = scale.domain,\n      base = 10,\n      logs = logp(10),\n      pows = powp(10);\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n    if (typeof specifier !== \"function\") specifier = exports.format(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  scale.copy = function() {\n    return copy(scale, log$1().base(base));\n  };\n\n  return scale;\n}\n\nfunction raise$1(x, exponent) {\n  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n}\n\nfunction pow$1() {\n  var exponent = 1,\n      scale = continuous(deinterpolate, reinterpolate),\n      domain = scale.domain;\n\n  function deinterpolate(a, b) {\n    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))\n        ? function(x) { return (raise$1(x, exponent) - a) / b; }\n        : constant$9(b);\n  }\n\n  function reinterpolate(a, b) {\n    b = raise$1(b, exponent) - (a = raise$1(a, exponent));\n    return function(t) { return raise$1(a + b * t, 1 / exponent); };\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n  };\n\n  scale.copy = function() {\n    return copy(scale, pow$1().exponent(exponent));\n  };\n\n  return linearish(scale);\n}\n\nfunction sqrt$1() {\n  return pow$1().exponent(0.5);\n}\n\nfunction quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [];\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\nfunction quantize$1() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1];\n\n  function scale(x) {\n    if (x <= x) return range[bisectRight(domain, x, 0, n)];\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice$5.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return quantize$1()\n        .domain([x0, x1])\n        .range(range);\n  };\n\n  return linearish(scale);\n}\n\nfunction threshold$1() {\n  var domain = [0.5],\n      range = [0, 1],\n      n = 1;\n\n  function scale(x) {\n    if (x <= x) return range[bisectRight(domain, x, 0, n)];\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return threshold$1()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\nvar t0$1 = new Date;\nvar t1$1 = new Date;\n\nfunction newInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = new Date(+date)), date;\n  }\n\n  interval.floor = interval;\n\n  interval.ceil = function(date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function(date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function(date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function(start, stop, step) {\n    var range = [];\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)\n    return range;\n  };\n\n  interval.filter = function(test) {\n    return newInterval(function(date) {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = function(start, end) {\n      t0$1.setTime(+start), t1$1.setTime(+end);\n      floori(t0$1), floori(t1$1);\n      return Math.floor(count(t0$1, t1$1));\n    };\n\n    interval.every = function(step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? function(d) { return field(d) % step === 0; }\n              : function(d) { return interval.count(0, d) % step === 0; });\n    };\n  }\n\n  return interval;\n}\n\nvar millisecond = newInterval(function() {\n  // noop\n}, function(date, step) {\n  date.setTime(+date + step);\n}, function(start, end) {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = function(k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return newInterval(function(date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function(date, step) {\n    date.setTime(+date + step * k);\n  }, function(start, end) {\n    return (end - start) / k;\n  });\n};\n\nvar milliseconds = millisecond.range;\n\nvar durationSecond$1 = 1e3;\nvar durationMinute$1 = 6e4;\nvar durationHour$1 = 36e5;\nvar durationDay$1 = 864e5;\nvar durationWeek$1 = 6048e5;\n\nvar second = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);\n}, function(date, step) {\n  date.setTime(+date + step * durationSecond$1);\n}, function(start, end) {\n  return (end - start) / durationSecond$1;\n}, function(date) {\n  return date.getUTCSeconds();\n});\n\nvar seconds = second.range;\n\nvar minute = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute$1);\n}, function(start, end) {\n  return (end - start) / durationMinute$1;\n}, function(date) {\n  return date.getMinutes();\n});\n\nvar minutes = minute.range;\n\nvar hour = newInterval(function(date) {\n  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;\n  if (offset < 0) offset += durationHour$1;\n  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour$1);\n}, function(start, end) {\n  return (end - start) / durationHour$1;\n}, function(date) {\n  return date.getHours();\n});\n\nvar hours = hour.range;\n\nvar day = newInterval(function(date) {\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setDate(date.getDate() + step);\n}, function(start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nvar days = day.range;\n\nfunction weekday(i) {\n  return newInterval(function(date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;\n  });\n}\n\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\nvar sundays = sunday.range;\nvar mondays = monday.range;\nvar tuesdays = tuesday.range;\nvar wednesdays = wednesday.range;\nvar thursdays = thursday.range;\nvar fridays = friday.range;\nvar saturdays = saturday.range;\n\nvar month = newInterval(function(date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function(start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function(date) {\n  return date.getMonth();\n});\n\nvar months = month.range;\n\nvar year = newInterval(function(date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function(start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function(date) {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\nyear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nvar years = year.range;\n\nvar utcMinute = newInterval(function(date) {\n  date.setUTCSeconds(0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute$1);\n}, function(start, end) {\n  return (end - start) / durationMinute$1;\n}, function(date) {\n  return date.getUTCMinutes();\n});\n\nvar utcMinutes = utcMinute.range;\n\nvar utcHour = newInterval(function(date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour$1);\n}, function(start, end) {\n  return (end - start) / durationHour$1;\n}, function(date) {\n  return date.getUTCHours();\n});\n\nvar utcHours = utcHour.range;\n\nvar utcDay = newInterval(function(date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function(start, end) {\n  return (end - start) / durationDay$1;\n}, function(date) {\n  return date.getUTCDate() - 1;\n});\n\nvar utcDays = utcDay.range;\n\nfunction utcWeekday(i) {\n  return newInterval(function(date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function(start, end) {\n    return (end - start) / durationWeek$1;\n  });\n}\n\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\n\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\nvar utcMonth = newInterval(function(date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function(start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function(date) {\n  return date.getUTCMonth();\n});\n\nvar utcMonths = utcMonth.range;\n\nvar utcYear = newInterval(function(date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function(start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function(date) {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nvar utcYears = utcYear.range;\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newYear(y) {\n  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n}\n\nfunction formatLocale$1(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"S\": formatSeconds,\n    \"U\": formatWeekNumberSunday,\n    \"w\": formatWeekdayNumber,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"S\": formatUTCSeconds,\n    \"U\": formatUTCWeekNumberSunday,\n    \"w\": formatUTCWeekdayNumber,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"S\": parseSeconds,\n    \"U\": parseWeekNumberSunday,\n    \"w\": parseWeekdayNumber,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, newDate) {\n    return function(string) {\n      var d = newYear(1900),\n          i = parseSpecifier(d, specifier, string += \"\", 0);\n      if (i != string.length) return null;\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n        var day$$1 = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return newDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", localDate);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier, utcDate);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  var map = {}, i = -1, n = names.length;\n  while (++i < n) map[names[i].toLowerCase()] = i;\n  return map;\n}\n\nfunction parseWeekdayNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + day.count(year(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(sunday.count(year(d), d), p, 2);\n}\n\nfunction formatWeekdayNumber(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(monday.count(year(d), d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCWeekdayNumber(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nvar locale$2;\n\n\n\n\n\ndefaultLocale$1({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nfunction defaultLocale$1(definition) {\n  locale$2 = formatLocale$1(definition);\n  exports.timeFormat = locale$2.format;\n  exports.timeParse = locale$2.parse;\n  exports.utcFormat = locale$2.utcFormat;\n  exports.utcParse = locale$2.utcParse;\n  return locale$2;\n}\n\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : exports.utcFormat(isoSpecifier);\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : exports.utcParse(isoSpecifier);\n\nvar durationSecond = 1000;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\nfunction date$1(t) {\n  return new Date(t);\n}\n\nfunction number$3(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {\n  var scale = continuous(deinterpolateLinear, reinterpolate),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second$$1,  1,      durationSecond],\n    [second$$1,  5,  5 * durationSecond],\n    [second$$1, 15, 15 * durationSecond],\n    [second$$1, 30, 30 * durationSecond],\n    [minute$$1,  1,      durationMinute],\n    [minute$$1,  5,  5 * durationMinute],\n    [minute$$1, 15, 15 * durationMinute],\n    [minute$$1, 30, 30 * durationMinute],\n    [  hour$$1,  1,      durationHour  ],\n    [  hour$$1,  3,  3 * durationHour  ],\n    [  hour$$1,  6,  6 * durationHour  ],\n    [  hour$$1, 12, 12 * durationHour  ],\n    [   day$$1,  1,      durationDay   ],\n    [   day$$1,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month$$1,  1,      durationMonth ],\n    [ month$$1,  3,  3 * durationMonth ],\n    [  year$$1,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date$$1) {\n    return (second$$1(date$$1) < date$$1 ? formatMillisecond\n        : minute$$1(date$$1) < date$$1 ? formatSecond\n        : hour$$1(date$$1) < date$$1 ? formatMinute\n        : day$$1(date$$1) < date$$1 ? formatHour\n        : month$$1(date$$1) < date$$1 ? (week(date$$1) < date$$1 ? formatDay : formatWeek)\n        : year$$1(date$$1) < date$$1 ? formatMonth\n        : formatYear)(date$$1);\n  }\n\n  function tickInterval(interval$$1, start, stop, step) {\n    if (interval$$1 == null) interval$$1 = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval$$1 === \"number\") {\n      var target = Math.abs(stop - start) / interval$$1,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval$$1);\n        interval$$1 = year$$1;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval$$1 = i[0];\n      } else {\n        step = tickStep(start, stop, interval$$1);\n        interval$$1 = millisecond$$1;\n      }\n    }\n\n    return step == null ? interval$$1 : interval$$1.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map$3.call(_, number$3)) : domain().map(date$1);\n  };\n\n  scale.ticks = function(interval$$1, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval$$1, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval$$1, step) {\n    var d = domain();\n    return (interval$$1 = tickInterval(interval$$1, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval$$1))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));\n  };\n\n  return scale;\n}\n\nvar time = function() {\n  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n};\n\nvar utcTime = function() {\n  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n};\n\nvar colors = function(s) {\n  return s.match(/.{6}/g).map(function(x) {\n    return \"#\" + x;\n  });\n};\n\nvar category10 = colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\nvar category20b = colors(\"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6\");\n\nvar category20c = colors(\"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9\");\n\nvar category20 = colors(\"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5\");\n\nvar cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar rainbow = cubehelix();\n\nvar rainbow$1 = function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  rainbow.h = 360 * t - 100;\n  rainbow.s = 1.5 - 1.5 * ts;\n  rainbow.l = 0.8 - 0.9 * ts;\n  return rainbow + \"\";\n};\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\nvar viridis = ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\nvar magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\nvar inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\nvar plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\nfunction sequential(interpolator) {\n  var x0 = 0,\n      x1 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = (x - x0) / (x1 - x0);\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequential(interpolator).domain([x0, x1]).clamp(clamp);\n  };\n\n  return linearish(scale);\n}\n\nvar constant$10 = function(x) {\n  return function constant() {\n    return x;\n  };\n};\n\nvar abs$1 = Math.abs;\nvar atan2$1 = Math.atan2;\nvar cos$2 = Math.cos;\nvar max$2 = Math.max;\nvar min$1 = Math.min;\nvar sin$2 = Math.sin;\nvar sqrt$2 = Math.sqrt;\n\nvar epsilon$3 = 1e-12;\nvar pi$4 = Math.PI;\nvar halfPi$3 = pi$4 / 2;\nvar tau$4 = 2 * pi$4;\n\nfunction acos$1(x) {\n  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);\n}\n\nfunction asin$1(x) {\n  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);\n}\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nvar arc = function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant$10(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi$3,\n        a1 = endAngle.apply(this, arguments) - halfPi$3,\n        da = abs$1(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon$3)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau$4 - epsilon$3) {\n      context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon$3) {\n        context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon$3) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),\n          rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon$3) {\n        var p0 = asin$1(rp / r0 * sin$2(ap)),\n            p1 = asin$1(rp / r1 * sin$2(ap));\n        if ((da0 -= p0 * 2) > epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos$2(a01),\n          y01 = r1 * sin$2(a01),\n          x10 = r0 * cos$2(a10),\n          y10 = r0 * sin$2(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon$3) {\n        var x11 = r1 * cos$2(a11),\n            y11 = r1 * sin$2(a11),\n            x00 = r0 * cos$2(a00),\n            y00 = r0 * sin$2(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi$4) {\n          var oc = da0 > epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),\n              lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min$1(rc, (r0 - lc) / (kc - 1));\n          rc1 = min$1(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon$3)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon$3) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon$3) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;\n    return [cos$2(a) * r, sin$2(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant$10(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$10(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n};\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nvar curveLinear = function(context) {\n  return new Linear(context);\n};\n\nfunction x$3(p) {\n  return p[0];\n}\n\nfunction y$3(p) {\n  return p[1];\n}\n\nvar line = function() {\n  var x = x$3,\n      y = y$3,\n      defined = constant$10(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$10(+_), line) : x;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$10(+_), line) : y;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$10(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n};\n\nvar area$2 = function() {\n  var x0 = x$3,\n      x1 = null,\n      y0 = constant$10(0),\n      y1 = y$3,\n      defined = constant$10(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$10(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$10(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$10(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$10(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$10(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$10(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n};\n\nvar descending$1 = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar identity$7 = function(d) {\n  return d;\n};\n\nvar pie = function() {\n  var value = identity$7,\n      sortValues = descending$1,\n      sort = null,\n      startAngle = constant$10(0),\n      endAngle = constant$10(tau$4),\n      padAngle = constant$10(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$10(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$10(+_), pie) : padAngle;\n  };\n\n  return pie;\n};\n\nvar curveRadialLinear = curveRadial(curveLinear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nfunction curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n\nfunction lineRadial(l) {\n  var c = l.curve;\n\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n\n  l.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return l;\n}\n\nvar lineRadial$1 = function() {\n  return lineRadial(line().curve(curveRadialLinear));\n};\n\nvar areaRadial = function() {\n  var a = area$2().curve(curveRadialLinear),\n      c = a.curve,\n      x0 = a.lineX0,\n      x1 = a.lineX1,\n      y0 = a.lineY0,\n      y1 = a.lineY1;\n\n  a.angle = a.x, delete a.x;\n  a.startAngle = a.x0, delete a.x0;\n  a.endAngle = a.x1, delete a.x1;\n  a.radius = a.y, delete a.y;\n  a.innerRadius = a.y0, delete a.y0;\n  a.outerRadius = a.y1, delete a.y1;\n  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;\n  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;\n  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;\n  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;\n\n  a.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return a;\n};\n\nvar pointRadial = function(x, y) {\n  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n};\n\nvar slice$6 = Array.prototype.slice;\n\nfunction linkSource(d) {\n  return d.source;\n}\n\nfunction linkTarget(d) {\n  return d.target;\n}\n\nfunction link$2(curve) {\n  var source = linkSource,\n      target = linkTarget,\n      x = x$3,\n      y = y$3,\n      context = null;\n\n  function link() {\n    var buffer, argv = slice$6.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n    if (!context) context = buffer = path();\n    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  link.source = function(_) {\n    return arguments.length ? (source = _, link) : source;\n  };\n\n  link.target = function(_) {\n    return arguments.length ? (target = _, link) : target;\n  };\n\n  link.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$10(+_), link) : x;\n  };\n\n  link.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$10(+_), link) : y;\n  };\n\n  link.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), link) : context;\n  };\n\n  return link;\n}\n\nfunction curveHorizontal(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n}\n\nfunction curveVertical(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n}\n\nfunction curveRadial$1(context, x0, y0, x1, y1) {\n  var p0 = pointRadial(x0, y0),\n      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),\n      p2 = pointRadial(x1, y0),\n      p3 = pointRadial(x1, y1);\n  context.moveTo(p0[0], p0[1]);\n  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\nfunction linkHorizontal() {\n  return link$2(curveHorizontal);\n}\n\nfunction linkVertical() {\n  return link$2(curveVertical);\n}\n\nfunction linkRadial() {\n  var l = link$2(curveRadial$1);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n\nvar circle$2 = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / pi$4);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau$4);\n  }\n};\n\nvar cross$2 = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\nvar tan30 = Math.sqrt(1 / 3);\nvar tan30_2 = tan30 * 2;\n\nvar diamond = {\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n\nvar ka = 0.89081309152928522810;\nvar kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);\nvar kx = Math.sin(tau$4 / 10) * kr;\nvar ky = -Math.cos(tau$4 / 10) * kr;\n\nvar star = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = tau$4 * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n\nvar square = {\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n};\n\nvar sqrt3 = Math.sqrt(3);\n\nvar triangle = {\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n\nvar c = -0.5;\nvar s = Math.sqrt(3) / 2;\nvar k = 1 / Math.sqrt(12);\nvar a = (k / 2 + 1) * 3;\n\nvar wye = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n};\n\nvar symbols = [\n  circle$2,\n  cross$2,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\nvar symbol = function() {\n  var type = constant$10(circle$2),\n      size = constant$10(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant$10(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant$10(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n};\n\nvar noop$2 = function() {};\n\nfunction point$2(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point$2(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basis$2 = function(context) {\n  return new Basis(context);\n};\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisClosed$1 = function(context) {\n  return new BasisClosed(context);\n};\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point$2(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisOpen = function(context) {\n  return new BasisOpen(context);\n};\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nvar bundle = (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n\nfunction point$3(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point$3(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinal = (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalClosed = (function custom(tension) {\n\n  function cardinal$$1(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal$$1.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal$$1;\n})(0);\n\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$3(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalOpen = (function custom(tension) {\n\n  function cardinal$$1(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal$$1.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal$$1;\n})(0);\n\nfunction point$4(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon$3) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon$3) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRom = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomClosed = (function custom(alpha) {\n\n  function catmullRom$$1(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom$$1.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom$$1;\n})(0.5);\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$4(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomOpen = (function custom(alpha) {\n\n  function catmullRom$$1(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom$$1.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom$$1;\n})(0.5);\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop$2,\n  areaEnd: noop$2,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nvar linearClosed = function(context) {\n  return new LinearClosed(context);\n};\n\nfunction sign$1(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point$5(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n};\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\nfunction Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nvar natural = function(context) {\n  return new Natural(context);\n};\n\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nvar step = function(context) {\n  return new Step(context, 0.5);\n};\n\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\n\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\nvar none$1 = function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n};\n\nvar none$2 = function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n};\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nvar stack = function() {\n  var keys = constant$10([]),\n      order = none$2,\n      offset = none$1,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant$10(slice$6.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$10(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? none$2 : typeof _ === \"function\" ? _ : constant$10(slice$6.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;\n  };\n\n  return stack;\n};\n\nvar expand = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  none$1(series, order);\n};\n\nvar diverging = function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n};\n\nvar silhouette = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  none$1(series, order);\n};\n\nvar wiggle = function(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  none$1(series, order);\n};\n\nvar ascending$2 = function(series) {\n  var sums = series.map(sum$2);\n  return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });\n};\n\nfunction sum$2(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n\nvar descending$2 = function(series) {\n  return ascending$2(series).reverse();\n};\n\nvar insideOut = function(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(sum$2),\n      order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n};\n\nvar reverse = function(series) {\n  return none$2(series).reverse();\n};\n\nvar constant$11 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction x$4(d) {\n  return d[0];\n}\n\nfunction y$4(d) {\n  return d[1];\n}\n\nfunction RedBlackTree() {\n  this._ = null; // root node\n}\n\nfunction RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\nfunction createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nfunction createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nfunction setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// Liang–Barsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nfunction clipEdges(x0, y0, x1, y1) {\n  var i = edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {\n      delete edges[i];\n    }\n  }\n}\n\nfunction createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nfunction sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1]\n              : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0]\n              : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n\nvar circlePool = [];\n\nvar firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nfunction attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2$2) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nfunction detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nfunction removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon$4\n      && Math.abs(y - lArc.circle.cy) < epsilon$4) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon$4\n      && Math.abs(y - rArc.circle.cy) < epsilon$4) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon$4) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon$4) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon$4) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon$4) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n\nvar epsilon$4 = 1e-6;\nvar epsilon2$2 = 1e-12;\nvar beaches;\nvar cells;\nvar circles;\nvar edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nfunction Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n};\n\nvar voronoi = function() {\n  var x = x$4,\n      y = y$4,\n      extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function(d, i) {\n      var s = [Math.round(x(d, i, data) / epsilon$4) * epsilon$4, Math.round(y(d, i, data) / epsilon$4) * epsilon$4];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function(data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function(data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function(data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$11(+_), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$11(+_), voronoi) : y;\n  };\n\n  voronoi.extent = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n};\n\nvar constant$12 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction ZoomEvent(target, type, transform) {\n  this.target = target;\n  this.type = type;\n  this.transform = transform;\n}\n\nfunction Transform(k, x, y) {\n  this.k = k;\n  this.x = x;\n  this.y = y;\n}\n\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k) {\n    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n  },\n  translate: function(x, y) {\n    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n  },\n  apply: function(point) {\n    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n  },\n  applyX: function(x) {\n    return x * this.k + this.x;\n  },\n  applyY: function(y) {\n    return y * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x) {\n    return (x - this.x) / this.k;\n  },\n  invertY: function(y) {\n    return (y - this.y) / this.k;\n  },\n  rescaleX: function(x) {\n    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n  },\n  rescaleY: function(y) {\n    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\n\nvar identity$8 = new Transform(1, 0, 0);\n\ntransform$1.prototype = Transform.prototype;\n\nfunction transform$1(node) {\n  return node.__zoom || identity$8;\n}\n\nfunction nopropagation$2() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$2 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$2() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent$1() {\n  var e = this, w, h;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    w = e.width.baseVal.value;\n    h = e.height.baseVal.value;\n  } else {\n    w = e.clientWidth;\n    h = e.clientHeight;\n  }\n  return [[0, 0], [w, h]];\n}\n\nfunction defaultTransform() {\n  return this.__zoom || identity$8;\n}\n\nfunction defaultWheelDelta() {\n  return -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500;\n}\n\nfunction touchable$1() {\n  return \"ontouchstart\" in this;\n}\n\nvar zoom = function() {\n  var filter = defaultFilter$2,\n      extent = defaultExtent$1,\n      wheelDelta = defaultWheelDelta,\n      k0 = 0,\n      k1 = Infinity,\n      x0 = -k1,\n      x1 = k1,\n      y0 = x0,\n      y1 = x1,\n      duration = 250,\n      interpolate = interpolateZoom,\n      gestures = [],\n      listeners = dispatch(\"start\", \"zoom\", \"end\"),\n      touchstarting,\n      touchending,\n      touchDelay = 500,\n      wheelDelay = 150,\n      clickDistance2 = 0;\n\n  function zoom(selection$$1) {\n    selection$$1\n        .property(\"__zoom\", defaultTransform)\n        .on(\"wheel.zoom\", wheeled)\n        .on(\"mousedown.zoom\", mousedowned)\n        .on(\"dblclick.zoom\", dblclicked)\n      .filter(touchable$1)\n        .on(\"touchstart.zoom\", touchstarted)\n        .on(\"touchmove.zoom\", touchmoved)\n        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  zoom.transform = function(collection, transform$$1) {\n    var selection$$1 = collection.selection ? collection.selection() : collection;\n    selection$$1.property(\"__zoom\", defaultTransform);\n    if (collection !== selection$$1) {\n      schedule(collection, transform$$1);\n    } else {\n      selection$$1.interrupt().each(function() {\n        gesture(this, arguments)\n            .start()\n            .zoom(null, typeof transform$$1 === \"function\" ? transform$$1.apply(this, arguments) : transform$$1)\n            .end();\n      });\n    }\n  };\n\n  zoom.scaleBy = function(selection$$1, k) {\n    zoom.scaleTo(selection$$1, function() {\n      var k0 = this.__zoom.k,\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return k0 * k1;\n    });\n  };\n\n  zoom.scaleTo = function(selection$$1, k) {\n    zoom.transform(selection$$1, function() {\n      var e = extent.apply(this, arguments),\n          t0 = this.__zoom,\n          p0 = centroid(e),\n          p1 = t0.invert(p0),\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return constrain(translate(scale(t0, k1), p0, p1), e);\n    });\n  };\n\n  zoom.translateBy = function(selection$$1, x, y) {\n    zoom.transform(selection$$1, function() {\n      return constrain(this.__zoom.translate(\n        typeof x === \"function\" ? x.apply(this, arguments) : x,\n        typeof y === \"function\" ? y.apply(this, arguments) : y\n      ), extent.apply(this, arguments));\n    });\n  };\n\n  zoom.translateTo = function(selection$$1, x, y) {\n    zoom.transform(selection$$1, function() {\n      var e = extent.apply(this, arguments),\n          t = this.__zoom,\n          p = centroid(e);\n      return constrain(identity$8.translate(p[0], p[1]).scale(t.k).translate(\n        typeof x === \"function\" ? -x.apply(this, arguments) : -x,\n        typeof y === \"function\" ? -y.apply(this, arguments) : -y\n      ), e);\n    });\n  };\n\n  function scale(transform$$1, k) {\n    k = Math.max(k0, Math.min(k1, k));\n    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);\n  }\n\n  function translate(transform$$1, p0, p1) {\n    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;\n    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);\n  }\n\n  function constrain(transform$$1, extent) {\n    var dx0 = transform$$1.invertX(extent[0][0]) - x0,\n        dx1 = transform$$1.invertX(extent[1][0]) - x1,\n        dy0 = transform$$1.invertY(extent[0][1]) - y0,\n        dy1 = transform$$1.invertY(extent[1][1]) - y1;\n    return transform$$1.translate(\n      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\n      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\n    );\n  }\n\n  function centroid(extent) {\n    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n  }\n\n  function schedule(transition$$1, transform$$1, center) {\n    transition$$1\n        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n        .tween(\"zoom\", function() {\n          var that = this,\n              args = arguments,\n              g = gesture(that, args),\n              e = extent.apply(that, args),\n              p = center || centroid(e),\n              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n              a = that.__zoom,\n              b = typeof transform$$1 === \"function\" ? transform$$1.apply(that, args) : transform$$1,\n              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n          return function(t) {\n            if (t === 1) t = b; // Avoid rounding error on end.\n            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n            g.zoom(null, t);\n          };\n        });\n  }\n\n  function gesture(that, args) {\n    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n      if ((g = gestures[i]).that === that) {\n        return g;\n      }\n    }\n    return new Gesture(that, args);\n  }\n\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.index = -1;\n    this.active = 0;\n    this.extent = extent.apply(that, args);\n  }\n\n  Gesture.prototype = {\n    start: function() {\n      if (++this.active === 1) {\n        this.index = gestures.push(this) - 1;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform$$1) {\n      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform$$1.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform$$1.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform$$1.invert(this.touch1[0]);\n      this.that.__zoom = transform$$1;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        gestures.splice(this.index, 1);\n        this.index = -1;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function wheeled() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        t = this.__zoom,\n        k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),\n        p = mouse(this);\n\n    // If the mouse is in the same location as before, reuse it.\n    // If there were recent wheel events, reset the wheel idle timeout.\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    }\n\n    // If this wheel event won’t trigger a transform change, ignore it.\n    else if (t.k === k) return;\n\n    // Otherwise, capture the mouse point and location at the start.\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt(this);\n      g.start();\n    }\n\n    noevent$2();\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));\n\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        v = select(exports.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n        p = mouse(this),\n        x0 = exports.event.clientX,\n        y0 = exports.event.clientY;\n\n    dragDisable(exports.event.view);\n    nopropagation$2();\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt(this);\n    g.start();\n\n    function mousemoved() {\n      noevent$2();\n      if (!g.moved) {\n        var dx = exports.event.clientX - x0, dy = exports.event.clientY - y0;\n        g.moved = dx * dx + dy * dy > clickDistance2;\n      }\n      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));\n    }\n\n    function mouseupped() {\n      v.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(exports.event.view, g.moved);\n      noevent$2();\n      g.end();\n    }\n  }\n\n  function dblclicked() {\n    if (!filter.apply(this, arguments)) return;\n    var t0 = this.__zoom,\n        p0 = mouse(this),\n        p1 = t0.invert(p0),\n        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),\n        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));\n\n    noevent$2();\n    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);\n    else select(this).call(zoom.transform, t1);\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        started,\n        n = touches$$1.length, i, t, p;\n\n    nopropagation$2();\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0) g.touch0 = p, started = true;\n      else if (!g.touch1) g.touch1 = p;\n    }\n\n    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\n    if (touchstarting) {\n      touchstarting = clearTimeout(touchstarting);\n      if (!g.touch1) {\n        g.end();\n        p = select(this).on(\"dblclick.zoom\");\n        if (p) p.apply(this, arguments);\n        return;\n      }\n    }\n\n    if (started) {\n      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n      interrupt(this);\n      g.start();\n    }\n  }\n\n  function touchmoved() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t, p, l;\n\n    noevent$2();\n    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p0 = g.touch0[0], l0 = g.touch0[1],\n          p1 = g.touch1[0], l1 = g.touch1[1],\n          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale(t, Math.sqrt(dp / dl));\n      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    }\n    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n    else return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent));\n  }\n\n  function touchended() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t;\n\n    nopropagation$2();\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i];\n      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);\n    else g.end();\n  }\n\n  zoom.wheelDelta = function(_) {\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant$12(+_), zoom) : wheelDelta;\n  };\n\n  zoom.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$12(!!_), zoom) : filter;\n  };\n\n  zoom.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$12([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n  };\n\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];\n  };\n\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];\n  };\n\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n\n  zoom.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\n  };\n\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n\n  zoom.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\n  };\n\n  return zoom;\n};\n\nexports.version = version;\nexports.bisect = bisectRight;\nexports.bisectRight = bisectRight;\nexports.bisectLeft = bisectLeft;\nexports.ascending = ascending;\nexports.bisector = bisector;\nexports.cross = cross;\nexports.descending = descending;\nexports.deviation = deviation;\nexports.extent = extent;\nexports.histogram = histogram;\nexports.thresholdFreedmanDiaconis = freedmanDiaconis;\nexports.thresholdScott = scott;\nexports.thresholdSturges = sturges;\nexports.max = max;\nexports.mean = mean;\nexports.median = median;\nexports.merge = merge;\nexports.min = min;\nexports.pairs = pairs;\nexports.permute = permute;\nexports.quantile = threshold;\nexports.range = sequence;\nexports.scan = scan;\nexports.shuffle = shuffle;\nexports.sum = sum;\nexports.ticks = ticks;\nexports.tickIncrement = tickIncrement;\nexports.tickStep = tickStep;\nexports.transpose = transpose;\nexports.variance = variance;\nexports.zip = zip;\nexports.axisTop = axisTop;\nexports.axisRight = axisRight;\nexports.axisBottom = axisBottom;\nexports.axisLeft = axisLeft;\nexports.brush = brush;\nexports.brushX = brushX;\nexports.brushY = brushY;\nexports.brushSelection = brushSelection;\nexports.chord = chord;\nexports.ribbon = ribbon;\nexports.nest = nest;\nexports.set = set$2;\nexports.map = map$1;\nexports.keys = keys;\nexports.values = values;\nexports.entries = entries;\nexports.color = color;\nexports.rgb = rgb;\nexports.hsl = hsl;\nexports.lab = lab;\nexports.hcl = hcl;\nexports.cubehelix = cubehelix;\nexports.dispatch = dispatch;\nexports.drag = drag;\nexports.dragDisable = dragDisable;\nexports.dragEnable = yesdrag;\nexports.dsvFormat = dsv;\nexports.csvParse = csvParse;\nexports.csvParseRows = csvParseRows;\nexports.csvFormat = csvFormat;\nexports.csvFormatRows = csvFormatRows;\nexports.tsvParse = tsvParse;\nexports.tsvParseRows = tsvParseRows;\nexports.tsvFormat = tsvFormat;\nexports.tsvFormatRows = tsvFormatRows;\nexports.easeLinear = linear$1;\nexports.easeQuad = quadInOut;\nexports.easeQuadIn = quadIn;\nexports.easeQuadOut = quadOut;\nexports.easeQuadInOut = quadInOut;\nexports.easeCubic = cubicInOut;\nexports.easeCubicIn = cubicIn;\nexports.easeCubicOut = cubicOut;\nexports.easeCubicInOut = cubicInOut;\nexports.easePoly = polyInOut;\nexports.easePolyIn = polyIn;\nexports.easePolyOut = polyOut;\nexports.easePolyInOut = polyInOut;\nexports.easeSin = sinInOut;\nexports.easeSinIn = sinIn;\nexports.easeSinOut = sinOut;\nexports.easeSinInOut = sinInOut;\nexports.easeExp = expInOut;\nexports.easeExpIn = expIn;\nexports.easeExpOut = expOut;\nexports.easeExpInOut = expInOut;\nexports.easeCircle = circleInOut;\nexports.easeCircleIn = circleIn;\nexports.easeCircleOut = circleOut;\nexports.easeCircleInOut = circleInOut;\nexports.easeBounce = bounceOut;\nexports.easeBounceIn = bounceIn;\nexports.easeBounceOut = bounceOut;\nexports.easeBounceInOut = bounceInOut;\nexports.easeBack = backInOut;\nexports.easeBackIn = backIn;\nexports.easeBackOut = backOut;\nexports.easeBackInOut = backInOut;\nexports.easeElastic = elasticOut;\nexports.easeElasticIn = elasticIn;\nexports.easeElasticOut = elasticOut;\nexports.easeElasticInOut = elasticInOut;\nexports.forceCenter = center$1;\nexports.forceCollide = collide;\nexports.forceLink = link;\nexports.forceManyBody = manyBody;\nexports.forceSimulation = simulation;\nexports.forceX = x$2;\nexports.forceY = y$2;\nexports.formatDefaultLocale = defaultLocale;\nexports.formatLocale = formatLocale;\nexports.formatSpecifier = formatSpecifier;\nexports.precisionFixed = precisionFixed;\nexports.precisionPrefix = precisionPrefix;\nexports.precisionRound = precisionRound;\nexports.geoArea = area;\nexports.geoBounds = bounds;\nexports.geoCentroid = centroid;\nexports.geoCircle = circle;\nexports.geoClipExtent = extent$1;\nexports.geoContains = contains;\nexports.geoDistance = distance;\nexports.geoGraticule = graticule;\nexports.geoGraticule10 = graticule10;\nexports.geoInterpolate = interpolate$1;\nexports.geoLength = length$1;\nexports.geoPath = index$1;\nexports.geoAlbers = albers;\nexports.geoAlbersUsa = albersUsa;\nexports.geoAzimuthalEqualArea = azimuthalEqualArea;\nexports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\nexports.geoAzimuthalEquidistant = azimuthalEquidistant;\nexports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\nexports.geoConicConformal = conicConformal;\nexports.geoConicConformalRaw = conicConformalRaw;\nexports.geoConicEqualArea = conicEqualArea;\nexports.geoConicEqualAreaRaw = conicEqualAreaRaw;\nexports.geoConicEquidistant = conicEquidistant;\nexports.geoConicEquidistantRaw = conicEquidistantRaw;\nexports.geoEquirectangular = equirectangular;\nexports.geoEquirectangularRaw = equirectangularRaw;\nexports.geoGnomonic = gnomonic;\nexports.geoGnomonicRaw = gnomonicRaw;\nexports.geoIdentity = identity$5;\nexports.geoProjection = projection;\nexports.geoProjectionMutator = projectionMutator;\nexports.geoMercator = mercator;\nexports.geoMercatorRaw = mercatorRaw;\nexports.geoOrthographic = orthographic;\nexports.geoOrthographicRaw = orthographicRaw;\nexports.geoStereographic = stereographic;\nexports.geoStereographicRaw = stereographicRaw;\nexports.geoTransverseMercator = transverseMercator;\nexports.geoTransverseMercatorRaw = transverseMercatorRaw;\nexports.geoRotation = rotation;\nexports.geoStream = geoStream;\nexports.geoTransform = transform;\nexports.cluster = cluster;\nexports.hierarchy = hierarchy;\nexports.pack = index$2;\nexports.packSiblings = siblings;\nexports.packEnclose = enclose;\nexports.partition = partition;\nexports.stratify = stratify;\nexports.tree = tree;\nexports.treemap = index$3;\nexports.treemapBinary = binary;\nexports.treemapDice = treemapDice;\nexports.treemapSlice = treemapSlice;\nexports.treemapSliceDice = sliceDice;\nexports.treemapSquarify = squarify;\nexports.treemapResquarify = resquarify;\nexports.interpolate = interpolateValue;\nexports.interpolateArray = array$1;\nexports.interpolateBasis = basis$1;\nexports.interpolateBasisClosed = basisClosed;\nexports.interpolateDate = date;\nexports.interpolateNumber = reinterpolate;\nexports.interpolateObject = object;\nexports.interpolateRound = interpolateRound;\nexports.interpolateString = interpolateString;\nexports.interpolateTransformCss = interpolateTransformCss;\nexports.interpolateTransformSvg = interpolateTransformSvg;\nexports.interpolateZoom = interpolateZoom;\nexports.interpolateRgb = interpolateRgb;\nexports.interpolateRgbBasis = rgbBasis;\nexports.interpolateRgbBasisClosed = rgbBasisClosed;\nexports.interpolateHsl = hsl$2;\nexports.interpolateHslLong = hslLong;\nexports.interpolateLab = lab$1;\nexports.interpolateHcl = hcl$2;\nexports.interpolateHclLong = hclLong;\nexports.interpolateCubehelix = cubehelix$2;\nexports.interpolateCubehelixLong = cubehelixLong;\nexports.quantize = quantize;\nexports.path = path;\nexports.polygonArea = area$1;\nexports.polygonCentroid = centroid$1;\nexports.polygonHull = hull;\nexports.polygonContains = contains$1;\nexports.polygonLength = length$2;\nexports.quadtree = quadtree;\nexports.queue = queue;\nexports.randomUniform = uniform;\nexports.randomNormal = normal;\nexports.randomLogNormal = logNormal;\nexports.randomBates = bates;\nexports.randomIrwinHall = irwinHall;\nexports.randomExponential = exponential$1;\nexports.request = request;\nexports.html = html;\nexports.json = json;\nexports.text = text;\nexports.xml = xml;\nexports.csv = csv$1;\nexports.tsv = tsv$1;\nexports.scaleBand = band;\nexports.scalePoint = point$1;\nexports.scaleIdentity = identity$6;\nexports.scaleLinear = linear$2;\nexports.scaleLog = log$1;\nexports.scaleOrdinal = ordinal;\nexports.scaleImplicit = implicit;\nexports.scalePow = pow$1;\nexports.scaleSqrt = sqrt$1;\nexports.scaleQuantile = quantile;\nexports.scaleQuantize = quantize$1;\nexports.scaleThreshold = threshold$1;\nexports.scaleTime = time;\nexports.scaleUtc = utcTime;\nexports.schemeCategory10 = category10;\nexports.schemeCategory20b = category20b;\nexports.schemeCategory20c = category20c;\nexports.schemeCategory20 = category20;\nexports.interpolateCubehelixDefault = cubehelix$3;\nexports.interpolateRainbow = rainbow$1;\nexports.interpolateWarm = warm;\nexports.interpolateCool = cool;\nexports.interpolateViridis = viridis;\nexports.interpolateMagma = magma;\nexports.interpolateInferno = inferno;\nexports.interpolatePlasma = plasma;\nexports.scaleSequential = sequential;\nexports.creator = creator;\nexports.local = local$1;\nexports.matcher = matcher$1;\nexports.mouse = mouse;\nexports.namespace = namespace;\nexports.namespaces = namespaces;\nexports.select = select;\nexports.selectAll = selectAll;\nexports.selection = selection;\nexports.selector = selector;\nexports.selectorAll = selectorAll;\nexports.style = styleValue;\nexports.touch = touch;\nexports.touches = touches;\nexports.window = defaultView;\nexports.customEvent = customEvent;\nexports.arc = arc;\nexports.area = area$2;\nexports.line = line;\nexports.pie = pie;\nexports.areaRadial = areaRadial;\nexports.radialArea = areaRadial;\nexports.lineRadial = lineRadial$1;\nexports.radialLine = lineRadial$1;\nexports.pointRadial = pointRadial;\nexports.linkHorizontal = linkHorizontal;\nexports.linkVertical = linkVertical;\nexports.linkRadial = linkRadial;\nexports.symbol = symbol;\nexports.symbols = symbols;\nexports.symbolCircle = circle$2;\nexports.symbolCross = cross$2;\nexports.symbolDiamond = diamond;\nexports.symbolSquare = square;\nexports.symbolStar = star;\nexports.symbolTriangle = triangle;\nexports.symbolWye = wye;\nexports.curveBasisClosed = basisClosed$1;\nexports.curveBasisOpen = basisOpen;\nexports.curveBasis = basis$2;\nexports.curveBundle = bundle;\nexports.curveCardinalClosed = cardinalClosed;\nexports.curveCardinalOpen = cardinalOpen;\nexports.curveCardinal = cardinal;\nexports.curveCatmullRomClosed = catmullRomClosed;\nexports.curveCatmullRomOpen = catmullRomOpen;\nexports.curveCatmullRom = catmullRom;\nexports.curveLinearClosed = linearClosed;\nexports.curveLinear = curveLinear;\nexports.curveMonotoneX = monotoneX;\nexports.curveMonotoneY = monotoneY;\nexports.curveNatural = natural;\nexports.curveStep = step;\nexports.curveStepAfter = stepAfter;\nexports.curveStepBefore = stepBefore;\nexports.stack = stack;\nexports.stackOffsetExpand = expand;\nexports.stackOffsetDiverging = diverging;\nexports.stackOffsetNone = none$1;\nexports.stackOffsetSilhouette = silhouette;\nexports.stackOffsetWiggle = wiggle;\nexports.stackOrderAscending = ascending$2;\nexports.stackOrderDescending = descending$2;\nexports.stackOrderInsideOut = insideOut;\nexports.stackOrderNone = none$2;\nexports.stackOrderReverse = reverse;\nexports.timeInterval = newInterval;\nexports.timeMillisecond = millisecond;\nexports.timeMilliseconds = milliseconds;\nexports.utcMillisecond = millisecond;\nexports.utcMilliseconds = milliseconds;\nexports.timeSecond = second;\nexports.timeSeconds = seconds;\nexports.utcSecond = second;\nexports.utcSeconds = seconds;\nexports.timeMinute = minute;\nexports.timeMinutes = minutes;\nexports.timeHour = hour;\nexports.timeHours = hours;\nexports.timeDay = day;\nexports.timeDays = days;\nexports.timeWeek = sunday;\nexports.timeWeeks = sundays;\nexports.timeSunday = sunday;\nexports.timeSundays = sundays;\nexports.timeMonday = monday;\nexports.timeMondays = mondays;\nexports.timeTuesday = tuesday;\nexports.timeTuesdays = tuesdays;\nexports.timeWednesday = wednesday;\nexports.timeWednesdays = wednesdays;\nexports.timeThursday = thursday;\nexports.timeThursdays = thursdays;\nexports.timeFriday = friday;\nexports.timeFridays = fridays;\nexports.timeSaturday = saturday;\nexports.timeSaturdays = saturdays;\nexports.timeMonth = month;\nexports.timeMonths = months;\nexports.timeYear = year;\nexports.timeYears = years;\nexports.utcMinute = utcMinute;\nexports.utcMinutes = utcMinutes;\nexports.utcHour = utcHour;\nexports.utcHours = utcHours;\nexports.utcDay = utcDay;\nexports.utcDays = utcDays;\nexports.utcWeek = utcSunday;\nexports.utcWeeks = utcSundays;\nexports.utcSunday = utcSunday;\nexports.utcSundays = utcSundays;\nexports.utcMonday = utcMonday;\nexports.utcMondays = utcMondays;\nexports.utcTuesday = utcTuesday;\nexports.utcTuesdays = utcTuesdays;\nexports.utcWednesday = utcWednesday;\nexports.utcWednesdays = utcWednesdays;\nexports.utcThursday = utcThursday;\nexports.utcThursdays = utcThursdays;\nexports.utcFriday = utcFriday;\nexports.utcFridays = utcFridays;\nexports.utcSaturday = utcSaturday;\nexports.utcSaturdays = utcSaturdays;\nexports.utcMonth = utcMonth;\nexports.utcMonths = utcMonths;\nexports.utcYear = utcYear;\nexports.utcYears = utcYears;\nexports.timeFormatDefaultLocale = defaultLocale$1;\nexports.timeFormatLocale = formatLocale$1;\nexports.isoFormat = formatIso;\nexports.isoParse = parseIso;\nexports.now = now;\nexports.timer = timer;\nexports.timerFlush = timerFlush;\nexports.timeout = timeout$1;\nexports.interval = interval$1;\nexports.transition = transition;\nexports.active = active;\nexports.interrupt = interrupt;\nexports.voronoi = voronoi;\nexports.zoom = zoom;\nexports.zoomTransform = transform$1;\nexports.zoomIdentity = identity$8;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3/build/d3.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('./Observable');\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return Observable_1.Observable.of(this.value);\n            case 'E':\n                return Observable_1.Observable.throw(this.error);\n            case 'C':\n                return Observable_1.Observable.empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexports.Notification = Notification;\n//# sourceMappingURL=Notification.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Notification.js\n// module id = 16\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncAction.js\n// module id = 17\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncScheduler.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.iterator = symbolIteratorPonyfill(root_1.root);\n/**\n * @deprecated use iterator instead\n */\nexports.$$iterator = exports.iterator;\n//# sourceMappingURL=iterator.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/iterator.js\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var err = _super.call(this, 'argument out of range');\n        this.name = err.name = 'ArgumentOutOfRangeError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/ArgumentOutOfRangeError.js\n// module id = 20\n// module chunks = 0","/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar Subscription_1 = require('./Subscription');\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/AsyncSubject.js\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar queue_1 = require('./scheduler/queue');\nvar Subscription_1 = require('./Subscription');\nvar observeOn_1 = require('./operator/observeOn');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/ReplaySubject.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mergeAll.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\nexports.$$observable = exports.observable;\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/observable.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\nexports.$$rxSubscriber = exports.rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/rxSubscriber.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var err = _super.call(this, 'no elements in sequence');\n        this.name = err.name = 'EmptyError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return EmptyError;\n}(Error));\nexports.EmptyError = EmptyError;\n//# sourceMappingURL=EmptyError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/EmptyError.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/ObjectUnsubscribedError.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isDate.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isFunction.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isNumeric.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ScalarObservable.js\n// module id = 32\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    observables.unshift(this);\n    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/combineLatest.js\n// module id = 33\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../Observable');\nvar isScheduler_1 = require('../util/isScheduler');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar mergeAll_1 = require('./mergeAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n}\nexports.concat = concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concatStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var scheduler = null;\n    var args = observables;\n    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n        scheduler = args.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatStatic = concatStatic;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concat.js\n// module id = 34\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/map.js\n// module id = 35\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new ObserveOnOperator(scheduler, delay));\n}\nexports.observeOn = observeOn;\nvar ObserveOnOperator = (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexports.ObserveOnOperator = ObserveOnOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification_1.Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification_1.Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification_1.Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ObserveOnSubscriber = ObserveOnSubscriber;\nvar ObserveOnMessage = (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexports.ObserveOnMessage = ObserveOnMessage;\n//# sourceMappingURL=observeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/observeOn.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * <img src=\"./img/reduce.png\" width=\"100%\">\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n *   .takeUntil(Rx.Observable.interval(5000));\n * var ones = clicksInFiveSeconds.mapTo(1);\n * var seed = 0;\n * var count = ones.reduce((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nfunction reduce(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));\n}\nexports.reduce = reduce;\nvar ReduceOperator = (function () {\n    function ReduceOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ReduceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ReduceOperator;\n}());\nexports.ReduceOperator = ReduceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ReduceSubscriber = (function (_super) {\n    __extends(ReduceSubscriber, _super);\n    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n        this.hasValue = false;\n        this.acc = seed;\n        if (!this.hasSeed) {\n            this.index++;\n        }\n    }\n    ReduceSubscriber.prototype._next = function (value) {\n        if (this.hasValue || (this.hasValue = this.hasSeed)) {\n            this._tryReduce(value);\n        }\n        else {\n            this.acc = value;\n            this.hasValue = true;\n        }\n    };\n    ReduceSubscriber.prototype._tryReduce = function (value) {\n        var result;\n        try {\n            result = this.accumulator(this.acc, value, this.index++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.acc = result;\n    };\n    ReduceSubscriber.prototype._complete = function () {\n        if (this.hasValue || this.hasSeed) {\n            this.destination.next(this.acc);\n        }\n        this.destination.complete();\n    };\n    return ReduceSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ReduceSubscriber = ReduceSubscriber;\n//# sourceMappingURL=reduce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/reduce.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar Subscriber_1 = require('../Subscriber');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar iterator_1 = require('../symbol/iterator');\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zipProto() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));\n}\nexports.zipProto = zipProto;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/zip.js\n// module id = 38\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 39\n// module chunks = 0","\"use strict\";\n/* tslint:disable:no-unused-variable */\n// Subject imported before Observable to bypass circular dependency issue since\n// Subject extends Observable and Observable references Subject in it's\n// definition\nvar Subject_1 = require('./Subject');\nexports.Subject = Subject_1.Subject;\nexports.AnonymousSubject = Subject_1.AnonymousSubject;\n/* tslint:enable:no-unused-variable */\nvar Observable_1 = require('./Observable');\nexports.Observable = Observable_1.Observable;\n// statics\n/* tslint:disable:no-use-before-declare */\nrequire('./add/observable/bindCallback');\nrequire('./add/observable/bindNodeCallback');\nrequire('./add/observable/combineLatest');\nrequire('./add/observable/concat');\nrequire('./add/observable/defer');\nrequire('./add/observable/empty');\nrequire('./add/observable/forkJoin');\nrequire('./add/observable/from');\nrequire('./add/observable/fromEvent');\nrequire('./add/observable/fromEventPattern');\nrequire('./add/observable/fromPromise');\nrequire('./add/observable/generate');\nrequire('./add/observable/if');\nrequire('./add/observable/interval');\nrequire('./add/observable/merge');\nrequire('./add/observable/race');\nrequire('./add/observable/never');\nrequire('./add/observable/of');\nrequire('./add/observable/onErrorResumeNext');\nrequire('./add/observable/pairs');\nrequire('./add/observable/range');\nrequire('./add/observable/using');\nrequire('./add/observable/throw');\nrequire('./add/observable/timer');\nrequire('./add/observable/zip');\n//dom\nrequire('./add/observable/dom/ajax');\nrequire('./add/observable/dom/webSocket');\n//operators\nrequire('./add/operator/buffer');\nrequire('./add/operator/bufferCount');\nrequire('./add/operator/bufferTime');\nrequire('./add/operator/bufferToggle');\nrequire('./add/operator/bufferWhen');\nrequire('./add/operator/catch');\nrequire('./add/operator/combineAll');\nrequire('./add/operator/combineLatest');\nrequire('./add/operator/concat');\nrequire('./add/operator/concatAll');\nrequire('./add/operator/concatMap');\nrequire('./add/operator/concatMapTo');\nrequire('./add/operator/count');\nrequire('./add/operator/dematerialize');\nrequire('./add/operator/debounce');\nrequire('./add/operator/debounceTime');\nrequire('./add/operator/defaultIfEmpty');\nrequire('./add/operator/delay');\nrequire('./add/operator/delayWhen');\nrequire('./add/operator/distinct');\nrequire('./add/operator/distinctUntilChanged');\nrequire('./add/operator/distinctUntilKeyChanged');\nrequire('./add/operator/do');\nrequire('./add/operator/exhaust');\nrequire('./add/operator/exhaustMap');\nrequire('./add/operator/expand');\nrequire('./add/operator/elementAt');\nrequire('./add/operator/filter');\nrequire('./add/operator/finally');\nrequire('./add/operator/find');\nrequire('./add/operator/findIndex');\nrequire('./add/operator/first');\nrequire('./add/operator/groupBy');\nrequire('./add/operator/ignoreElements');\nrequire('./add/operator/isEmpty');\nrequire('./add/operator/audit');\nrequire('./add/operator/auditTime');\nrequire('./add/operator/last');\nrequire('./add/operator/let');\nrequire('./add/operator/every');\nrequire('./add/operator/map');\nrequire('./add/operator/mapTo');\nrequire('./add/operator/materialize');\nrequire('./add/operator/max');\nrequire('./add/operator/merge');\nrequire('./add/operator/mergeAll');\nrequire('./add/operator/mergeMap');\nrequire('./add/operator/mergeMapTo');\nrequire('./add/operator/mergeScan');\nrequire('./add/operator/min');\nrequire('./add/operator/multicast');\nrequire('./add/operator/observeOn');\nrequire('./add/operator/onErrorResumeNext');\nrequire('./add/operator/pairwise');\nrequire('./add/operator/partition');\nrequire('./add/operator/pluck');\nrequire('./add/operator/publish');\nrequire('./add/operator/publishBehavior');\nrequire('./add/operator/publishReplay');\nrequire('./add/operator/publishLast');\nrequire('./add/operator/race');\nrequire('./add/operator/reduce');\nrequire('./add/operator/repeat');\nrequire('./add/operator/repeatWhen');\nrequire('./add/operator/retry');\nrequire('./add/operator/retryWhen');\nrequire('./add/operator/sample');\nrequire('./add/operator/sampleTime');\nrequire('./add/operator/scan');\nrequire('./add/operator/sequenceEqual');\nrequire('./add/operator/share');\nrequire('./add/operator/shareReplay');\nrequire('./add/operator/single');\nrequire('./add/operator/skip');\nrequire('./add/operator/skipLast');\nrequire('./add/operator/skipUntil');\nrequire('./add/operator/skipWhile');\nrequire('./add/operator/startWith');\nrequire('./add/operator/subscribeOn');\nrequire('./add/operator/switch');\nrequire('./add/operator/switchMap');\nrequire('./add/operator/switchMapTo');\nrequire('./add/operator/take');\nrequire('./add/operator/takeLast');\nrequire('./add/operator/takeUntil');\nrequire('./add/operator/takeWhile');\nrequire('./add/operator/throttle');\nrequire('./add/operator/throttleTime');\nrequire('./add/operator/timeInterval');\nrequire('./add/operator/timeout');\nrequire('./add/operator/timeoutWith');\nrequire('./add/operator/timestamp');\nrequire('./add/operator/toArray');\nrequire('./add/operator/toPromise');\nrequire('./add/operator/window');\nrequire('./add/operator/windowCount');\nrequire('./add/operator/windowTime');\nrequire('./add/operator/windowToggle');\nrequire('./add/operator/windowWhen');\nrequire('./add/operator/withLatestFrom');\nrequire('./add/operator/zip');\nrequire('./add/operator/zipAll');\n/* tslint:disable:no-unused-variable */\nvar Subscription_1 = require('./Subscription');\nexports.Subscription = Subscription_1.Subscription;\nvar Subscriber_1 = require('./Subscriber');\nexports.Subscriber = Subscriber_1.Subscriber;\nvar AsyncSubject_1 = require('./AsyncSubject');\nexports.AsyncSubject = AsyncSubject_1.AsyncSubject;\nvar ReplaySubject_1 = require('./ReplaySubject');\nexports.ReplaySubject = ReplaySubject_1.ReplaySubject;\nvar BehaviorSubject_1 = require('./BehaviorSubject');\nexports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\nvar ConnectableObservable_1 = require('./observable/ConnectableObservable');\nexports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\nvar Notification_1 = require('./Notification');\nexports.Notification = Notification_1.Notification;\nvar EmptyError_1 = require('./util/EmptyError');\nexports.EmptyError = EmptyError_1.EmptyError;\nvar ArgumentOutOfRangeError_1 = require('./util/ArgumentOutOfRangeError');\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\nvar TimeoutError_1 = require('./util/TimeoutError');\nexports.TimeoutError = TimeoutError_1.TimeoutError;\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\nexports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\nvar timeInterval_1 = require('./operator/timeInterval');\nexports.TimeInterval = timeInterval_1.TimeInterval;\nvar timestamp_1 = require('./operator/timestamp');\nexports.Timestamp = timestamp_1.Timestamp;\nvar TestScheduler_1 = require('./testing/TestScheduler');\nexports.TestScheduler = TestScheduler_1.TestScheduler;\nvar VirtualTimeScheduler_1 = require('./scheduler/VirtualTimeScheduler');\nexports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\nvar AjaxObservable_1 = require('./observable/dom/AjaxObservable');\nexports.AjaxResponse = AjaxObservable_1.AjaxResponse;\nexports.AjaxError = AjaxObservable_1.AjaxError;\nexports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\nvar asap_1 = require('./scheduler/asap');\nvar async_1 = require('./scheduler/async');\nvar queue_1 = require('./scheduler/queue');\nvar animationFrame_1 = require('./scheduler/animationFrame');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar iterator_1 = require('./symbol/iterator');\nvar observable_1 = require('./symbol/observable');\n/* tslint:enable:no-unused-variable */\n/**\n * @typedef {Object} Rx.Scheduler\n * @property {Scheduler} queue Schedules on a queue in the current event frame\n * (trampoline scheduler). Use this for iteration operations.\n * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n * fastest transport mechanism available, either Node.js' `process.nextTick()`\n * or Web Worker MessageChannel or setTimeout or others. Use this for\n * asynchronous conversions.\n * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n * time-based operations.\n * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n * Use this for synchronizing with the platform's painting\n */\nvar Scheduler = {\n    asap: asap_1.asap,\n    queue: queue_1.queue,\n    animationFrame: animationFrame_1.animationFrame,\n    async: async_1.async\n};\nexports.Scheduler = Scheduler;\n/**\n * @typedef {Object} Rx.Symbol\n * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n * an object that has all of the traits of an Rx Subscriber, including the\n * ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription,\n * etc).\n * @property {Symbol|string} observable A symbol to use as a property name to\n * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n * to retrieve an iterator from an object.\n */\nvar Symbol = {\n    rxSubscriber: rxSubscriber_1.rxSubscriber,\n    observable: observable_1.observable,\n    iterator: iterator_1.iterator\n};\nexports.Symbol = Symbol;\n//# sourceMappingURL=Rx.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Rx.js\n// module id = 40\n// module chunks = 0","/*!\n * Vue.js v2.4.2\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefix has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listensers hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n  vm.$listeners = listeners;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (process.env.NODE_ENV !== 'production' && !source) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.2';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n              typeof console !== 'undefined' &&\n              !bailed\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers && modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (modelRs.exp) + \", \" + (modelRs.idx) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' &&\n      name === 'click' &&\n      handler && handler.modifiers && handler.modifiers.right\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el, state) || 'void 0'\n      : genElement(el, state)) + \"}}\"\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nexport default Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.esm.js\n// module id = 41\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/BehaviorSubject.js\n// module id = 42\n// module chunks = 0","\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observer.js\n// module id = 43\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('./Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/SubjectSubscription.js\n// module id = 44\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n        this._isComplete = false;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return this.lift(new RefCountOperator(this));\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ConnectableObservable.js\n// module id = 45\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar isArrayLike_1 = require('../util/isArrayLike');\nvar isPromise_1 = require('../util/isPromise');\nvar PromiseObservable_1 = require('./PromiseObservable');\nvar IteratorObservable_1 = require('./IteratorObservable');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\nvar iterator_1 = require('../symbol/iterator');\nvar Observable_1 = require('../Observable');\nvar observeOn_1 = require('../operator/observeOn');\nvar observable_1 = require('../symbol/observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromObservable = (function (_super) {\n    __extends(FromObservable, _super);\n    function FromObservable(ish, scheduler) {\n        _super.call(this, null);\n        this.ish = ish;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable from an Array, an array-like object, a Promise, an\n     * iterable object, or an Observable-like object.\n     *\n     * <span class=\"informal\">Converts almost anything to an Observable.</span>\n     *\n     * <img src=\"./img/from.png\" width=\"100%\">\n     *\n     * Convert various other objects and data types into Observables. `from`\n     * converts a Promise or an array-like or an\n     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n     * object into an Observable that emits the items in that promise or array or\n     * iterable. A String, in this context, is treated as an array of characters.\n     * Observable-like objects (contains a function named with the ES2015 Symbol\n     * for Observable) can also be converted through this operator.\n     *\n     * @example <caption>Converts an array to an Observable</caption>\n     * var array = [10, 20, 30];\n     * var result = Rx.Observable.from(array);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 10 20 30\n     *\n     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n     * function* generateDoubles(seed) {\n     *   var i = seed;\n     *   while (true) {\n     *     yield i;\n     *     i = 2 * i; // double it\n     *   }\n     * }\n     *\n     * var iterator = generateDoubles(3);\n     * var result = Rx.Observable.from(iterator).take(10);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // 3 6 12 24 48 96 192 384 768 1536\n     *\n     * @see {@link create}\n     * @see {@link fromEvent}\n     * @see {@link fromEventPattern}\n     * @see {@link fromPromise}\n     *\n     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n     * Observable-like, an Array, an iterable or an array-like object to be\n     * converted.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * emissions of values.\n     * @return {Observable<T>} The Observable whose values are originally from the\n     * input object that was converted.\n     * @static true\n     * @name from\n     * @owner Observable\n     */\n    FromObservable.create = function (ish, scheduler) {\n        if (ish != null) {\n            if (typeof ish[observable_1.observable] === 'function') {\n                if (ish instanceof Observable_1.Observable && !scheduler) {\n                    return ish;\n                }\n                return new FromObservable(ish, scheduler);\n            }\n            else if (isArray_1.isArray(ish)) {\n                return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n            }\n            else if (isPromise_1.isPromise(ish)) {\n                return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n            }\n            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n            }\n            else if (isArrayLike_1.isArrayLike(ish)) {\n                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n            }\n        }\n        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n    };\n    FromObservable.prototype._subscribe = function (subscriber) {\n        var ish = this.ish;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            return ish[observable_1.observable]().subscribe(subscriber);\n        }\n        else {\n            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n        }\n    };\n    return FromObservable;\n}(Observable_1.Observable));\nexports.FromObservable = FromObservable;\n//# sourceMappingURL=FromObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/FromObservable.js\n// module id = 46\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {PromiseLike<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/PromiseObservable.js\n// module id = 47\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../../util/root');\nvar tryCatch_1 = require('../../util/tryCatch');\nvar errorObject_1 = require('../../util/errorObject');\nvar Observable_1 = require('../../Observable');\nvar Subscriber_1 = require('../../Subscriber');\nvar map_1 = require('../../operator/map');\nfunction getCORSRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else if (!!root_1.root.XDomainRequest) {\n        return new root_1.root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else {\n        var progId = void 0;\n        try {\n            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (var i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root_1.root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root_1.root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nfunction ajaxGet(url, headers) {\n    if (headers === void 0) { headers = null; }\n    return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n}\nexports.ajaxGet = ajaxGet;\n;\nfunction ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n}\nexports.ajaxPost = ajaxPost;\n;\nfunction ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n}\nexports.ajaxDelete = ajaxDelete;\n;\nfunction ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n}\nexports.ajaxPut = ajaxPut;\n;\nfunction ajaxPatch(url, body, headers) {\n    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });\n}\nexports.ajaxPatch = ajaxPatch;\n;\nfunction ajaxGetJSON(url, headers) {\n    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })\n        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));\n}\nexports.ajaxGetJSON = ajaxGetJSON;\n;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar AjaxObservable = (function (_super) {\n    __extends(AjaxObservable, _super);\n    function AjaxObservable(urlOrRequest) {\n        _super.call(this);\n        var request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n            },\n            crossDomain: false,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (var prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    AjaxObservable.prototype._subscribe = function (subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    };\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * @example\n     * source = Rx.Observable.ajax('/products');\n     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n    */\n    AjaxObservable.create = (function () {\n        var create = function (urlOrRequest) {\n            return new AjaxObservable(urlOrRequest);\n        };\n        create.get = ajaxGet;\n        create.post = ajaxPost;\n        create.delete = ajaxDelete;\n        create.put = ajaxPut;\n        create.patch = ajaxPatch;\n        create.getJSON = ajaxGetJSON;\n        return create;\n    })();\n    return AjaxObservable;\n}(Observable_1.Observable));\nexports.AjaxObservable = AjaxObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AjaxSubscriber = (function (_super) {\n    __extends(AjaxSubscriber, _super);\n    function AjaxSubscriber(destination, request) {\n        _super.call(this, destination);\n        this.request = request;\n        this.done = false;\n        var headers = request.headers = request.headers || {};\n        // force CORS if requested\n        if (!request.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        // ensure content type is set\n        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        // properly serialize body\n        request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n        this.send();\n    }\n    AjaxSubscriber.prototype.next = function (e) {\n        this.done = true;\n        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n        var response = new AjaxResponse(e, xhr, request);\n        destination.next(response);\n    };\n    AjaxSubscriber.prototype.send = function () {\n        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n        var createXHR = request.createXHR;\n        var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n        if (xhr === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            this.xhr = xhr;\n            // set up the events before open XHR\n            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n            // You need to add the event listeners before calling open() on the request.\n            // Otherwise the progress events will not fire.\n            this.setupEvents(xhr, request);\n            // open XHR\n            var result = void 0;\n            if (user) {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n            }\n            else {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n            }\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n            // timeout, responseType and withCredentials can be set once the XHR is open\n            if (async) {\n                xhr.timeout = request.timeout;\n                xhr.responseType = request.responseType;\n            }\n            if ('withCredentials' in xhr) {\n                xhr.withCredentials = !!request.withCredentials;\n            }\n            // set headers\n            this.setHeaders(xhr, headers);\n            // finally send the request\n            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n        }\n        return xhr;\n    };\n    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            var splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(function (key) { return (encodeURI(key) + \"=\" + encodeURI(body[key])); }).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    };\n    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n        for (var key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    };\n    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n        var progressSubscriber = request.progressSubscriber;\n        function xhrTimeout(e) {\n            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n        }\n        ;\n        xhr.ontimeout = xhrTimeout;\n        xhrTimeout.request = request;\n        xhrTimeout.subscriber = this;\n        xhrTimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr) {\n            if (progressSubscriber) {\n                var xhrProgress_1;\n                xhrProgress_1 = function (e) {\n                    var progressSubscriber = xhrProgress_1.progressSubscriber;\n                    progressSubscriber.next(e);\n                };\n                if (root_1.root.XDomainRequest) {\n                    xhr.onprogress = xhrProgress_1;\n                }\n                else {\n                    xhr.upload.onprogress = xhrProgress_1;\n                }\n                xhrProgress_1.progressSubscriber = progressSubscriber;\n            }\n            var xhrError_1;\n            xhrError_1 = function (e) {\n                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxError('ajax error', this, request));\n            };\n            xhr.onerror = xhrError_1;\n            xhrError_1.request = request;\n            xhrError_1.subscriber = this;\n            xhrError_1.progressSubscriber = progressSubscriber;\n        }\n        function xhrReadyStateChange(e) {\n            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (this.readyState === 4) {\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                var status_1 = this.status === 1223 ? 204 : this.status;\n                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                // fix status code when it is 0 (0 status is undocumented).\n                // Occurs when accessing file resources or on Android 4.1 stock browser\n                // while retrieving files from application cache.\n                if (status_1 === 0) {\n                    status_1 = response ? 200 : 0;\n                }\n                if (200 <= status_1 && status_1 < 300) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                }\n            }\n        }\n        ;\n        xhr.onreadystatechange = xhrReadyStateChange;\n        xhrReadyStateChange.subscriber = this;\n        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n        xhrReadyStateChange.request = request;\n    };\n    AjaxSubscriber.prototype.unsubscribe = function () {\n        var _a = this, done = _a.done, xhr = _a.xhr;\n        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n            xhr.abort();\n        }\n        _super.prototype.unsubscribe.call(this);\n    };\n    return AjaxSubscriber;\n}(Subscriber_1.Subscriber));\nexports.AjaxSubscriber = AjaxSubscriber;\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nvar AjaxResponse = (function () {\n    function AjaxResponse(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        switch (this.responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    this.response = JSON.parse(xhr.responseText || 'null');\n                }\n                break;\n            case 'xml':\n                this.response = xhr.responseXML;\n                break;\n            case 'text':\n            default:\n                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n                break;\n        }\n    }\n    return AjaxResponse;\n}());\nexports.AjaxResponse = AjaxResponse;\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nvar AjaxError = (function (_super) {\n    __extends(AjaxError, _super);\n    function AjaxError(message, xhr, request) {\n        _super.call(this, message);\n        this.message = message;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n    }\n    return AjaxError;\n}(Error));\nexports.AjaxError = AjaxError;\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nvar AjaxTimeoutError = (function (_super) {\n    __extends(AjaxTimeoutError, _super);\n    function AjaxTimeoutError(xhr, request) {\n        _super.call(this, 'ajax timeout', xhr, request);\n    }\n    return AjaxTimeoutError;\n}(AjaxError));\nexports.AjaxTimeoutError = AjaxTimeoutError;\n//# sourceMappingURL=AjaxObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/dom/AjaxObservable.js\n// module id = 48\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nvar DistinctUntilChangedOperator = (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/distinctUntilChanged.js\n// module id = 49\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/filter.js\n// module id = 50\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return this.lift(new FindValueOperator(predicate, this, false, thisArg));\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/find.js\n// module id = 51\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../Observable');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar mergeAll_1 = require('./mergeAll');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));\n}\nexports.merge = merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nfunction mergeStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var concurrent = Number.POSITIVE_INFINITY;\n    var scheduler = null;\n    var last = observables[observables.length - 1];\n    if (isScheduler_1.isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));\n}\nexports.mergeStatic = mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/merge.js\n// module id = 52\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mergeMap.js\n// module id = 53\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mergeMapTo.js\n// module id = 54\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = require('../observable/FromObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return this.lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/onErrorResumeNext.js\n// module id = 55\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));\n}\nexports.race = race;\nfunction raceStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.raceStatic = raceStatic;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/race.js\n// module id = 56\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nexports.defaultThrottleConfig = {\n    leading: true,\n    trailing: false\n};\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/throttle.png\" width=\"100%\">\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nfunction throttle(durationSelector, config) {\n    if (config === void 0) { config = exports.defaultThrottleConfig; }\n    return this.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n}\nexports.throttle = throttle;\nvar ThrottleOperator = (function () {\n    function ThrottleOperator(durationSelector, leading, trailing) {\n        this.durationSelector = durationSelector;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n    };\n    return ThrottleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleSubscriber = (function (_super) {\n    __extends(ThrottleSubscriber, _super);\n    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.durationSelector = durationSelector;\n        this._leading = _leading;\n        this._trailing = _trailing;\n        this._hasTrailingValue = false;\n    }\n    ThrottleSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this._trailing) {\n                this._hasTrailingValue = true;\n                this._trailingValue = value;\n            }\n        }\n        else {\n            var duration = this.tryDurationSelector(value);\n            if (duration) {\n                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n            }\n            if (this._leading) {\n                this.destination.next(value);\n                if (this._trailing) {\n                    this._hasTrailingValue = true;\n                    this._trailingValue = value;\n                }\n            }\n        }\n    };\n    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n        try {\n            return this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return null;\n        }\n    };\n    ThrottleSubscriber.prototype._unsubscribe = function () {\n        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n    };\n    ThrottleSubscriber.prototype._sendTrailing = function () {\n        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;\n        if (throttled && _trailing && _hasTrailingValue) {\n            destination.next(_trailingValue);\n            this._trailingValue = null;\n            this._hasTrailingValue = false;\n        }\n    };\n    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._sendTrailing();\n        this._unsubscribe();\n    };\n    ThrottleSubscriber.prototype.notifyComplete = function () {\n        this._sendTrailing();\n        this._unsubscribe();\n    };\n    return ThrottleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=throttle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/throttle.js\n// module id = 57\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * @param scheduler\n * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timeInterval\n * @owner Observable\n */\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimeIntervalOperator(scheduler));\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/timeInterval.js\n// module id = 58\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\nvar TimestampOperator = (function () {\n    function TimestampOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimestampOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));\n    };\n    return TimestampOperator;\n}());\nvar TimestampSubscriber = (function (_super) {\n    __extends(TimestampSubscriber, _super);\n    function TimestampSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n    }\n    TimestampSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        this.destination.next(new Timestamp(value, now));\n    };\n    return TimestampSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/timestamp.js\n// module id = 59\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar VirtualTimeScheduler = (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        var _this = this;\n        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }\n        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }\n        _super.call(this, SchedulerAction, function () { return _this.frame; });\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar VirtualAction = (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) { index = scheduler.index += 1; }\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.active = true;\n        this.index = scheduler.index = index;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (!this.id) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.active = false;\n        // If an action is rescheduled, we save allocations by mutating its state,\n        // pushing it to the end of the scheduler queue, and recycling the action.\n        // But since the VirtualTimeScheduler is used for testing, VirtualActions\n        // must be immutable so they can be inspected later.\n        var action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction_1.AsyncAction));\nexports.VirtualAction = VirtualAction;\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/VirtualTimeScheduler.js\n// module id = 60\n// module chunks = 0","\"use strict\";\nvar AsapAction_1 = require('./AsapAction');\nvar AsapScheduler_1 = require('./AsapScheduler');\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * @example <caption>Compare async and asap scheduler</caption>\n *\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n *\n * @static true\n * @name asap\n * @owner Scheduler\n */\nexports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n//# sourceMappingURL=asap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/asap.js\n// module id = 61\n// module chunks = 0","\"use strict\";\nvar QueueAction_1 = require('./QueueAction');\nvar QueueScheduler_1 = require('./QueueScheduler');\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/queue.js\n// module id = 62\n// module chunks = 0","\"use strict\";\nvar SubscriptionLog = (function () {\n    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }\n        this.subscribedFrame = subscribedFrame;\n        this.unsubscribedFrame = unsubscribedFrame;\n    }\n    return SubscriptionLog;\n}());\nexports.SubscriptionLog = SubscriptionLog;\n//# sourceMappingURL=SubscriptionLog.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/testing/SubscriptionLog.js\n// module id = 63\n// module chunks = 0","\"use strict\";\nvar SubscriptionLog_1 = require('./SubscriptionLog');\nvar SubscriptionLoggable = (function () {\n    function SubscriptionLoggable() {\n        this.subscriptions = [];\n    }\n    SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n        return this.subscriptions.length - 1;\n    };\n    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n        var subscriptionLogs = this.subscriptions;\n        var oldSubscriptionLog = subscriptionLogs[index];\n        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n    };\n    return SubscriptionLoggable;\n}());\nexports.SubscriptionLoggable = SubscriptionLoggable;\n//# sourceMappingURL=SubscriptionLoggable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/testing/SubscriptionLoggable.js\n// module id = 64\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/TimeoutError.js\n// module id = 65\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/UnsubscriptionError.js\n// module id = 66\n// module chunks = 0","\"use strict\";\nfunction applyMixins(derivedCtor, baseCtors) {\n    for (var i = 0, len = baseCtors.length; i < len; i++) {\n        var baseCtor = baseCtors[i];\n        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n            var name_1 = propertyKeys[j];\n            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n        }\n    }\n}\nexports.applyMixins = applyMixins;\n//# sourceMappingURL=applyMixins.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/applyMixins.js\n// module id = 67\n// module chunks = 0","\"use strict\";\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isArrayLike.js\n// module id = 68\n// module chunks = 0","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isObject.js\n// module id = 69\n// module chunks = 0","\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isPromise.js\n// module id = 70\n// module chunks = 0","\"use strict\";\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/noop.js\n// module id = 71\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 72\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.VueRx = factory());\n}(this, (function () { 'use strict';\n\nvar Rx$1;\nvar Vue$1;\nvar warn = function () {};\n\nfunction install (_Vue, _Rx) {\n  Rx$1 = _Rx;\n  Vue$1 = _Vue;\n  warn = Vue$1.util.warn || warn;\n}\n\nfunction hasRx (vm) {\n  if (!Rx$1) {\n    warn(\n      '$watchAsObservable requires Rx to be present globally or ' +\n      'be passed to Vue.use() as the second argument.',\n      vm\n    );\n    return false\n  }\n  return true\n}\n\nfunction isObservable (ob) {\n  return ob && typeof ob.subscribe === 'function'\n}\n\nfunction isSubject (subject) {\n  return subject && (\n    typeof subject.next === 'function' ||\n    typeof subject.onNext === 'function'\n  )\n}\n\nfunction unsub (handle) {\n  if (!handle) { return }\n  if (handle.dispose) {\n    handle.dispose();\n  } else if (handle.unsubscribe) {\n    handle.unsubscribe();\n  }\n}\n\nfunction getDisposable (target) {\n  if (Rx$1.Subscription) { // Rx5\n    return new Rx$1.Subscription(target)\n  } else { // Rx4\n    return Rx$1.Disposable.create(target)\n  }\n}\n\nfunction defineReactive (vm, key, val) {\n  if (key in vm) {\n    vm[key] = val;\n  } else {\n    Vue$1.util.defineReactive(vm, key, val);\n  }\n}\n\nfunction getKey (binding) {\n  return [binding.arg].concat(Object.keys(binding.modifiers)).join(':')\n}\n\nvar rxMixin = {\n  created: function created () {\n    var vm = this;\n    var domStreams = vm.$options.domStreams;\n    if (domStreams) {\n      if (!Rx$1.Subject) {\n        warn('Rx.Subject is required to use the \"domStreams\" option.');\n      } else {\n        domStreams.forEach(function (key) {\n          vm[key] = new Rx$1.Subject();\n        });\n      }\n    }\n\n    var observableMethods = vm.$options.observableMethods;\n    if (observableMethods) {\n      if (Array.isArray(observableMethods)) {\n        observableMethods.forEach(function (methodName) {\n          vm[ methodName + '$' ] = vm.$createObservableMethod(methodName);\n        });\n      } else {\n        Object.keys(observableMethods).forEach(function (methodName) {\n          vm[observableMethods[methodName]] = vm.$createObservableMethod(methodName);\n        });\n      }\n    }\n\n    var obs = vm.$options.subscriptions;\n    if (typeof obs === 'function') {\n      obs = obs.call(vm);\n    }\n    if (obs) {\n      vm.$observables = {};\n      vm._obSubscriptions = [];\n      Object.keys(obs).forEach(function (key) {\n        defineReactive(vm, key, undefined);\n        var ob = vm.$observables[key] = obs[key];\n        if (!isObservable(ob)) {\n          warn(\n            'Invalid Observable found in subscriptions option with key \"' + key + '\".',\n            vm\n          );\n          return\n        }\n        vm._obSubscriptions.push(obs[key].subscribe(function (value) {\n          vm[key] = value;\n        }));\n      });\n    }\n  },\n\n  beforeDestroy: function beforeDestroy () {\n    if (this._obSubscriptions) {\n      this._obSubscriptions.forEach(unsub);\n    }\n  }\n};\n\nvar streamDirective = {\n  // Example ./example/counter_dir.html\n  bind: function bind (el, binding, vnode) {\n    if (!hasRx()) {\n      return\n    }\n\n    var handle = binding.value;\n    var event = binding.arg;\n    var streamName = binding.expression;\n    var modifiers = binding.modifiers;\n\n    if (isSubject(handle)) {\n      handle = { subject: handle };\n    } else if (!handle || !isSubject(handle.subject)) {\n      warn(\n        'Invalid Subject found in directive with key \"' + streamName + '\".' +\n        streamName + ' should be an instance of Rx.Subject or have the ' +\n        'type { subject: Rx.Subject, data: any }.',\n        vnode.context\n      );\n      return\n    }\n\n    var subject = handle.subject;\n    var next = (subject.next || subject.onNext).bind(subject);\n\n    if (!modifiers.native && vnode.componentInstance) {\n      handle.subscription = vnode.componentInstance.$eventToObservable(event).subscribe(function (e) {\n        next({\n          event: e,\n          data: handle.data\n        });\n      });\n    } else {\n      if (!Rx$1.Observable.fromEvent) {\n        warn(\n          \"No 'fromEvent' method on Observable class. \" +\n          \"v-stream directive requires Rx.Observable.fromEvent method. \" +\n          \"Try import 'rxjs/add/observable/fromEvent' for \" + streamName,\n          vnode.context\n        );\n        return\n      }\n      var fromEventArgs = handle.options ? [el, event, handle.options] : [el, event];\n      handle.subscription = (ref = Rx$1.Observable).fromEvent.apply(ref, fromEventArgs).subscribe(function (e) {\n        next({\n          event: e,\n          data: handle.data\n        });\n      })\n\n      // store handle on element with a unique key for identifying\n      // multiple v-stream directives on the same node\n      ;(el._rxHandles || (el._rxHandles = {}))[getKey(binding)] = handle;\n    }\n    var ref;\n  },\n\n  update: function update (el, binding) {\n    var handle = binding.value;\n    var _handle = el._rxHandles && el._rxHandles[getKey(binding)];\n    if (_handle && handle && isSubject(handle.subject)) {\n      _handle.data = handle.data;\n    }\n  },\n\n  unbind: function unbind (el, binding) {\n    var key = getKey(binding);\n    var handle = el._rxHandles && el._rxHandles[key];\n    if (handle) {\n      unsub(handle.subscription);\n      el._rxHandles[key] = null;\n    }\n  }\n};\n\nfunction watchAsObservable (expOrFn, options) {\n  if (!hasRx()) {\n    return\n  }\n\n  var vm = this;\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    var _unwatch;\n    var watch = function () {\n      _unwatch = vm.$watch(expOrFn, function (newValue, oldValue) {\n        observer.next({ oldValue: oldValue, newValue: newValue });\n      }, options);\n    };\n\n    // if $watchAsObservable is called inside the subscriptions function,\n    // because data hasn't been observed yet, the watcher will not work.\n    // in that case, wait until created hook to watch.\n    if (vm._data) {\n      watch();\n    } else {\n      vm.$once('hook:created', watch);\n    }\n\n    // Returns function which disconnects the $watch expression\n    return getDisposable(function () {\n      _unwatch && _unwatch();\n    })\n  });\n\n  return obs$\n}\n\nfunction fromDOMEvent (selector, event) {\n  if (!hasRx()) {\n    return\n  }\n  if (typeof window === 'undefined') {\n    return Rx$1.Observable.create(function () {})\n  }\n\n  var vm = this;\n  var doc = document.documentElement;\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    function listener (e) {\n      if (!vm.$el) { return }\n      if (selector === null && vm.$el === e.target) { return observer.next(e) }\n      var els = vm.$el.querySelectorAll(selector);\n      var el = e.target;\n      for (var i = 0, len = els.length; i < len; i++) {\n        if (els[i] === el) { return observer.next(e) }\n      }\n    }\n    doc.addEventListener(event, listener);\n    // Returns function which disconnects the $watch expression\n    return getDisposable(function () {\n      doc.removeEventListener(event, listener);\n    })\n  });\n\n  return obs$\n}\n\nfunction subscribeTo (observable, next, error, complete) {\n  var obs$ = observable.subscribe(next, error, complete);(this._obSubscriptions || (this._obSubscriptions = [])).push(obs$);\n  return obs$\n}\n\n/**\n * @see {@link https://vuejs.org/v2/api/#vm-on}\n * @param {String||Array} evtName Event name\n * @return {Observable} Event stream\n */\nfunction eventToObservable (evtName) {\n  if (!hasRx()) {\n    return\n  }\n  var vm = this;\n  var evtNames = Array.isArray(evtName) ? evtName : [evtName];\n  var obs$ = Rx$1.Observable.create(function (observer) {\n    var eventPairs = evtNames.map(function (name) {\n      var callback = function (msg) { return observer.next({ name: name, msg: msg }); };\n      vm.$on(name, callback);\n      return { name: name, callback: callback }\n    });\n    return function () {\n      // Only remove the specific callback\n      eventPairs.forEach(function (pair) { return vm.$off(pair.name, pair.callback); });\n    }\n  });\n\n  return obs$\n}\n\n/**\n * @name Vue.prototype.$createObservableMethod\n * @description Creates an observable from a given function name.\n * @param {String} methodName Function name\n * @param {Boolean} [passContext] Append the call context at the end of emit data?\n * @return {Observable} Hot stream\n */\nfunction createObservableMethod (methodName, passContext) {\n  if (!hasRx()) {\n    return\n  }\n  var vm = this;\n\n  if (!Rx$1.Observable.prototype.share) {\n    warn(\n      \"No 'share' operator. \" +\n      \"$createObservableMethod returns a shared hot observable. \" +\n      \"Try import 'rxjs/add/operator/share' for creating \" + methodName,\n      vm\n    );\n    return\n  }\n\n  if (vm[methodName] !== undefined) {\n    warn(\n      'Potential bug: ' +\n      \"Method \" + methodName + \" already defined on vm and has been overwritten by $createObservableMethod.\" +\n      String(vm[methodName]),\n      vm\n    );\n  }\n\n  var creator = function (observer) {\n    vm[methodName] = function () {\n      var args = Array.from(arguments);\n      if (passContext) {\n        args.push(this);\n        observer.next(args);\n      } else {\n        if (args.length <= 1) {\n          observer.next(args[0]);\n        } else {\n          observer.next(args);\n        }\n      }\n    };\n    return function () {\n      delete vm[methodName];\n    }\n  };\n\n  // Must be a hot stream otherwise function context may overwrite over and over again\n  return Rx$1.Observable.create(creator).share()\n}\n\n/* global Vue, Rx */\n\nfunction VueRx (Vue$$1, Rx$$1) {\n  install(Vue$$1, Rx$$1);\n  Vue$$1.mixin(rxMixin);\n  Vue$$1.directive('stream', streamDirective);\n  Vue$$1.prototype.$watchAsObservable = watchAsObservable;\n  Vue$$1.prototype.$fromDOMEvent = fromDOMEvent;\n  Vue$$1.prototype.$subscribeTo = subscribeTo;\n  Vue$$1.prototype.$eventToObservable = eventToObservable;\n  Vue$$1.prototype.$createObservableMethod = createObservableMethod;\n}\n\n// auto install\nif (typeof Vue !== 'undefined' && typeof Rx !== 'undefined') {\n  Vue.use(VueRx, Rx);\n}\n\nreturn VueRx;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-rx/dist/vue-rx.js\n// module id = 75\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 89\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/InnerSubscriber.js\n// module id = 90\n// module chunks = 0","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Scheduler.js\n// module id = 91\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bindCallback_1 = require('../../observable/bindCallback');\nObservable_1.Observable.bindCallback = bindCallback_1.bindCallback;\n//# sourceMappingURL=bindCallback.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/bindCallback.js\n// module id = 92\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bindNodeCallback_1 = require('../../observable/bindNodeCallback');\nObservable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/bindNodeCallback.js\n// module id = 93\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar combineLatest_1 = require('../../observable/combineLatest');\nObservable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/combineLatest.js\n// module id = 94\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concat_1 = require('../../observable/concat');\nObservable_1.Observable.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/concat.js\n// module id = 95\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar defer_1 = require('../../observable/defer');\nObservable_1.Observable.defer = defer_1.defer;\n//# sourceMappingURL=defer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/defer.js\n// module id = 96\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../../Observable');\nvar ajax_1 = require('../../../observable/dom/ajax');\nObservable_1.Observable.ajax = ajax_1.ajax;\n//# sourceMappingURL=ajax.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/dom/ajax.js\n// module id = 97\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../../Observable');\nvar webSocket_1 = require('../../../observable/dom/webSocket');\nObservable_1.Observable.webSocket = webSocket_1.webSocket;\n//# sourceMappingURL=webSocket.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/dom/webSocket.js\n// module id = 98\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar empty_1 = require('../../observable/empty');\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/empty.js\n// module id = 99\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar forkJoin_1 = require('../../observable/forkJoin');\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/forkJoin.js\n// module id = 100\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar from_1 = require('../../observable/from');\nObservable_1.Observable.from = from_1.from;\n//# sourceMappingURL=from.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/from.js\n// module id = 101\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/fromEvent.js\n// module id = 102\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEventPattern_1 = require('../../observable/fromEventPattern');\nObservable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;\n//# sourceMappingURL=fromEventPattern.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/fromEventPattern.js\n// module id = 103\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromPromise_1 = require('../../observable/fromPromise');\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/fromPromise.js\n// module id = 104\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar generate_1 = require('../../observable/generate');\nObservable_1.Observable.generate = generate_1.generate;\n//# sourceMappingURL=generate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/generate.js\n// module id = 105\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar if_1 = require('../../observable/if');\nObservable_1.Observable.if = if_1._if;\n//# sourceMappingURL=if.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/if.js\n// module id = 106\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar interval_1 = require('../../observable/interval');\nObservable_1.Observable.interval = interval_1.interval;\n//# sourceMappingURL=interval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/interval.js\n// module id = 107\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../observable/merge');\nObservable_1.Observable.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/merge.js\n// module id = 108\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar never_1 = require('../../observable/never');\nObservable_1.Observable.never = never_1.never;\n//# sourceMappingURL=never.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/never.js\n// module id = 109\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar of_1 = require('../../observable/of');\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/of.js\n// module id = 110\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar onErrorResumeNext_1 = require('../../observable/onErrorResumeNext');\nObservable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/onErrorResumeNext.js\n// module id = 111\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar pairs_1 = require('../../observable/pairs');\nObservable_1.Observable.pairs = pairs_1.pairs;\n//# sourceMappingURL=pairs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/pairs.js\n// module id = 112\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar race_1 = require('../../observable/race');\nObservable_1.Observable.race = race_1.race;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/race.js\n// module id = 113\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar range_1 = require('../../observable/range');\nObservable_1.Observable.range = range_1.range;\n//# sourceMappingURL=range.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/range.js\n// module id = 114\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar throw_1 = require('../../observable/throw');\nObservable_1.Observable.throw = throw_1._throw;\n//# sourceMappingURL=throw.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/throw.js\n// module id = 115\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timer_1 = require('../../observable/timer');\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/timer.js\n// module id = 116\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar using_1 = require('../../observable/using');\nObservable_1.Observable.using = using_1.using;\n//# sourceMappingURL=using.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/using.js\n// module id = 117\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar zip_1 = require('../../observable/zip');\nObservable_1.Observable.zip = zip_1.zip;\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/zip.js\n// module id = 118\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar audit_1 = require('../../operator/audit');\nObservable_1.Observable.prototype.audit = audit_1.audit;\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/audit.js\n// module id = 119\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar auditTime_1 = require('../../operator/auditTime');\nObservable_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/auditTime.js\n// module id = 120\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar buffer_1 = require('../../operator/buffer');\nObservable_1.Observable.prototype.buffer = buffer_1.buffer;\n//# sourceMappingURL=buffer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/buffer.js\n// module id = 121\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bufferCount_1 = require('../../operator/bufferCount');\nObservable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/bufferCount.js\n// module id = 122\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bufferTime_1 = require('../../operator/bufferTime');\nObservable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n//# sourceMappingURL=bufferTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/bufferTime.js\n// module id = 123\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bufferToggle_1 = require('../../operator/bufferToggle');\nObservable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n//# sourceMappingURL=bufferToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/bufferToggle.js\n// module id = 124\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar bufferWhen_1 = require('../../operator/bufferWhen');\nObservable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n//# sourceMappingURL=bufferWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/bufferWhen.js\n// module id = 125\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar catch_1 = require('../../operator/catch');\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/catch.js\n// module id = 126\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar combineAll_1 = require('../../operator/combineAll');\nObservable_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/combineAll.js\n// module id = 127\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar combineLatest_1 = require('../../operator/combineLatest');\nObservable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/combineLatest.js\n// module id = 128\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concat_1 = require('../../operator/concat');\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/concat.js\n// module id = 129\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concatAll_1 = require('../../operator/concatAll');\nObservable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/concatAll.js\n// module id = 130\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concatMap_1 = require('../../operator/concatMap');\nObservable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/concatMap.js\n// module id = 131\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concatMapTo_1 = require('../../operator/concatMapTo');\nObservable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/concatMapTo.js\n// module id = 132\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar count_1 = require('../../operator/count');\nObservable_1.Observable.prototype.count = count_1.count;\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/count.js\n// module id = 133\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar debounce_1 = require('../../operator/debounce');\nObservable_1.Observable.prototype.debounce = debounce_1.debounce;\n//# sourceMappingURL=debounce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/debounce.js\n// module id = 134\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar debounceTime_1 = require('../../operator/debounceTime');\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/debounceTime.js\n// module id = 135\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar defaultIfEmpty_1 = require('../../operator/defaultIfEmpty');\nObservable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/defaultIfEmpty.js\n// module id = 136\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar delay_1 = require('../../operator/delay');\nObservable_1.Observable.prototype.delay = delay_1.delay;\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/delay.js\n// module id = 137\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar delayWhen_1 = require('../../operator/delayWhen');\nObservable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n//# sourceMappingURL=delayWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/delayWhen.js\n// module id = 138\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar dematerialize_1 = require('../../operator/dematerialize');\nObservable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n//# sourceMappingURL=dematerialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/dematerialize.js\n// module id = 139\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar distinct_1 = require('../../operator/distinct');\nObservable_1.Observable.prototype.distinct = distinct_1.distinct;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/distinct.js\n// module id = 140\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar distinctUntilChanged_1 = require('../../operator/distinctUntilChanged');\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/distinctUntilChanged.js\n// module id = 141\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar distinctUntilKeyChanged_1 = require('../../operator/distinctUntilKeyChanged');\nObservable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/distinctUntilKeyChanged.js\n// module id = 142\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar do_1 = require('../../operator/do');\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/do.js\n// module id = 143\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar elementAt_1 = require('../../operator/elementAt');\nObservable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n//# sourceMappingURL=elementAt.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/elementAt.js\n// module id = 144\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar every_1 = require('../../operator/every');\nObservable_1.Observable.prototype.every = every_1.every;\n//# sourceMappingURL=every.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/every.js\n// module id = 145\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar exhaust_1 = require('../../operator/exhaust');\nObservable_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n//# sourceMappingURL=exhaust.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/exhaust.js\n// module id = 146\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar exhaustMap_1 = require('../../operator/exhaustMap');\nObservable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/exhaustMap.js\n// module id = 147\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar expand_1 = require('../../operator/expand');\nObservable_1.Observable.prototype.expand = expand_1.expand;\n//# sourceMappingURL=expand.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/expand.js\n// module id = 148\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar filter_1 = require('../../operator/filter');\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/filter.js\n// module id = 149\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar finally_1 = require('../../operator/finally');\nObservable_1.Observable.prototype.finally = finally_1._finally;\nObservable_1.Observable.prototype._finally = finally_1._finally;\n//# sourceMappingURL=finally.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/finally.js\n// module id = 150\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar find_1 = require('../../operator/find');\nObservable_1.Observable.prototype.find = find_1.find;\n//# sourceMappingURL=find.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/find.js\n// module id = 151\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar findIndex_1 = require('../../operator/findIndex');\nObservable_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/findIndex.js\n// module id = 152\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar first_1 = require('../../operator/first');\nObservable_1.Observable.prototype.first = first_1.first;\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/first.js\n// module id = 153\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar groupBy_1 = require('../../operator/groupBy');\nObservable_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n//# sourceMappingURL=groupBy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/groupBy.js\n// module id = 154\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar ignoreElements_1 = require('../../operator/ignoreElements');\nObservable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n//# sourceMappingURL=ignoreElements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/ignoreElements.js\n// module id = 155\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar isEmpty_1 = require('../../operator/isEmpty');\nObservable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n//# sourceMappingURL=isEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/isEmpty.js\n// module id = 156\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar last_1 = require('../../operator/last');\nObservable_1.Observable.prototype.last = last_1.last;\n//# sourceMappingURL=last.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/last.js\n// module id = 157\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar let_1 = require('../../operator/let');\nObservable_1.Observable.prototype.let = let_1.letProto;\nObservable_1.Observable.prototype.letBind = let_1.letProto;\n//# sourceMappingURL=let.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/let.js\n// module id = 158\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/map.js\n// module id = 159\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mapTo_1 = require('../../operator/mapTo');\nObservable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mapTo.js\n// module id = 160\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar materialize_1 = require('../../operator/materialize');\nObservable_1.Observable.prototype.materialize = materialize_1.materialize;\n//# sourceMappingURL=materialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/materialize.js\n// module id = 161\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar max_1 = require('../../operator/max');\nObservable_1.Observable.prototype.max = max_1.max;\n//# sourceMappingURL=max.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/max.js\n// module id = 162\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../operator/merge');\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/merge.js\n// module id = 163\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeAll_1 = require('../../operator/mergeAll');\nObservable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mergeAll.js\n// module id = 164\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mergeMap.js\n// module id = 165\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMapTo_1 = require('../../operator/mergeMapTo');\nObservable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\nObservable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mergeMapTo.js\n// module id = 166\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeScan_1 = require('../../operator/mergeScan');\nObservable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n//# sourceMappingURL=mergeScan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/mergeScan.js\n// module id = 167\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar min_1 = require('../../operator/min');\nObservable_1.Observable.prototype.min = min_1.min;\n//# sourceMappingURL=min.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/min.js\n// module id = 168\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar multicast_1 = require('../../operator/multicast');\nObservable_1.Observable.prototype.multicast = multicast_1.multicast;\n//# sourceMappingURL=multicast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/multicast.js\n// module id = 169\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar observeOn_1 = require('../../operator/observeOn');\nObservable_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n//# sourceMappingURL=observeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/observeOn.js\n// module id = 170\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar onErrorResumeNext_1 = require('../../operator/onErrorResumeNext');\nObservable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/onErrorResumeNext.js\n// module id = 171\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar pairwise_1 = require('../../operator/pairwise');\nObservable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/pairwise.js\n// module id = 172\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar partition_1 = require('../../operator/partition');\nObservable_1.Observable.prototype.partition = partition_1.partition;\n//# sourceMappingURL=partition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/partition.js\n// module id = 173\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar pluck_1 = require('../../operator/pluck');\nObservable_1.Observable.prototype.pluck = pluck_1.pluck;\n//# sourceMappingURL=pluck.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/pluck.js\n// module id = 174\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar publish_1 = require('../../operator/publish');\nObservable_1.Observable.prototype.publish = publish_1.publish;\n//# sourceMappingURL=publish.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/publish.js\n// module id = 175\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar publishBehavior_1 = require('../../operator/publishBehavior');\nObservable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/publishBehavior.js\n// module id = 176\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar publishLast_1 = require('../../operator/publishLast');\nObservable_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/publishLast.js\n// module id = 177\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar publishReplay_1 = require('../../operator/publishReplay');\nObservable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/publishReplay.js\n// module id = 178\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar race_1 = require('../../operator/race');\nObservable_1.Observable.prototype.race = race_1.race;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/race.js\n// module id = 179\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar reduce_1 = require('../../operator/reduce');\nObservable_1.Observable.prototype.reduce = reduce_1.reduce;\n//# sourceMappingURL=reduce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/reduce.js\n// module id = 180\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar repeat_1 = require('../../operator/repeat');\nObservable_1.Observable.prototype.repeat = repeat_1.repeat;\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/repeat.js\n// module id = 181\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar repeatWhen_1 = require('../../operator/repeatWhen');\nObservable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n//# sourceMappingURL=repeatWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/repeatWhen.js\n// module id = 182\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar retry_1 = require('../../operator/retry');\nObservable_1.Observable.prototype.retry = retry_1.retry;\n//# sourceMappingURL=retry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/retry.js\n// module id = 183\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar retryWhen_1 = require('../../operator/retryWhen');\nObservable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/retryWhen.js\n// module id = 184\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar sample_1 = require('../../operator/sample');\nObservable_1.Observable.prototype.sample = sample_1.sample;\n//# sourceMappingURL=sample.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/sample.js\n// module id = 185\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar sampleTime_1 = require('../../operator/sampleTime');\nObservable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n//# sourceMappingURL=sampleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/sampleTime.js\n// module id = 186\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar scan_1 = require('../../operator/scan');\nObservable_1.Observable.prototype.scan = scan_1.scan;\n//# sourceMappingURL=scan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/scan.js\n// module id = 187\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar sequenceEqual_1 = require('../../operator/sequenceEqual');\nObservable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n//# sourceMappingURL=sequenceEqual.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/sequenceEqual.js\n// module id = 188\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar share_1 = require('../../operator/share');\nObservable_1.Observable.prototype.share = share_1.share;\n//# sourceMappingURL=share.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/share.js\n// module id = 189\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar shareReplay_1 = require('../../operator/shareReplay');\nObservable_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;\n//# sourceMappingURL=shareReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/shareReplay.js\n// module id = 190\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar single_1 = require('../../operator/single');\nObservable_1.Observable.prototype.single = single_1.single;\n//# sourceMappingURL=single.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/single.js\n// module id = 191\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar skip_1 = require('../../operator/skip');\nObservable_1.Observable.prototype.skip = skip_1.skip;\n//# sourceMappingURL=skip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/skip.js\n// module id = 192\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar skipLast_1 = require('../../operator/skipLast');\nObservable_1.Observable.prototype.skipLast = skipLast_1.skipLast;\n//# sourceMappingURL=skipLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/skipLast.js\n// module id = 193\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar skipUntil_1 = require('../../operator/skipUntil');\nObservable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/skipUntil.js\n// module id = 194\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar skipWhile_1 = require('../../operator/skipWhile');\nObservable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/skipWhile.js\n// module id = 195\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar startWith_1 = require('../../operator/startWith');\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/startWith.js\n// module id = 196\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar subscribeOn_1 = require('../../operator/subscribeOn');\nObservable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n//# sourceMappingURL=subscribeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/subscribeOn.js\n// module id = 197\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switch_1 = require('../../operator/switch');\nObservable_1.Observable.prototype.switch = switch_1._switch;\nObservable_1.Observable.prototype._switch = switch_1._switch;\n//# sourceMappingURL=switch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/switch.js\n// module id = 198\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMap_1 = require('../../operator/switchMap');\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/switchMap.js\n// module id = 199\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMapTo_1 = require('../../operator/switchMapTo');\nObservable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/switchMapTo.js\n// module id = 200\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar take_1 = require('../../operator/take');\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/take.js\n// module id = 201\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar takeLast_1 = require('../../operator/takeLast');\nObservable_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n//# sourceMappingURL=takeLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/takeLast.js\n// module id = 202\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar takeUntil_1 = require('../../operator/takeUntil');\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/takeUntil.js\n// module id = 203\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar takeWhile_1 = require('../../operator/takeWhile');\nObservable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n//# sourceMappingURL=takeWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/takeWhile.js\n// module id = 204\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar throttle_1 = require('../../operator/throttle');\nObservable_1.Observable.prototype.throttle = throttle_1.throttle;\n//# sourceMappingURL=throttle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/throttle.js\n// module id = 205\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar throttleTime_1 = require('../../operator/throttleTime');\nObservable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n//# sourceMappingURL=throttleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/throttleTime.js\n// module id = 206\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timeInterval_1 = require('../../operator/timeInterval');\nObservable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n//# sourceMappingURL=timeInterval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/timeInterval.js\n// module id = 207\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timeout_1 = require('../../operator/timeout');\nObservable_1.Observable.prototype.timeout = timeout_1.timeout;\n//# sourceMappingURL=timeout.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/timeout.js\n// module id = 208\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timeoutWith_1 = require('../../operator/timeoutWith');\nObservable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n//# sourceMappingURL=timeoutWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/timeoutWith.js\n// module id = 209\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timestamp_1 = require('../../operator/timestamp');\nObservable_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/timestamp.js\n// module id = 210\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar toArray_1 = require('../../operator/toArray');\nObservable_1.Observable.prototype.toArray = toArray_1.toArray;\n//# sourceMappingURL=toArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/toArray.js\n// module id = 211\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar toPromise_1 = require('../../operator/toPromise');\nObservable_1.Observable.prototype.toPromise = toPromise_1.toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/toPromise.js\n// module id = 212\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar window_1 = require('../../operator/window');\nObservable_1.Observable.prototype.window = window_1.window;\n//# sourceMappingURL=window.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/window.js\n// module id = 213\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar windowCount_1 = require('../../operator/windowCount');\nObservable_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n//# sourceMappingURL=windowCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/windowCount.js\n// module id = 214\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar windowTime_1 = require('../../operator/windowTime');\nObservable_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n//# sourceMappingURL=windowTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/windowTime.js\n// module id = 215\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar windowToggle_1 = require('../../operator/windowToggle');\nObservable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n//# sourceMappingURL=windowToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/windowToggle.js\n// module id = 216\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar windowWhen_1 = require('../../operator/windowWhen');\nObservable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n//# sourceMappingURL=windowWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/windowWhen.js\n// module id = 217\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar withLatestFrom_1 = require('../../operator/withLatestFrom');\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/withLatestFrom.js\n// module id = 218\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar zip_1 = require('../../operator/zip');\nObservable_1.Observable.prototype.zip = zip_1.zipProto;\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/zip.js\n// module id = 219\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar zipAll_1 = require('../../operator/zipAll');\nObservable_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/zipAll.js\n// module id = 220\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayLikeObservable = (function (_super) {\n    __extends(ArrayLikeObservable, _super);\n    function ArrayLikeObservable(arrayLike, scheduler) {\n        _super.call(this);\n        this.arrayLike = arrayLike;\n        this.scheduler = scheduler;\n        if (!scheduler && arrayLike.length === 1) {\n            this._isScalar = true;\n            this.value = arrayLike[0];\n        }\n    }\n    ArrayLikeObservable.create = function (arrayLike, scheduler) {\n        var length = arrayLike.length;\n        if (length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (length === 1) {\n            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n        }\n        else {\n            return new ArrayLikeObservable(arrayLike, scheduler);\n        }\n    };\n    ArrayLikeObservable.dispatch = function (state) {\n        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n        if (subscriber.closed) {\n            return;\n        }\n        if (index >= length) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(arrayLike[index]);\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n        var length = arrayLike.length;\n        if (scheduler) {\n            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < length && !subscriber.closed; i++) {\n                subscriber.next(arrayLike[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayLikeObservable;\n}(Observable_1.Observable));\nexports.ArrayLikeObservable = ArrayLikeObservable;\n//# sourceMappingURL=ArrayLikeObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ArrayLikeObservable.js\n// module id = 221\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundCallbackObservable = (function (_super) {\n    __extends(BoundCallbackObservable, _super);\n    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a callback API to a function that returns an Observable.\n     *\n     * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n     * it will return a function `g` that when called as `g(x)` will output an\n     * Observable.</span>\n     *\n     * `bindCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done.\n     *\n     * The output of `bindCallback` is a function that takes the same parameters\n     * as `func`, except the last one (the callback). When the output function\n     * is called with arguments, it will return an Observable. If `func` function\n     * calls its callback with one argument, the Observable will emit that value.\n     * If on the other hand callback is called with multiple values, resulting\n     * Observable will emit an array with these arguments.\n     *\n     * It is very important to remember, that input function `func` is not called\n     * when output function is, but rather when Observable returned by output\n     * function is subscribed. This means if `func` makes AJAX request, that request\n     * will be made every time someone subscribes to resulting Observable, but not before.\n     *\n     * Optionally, selector function can be passed to `bindObservable`. That function\n     * takes the same arguments as callback, and returns value\n     * that will be emitted by Observable instead of callback parameters themselves.\n     * Even though by default multiple arguments passed to callback appear in the stream as array,\n     * selector function will be called with arguments directly, just as callback would.\n     * This means you can imagine default selector (when one is not provided explicitly)\n     * as function that aggregates all its arguments into array, or simply returns first argument,\n     * if there is only one.\n     *\n     * Last optional parameter - {@link Scheduler} - can be used to control when call\n     * to `func` happens after someone subscribes to Observable, as well as when results\n     * passed to callback will be emitted. By default subscription to Observable calls `func`\n     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,\n     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler\n     * and call `subscribe` on output Observable, all function calls that are currently executing,\n     * will end before `func` is invoked.\n     *\n     * When it comes to emitting results passed to callback, by default they are emitted\n     * immediately after `func` invokes callback. In particular, if callback is called synchronously,\n     * then subscription to resulting Observable will call `next` function synchronously as well.\n     * If you want to defer that call, using `Scheduler.async` will, again, do the job.\n     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`\n     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n     *\n     * Note that Observable created by output function will always emit only one value\n     * and then complete right after. Even if `func` calls callback multiple times, values from\n     * second and following calls will never appear in the stream. If you need to\n     * listen for multiple calls, you probably want to use {@link fromEvent} or\n     * {@link fromEventPattern} instead.\n     *\n     * If `func` depends on some context (`this` property), that context will be set\n     * to the same context that output function has at call time. In particular, if `func`\n     * is called as method of some object, in order to preserve proper behaviour,\n     * it is recommended to set context of output function to that object as well,\n     * provided `func` is not already bound.\n     *\n     * If input function calls its callback in \"node style\" (i.e. first argument to callback is\n     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}\n     * provides convenient error handling and probably is a better choice.\n     * `bindCallback` will treat such functions without any difference and error parameter\n     * (whether passed or not) will always be interpreted as regular callback argument.\n     *\n     *\n     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n     * // Suppose we have jQuery.getJSON('/my/url', callback)\n     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n     * var result = getJSONAsObservable('/my/url');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Receive array of arguments passed to callback</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 5\n     *   console.log(b); // 'some string'\n     *   console.log(c); // {someProperty: 'someValue'}\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n     * boundSomeFunction().subscribe(values => {\n     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n     * });\n     *\n     *\n     * @example <caption>Use bindCallback with selector function</caption>\n     * someFunction((a, b, c) => {\n     *   console.log(a); // 'a'\n     *   console.log(b); // 'b'\n     *   console.log(c); // 'c'\n     * });\n     *\n     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n     * boundSomeFunction().subscribe(value => {\n     *   console.log(value) // 'abc'\n     * });\n     *\n     *\n     * @example <caption>Compare behaviour with and without async Scheduler</caption>\n     * function iCallMyCallbackSynchronously(cb) {\n     *   cb();\n     * }\n     *\n     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n     *\n     * boundSyncFn().subscribe(() => console.log('I was sync!'));\n     * boundAsyncFn().subscribe(() => console.log('I was async!'));\n     * console.log('This happened...');\n     *\n     * // Logs:\n     * // I was sync!\n     * // This happened...\n     * // I was async!\n     *\n     *\n     * @example <caption>Use bindCallback on object method</caption>\n     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n     * .subscribe(subscriber);\n     *\n     *\n     * @see {@link bindNodeCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps those to a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the callback would deliver.\n     * @static true\n     * @name bindCallback\n     * @owner Observable\n     */\n    BoundCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    BoundCallbackObservable.dispatch = function (state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i - 0] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                subject.error(errorObject_1.errorObject.e);\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    };\n    return BoundCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundCallbackObservable = BoundCallbackObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundCallbackObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/BoundCallbackObservable.js\n// module id = 222\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar BoundNodeCallbackObservable = (function (_super) {\n    __extends(BoundNodeCallbackObservable, _super);\n    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n        _super.call(this);\n        this.callbackFunc = callbackFunc;\n        this.selector = selector;\n        this.args = args;\n        this.context = context;\n        this.scheduler = scheduler;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a Node.js-style callback API to a function that returns an\n     * Observable.\n     *\n     * <span class=\"informal\">It's just like {@link bindCallback}, but the\n     * callback is expected to be of type `callback(error, result)`.</span>\n     *\n     * `bindNodeCallback` is not an operator because its input and output are not\n     * Observables. The input is a function `func` with some parameters, but the\n     * last parameter must be a callback function that `func` calls when it is\n     * done. The callback function is expected to follow Node.js conventions,\n     * where the first argument to the callback is an error object, signaling\n     * whether call was successful. If that object is passed to callback, it means\n     * something went wrong.\n     *\n     * The output of `bindNodeCallback` is a function that takes the same\n     * parameters as `func`, except the last one (the callback). When the output\n     * function is called with arguments, it will return an Observable.\n     * If `func` calls its callback with error parameter present, Observable will\n     * error with that value as well. If error parameter is not passed, Observable will emit\n     * second parameter. If there are more parameters (third and so on),\n     * Observable will emit an array with all arguments, except first error argument.\n     *\n     * Optionally `bindNodeCallback` accepts selector function, which allows you to\n     * make resulting Observable emit value computed by selector, instead of regular\n     * callback arguments. It works similarly to {@link bindCallback} selector, but\n     * Node.js-style error argument will never be passed to that function.\n     *\n     * Note that `func` will not be called at the same time output function is,\n     * but rather whenever resulting Observable is subscribed. By default call to\n     * `func` will happen synchronously after subscription, but that can be changed\n     * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n     * can also control when values from callback will be emitted by Observable.\n     * To find out more, check out documentation for {@link bindCallback}, where\n     * Scheduler works exactly the same.\n     *\n     * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n     * of returned function, when it is called.\n     *\n     * After Observable emits value, it will complete immediately. This means\n     * even if `func` calls callback again, values from second and consecutive\n     * calls will never appear on the stream. If you need to handle functions\n     * that call callbacks multiple times, check out {@link fromEvent} or\n     * {@link fromEventPattern} instead.\n     *\n     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n     * \"Node.js-style\" callbacks are just a convention, so if you write for\n     * browsers or any other environment and API you use implements that callback style,\n     * `bindNodeCallback` can be safely used on that API functions as well.\n     *\n     * Remember that Error object passed to callback does not have to be an instance\n     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n     * Error parameter of callback function is interpreted as \"present\", when value\n     * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n     * string or boolean `true`. In all of these cases resulting Observable would error\n     * with that value. This means usually regular style callbacks will fail very often when\n     * `bindNodeCallback` is used. If your Observable errors much more often then you\n     * would expect, check if callback really is called in Node.js-style and, if not,\n     * switch to {@link bindCallback} instead.\n     *\n     * Note that even if error parameter is technically present in callback, but its value\n     * is falsy, it still won't appear in array emitted by Observable or in selector function.\n     *\n     *\n     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n     * import * as fs from 'fs';\n     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n     * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     *\n     * @example <caption>Use on function calling callback with multiple arguments</caption>\n     * someFunction((err, a, b) => {\n     *   console.log(err); // null\n     *   console.log(a); // 5\n     *   console.log(b); // \"some string\"\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n     * boundSomeFunction()\n     * .subscribe(value => {\n     *   console.log(value); // [5, \"some string\"]\n     * });\n     *\n     *\n     * @example <caption>Use with selector function</caption>\n     * someFunction((err, a, b) => {\n     *   console.log(err); // undefined\n     *   console.log(a); // \"abc\"\n     *   console.log(b); // \"DEF\"\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n     * boundSomeFunction()\n     * .subscribe(value => {\n     *   console.log(value); // \"abcDEF\"\n     * });\n     *\n     *\n     * @example <caption>Use on function calling callback in regular style</caption>\n     * someFunction(a => {\n     *   console.log(a); // 5\n     * });\n     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n     * boundSomeFunction()\n     * .subscribe(\n     *   value => {}             // never gets called\n     *   err => console.log(err) // 5\n     *);\n     *\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     * @see {@link fromPromise}\n     *\n     * @param {function} func Function with a Node.js-style callback as the last parameter.\n     * @param {function} [selector] A function which takes the arguments from the\n     * callback and maps those to a value to emit on the output Observable.\n     * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n     * callbacks.\n     * @return {function(...params: *): Observable} A function which returns the\n     * Observable that delivers the same values the Node.js callback would\n     * deliver.\n     * @static true\n     * @name bindNodeCallback\n     * @owner Observable\n     */\n    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n        if (selector === void 0) { selector = undefined; }\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n        };\n    };\n    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n        var callbackFunc = this.callbackFunc;\n        var args = this.args;\n        var scheduler = this.scheduler;\n        var subject = this.subject;\n        if (!scheduler) {\n            if (!subject) {\n                subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i - 0] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    var err = innerArgs.shift();\n                    if (err) {\n                        subject.error(err);\n                    }\n                    else if (selector) {\n                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_1 === errorObject_1.errorObject) {\n                            subject.error(errorObject_1.errorObject.e);\n                        }\n                        else {\n                            subject.next(result_1);\n                            subject.complete();\n                        }\n                    }\n                    else {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    }\n                };\n                // use named function instance to avoid closure.\n                handler.source = this;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            return subject.subscribe(subscriber);\n        }\n        else {\n            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n        }\n    };\n    return BoundNodeCallbackObservable;\n}(Observable_1.Observable));\nexports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\nfunction dispatch(state) {\n    var self = this;\n    var source = state.source, subscriber = state.subscriber, context = state.context;\n    // XXX: cast to `any` to access to the private field in `source`.\n    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;\n    var subject = source.subject;\n    if (!subject) {\n        subject = source.subject = new AsyncSubject_1.AsyncSubject();\n        var handler = function handlerFn() {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i - 0] = arguments[_i];\n            }\n            var source = handlerFn.source;\n            var selector = source.selector, subject = source.subject;\n            var err = innerArgs.shift();\n            if (err) {\n                self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n            }\n            else if (selector) {\n                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                if (result_2 === errorObject_1.errorObject) {\n                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                }\n                else {\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                }\n            }\n            else {\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n            }\n        };\n        // use named function to pass values in without closure\n        handler.source = source;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n        if (result === errorObject_1.errorObject) {\n            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n        }\n    }\n    self.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=BoundNodeCallbackObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/BoundNodeCallbackObservable.js\n// module id = 223\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar DeferObservable = (function (_super) {\n    __extends(DeferObservable, _super);\n    function DeferObservable(observableFactory) {\n        _super.call(this);\n        this.observableFactory = observableFactory;\n    }\n    /**\n     * Creates an Observable that, on subscribe, calls an Observable factory to\n     * make an Observable for each new Observer.\n     *\n     * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n     * is subscribed.\n     * </span>\n     *\n     * <img src=\"./img/defer.png\" width=\"100%\">\n     *\n     * `defer` allows you to create the Observable only when the Observer\n     * subscribes, and create a fresh Observable for each Observer. It waits until\n     * an Observer subscribes to it, and then it generates an Observable,\n     * typically with an Observable factory function. It does this afresh for each\n     * subscriber, so although each subscriber may think it is subscribing to the\n     * same Observable, in fact each subscriber gets its own individual\n     * Observable.\n     *\n     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n     * var clicksOrInterval = Rx.Observable.defer(function () {\n     *   if (Math.random() > 0.5) {\n     *     return Rx.Observable.fromEvent(document, 'click');\n     *   } else {\n     *     return Rx.Observable.interval(1000);\n     *   }\n     * });\n     * clicksOrInterval.subscribe(x => console.log(x));\n     *\n     * // Results in the following behavior:\n     * // If the result of Math.random() is greater than 0.5 it will listen\n     * // for clicks anywhere on the \"document\"; when document is clicked it\n     * // will log a MouseEvent object to the console. If the result is less\n     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n     *\n     * @see {@link create}\n     *\n     * @param {function(): SubscribableOrPromise} observableFactory The Observable\n     * factory function to invoke for each Observer that subscribes to the output\n     * Observable. May also return a Promise, which will be converted on the fly\n     * to an Observable.\n     * @return {Observable} An Observable whose Observers' subscriptions trigger\n     * an invocation of the given Observable factory function.\n     * @static true\n     * @name defer\n     * @owner Observable\n     */\n    DeferObservable.create = function (observableFactory) {\n        return new DeferObservable(observableFactory);\n    };\n    DeferObservable.prototype._subscribe = function (subscriber) {\n        return new DeferSubscriber(subscriber, this.observableFactory);\n    };\n    return DeferObservable;\n}(Observable_1.Observable));\nexports.DeferObservable = DeferObservable;\nvar DeferSubscriber = (function (_super) {\n    __extends(DeferSubscriber, _super);\n    function DeferSubscriber(destination, factory) {\n        _super.call(this, destination);\n        this.factory = factory;\n        this.tryDefer();\n    }\n    DeferSubscriber.prototype.tryDefer = function () {\n        try {\n            this._callFactory();\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    DeferSubscriber.prototype._callFactory = function () {\n        var result = this.factory();\n        if (result) {\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=DeferObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/DeferObservable.js\n// module id = 224\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ErrorObservable = (function (_super) {\n    __extends(ErrorObservable, _super);\n    function ErrorObservable(error, scheduler) {\n        _super.call(this);\n        this.error = error;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits an error notification.\n     *\n     * <span class=\"informal\">Just emits 'error', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/throw.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the error notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then emit an error.</caption>\n     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x === 13 ?\n     *     Rx.Observable.throw('Thirteens are bad') :\n     *     Rx.Observable.of('a', 'b', 'c')\n     * );\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     *\n     * @param {any} error The particular Error to pass to the error notification.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the error notification.\n     * @return {Observable} An error Observable: emits only the error notification\n     * using the given error argument.\n     * @static true\n     * @name throw\n     * @owner Observable\n     */\n    ErrorObservable.create = function (error, scheduler) {\n        return new ErrorObservable(error, scheduler);\n    };\n    ErrorObservable.dispatch = function (arg) {\n        var error = arg.error, subscriber = arg.subscriber;\n        subscriber.error(error);\n    };\n    ErrorObservable.prototype._subscribe = function (subscriber) {\n        var error = this.error;\n        var scheduler = this.scheduler;\n        subscriber.syncErrorThrowable = true;\n        if (scheduler) {\n            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                error: error, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.error(error);\n        }\n    };\n    return ErrorObservable;\n}(Observable_1.Observable));\nexports.ErrorObservable = ErrorObservable;\n//# sourceMappingURL=ErrorObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ErrorObservable.js\n// module id = 225\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isArray_1 = require('../util/isArray');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * @param sources\n     * @return {any}\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/ForkJoinObservable.js\n// module id = 226\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console everytime a click\n     * // occurs on the document.\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/FromEventObservable.js\n// module id = 227\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('../util/isFunction');\nvar Observable_1 = require('../Observable');\nvar Subscription_1 = require('../Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventPatternObservable = (function (_super) {\n    __extends(FromEventPatternObservable, _super);\n    function FromEventPatternObservable(addHandler, removeHandler, selector) {\n        _super.call(this);\n        this.addHandler = addHandler;\n        this.removeHandler = removeHandler;\n        this.selector = selector;\n    }\n    /**\n     * Creates an Observable from an API based on addHandler/removeHandler\n     * functions.\n     *\n     * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n     * Observable.</span>\n     *\n     * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n     *\n     * Creates an Observable by using the `addHandler` and `removeHandler`\n     * functions to add and remove the handlers, with an optional selector\n     * function to project the event arguments to a result. The `addHandler` is\n     * called when the output Observable is subscribed, and `removeHandler` is\n     * called when the Subscription is unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * function addClickHandler(handler) {\n     *   document.addEventListener('click', handler);\n     * }\n     *\n     * function removeClickHandler(handler) {\n     *   document.removeEventListener('click', handler);\n     * }\n     *\n     * var clicks = Rx.Observable.fromEventPattern(\n     *   addClickHandler,\n     *   removeClickHandler\n     * );\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEvent}\n     *\n     * @param {function(handler: Function): any} addHandler A function that takes\n     * a `handler` function as argument and attaches it somehow to the actual\n     * source of events.\n     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n     * takes a `handler` function as argument and removes it in case it was\n     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n     * removeHandler function will forward it.\n     * @param {function(...args: any): T} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEventPattern\n     * @owner Observable\n     */\n    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n        return new FromEventPatternObservable(addHandler, removeHandler, selector);\n    };\n    FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var removeHandler = this.removeHandler;\n        var handler = !!this.selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            _this._callSelector(subscriber, args);\n        } : function (e) { subscriber.next(e); };\n        var retValue = this._callAddHandler(handler, subscriber);\n        if (!isFunction_1.isFunction(removeHandler)) {\n            return;\n        }\n        subscriber.add(new Subscription_1.Subscription(function () {\n            //TODO: determine whether or not to forward to error handler\n            removeHandler(handler, retValue);\n        }));\n    };\n    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n        try {\n            var result = this.selector.apply(this, args);\n            subscriber.next(result);\n        }\n        catch (e) {\n            subscriber.error(e);\n        }\n    };\n    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n        try {\n            return this.addHandler(handler) || null;\n        }\n        catch (e) {\n            errorSubscriber.error(e);\n        }\n    };\n    return FromEventPatternObservable;\n}(Observable_1.Observable));\nexports.FromEventPatternObservable = FromEventPatternObservable;\n//# sourceMappingURL=FromEventPatternObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/FromEventPatternObservable.js\n// module id = 228\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar isScheduler_1 = require('../util/isScheduler');\nvar selfSelector = function (value) { return value; };\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar GenerateObservable = (function (_super) {\n    __extends(GenerateObservable, _super);\n    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n        _super.call(this);\n        this.initialState = initialState;\n        this.condition = condition;\n        this.iterate = iterate;\n        this.resultSelector = resultSelector;\n        this.scheduler = scheduler;\n    }\n    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n        if (arguments.length == 1) {\n            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n        }\n        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n        }\n        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n    };\n    GenerateObservable.prototype._subscribe = function (subscriber) {\n        var state = this.initialState;\n        if (this.scheduler) {\n            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n                subscriber: subscriber,\n                iterate: this.iterate,\n                condition: this.condition,\n                resultSelector: this.resultSelector,\n                state: state });\n        }\n        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\n        do {\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            var value = void 0;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        } while (true);\n    };\n    GenerateObservable.dispatch = function (state) {\n        var subscriber = state.subscriber, condition = state.condition;\n        if (subscriber.closed) {\n            return;\n        }\n        if (state.needIterate) {\n            try {\n                state.state = state.iterate(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n        }\n        else {\n            state.needIterate = true;\n        }\n        if (condition) {\n            var conditionResult = void 0;\n            try {\n                conditionResult = condition(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            if (!conditionResult) {\n                subscriber.complete();\n                return;\n            }\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        var value;\n        try {\n            value = state.resultSelector(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return;\n        }\n        if (subscriber.closed) {\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        return this.schedule(state);\n    };\n    return GenerateObservable;\n}(Observable_1.Observable));\nexports.GenerateObservable = GenerateObservable;\n//# sourceMappingURL=GenerateObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/GenerateObservable.js\n// module id = 229\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IfObservable = (function (_super) {\n    __extends(IfObservable, _super);\n    function IfObservable(condition, thenSource, elseSource) {\n        _super.call(this);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n    }\n    IfObservable.create = function (condition, thenSource, elseSource) {\n        return new IfObservable(condition, thenSource, elseSource);\n    };\n    IfObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n    };\n    return IfObservable;\n}(Observable_1.Observable));\nexports.IfObservable = IfObservable;\nvar IfSubscriber = (function (_super) {\n    __extends(IfSubscriber, _super);\n    function IfSubscriber(destination, condition, thenSource, elseSource) {\n        _super.call(this, destination);\n        this.condition = condition;\n        this.thenSource = thenSource;\n        this.elseSource = elseSource;\n        this.tryIf();\n    }\n    IfSubscriber.prototype.tryIf = function () {\n        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n        var result;\n        try {\n            result = condition();\n            var source = result ? thenSource : elseSource;\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n            else {\n                this._complete();\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return IfSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=IfObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/IfObservable.js\n// module id = 230\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IntervalObservable = (function (_super) {\n    __extends(IntervalObservable, _super);\n    function IntervalObservable(period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        _super.call(this);\n        this.period = period;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(period) || period < 0) {\n            this.period = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = async_1.async;\n        }\n    }\n    /**\n     * Creates an Observable that emits sequential numbers every specified\n     * interval of time, on a specified IScheduler.\n     *\n     * <span class=\"informal\">Emits incremental numbers periodically in time.\n     * </span>\n     *\n     * <img src=\"./img/interval.png\" width=\"100%\">\n     *\n     * `interval` returns an Observable that emits an infinite sequence of\n     * ascending integers, with a constant interval of time of your choosing\n     * between those emissions. The first emission is not sent immediately, but\n     * only after the first period has passed. By default, this operator uses the\n     * `async` IScheduler to provide a notion of time, but you may pass any\n     * IScheduler to it.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n     * var numbers = Rx.Observable.interval(1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link delay}\n     *\n     * @param {number} [period=0] The interval size in milliseconds (by default)\n     * or the time unit determined by the scheduler's clock.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a sequential number each time\n     * interval.\n     * @static true\n     * @name interval\n     * @owner Observable\n     */\n    IntervalObservable.create = function (period, scheduler) {\n        if (period === void 0) { period = 0; }\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return new IntervalObservable(period, scheduler);\n    };\n    IntervalObservable.dispatch = function (state) {\n        var index = state.index, subscriber = state.subscriber, period = state.period;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index += 1;\n        this.schedule(state, period);\n    };\n    IntervalObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var period = this.period;\n        var scheduler = this.scheduler;\n        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n            index: index, subscriber: subscriber, period: period\n        }));\n    };\n    return IntervalObservable;\n}(Observable_1.Observable));\nexports.IntervalObservable = IntervalObservable;\n//# sourceMappingURL=IntervalObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/IntervalObservable.js\n// module id = 231\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar IteratorObservable = (function (_super) {\n    __extends(IteratorObservable, _super);\n    function IteratorObservable(iterator, scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n        if (iterator == null) {\n            throw new Error('iterator cannot be null.');\n        }\n        this.iterator = getIterator(iterator);\n    }\n    IteratorObservable.create = function (iterator, scheduler) {\n        return new IteratorObservable(iterator, scheduler);\n    };\n    IteratorObservable.dispatch = function (state) {\n        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n        if (hasError) {\n            subscriber.error(state.error);\n            return;\n        }\n        var result = iterator.next();\n        if (result.done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(result.value);\n        state.index = index + 1;\n        if (subscriber.closed) {\n            if (typeof iterator.return === 'function') {\n                iterator.return();\n            }\n            return;\n        }\n        this.schedule(state);\n    };\n    IteratorObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                index: index, iterator: iterator, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                var result = iterator.next();\n                if (result.done) {\n                    subscriber.complete();\n                    break;\n                }\n                else {\n                    subscriber.next(result.value);\n                }\n                if (subscriber.closed) {\n                    if (typeof iterator.return === 'function') {\n                        iterator.return();\n                    }\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return IteratorObservable;\n}(Observable_1.Observable));\nexports.IteratorObservable = IteratorObservable;\nvar StringIterator = (function () {\n    function StringIterator(str, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = str.length; }\n        this.str = str;\n        this.idx = idx;\n        this.len = len;\n    }\n    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n    StringIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.str.charAt(this.idx++)\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return StringIterator;\n}());\nvar ArrayIterator = (function () {\n    function ArrayIterator(arr, idx, len) {\n        if (idx === void 0) { idx = 0; }\n        if (len === void 0) { len = toLength(arr); }\n        this.arr = arr;\n        this.idx = idx;\n        this.len = len;\n    }\n    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n    ArrayIterator.prototype.next = function () {\n        return this.idx < this.len ? {\n            done: false,\n            value: this.arr[this.idx++]\n        } : {\n            done: true,\n            value: undefined\n        };\n    };\n    return ArrayIterator;\n}());\nfunction getIterator(obj) {\n    var i = obj[iterator_1.iterator];\n    if (!i && typeof obj === 'string') {\n        return new StringIterator(obj);\n    }\n    if (!i && obj.length !== undefined) {\n        return new ArrayIterator(obj);\n    }\n    if (!i) {\n        throw new TypeError('object is not iterable');\n    }\n    return obj[iterator_1.iterator]();\n}\nvar maxSafeInteger = Math.pow(2, 53) - 1;\nfunction toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) {\n        return 0;\n    }\n    if (len === 0 || !numberIsFinite(len)) {\n        return len;\n    }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) {\n        return 0;\n    }\n    if (len > maxSafeInteger) {\n        return maxSafeInteger;\n    }\n    return len;\n}\nfunction numberIsFinite(value) {\n    return typeof value === 'number' && root_1.root.isFinite(value);\n}\nfunction sign(value) {\n    var valueAsNumber = +value;\n    if (valueAsNumber === 0) {\n        return valueAsNumber;\n    }\n    if (isNaN(valueAsNumber)) {\n        return valueAsNumber;\n    }\n    return valueAsNumber < 0 ? -1 : 1;\n}\n//# sourceMappingURL=IteratorObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/IteratorObservable.js\n// module id = 232\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar noop_1 = require('../util/noop');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar NeverObservable = (function (_super) {\n    __extends(NeverObservable, _super);\n    function NeverObservable() {\n        _super.call(this);\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer.\n     *\n     * <span class=\"informal\">An Observable that never emits anything.</span>\n     *\n     * <img src=\"./img/never.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that emits\n     * neither values nor errors nor the completion notification. It can be used\n     * for testing purposes or for composing with other Observables. Please note\n     * that by never emitting a complete notification, this Observable keeps the\n     * subscription from being disposed automatically. Subscriptions need to be\n     * manually disposed.\n     *\n     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n     * function info() {\n     *   console.log('Will not be called');\n     * }\n     * var result = Rx.Observable.never().startWith(7);\n     * result.subscribe(x => console.log(x), info, info);\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @return {Observable} A \"never\" Observable: never emits anything.\n     * @static true\n     * @name never\n     * @owner Observable\n     */\n    NeverObservable.create = function () {\n        return new NeverObservable();\n    };\n    NeverObservable.prototype._subscribe = function (subscriber) {\n        noop_1.noop();\n    };\n    return NeverObservable;\n}(Observable_1.Observable));\nexports.NeverObservable = NeverObservable;\n//# sourceMappingURL=NeverObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/NeverObservable.js\n// module id = 233\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nfunction dispatch(state) {\n    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;\n    if (index === length) {\n        subscriber.complete();\n        return;\n    }\n    var key = keys[index];\n    subscriber.next([key, obj[key]]);\n    state.index = index + 1;\n    this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PairsObservable = (function (_super) {\n    __extends(PairsObservable, _super);\n    function PairsObservable(obj, scheduler) {\n        _super.call(this);\n        this.obj = obj;\n        this.scheduler = scheduler;\n        this.keys = Object.keys(obj);\n    }\n    /**\n     * Convert an object into an observable sequence of [key, value] pairs\n     * using an optional IScheduler to enumerate the object.\n     *\n     * @example <caption>Converts a javascript object to an Observable</caption>\n     * var obj = {\n     *   foo: 42,\n     *   bar: 56,\n     *   baz: 78\n     * };\n     *\n     * var source = Rx.Observable.pairs(obj);\n     *\n     * var subscription = source.subscribe(\n     *   function (x) {\n     *     console.log('Next: %s', x);\n     *   },\n     *   function (err) {\n     *     console.log('Error: %s', err);\n     *   },\n     *   function () {\n     *     console.log('Completed');\n     *   });\n     *\n     * @param {Object} obj The object to inspect and turn into an\n     * Observable sequence.\n     * @param {Scheduler} [scheduler] An optional IScheduler to run the\n     * enumeration of the input sequence on.\n     * @returns {(Observable<Array<string | T>>)} An observable sequence of\n     * [key, value] pairs from the object.\n     */\n    PairsObservable.create = function (obj, scheduler) {\n        return new PairsObservable(obj, scheduler);\n    };\n    PairsObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, keys = _a.keys, scheduler = _a.scheduler;\n        var length = keys.length;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber\n            });\n        }\n        else {\n            for (var idx = 0; idx < length; idx++) {\n                var key = keys[idx];\n                subscriber.next([key, this.obj[key]]);\n            }\n            subscriber.complete();\n        }\n    };\n    return PairsObservable;\n}(Observable_1.Observable));\nexports.PairsObservable = PairsObservable;\n//# sourceMappingURL=PairsObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/PairsObservable.js\n// module id = 234\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar RangeObservable = (function (_super) {\n    __extends(RangeObservable, _super);\n    function RangeObservable(start, count, scheduler) {\n        _super.call(this);\n        this.start = start;\n        this._count = count;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits a sequence of numbers within a specified\n     * range.\n     *\n     * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n     *\n     * <img src=\"./img/range.png\" width=\"100%\">\n     *\n     * `range` operator emits a range of sequential integers, in order, where you\n     * select the `start` of the range and its `length`. By default, uses no\n     * IScheduler and just delivers the notifications synchronously, but may use\n     * an optional IScheduler to regulate those deliveries.\n     *\n     * @example <caption>Emits the numbers 1 to 10</caption>\n     * var numbers = Rx.Observable.range(1, 10);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link interval}\n     *\n     * @param {number} [start=0] The value of the first integer in the sequence.\n     * @param {number} [count=0] The number of sequential integers to generate.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the notifications.\n     * @return {Observable} An Observable of numbers that emits a finite range of\n     * sequential integers.\n     * @static true\n     * @name range\n     * @owner Observable\n     */\n    RangeObservable.create = function (start, count, scheduler) {\n        if (start === void 0) { start = 0; }\n        if (count === void 0) { count = 0; }\n        return new RangeObservable(start, count, scheduler);\n    };\n    RangeObservable.dispatch = function (state) {\n        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(start);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        state.start = start + 1;\n        this.schedule(state);\n    };\n    RangeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var start = this.start;\n        var count = this._count;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(RangeObservable.dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(start++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return RangeObservable;\n}(Observable_1.Observable));\nexports.RangeObservable = RangeObservable;\n//# sourceMappingURL=RangeObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/RangeObservable.js\n// module id = 235\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar asap_1 = require('../scheduler/asap');\nvar isNumeric_1 = require('../util/isNumeric');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar SubscribeOnObservable = (function (_super) {\n    __extends(SubscribeOnObservable, _super);\n    function SubscribeOnObservable(source, delayTime, scheduler) {\n        if (delayTime === void 0) { delayTime = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        _super.call(this);\n        this.source = source;\n        this.delayTime = delayTime;\n        this.scheduler = scheduler;\n        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n            this.delayTime = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            this.scheduler = asap_1.asap;\n        }\n    }\n    SubscribeOnObservable.create = function (source, delay, scheduler) {\n        if (delay === void 0) { delay = 0; }\n        if (scheduler === void 0) { scheduler = asap_1.asap; }\n        return new SubscribeOnObservable(source, delay, scheduler);\n    };\n    SubscribeOnObservable.dispatch = function (arg) {\n        var source = arg.source, subscriber = arg.subscriber;\n        return this.add(source.subscribe(subscriber));\n    };\n    SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n        var delay = this.delayTime;\n        var source = this.source;\n        var scheduler = this.scheduler;\n        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n            source: source, subscriber: subscriber\n        });\n    };\n    return SubscribeOnObservable;\n}(Observable_1.Observable));\nexports.SubscribeOnObservable = SubscribeOnObservable;\n//# sourceMappingURL=SubscribeOnObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/SubscribeOnObservable.js\n// module id = 236\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/TimerObservable.js\n// module id = 237\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar UsingObservable = (function (_super) {\n    __extends(UsingObservable, _super);\n    function UsingObservable(resourceFactory, observableFactory) {\n        _super.call(this);\n        this.resourceFactory = resourceFactory;\n        this.observableFactory = observableFactory;\n    }\n    UsingObservable.create = function (resourceFactory, observableFactory) {\n        return new UsingObservable(resourceFactory, observableFactory);\n    };\n    UsingObservable.prototype._subscribe = function (subscriber) {\n        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;\n        var resource;\n        try {\n            resource = resourceFactory();\n            return new UsingSubscriber(subscriber, resource, observableFactory);\n        }\n        catch (err) {\n            subscriber.error(err);\n        }\n    };\n    return UsingObservable;\n}(Observable_1.Observable));\nexports.UsingObservable = UsingObservable;\nvar UsingSubscriber = (function (_super) {\n    __extends(UsingSubscriber, _super);\n    function UsingSubscriber(destination, resource, observableFactory) {\n        _super.call(this, destination);\n        this.resource = resource;\n        this.observableFactory = observableFactory;\n        destination.add(resource);\n        this.tryUse();\n    }\n    UsingSubscriber.prototype.tryUse = function () {\n        try {\n            var source = this.observableFactory.call(this, this.resource);\n            if (source) {\n                this.add(subscribeToResult_1.subscribeToResult(this, source));\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    return UsingSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=UsingObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/UsingObservable.js\n// module id = 238\n// module chunks = 0","\"use strict\";\nvar BoundCallbackObservable_1 = require('./BoundCallbackObservable');\nexports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n//# sourceMappingURL=bindCallback.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/bindCallback.js\n// module id = 239\n// module chunks = 0","\"use strict\";\nvar BoundNodeCallbackObservable_1 = require('./BoundNodeCallbackObservable');\nexports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/bindNodeCallback.js\n// module id = 240\n// module chunks = 0","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar isArray_1 = require('../util/isArray');\nvar ArrayObservable_1 = require('./ArrayObservable');\nvar combineLatest_1 = require('../operator/combineLatest');\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n *\n * @example <caption>Combine two timer Observables</caption>\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n *\n *\n * @example <caption>Combine an array of Observables</caption>\n * const observables = [1, 5, 10].map(\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n * );\n * const combined = Rx.Observable.combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n *\n *\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @static true\n * @name combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    var scheduler = null;\n    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineLatest = combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/combineLatest.js\n// module id = 241\n// module chunks = 0","\"use strict\";\nvar concat_1 = require('../operator/concat');\nexports.concat = concat_1.concatStatic;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/concat.js\n// module id = 242\n// module chunks = 0","\"use strict\";\nvar DeferObservable_1 = require('./DeferObservable');\nexports.defer = DeferObservable_1.DeferObservable.create;\n//# sourceMappingURL=defer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/defer.js\n// module id = 243\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../../Subject');\nvar Subscriber_1 = require('../../Subscriber');\nvar Observable_1 = require('../../Observable');\nvar Subscription_1 = require('../../Subscription');\nvar root_1 = require('../../util/root');\nvar ReplaySubject_1 = require('../../ReplaySubject');\nvar tryCatch_1 = require('../../util/tryCatch');\nvar errorObject_1 = require('../../util/errorObject');\nvar assign_1 = require('../../util/assign');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        if (urlConfigOrSource instanceof Observable_1.Observable) {\n            _super.call(this, destination, urlConfigOrSource);\n        }\n        else {\n            _super.call(this);\n            this.WebSocketCtor = root_1.root.WebSocket;\n            this._output = new Subject_1.Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                this.url = urlConfigOrSource;\n            }\n            else {\n                // WARNING: config object could override important members here.\n                assign_1.assign(this, urlConfigOrSource);\n            }\n            if (!this.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    }\n    WebSocketSubject.prototype.resultSelector = function (e) {\n        return JSON.parse(e.data);\n    };\n    /**\n     * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n     *\n     * @example <caption>Wraps browser WebSocket</caption>\n     *\n     * let socket$ = Observable.webSocket('ws://localhost:8081');\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n     *\n     * import { w3cwebsocket } from 'websocket';\n     *\n     * let socket$ = Observable.webSocket({\n     *   url: 'ws://localhost:8081',\n     *   WebSocketCtor: w3cwebsocket\n     * });\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n     * @return {WebSocketSubject}\n     * @static true\n     * @name webSocket\n     * @owner Observable\n     */\n    WebSocketSubject.create = function (urlConfigOrSource) {\n        return new WebSocketSubject(urlConfigOrSource);\n    };\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this, this.destination);\n        sock.operator = operator;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this.socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n        this._output = new Subject_1.Subject();\n    };\n    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable_1.Observable(function (observer) {\n            var result = tryCatch_1.tryCatch(subMsg)();\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                self.next(result);\n            }\n            var subscription = self.subscribe(function (x) {\n                var result = tryCatch_1.tryCatch(messageFilter)(x);\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else if (result) {\n                    observer.next(x);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                var result = tryCatch_1.tryCatch(unsubMsg)();\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var WebSocketCtor = this.WebSocketCtor;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = this.protocol ?\n                new WebSocketCtor(this.url, this.protocol) :\n                new WebSocketCtor(this.url);\n            this.socket = socket;\n            if (this.binaryType) {\n                this.socket.binaryType = this.binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription_1.Subscription(function () {\n            _this.socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var openObserver = _this.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                        'and an optional reason: { code: number, reason: string }'));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n            if (result === errorObject_1.errorObject) {\n                observer.error(errorObject_1.errorObject.e);\n            }\n            else {\n                observer.next(result);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this.socket) {\n            this._connectSocket();\n        }\n        var subscription = new Subscription_1.Subscription();\n        subscription.add(this._output.subscribe(subscriber));\n        subscription.add(function () {\n            var socket = _this.socket;\n            if (_this._output.observers.length === 0) {\n                if (socket && socket.readyState === 1) {\n                    socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscription;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _a = this, source = _a.source, socket = _a.socket;\n        if (socket && socket.readyState === 1) {\n            socket.close();\n            this._resetState();\n        }\n        _super.prototype.unsubscribe.call(this);\n        if (!source) {\n            this.destination = new ReplaySubject_1.ReplaySubject();\n        }\n    };\n    return WebSocketSubject;\n}(Subject_1.AnonymousSubject));\nexports.WebSocketSubject = WebSocketSubject;\n//# sourceMappingURL=WebSocketSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/dom/WebSocketSubject.js\n// module id = 244\n// module chunks = 0","\"use strict\";\nvar AjaxObservable_1 = require('./AjaxObservable');\nexports.ajax = AjaxObservable_1.AjaxObservable.create;\n//# sourceMappingURL=ajax.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/dom/ajax.js\n// module id = 245\n// module chunks = 0","\"use strict\";\nvar WebSocketSubject_1 = require('./WebSocketSubject');\nexports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n//# sourceMappingURL=webSocket.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/dom/webSocket.js\n// module id = 246\n// module chunks = 0","\"use strict\";\nvar EmptyObservable_1 = require('./EmptyObservable');\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/empty.js\n// module id = 247\n// module chunks = 0","\"use strict\";\nvar ForkJoinObservable_1 = require('./ForkJoinObservable');\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/forkJoin.js\n// module id = 248\n// module chunks = 0","\"use strict\";\nvar FromObservable_1 = require('./FromObservable');\nexports.from = FromObservable_1.FromObservable.create;\n//# sourceMappingURL=from.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/from.js\n// module id = 249\n// module chunks = 0","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/fromEvent.js\n// module id = 250\n// module chunks = 0","\"use strict\";\nvar FromEventPatternObservable_1 = require('./FromEventPatternObservable');\nexports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n//# sourceMappingURL=fromEventPattern.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/fromEventPattern.js\n// module id = 251\n// module chunks = 0","\"use strict\";\nvar PromiseObservable_1 = require('./PromiseObservable');\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/fromPromise.js\n// module id = 252\n// module chunks = 0","\"use strict\";\nvar GenerateObservable_1 = require('./GenerateObservable');\nexports.generate = GenerateObservable_1.GenerateObservable.create;\n//# sourceMappingURL=generate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/generate.js\n// module id = 253\n// module chunks = 0","\"use strict\";\nvar IfObservable_1 = require('./IfObservable');\nexports._if = IfObservable_1.IfObservable.create;\n//# sourceMappingURL=if.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/if.js\n// module id = 254\n// module chunks = 0","\"use strict\";\nvar IntervalObservable_1 = require('./IntervalObservable');\nexports.interval = IntervalObservable_1.IntervalObservable.create;\n//# sourceMappingURL=interval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/interval.js\n// module id = 255\n// module chunks = 0","\"use strict\";\nvar merge_1 = require('../operator/merge');\nexports.merge = merge_1.mergeStatic;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/merge.js\n// module id = 256\n// module chunks = 0","\"use strict\";\nvar NeverObservable_1 = require('./NeverObservable');\nexports.never = NeverObservable_1.NeverObservable.create;\n//# sourceMappingURL=never.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/never.js\n// module id = 257\n// module chunks = 0","\"use strict\";\nvar ArrayObservable_1 = require('./ArrayObservable');\nexports.of = ArrayObservable_1.ArrayObservable.of;\n//# sourceMappingURL=of.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/of.js\n// module id = 258\n// module chunks = 0","\"use strict\";\nvar onErrorResumeNext_1 = require('../operator/onErrorResumeNext');\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/onErrorResumeNext.js\n// module id = 259\n// module chunks = 0","\"use strict\";\nvar PairsObservable_1 = require('./PairsObservable');\nexports.pairs = PairsObservable_1.PairsObservable.create;\n//# sourceMappingURL=pairs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/pairs.js\n// module id = 260\n// module chunks = 0","\"use strict\";\nvar race_1 = require('../operator/race');\nexports.race = race_1.raceStatic;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/race.js\n// module id = 261\n// module chunks = 0","\"use strict\";\nvar RangeObservable_1 = require('./RangeObservable');\nexports.range = RangeObservable_1.RangeObservable.create;\n//# sourceMappingURL=range.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/range.js\n// module id = 262\n// module chunks = 0","\"use strict\";\nvar ErrorObservable_1 = require('./ErrorObservable');\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n//# sourceMappingURL=throw.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/throw.js\n// module id = 263\n// module chunks = 0","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/timer.js\n// module id = 264\n// module chunks = 0","\"use strict\";\nvar UsingObservable_1 = require('./UsingObservable');\nexports.using = UsingObservable_1.UsingObservable.create;\n//# sourceMappingURL=using.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/using.js\n// module id = 265\n// module chunks = 0","\"use strict\";\nvar zip_1 = require('../operator/zip');\nexports.zip = zip_1.zipStatic;\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/zip.js\n// module id = 266\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return this.lift(new AuditOperator(durationSelector));\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/audit.js\n// module id = 267\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new AuditTimeOperator(duration, scheduler));\n}\nexports.auditTime = auditTime;\nvar AuditTimeOperator = (function () {\n    function AuditTimeOperator(duration, scheduler) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n    }\n    AuditTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));\n    };\n    return AuditTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditTimeSubscriber = (function (_super) {\n    __extends(AuditTimeSubscriber, _super);\n    function AuditTimeSubscriber(destination, duration, scheduler) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n    }\n    AuditTimeSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));\n        }\n    };\n    AuditTimeSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    return AuditTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/auditTime.js\n// module id = 268\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return this.lift(new BufferOperator(closingNotifier));\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/buffer.js\n// module id = 269\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/bufferCount.js\n// module id = 270\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/bufferTime.js\n// module id = 271\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return this.lift(new BufferToggleOperator(openings, closingSelector));\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/bufferToggle.js\n// module id = 272\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return this.lift(new BufferWhenOperator(closingSelector));\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/bufferWhen.js\n// module id = 273\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/catch.js\n// module id = 274\n// module chunks = 0","\"use strict\";\nvar combineLatest_1 = require('./combineLatest');\n/**\n * Converts a higher-order Observable into a first-order Observable by waiting\n * for the outer Observable to complete, then applying {@link combineLatest}.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n * {@link combineLatest} when the Observable-of-Observables completes.</span>\n *\n * <img src=\"./img/combineAll.png\" width=\"100%\">\n *\n * Takes an Observable of Observables, and collects all Observables from it.\n * Once the outer Observable completes, it subscribes to all collected\n * Observables and combines their values using the {@link combineLatest}\n * strategy, such that:\n * - Every time an inner Observable emits, the output Observable emits.\n * - When the returned observable emits, it emits all of the latest values by:\n *   - If a `project` function is provided, it is called with each recent value\n *     from each inner Observable in whatever order they arrived, and the result\n *     of the `project` function is what is emitted by the output Observable.\n *   - If there is no `project` function, an array of all of the most recent\n *     values is emitted by the output Observable.\n *\n * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev =>\n *   Rx.Observable.interval(Math.random()*2000).take(3)\n * ).take(2);\n * var result = higherOrder.combineAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function} [project] An optional function to map the most recent\n * values from each inner Observable into a new result. Takes each of the most\n * recent values from each collected inner Observable as arguments, in order.\n * @return {Observable} An Observable of projected results or arrays of recent\n * values.\n * @method combineAll\n * @owner Observable\n */\nfunction combineAll(project) {\n    return this.lift(new combineLatest_1.CombineLatestOperator(project));\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/combineAll.js\n// module id = 275\n// module chunks = 0","\"use strict\";\nvar mergeAll_1 = require('./mergeAll');\n/* tslint:enable:max-line-length */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\nfunction concatAll() {\n    return this.lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concatAll.js\n// module id = 276\n// module chunks = 0","\"use strict\";\nvar mergeMap_1 = require('./mergeMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * <img src=\"./img/concatMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nfunction concatMap(project, resultSelector) {\n    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concatMap.js\n// module id = 277\n// module chunks = 0","\"use strict\";\nvar mergeMapTo_1 = require('./mergeMapTo');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/concatMapTo.js\n// module id = 278\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return this.lift(new CountOperator(predicate, this));\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/count.js\n// module id = 279\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return this.lift(new DebounceOperator(durationSelector));\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/debounce.js\n// module id = 280\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/debounceTime.js\n// module id = 281\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nfunction defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) { defaultValue = null; }\n    return this.lift(new DefaultIfEmptyOperator(defaultValue));\n}\nexports.defaultIfEmpty = defaultIfEmpty;\nvar DefaultIfEmptyOperator = (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DefaultIfEmptySubscriber = (function (_super) {\n    __extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        _super.call(this, destination);\n        this.defaultValue = defaultValue;\n        this.isEmpty = true;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/defaultIfEmpty.js\n// module id = 282\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return this.lift(new DelayOperator(delayFor, scheduler));\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/delay.js\n// module id = 283\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Observable_1 = require('../Observable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return new SubscriptionDelayObservable(this, subscriptionDelay)\n            .lift(new DelayWhenOperator(delayDurationSelector));\n    }\n    return this.lift(new DelayWhenOperator(delayDurationSelector));\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/delayWhen.js\n// module id = 284\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return this.lift(new DeMaterializeOperator());\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/dematerialize.js\n// module id = 285\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar Set_1 = require('../util/Set');\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return this.lift(new DistinctOperator(keySelector, flushes));\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/distinct.js\n// module id = 286\n// module chunks = 0","\"use strict\";\nvar distinctUntilChanged_1 = require('./distinctUntilChanged');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {\n        if (compare) {\n            return compare(x[key], y[key]);\n        }\n        return x[key] === y[key];\n    });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/distinctUntilKeyChanged.js\n// module id = 287\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\nexports._do = _do;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/do.js\n// module id = 288\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return this.lift(new ElementAtOperator(index, defaultValue));\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/elementAt.js\n// module id = 289\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n *  Observable.of(1, 2, 3, 4, 5, 6)\n *     .every(x => x < 5)\n *     .subscribe(x => console.log(x)); // -> false\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nfunction every(predicate, thisArg) {\n    return this.lift(new EveryOperator(predicate, thisArg, this));\n}\nexports.every = every;\nvar EveryOperator = (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar EverySubscriber = (function (_super) {\n    __extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n        this.index = 0;\n        this.thisArg = thisArg || this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=every.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/every.js\n// module id = 290\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return this.lift(new SwitchFirstOperator());\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/exhaust.js\n// module id = 291\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return this.lift(new SwitchFirstMapOperator(project, resultSelector));\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/exhaustMap.js\n// module id = 292\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return this.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/expand.js\n// module id = 293\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction _finally(callback) {\n    return this.lift(new FinallyOperator(callback));\n}\nexports._finally = _finally;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finally.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/finally.js\n// module id = 294\n// module chunks = 0","\"use strict\";\nvar find_1 = require('./find');\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/findIndex.js\n// module id = 295\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nfunction first(predicate, resultSelector, defaultValue) {\n    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.first = first;\nvar FirstOperator = (function () {\n    function FirstOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    FirstOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return FirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FirstSubscriber = (function (_super) {\n    __extends(FirstSubscriber, _super);\n    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.index = 0;\n        this.hasCompleted = false;\n        this._emitted = false;\n    }\n    FirstSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this._emit(value, index);\n        }\n    };\n    FirstSubscriber.prototype._emit = function (value, index) {\n        if (this.resultSelector) {\n            this._tryResultSelector(value, index);\n            return;\n        }\n        this._emitFinal(value);\n    };\n    FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this._emitFinal(result);\n    };\n    FirstSubscriber.prototype._emitFinal = function (value) {\n        var destination = this.destination;\n        if (!this._emitted) {\n            this._emitted = true;\n            destination.next(value);\n            destination.complete();\n            this.hasCompleted = true;\n        }\n    };\n    FirstSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n            destination.next(this.defaultValue);\n            destination.complete();\n        }\n        else if (!this.hasCompleted) {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return FirstSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=first.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/first.js\n// module id = 296\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar Observable_1 = require('../Observable');\nvar Subject_1 = require('../Subject');\nvar Map_1 = require('../util/Map');\nvar FastMap_1 = require('../util/FastMap');\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/groupBy.js\n// module id = 297\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar noop_1 = require('../util/noop');\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return this.lift(new IgnoreElementsOperator());\n}\nexports.ignoreElements = ignoreElements;\n;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/ignoreElements.js\n// module id = 298\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n *\n * <img src=\"./img/isEmpty.png\" width=\"100%\">\n *\n * @return {Observable} An Observable that emits a Boolean.\n * @method isEmpty\n * @owner Observable\n */\nfunction isEmpty() {\n    return this.lift(new IsEmptyOperator());\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/isEmpty.js\n// module id = 299\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * <img src=\"./img/last.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} predicate - The condition any source emitted item has to satisfy.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n * @method last\n * @owner Observable\n */\nfunction last(predicate, resultSelector, defaultValue) {\n    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));\n}\nexports.last = last;\nvar LastOperator = (function () {\n    function LastOperator(predicate, resultSelector, defaultValue, source) {\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n    }\n    LastOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n    };\n    return LastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar LastSubscriber = (function (_super) {\n    __extends(LastSubscriber, _super);\n    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.resultSelector = resultSelector;\n        this.defaultValue = defaultValue;\n        this.source = source;\n        this.hasValue = false;\n        this.index = 0;\n        if (typeof defaultValue !== 'undefined') {\n            this.lastValue = defaultValue;\n            this.hasValue = true;\n        }\n    }\n    LastSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this._tryPredicate(value, index);\n        }\n        else {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryPredicate = function (value, index) {\n        var result;\n        try {\n            result = this.predicate(value, index, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this.lastValue = value;\n            this.hasValue = true;\n        }\n    };\n    LastSubscriber.prototype._tryResultSelector = function (value, index) {\n        var result;\n        try {\n            result = this.resultSelector(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.lastValue = result;\n        this.hasValue = true;\n    };\n    LastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.hasValue) {\n            destination.next(this.lastValue);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return LastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=last.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/last.js\n// module id = 300\n// module chunks = 0","\"use strict\";\n/**\n * @param func\n * @return {Observable<R>}\n * @method let\n * @owner Observable\n */\nfunction letProto(func) {\n    return func(this);\n}\nexports.letProto = letProto;\n//# sourceMappingURL=let.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/let.js\n// module id = 301\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return this.lift(new MapToOperator(value));\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mapTo.js\n// module id = 302\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return this.lift(new MaterializeOperator());\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/materialize.js\n// module id = 303\n// module chunks = 0","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(max));\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/max.js\n// module id = 304\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/mergeScan.js\n// module id = 305\n// module chunks = 0","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return this.lift(new reduce_1.ReduceOperator(min));\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/min.js\n// module id = 306\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * <img src=\"./img/pairwise.png\" width=\"100%\">\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var pairs = clicks.pairwise();\n * var distance = pairs.map(pair => {\n *   var x0 = pair[0].clientX;\n *   var y0 = pair[0].clientY;\n *   var x1 = pair[1].clientX;\n *   var y1 = pair[1].clientY;\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n * });\n * distance.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nfunction pairwise() {\n    return this.lift(new PairwiseOperator());\n}\nexports.pairwise = pairwise;\nvar PairwiseOperator = (function () {\n    function PairwiseOperator() {\n    }\n    PairwiseOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    };\n    return PairwiseOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar PairwiseSubscriber = (function (_super) {\n    __extends(PairwiseSubscriber, _super);\n    function PairwiseSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasPrev = false;\n    }\n    PairwiseSubscriber.prototype._next = function (value) {\n        if (this.hasPrev) {\n            this.destination.next([this.prev, value]);\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n    };\n    return PairwiseSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=pairwise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/pairwise.js\n// module id = 307\n// module chunks = 0","\"use strict\";\nvar not_1 = require('../util/not');\nvar filter_1 = require('./filter');\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return [\n        filter_1.filter.call(this, predicate, thisArg),\n        filter_1.filter.call(this, not_1.not(predicate, thisArg))\n    ];\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/partition.js\n// module id = 308\n// module chunks = 0","\"use strict\";\nvar map_1 = require('./map');\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return map_1.map.call(this, plucker(properties, length));\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/pluck.js\n// module id = 309\n// module chunks = 0","\"use strict\";\nvar Subject_1 = require('../Subject');\nvar multicast_1 = require('./multicast');\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast.call(this, new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/publish.js\n// module id = 310\n// module chunks = 0","\"use strict\";\nvar BehaviorSubject_1 = require('../BehaviorSubject');\nvar multicast_1 = require('./multicast');\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/publishBehavior.js\n// module id = 311\n// module chunks = 0","\"use strict\";\nvar AsyncSubject_1 = require('../AsyncSubject');\nvar multicast_1 = require('./multicast');\n/**\n * @return {ConnectableObservable<T>}\n * @method publishLast\n * @owner Observable\n */\nfunction publishLast() {\n    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/publishLast.js\n// module id = 312\n// module chunks = 0","\"use strict\";\nvar ReplaySubject_1 = require('../ReplaySubject');\nvar multicast_1 = require('./multicast');\n/**\n * @param bufferSize\n * @param windowTime\n * @param scheduler\n * @return {ConnectableObservable<T>}\n * @method publishReplay\n * @owner Observable\n */\nfunction publishReplay(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/publishReplay.js\n// module id = 313\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else if (count < 0) {\n        return this.lift(new RepeatOperator(-1, this));\n    }\n    else {\n        return this.lift(new RepeatOperator(count - 1, this));\n    }\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/repeat.js\n// module id = 314\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return this.lift(new RepeatWhenOperator(notifier));\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            else if (this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/repeatWhen.js\n// module id = 315\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return this.lift(new RetryOperator(count, this));\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/retry.js\n// module id = 316\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return this.lift(new RetryWhenOperator(notifier, this));\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/retryWhen.js\n// module id = 317\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return this.lift(new SampleOperator(notifier));\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/sample.js\n// module id = 318\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return this.lift(new SampleTimeOperator(period, scheduler));\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/sampleTime.js\n// module id = 319\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ScanOperator(accumulator, seed, hasSeed));\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/scan.js\n// module id = 320\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return this.lift(new SequenceEqualOperator(compareTo, comparor));\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/sequenceEqual.js\n// module id = 321\n// module chunks = 0","\"use strict\";\nvar multicast_1 = require('./multicast');\nvar Subject_1 = require('../Subject');\nfunction shareSubjectFactory() {\n    return new Subject_1.Subject();\n}\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for .publish().refCount().\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();\n}\nexports.share = share;\n;\n//# sourceMappingURL=share.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/share.js\n// module id = 322\n// module chunks = 0","\"use strict\";\nvar multicast_1 = require('./multicast');\nvar ReplaySubject_1 = require('../ReplaySubject');\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    var subject;\n    var connectable = multicast_1.multicast.call(this, function shareReplaySubjectFactory() {\n        if (this._isComplete) {\n            return subject;\n        }\n        else {\n            return (subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));\n        }\n    });\n    return connectable.refCount();\n}\nexports.shareReplay = shareReplay;\n;\n//# sourceMappingURL=shareReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/shareReplay.js\n// module id = 323\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return this.lift(new SingleOperator(predicate, this));\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/single.js\n// module id = 324\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return this.lift(new SkipOperator(count));\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/skip.js\n// module id = 325\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return this.lift(new SkipLastOperator(count));\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/skipLast.js\n// module id = 326\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return this.lift(new SkipUntilOperator(notifier));\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/skipUntil.js\n// module id = 327\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return this.lift(new SkipWhileOperator(predicate));\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/skipWhile.js\n// module id = 328\n// module chunks = 0","\"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('./concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n        array.pop();\n    }\n    else {\n        scheduler = null;\n    }\n    var len = array.length;\n    if (len === 1) {\n        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n    }\n    else if (len > 1) {\n        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n    }\n    else {\n        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n    }\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/startWith.js\n// module id = 329\n// module chunks = 0","\"use strict\";\nvar SubscribeOnObservable_1 = require('../observable/SubscribeOnObservable');\n/**\n * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n *\n * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n *\n * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n .\n * @method subscribeOn\n * @owner Observable\n */\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return this.lift(new SubscribeOnOperator(scheduler, delay));\n}\nexports.subscribeOn = subscribeOn;\nvar SubscribeOnOperator = (function () {\n    function SubscribeOnOperator(scheduler, delay) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    SubscribeOnOperator.prototype.call = function (subscriber, source) {\n        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n    };\n    return SubscribeOnOperator;\n}());\n//# sourceMappingURL=subscribeOn.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/subscribeOn.js\n// module id = 330\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src=\"./img/switch.png\" width=\"100%\">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nfunction _switch() {\n    return this.lift(new SwitchOperator());\n}\nexports._switch = _switch;\nvar SwitchOperator = (function () {\n    function SwitchOperator() {\n    }\n    SwitchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchSubscriber(subscriber));\n    };\n    return SwitchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchSubscriber = (function (_super) {\n    __extends(SwitchSubscriber, _super);\n    function SwitchSubscriber(destination) {\n        _super.call(this, destination);\n        this.active = 0;\n        this.hasCompleted = false;\n    }\n    SwitchSubscriber.prototype._next = function (value) {\n        this.unsubscribeInner();\n        this.active++;\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));\n    };\n    SwitchSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    SwitchSubscriber.prototype.unsubscribeInner = function () {\n        this.active = this.active > 0 ? this.active - 1 : 0;\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n            this.remove(innerSubscription);\n        }\n    };\n    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    SwitchSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchSubscriber.prototype.notifyComplete = function () {\n        this.unsubscribeInner();\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return SwitchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/switch.js\n// module id = 331\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/switchMap.js\n// module id = 332\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/switchMapTo.js\n// module id = 333\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeOperator(count));\n    }\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/take.js\n// module id = 334\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * <img src=\"./img/takeLast.png\" width=\"100%\">\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * @example <caption>Take the last 3 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 100);\n * var lastThree = many.takeLast(3);\n * lastThree.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nfunction takeLast(count) {\n    if (count === 0) {\n        return new EmptyObservable_1.EmptyObservable();\n    }\n    else {\n        return this.lift(new TakeLastOperator(count));\n    }\n}\nexports.takeLast = takeLast;\nvar TakeLastOperator = (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeLastSubscriber = (function (_super) {\n    __extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.ring = new Array();\n        this.count = 0;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/takeLast.js\n// module id = 335\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return this.lift(new TakeUntilOperator(notifier));\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/takeUntil.js\n// module id = 336\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return this.lift(new TakeWhileOperator(predicate));\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/takeWhile.js\n// module id = 337\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nvar throttle_1 = require('./throttle');\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return this.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/throttleTime.js\n// module id = 338\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar TimeoutError_1 = require('../util/TimeoutError');\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/timeout.js\n// module id = 339\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * @param due\n * @param withObservable\n * @param scheduler\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/timeoutWith.js\n// module id = 340\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n * @method toArray\n * @owner Observable\n */\nfunction toArray() {\n    return this.lift(new ToArrayOperator());\n}\nexports.toArray = toArray;\nvar ToArrayOperator = (function () {\n    function ToArrayOperator() {\n    }\n    ToArrayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ToArraySubscriber(subscriber));\n    };\n    return ToArrayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ToArraySubscriber = (function (_super) {\n    __extends(ToArraySubscriber, _super);\n    function ToArraySubscriber(destination) {\n        _super.call(this, destination);\n        this.array = [];\n    }\n    ToArraySubscriber.prototype._next = function (x) {\n        this.array.push(x);\n    };\n    ToArraySubscriber.prototype._complete = function () {\n        this.destination.next(this.array);\n        this.destination.complete();\n    };\n    return ToArraySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=toArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/toArray.js\n// module id = 341\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\n/* tslint:enable:max-line-length */\n/**\n * Converts an Observable sequence to a ES2015 compliant promise.\n *\n * @example\n * // Using normal ES2015\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise();\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * // Rejected Promise\n * // Using normal ES2015\n * let source = Rx.Observable\n *   .throw(new Error('woops'))\n *   .toPromise();\n *\n * source\n *   .then((value) => console.log('Value: %s', value))\n *   .catch((err) => console.log('Error: %s', err));\n * // => Error: Error: woops\n *\n * // Setting via the config\n * Rx.config.Promise = RSVP.Promise;\n *\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise();\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * // Setting via the method\n * let source = Rx.Observable\n *   .of(42)\n *   .toPromise(RSVP.Promise);\n *\n * source.then((value) => console.log('Value: %s', value));\n * // => Value: 42\n *\n * @param {PromiseConstructor} [PromiseCtor] The constructor of the promise. If not provided,\n * it will look for a constructor first in Rx.config.Promise then fall back to\n * the native Promise constructor if available.\n * @return {Promise<T>} An ES2015 compatible promise with the last value from\n * the observable sequence.\n * @method toPromise\n * @owner Observable\n */\nfunction toPromise(PromiseCtor) {\n    var _this = this;\n    if (!PromiseCtor) {\n        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n            PromiseCtor = root_1.root.Rx.config.Promise;\n        }\n        else if (root_1.root.Promise) {\n            PromiseCtor = root_1.root.Promise;\n        }\n    }\n    if (!PromiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return new PromiseCtor(function (resolve, reject) {\n        var value;\n        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n    });\n}\nexports.toPromise = toPromise;\n//# sourceMappingURL=toPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/toPromise.js\n// module id = 342\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return this.lift(new WindowOperator(windowBoundaries));\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/window.js\n// module id = 343\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subject_1 = require('../Subject');\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/windowCount.js\n// module id = 344\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isNumeric_1 = require('../util/isNumeric');\nvar isScheduler_1 = require('../util/isScheduler');\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/windowTime.js\n// module id = 345\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return this.lift(new WindowToggleOperator(openings, closingSelector));\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/windowToggle.js\n// module id = 346\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return this.lift(new WindowOperator(closingSelector));\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/windowWhen.js\n// module id = 347\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/withLatestFrom.js\n// module id = 348\n// module chunks = 0","\"use strict\";\nvar zip_1 = require('./zip');\n/**\n * @param project\n * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n * @method zipAll\n * @owner Observable\n */\nfunction zipAll(project) {\n    return this.lift(new zip_1.ZipOperator(project));\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/zipAll.js\n// module id = 349\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/Action.js\n// module id = 350\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\nvar AnimationFrame_1 = require('../util/AnimationFrame');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If an animation frame has already been requested, don't request another\n        // one. If an animation frame hasn't been requested yet, request one. Return\n        // the current animation frame request id.\n        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested animation frame and\n        // set the scheduled flag to undefined so the next AnimationFrameAction will\n        // request its own.\n        if (scheduler.actions.length === 0) {\n            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction_1.AsyncAction));\nexports.AnimationFrameAction = AnimationFrameAction;\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AnimationFrameAction.js\n// module id = 351\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        _super.apply(this, arguments);\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AnimationFrameScheduler = AnimationFrameScheduler;\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AnimationFrameScheduler.js\n// module id = 352\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Immediate_1 = require('../util/Immediate');\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If a microtask has already been scheduled, don't schedule another\n        // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n        // the current scheduled microtask id.\n        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested microtask and\n        // set the scheduled flag to undefined so the next AsapAction will schedule\n        // its own.\n        if (scheduler.actions.length === 0) {\n            Immediate_1.Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction_1.AsyncAction));\nexports.AsapAction = AsapAction;\n//# sourceMappingURL=AsapAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsapAction.js\n// module id = 353\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        _super.apply(this, arguments);\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AsapScheduler = AsapScheduler;\n//# sourceMappingURL=AsapScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsapScheduler.js\n// module id = 354\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/QueueAction.js\n// module id = 355\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/QueueScheduler.js\n// module id = 356\n// module chunks = 0","\"use strict\";\nvar AnimationFrameAction_1 = require('./AnimationFrameAction');\nvar AnimationFrameScheduler_1 = require('./AnimationFrameScheduler');\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * @example <caption>Schedule div height animation</caption>\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n *\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\nexports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n//# sourceMappingURL=animationFrame.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/animationFrame.js\n// module id = 357\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar Subscription_1 = require('../Subscription');\nvar SubscriptionLoggable_1 = require('./SubscriptionLoggable');\nvar applyMixins_1 = require('../util/applyMixins');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ColdObservable = (function (_super) {\n    __extends(ColdObservable, _super);\n    function ColdObservable(messages, scheduler) {\n        _super.call(this, function (subscriber) {\n            var observable = this;\n            var index = observable.logSubscribedFrame();\n            subscriber.add(new Subscription_1.Subscription(function () {\n                observable.logUnsubscribedFrame(index);\n            }));\n            observable.scheduleMessages(subscriber);\n            return subscriber;\n        });\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    ColdObservable.prototype.scheduleMessages = function (subscriber) {\n        var messagesLength = this.messages.length;\n        for (var i = 0; i < messagesLength; i++) {\n            var message = this.messages[i];\n            subscriber.add(this.scheduler.schedule(function (_a) {\n                var message = _a.message, subscriber = _a.subscriber;\n                message.notification.observe(subscriber);\n            }, message.frame, { message: message, subscriber: subscriber }));\n        }\n    };\n    return ColdObservable;\n}(Observable_1.Observable));\nexports.ColdObservable = ColdObservable;\napplyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=ColdObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/testing/ColdObservable.js\n// module id = 358\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Subscription_1 = require('../Subscription');\nvar SubscriptionLoggable_1 = require('./SubscriptionLoggable');\nvar applyMixins_1 = require('../util/applyMixins');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar HotObservable = (function (_super) {\n    __extends(HotObservable, _super);\n    function HotObservable(messages, scheduler) {\n        _super.call(this);\n        this.messages = messages;\n        this.subscriptions = [];\n        this.scheduler = scheduler;\n    }\n    HotObservable.prototype._subscribe = function (subscriber) {\n        var subject = this;\n        var index = subject.logSubscribedFrame();\n        subscriber.add(new Subscription_1.Subscription(function () {\n            subject.logUnsubscribedFrame(index);\n        }));\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    HotObservable.prototype.setup = function () {\n        var subject = this;\n        var messagesLength = subject.messages.length;\n        /* tslint:disable:no-var-keyword */\n        for (var i = 0; i < messagesLength; i++) {\n            (function () {\n                var message = subject.messages[i];\n                /* tslint:enable */\n                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);\n            })();\n        }\n    };\n    return HotObservable;\n}(Subject_1.Subject));\nexports.HotObservable = HotObservable;\napplyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n//# sourceMappingURL=HotObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/testing/HotObservable.js\n// module id = 359\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar Notification_1 = require('../Notification');\nvar ColdObservable_1 = require('./ColdObservable');\nvar HotObservable_1 = require('./HotObservable');\nvar SubscriptionLog_1 = require('./SubscriptionLog');\nvar VirtualTimeScheduler_1 = require('../scheduler/VirtualTimeScheduler');\nvar defaultMaxFrame = 750;\nvar TestScheduler = (function (_super) {\n    __extends(TestScheduler, _super);\n    function TestScheduler(assertDeepEqual) {\n        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n    }\n    TestScheduler.prototype.createTime = function (marbles) {\n        var indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    };\n    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var cold = new ColdObservable_1.ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    };\n    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        var messages = TestScheduler.parseMarbles(marbles, values, error);\n        var subject = new HotObservable_1.HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    };\n    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n        var _this = this;\n        var messages = [];\n        observable.subscribe(function (value) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });\n        }, function (err) {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });\n        }, function () {\n            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });\n        });\n        return messages;\n    };\n    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n        var _this = this;\n        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }\n        var actual = [];\n        var flushTest = { actual: actual, ready: false };\n        var unsubscriptionFrame = TestScheduler\n            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n        var subscription;\n        this.schedule(function () {\n            subscription = observable.subscribe(function (x) {\n                var value = x;\n                // Support Observable-of-Observables\n                if (x instanceof Observable_1.Observable) {\n                    value = _this.materializeInnerObservable(value, _this.frame);\n                }\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n            }, function (err) {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n            }, function () {\n                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n            });\n        }, 0);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n            }\n        };\n    };\n    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n        var flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        return {\n            toBe: function (marbles) {\n                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(function (marbles) {\n                    return TestScheduler.parseMarblesAsSubscriptions(marbles);\n                });\n            }\n        };\n    };\n    TestScheduler.prototype.flush = function () {\n        var hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        _super.prototype.flush.call(this);\n        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });\n        while (readyFlushTests.length > 0) {\n            var test = readyFlushTests.shift();\n            this.assertDeepEqual(test.actual, test.expected);\n        }\n    };\n    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        var len = marbles.length;\n        var groupStart = -1;\n        var subscriptionFrame = Number.POSITIVE_INFINITY;\n        var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    };\n    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        var len = marbles.length;\n        var testMessages = [];\n        var subIndex = marbles.indexOf('^');\n        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        var getValue = typeof values !== 'object' ?\n            function (x) { return x; } :\n            function (x) {\n                // Support Observable-of-Observables\n                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        var groupStart = -1;\n        for (var i = 0; i < len; i++) {\n            var frame = i * this.frameTimeFactor + frameOffset;\n            var notification = void 0;\n            var c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '|':\n                    notification = Notification_1.Notification.createComplete();\n                    break;\n                case '^':\n                    break;\n                case '#':\n                    notification = Notification_1.Notification.createError(errorValue || 'error');\n                    break;\n                default:\n                    notification = Notification_1.Notification.createNext(getValue(c));\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });\n            }\n        }\n        return testMessages;\n    };\n    return TestScheduler;\n}(VirtualTimeScheduler_1.VirtualTimeScheduler));\nexports.TestScheduler = TestScheduler;\n//# sourceMappingURL=TestScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/testing/TestScheduler.js\n// module id = 360\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nvar RequestAnimationFrameDefinition = (function () {\n    function RequestAnimationFrameDefinition(root) {\n        if (root.requestAnimationFrame) {\n            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n        }\n        else if (root.mozRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n        }\n        else if (root.webkitRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n        }\n        else if (root.msRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n        }\n        else if (root.oRequestAnimationFrame) {\n            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n        }\n        else {\n            this.cancelAnimationFrame = root.clearTimeout.bind(root);\n            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };\n        }\n    }\n    return RequestAnimationFrameDefinition;\n}());\nexports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\nexports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);\n//# sourceMappingURL=AnimationFrame.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/AnimationFrame.js\n// module id = 361\n// module chunks = 0","\"use strict\";\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/FastMap.js\n// module id = 362\n// module chunks = 0","/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\n\"use strict\";\nvar root_1 = require('./root');\nvar ImmediateDefinition = (function () {\n    function ImmediateDefinition(root) {\n        this.root = root;\n        if (root.setImmediate && typeof root.setImmediate === 'function') {\n            this.setImmediate = root.setImmediate.bind(root);\n            this.clearImmediate = root.clearImmediate.bind(root);\n        }\n        else {\n            this.nextHandle = 1;\n            this.tasksByHandle = {};\n            this.currentlyRunningATask = false;\n            // Don't get fooled by e.g. browserify environments.\n            if (this.canUseProcessNextTick()) {\n                // For Node.js before 0.9\n                this.setImmediate = this.createProcessNextTickSetImmediate();\n            }\n            else if (this.canUsePostMessage()) {\n                // For non-IE10 modern browsers\n                this.setImmediate = this.createPostMessageSetImmediate();\n            }\n            else if (this.canUseMessageChannel()) {\n                // For web workers, where supported\n                this.setImmediate = this.createMessageChannelSetImmediate();\n            }\n            else if (this.canUseReadyStateChange()) {\n                // For IE 6–8\n                this.setImmediate = this.createReadyStateChangeSetImmediate();\n            }\n            else {\n                // For older browsers\n                this.setImmediate = this.createSetTimeoutSetImmediate();\n            }\n            var ci = function clearImmediate(handle) {\n                delete clearImmediate.instance.tasksByHandle[handle];\n            };\n            ci.instance = this;\n            this.clearImmediate = ci;\n        }\n    }\n    ImmediateDefinition.prototype.identify = function (o) {\n        return this.root.Object.prototype.toString.call(o);\n    };\n    ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n        return this.identify(this.root.process) === '[object process]';\n    };\n    ImmediateDefinition.prototype.canUseMessageChannel = function () {\n        return Boolean(this.root.MessageChannel);\n    };\n    ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n        var document = this.root.document;\n        return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n    };\n    ImmediateDefinition.prototype.canUsePostMessage = function () {\n        var root = this.root;\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `root.postMessage` means something completely different and can't be used for this purpose.\n        if (root.postMessage && !root.importScripts) {\n            var postMessageIsAsynchronous_1 = true;\n            var oldOnMessage = root.onmessage;\n            root.onmessage = function () {\n                postMessageIsAsynchronous_1 = false;\n            };\n            root.postMessage('', '*');\n            root.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous_1;\n        }\n        return false;\n    };\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var fn = function result() {\n            var _a = result, handler = _a.handler, args = _a.args;\n            if (typeof handler === 'function') {\n                handler.apply(undefined, args);\n            }\n            else {\n                (new Function('' + handler))();\n            }\n        };\n        fn.handler = handler;\n        fn.args = args;\n        return fn;\n    };\n    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n        return this.nextHandle++;\n    };\n    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        var root = this.root;\n        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n        var onGlobalMessage = function globalMessageHandler(event) {\n            var instance = globalMessageHandler.instance;\n            if (event.source === root &&\n                typeof event.data === 'string' &&\n                event.data.indexOf(messagePrefix) === 0) {\n                instance.runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n        onGlobalMessage.instance = this;\n        root.addEventListener('message', onGlobalMessage, false);\n        var fn = function setImmediate() {\n            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.postMessage(messagePrefix + handle, '*');\n            return handle;\n        };\n        fn.instance = this;\n        fn.messagePrefix = messagePrefix;\n        return fn;\n    };\n    ImmediateDefinition.prototype.runIfPresent = function (handle) {\n        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (this.currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // 'too much recursion' error.\n            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n        }\n        else {\n            var task = this.tasksByHandle[handle];\n            if (task) {\n                this.currentlyRunningATask = true;\n                try {\n                    task();\n                }\n                finally {\n                    this.clearImmediate(handle);\n                    this.currentlyRunningATask = false;\n                }\n            }\n        }\n    };\n    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n        var _this = this;\n        var channel = new this.root.MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            _this.runIfPresent(handle);\n        };\n        var fn = function setImmediate() {\n            var _a = setImmediate, channel = _a.channel, instance = _a.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n        fn.channel = channel;\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var root = instance.root;\n            var doc = root.document;\n            var html = doc.documentElement;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement('script');\n            script.onreadystatechange = function () {\n                instance.runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n        var fn = function setImmediate() {\n            var instance = setImmediate.instance;\n            var handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    };\n    return ImmediateDefinition;\n}());\nexports.ImmediateDefinition = ImmediateDefinition;\nexports.Immediate = new ImmediateDefinition(root_1.root);\n//# sourceMappingURL=Immediate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/Immediate.js\n// module id = 363\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nvar MapPolyfill_1 = require('./MapPolyfill');\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/Map.js\n// module id = 364\n// module chunks = 0","\"use strict\";\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/MapPolyfill.js\n// module id = 365\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/Set.js\n// module id = 366\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nfunction assignImpl(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    var len = sources.length;\n    for (var i = 0; i < len; i++) {\n        var source = sources[i];\n        for (var k in source) {\n            if (source.hasOwnProperty(k)) {\n                target[k] = source[k];\n            }\n        }\n    }\n    return target;\n}\nexports.assignImpl = assignImpl;\n;\nfunction getAssign(root) {\n    return root.Object.assign || assignImpl;\n}\nexports.getAssign = getAssign;\nexports.assign = getAssign(root_1.root);\n//# sourceMappingURL=assign.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/assign.js\n// module id = 367\n// module chunks = 0","\"use strict\";\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/not.js\n// module id = 368\n// module chunks = 0","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nvar Observer_1 = require('../Observer');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/toSubscriber.js\n// module id = 369\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 370\n// module chunks = 0","/**\n  * vue-router v2.7.0\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (process.env.NODE_ENV !== 'production' && !condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nfunction isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n      ) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also regiseter instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\n          false,\n          \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n          \"expecting an object, function or boolean.\"\n        );\n      }\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery,\n  _parseQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    var val = extraQuery[key];\n    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;\n  }\n  return parsedQuery\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom,\n  router\n) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (\n  ref,\n  _stringifyQuery\n) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal)\n    }\n    return String(aVal) === String(bVal)\n  })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null\n            ? 'router-link-active'\n            : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null\n            ? 'router-link-exact-active'\n            : globalExactActiveClass;\n    var activeClass = this.activeClass == null\n            ? activeClassFallback\n            : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null\n            ? exactActiveClassFallback\n            : this.exactActiveClass;\n    var compareTarget = location.path\n      ? createRoute(null, location, null, router)\n      : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact\n      ? classes[exactActiveClass]\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function (v) { return v !== undefined; };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed () {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this._routerRoot._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this._routerRoot._route }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (index$1(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (index$1(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var normalizedPath = normalizePath(path, parent);\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && !route.redirect && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction compileRouteRegex (path, pathToRegexpOptions) {\n  var regex = index(path, [], pathToRegexpOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    var keys = {};\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\"));\n      keys[key.name] = true;\n    });\n  }\n  return regex\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\n/*  */\n\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append,\n  router\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : basePath;\n\n  var query = resolveQuery(\n    parsedPath.query,\n    next.query,\n    router && router.options.parseQuery\n  );\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\n\nfunction createMatcher (\n  routes,\n  router\n) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      if (!record) { return _createRoute(null, location) }\n      var paramNames = record.regex.keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location, null, router))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\n          false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n        );\n      }\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      }\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  regex,\n  path,\n  params\n) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n        offset = normalizeOffset(offset);\n        position = getElementPosition(el, offset);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction normalizeOffset (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents (matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (resolvedDef.__esModule && resolvedDef.default) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n          process.env.NODE_ENV !== 'production' && warn(false, msg);\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) { next(); }\n  }\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (called) { return }\n    called = true;\n    return fn.apply(this, args)\n  }\n}\n\n/*  */\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError (errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function (err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' && (\n            typeof to.path === 'string' ||\n            typeof to.name === 'string'\n          ))\n        ) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  window.location.replace((base + \"#\" + path));\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  return registerHook(this.beforeHooks, fn)\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n  return registerHook(this.resolveHooks, fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  return registerHook(this.afterHooks, fn)\n};\n\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError (errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? to.matched\n      ? to\n      : this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(\n    to,\n    current || this.history.current,\n    append,\n    this\n  );\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction registerHook (list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) { list.splice(i, 1); }\n  }\n}\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.7.0';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\nexport default VueRouter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-router/dist/vue-router.esm.js\n// module id = 380\n// module chunks = 0","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/listToStyles.js\n// module id = 381\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 382\n// module chunks = 0","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/addStylesClient.js\n// module id = 383\n// module chunks = 0"],"sourceRoot":""}